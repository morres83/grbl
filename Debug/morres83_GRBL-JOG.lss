
morres83_GRBL-JOG.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007ff6  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000855  00800100  00800100  0000806a  2**0
                  ALLOC
  2 .comment      00000030  00000000  00000000  0000806a  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000568  00000000  00000000  0000809a  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000879b  00000000  00000000  00008602  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00002085  00000000  00000000  00010d9d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00002968  00000000  00000000  00012e22  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00001238  00000000  00000000  0001578c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000173a  00000000  00000000  000169c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005f5e  00000000  00000000  000180fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000568  00000000  00000000  0001e05c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 db 04 	jmp	0x9b6	; 0x9b6 <__ctors_end>
       4:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
       8:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
       c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      10:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      14:	0c 94 4f 2f 	jmp	0x5e9e	; 0x5e9e <__vector_5>
      18:	0c 94 96 39 	jmp	0x732c	; 0x732c <__vector_6>
      1c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      20:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      24:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      28:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      2c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      30:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      34:	0c 94 79 1b 	jmp	0x36f2	; 0x36f2 <__vector_13>
      38:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      3c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      40:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      44:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      48:	0c 94 8f 1d 	jmp	0x3b1e	; 0x3b1e <__vector_18>
      4c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      50:	0c 94 69 18 	jmp	0x30d2	; 0x30d2 <__vector_20>
      54:	0c 94 2b 18 	jmp	0x3056	; 0x3056 <__vector_21>
      58:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      5c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      60:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      64:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      68:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      6c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      70:	d5 0d       	add	r29, r5
      72:	d5 0d       	add	r29, r5
      74:	d5 0d       	add	r29, r5
      76:	d5 0d       	add	r29, r5
      78:	70 0d       	add	r23, r0
      7a:	27 17       	cp	r18, r23
      7c:	27 17       	cp	r18, r23
      7e:	27 17       	cp	r18, r23
      80:	27 17       	cp	r18, r23
      82:	27 17       	cp	r18, r23
      84:	67 0d       	add	r22, r7
      86:	27 17       	cp	r18, r23
      88:	27 17       	cp	r18, r23
      8a:	27 17       	cp	r18, r23
      8c:	27 17       	cp	r18, r23
      8e:	27 17       	cp	r18, r23
      90:	27 17       	cp	r18, r23
      92:	36 0e       	add	r3, r22
      94:	36 0e       	add	r3, r22
      96:	36 0e       	add	r3, r22
      98:	6b 0e       	add	r6, r27
      9a:	6b 0e       	add	r6, r27
      9c:	27 17       	cp	r18, r23
      9e:	27 17       	cp	r18, r23
      a0:	27 17       	cp	r18, r23
      a2:	27 17       	cp	r18, r23
      a4:	27 17       	cp	r18, r23
      a6:	27 17       	cp	r18, r23
      a8:	67 0d       	add	r22, r7
      aa:	27 17       	cp	r18, r23
      ac:	67 0d       	add	r22, r7
      ae:	27 17       	cp	r18, r23
      b0:	27 17       	cp	r18, r23
      b2:	27 17       	cp	r18, r23
      b4:	27 17       	cp	r18, r23
      b6:	27 17       	cp	r18, r23
      b8:	27 17       	cp	r18, r23
      ba:	27 17       	cp	r18, r23
      bc:	d5 0d       	add	r29, r5
      be:	27 17       	cp	r18, r23
      c0:	9b 0e       	add	r9, r27
      c2:	27 17       	cp	r18, r23
      c4:	27 17       	cp	r18, r23
      c6:	79 0e       	add	r7, r25
      c8:	27 17       	cp	r18, r23
      ca:	27 17       	cp	r18, r23
      cc:	27 17       	cp	r18, r23
      ce:	27 17       	cp	r18, r23
      d0:	27 17       	cp	r18, r23
      d2:	79 0e       	add	r7, r25
      d4:	27 17       	cp	r18, r23
      d6:	27 17       	cp	r18, r23
      d8:	27 17       	cp	r18, r23
      da:	70 0d       	add	r23, r0
      dc:	94 0e       	add	r9, r20
      de:	94 0e       	add	r9, r20
      e0:	94 0e       	add	r9, r20
      e2:	94 0e       	add	r9, r20
      e4:	94 0e       	add	r9, r20
      e6:	94 0e       	add	r9, r20
      e8:	27 17       	cp	r18, r23
      ea:	27 17       	cp	r18, r23
      ec:	27 17       	cp	r18, r23
      ee:	27 17       	cp	r18, r23
      f0:	27 17       	cp	r18, r23
      f2:	27 17       	cp	r18, r23
      f4:	27 17       	cp	r18, r23
      f6:	27 17       	cp	r18, r23
      f8:	27 17       	cp	r18, r23
      fa:	27 17       	cp	r18, r23
      fc:	27 17       	cp	r18, r23
      fe:	27 17       	cp	r18, r23
     100:	27 17       	cp	r18, r23
     102:	27 17       	cp	r18, r23
     104:	27 17       	cp	r18, r23
     106:	27 17       	cp	r18, r23
     108:	27 17       	cp	r18, r23
     10a:	27 17       	cp	r18, r23
     10c:	27 17       	cp	r18, r23
     10e:	27 17       	cp	r18, r23
     110:	db 0d       	add	r29, r11
     112:	27 17       	cp	r18, r23
     114:	27 17       	cp	r18, r23
     116:	27 17       	cp	r18, r23
     118:	27 17       	cp	r18, r23
     11a:	27 17       	cp	r18, r23
     11c:	27 17       	cp	r18, r23
     11e:	27 17       	cp	r18, r23
     120:	27 17       	cp	r18, r23
     122:	27 17       	cp	r18, r23
     124:	4f 0e       	add	r4, r31
     126:	4f 0e       	add	r4, r31
     128:	67 0d       	add	r22, r7
     12a:	5d 0e       	add	r5, r29
     12c:	5d 0e       	add	r5, r29
     12e:	c6 0e       	add	r12, r22
     130:	c6 0e       	add	r12, r22
     132:	c6 0e       	add	r12, r22
     134:	d8 0e       	add	r13, r24
     136:	d8 0e       	add	r13, r24
     138:	d8 0e       	add	r13, r24
     13a:	3f 17       	cp	r19, r31
     13c:	3f 17       	cp	r19, r31
     13e:	ef 0e       	add	r14, r31
     140:	ef 0e       	add	r14, r31
     142:	3f 17       	cp	r19, r31
     144:	3f 17       	cp	r19, r31
     146:	3f 17       	cp	r19, r31
     148:	3f 17       	cp	r19, r31
     14a:	3f 17       	cp	r19, r31
     14c:	3f 17       	cp	r19, r31
     14e:	3f 17       	cp	r19, r31
     150:	3f 17       	cp	r19, r31
     152:	3f 17       	cp	r19, r31
     154:	3f 17       	cp	r19, r31
     156:	3f 17       	cp	r19, r31
     158:	3f 17       	cp	r19, r31
     15a:	3f 17       	cp	r19, r31
     15c:	3f 17       	cp	r19, r31
     15e:	3f 17       	cp	r19, r31
     160:	3f 17       	cp	r19, r31
     162:	3f 17       	cp	r19, r31
     164:	3f 17       	cp	r19, r31
     166:	3f 17       	cp	r19, r31
     168:	3f 17       	cp	r19, r31
     16a:	c6 0e       	add	r12, r22
     16c:	22 0f       	add	r18, r18
     16e:	43 17       	cp	r20, r19
     170:	43 17       	cp	r20, r19
     172:	2c 0f       	add	r18, r28
     174:	39 0f       	add	r19, r25
     176:	46 0f       	add	r20, r22
     178:	53 0f       	add	r21, r19
     17a:	43 17       	cp	r20, r19
     17c:	57 0f       	add	r21, r23
     17e:	43 17       	cp	r20, r19
     180:	65 0f       	add	r22, r21
     182:	43 17       	cp	r20, r19
     184:	6f 0f       	add	r22, r31
     186:	79 0f       	add	r23, r25
     188:	a9 0f       	add	r26, r25
     18a:	43 17       	cp	r20, r19
     18c:	43 17       	cp	r20, r19
     18e:	43 17       	cp	r20, r19
     190:	83 0f       	add	r24, r19
     192:	90 0f       	add	r25, r16
     194:	9d 0f       	add	r25, r29
     196:	f3 15       	cp	r31, r3
     198:	08 16       	cp	r0, r24
     19a:	27 16       	cp	r2, r23
     19c:	08 16       	cp	r0, r24
     19e:	2d 16       	cp	r2, r29
     1a0:	44 16       	cp	r4, r20
     1a2:	33 16       	cp	r3, r19
     1a4:	3d 16       	cp	r3, r29
     1a6:	59 16       	cp	r5, r25
     1a8:	63 16       	cp	r6, r19
     1aa:	72 16       	cp	r7, r18
     1ac:	97 16       	cp	r9, r23
     1ae:	bb 16       	cp	r11, r27
     1b0:	cc 16       	cp	r12, r28
     1b2:	de 16       	cp	r13, r30
     1b4:	ef 16       	cp	r14, r31
     1b6:	8b 27       	eor	r24, r27
     1b8:	91 27       	eor	r25, r17
     1ba:	94 27       	eor	r25, r20
     1bc:	99 27       	eor	r25, r25
     1be:	9e 27       	eor	r25, r30
     1c0:	ac 27       	eor	r26, r28
     1c2:	ba 27       	eor	r27, r26
     1c4:	57 28       	or	r5, r7
     1c6:	57 28       	or	r5, r7
     1c8:	57 28       	or	r5, r7
     1ca:	c8 27       	eor	r28, r24
     1cc:	cb 27       	eor	r28, r27
     1ce:	d4 27       	eor	r29, r20
     1d0:	dd 27       	eor	r29, r29
     1d2:	57 28       	or	r5, r7
     1d4:	57 28       	or	r5, r7
     1d6:	57 28       	or	r5, r7
     1d8:	57 28       	or	r5, r7
     1da:	57 28       	or	r5, r7
     1dc:	57 28       	or	r5, r7
     1de:	eb 27       	eor	r30, r27
     1e0:	fb 27       	eor	r31, r27
     1e2:	0b 28       	or	r0, r11
     1e4:	19 28       	or	r1, r9
     1e6:	1c 28       	or	r1, r12
     1e8:	25 28       	or	r2, r5
     1ea:	2e 28       	or	r2, r14
     1ec:	35 28       	or	r3, r5
     1ee:	57 28       	or	r5, r7
     1f0:	57 28       	or	r5, r7
     1f2:	3e 28       	or	r3, r14
     1f4:	47 28       	or	r4, r7
     1f6:	5a 34       	cpi	r21, 0x4A	; 74
     1f8:	5f 34       	cpi	r21, 0x4F	; 79
     1fa:	64 34       	cpi	r22, 0x44	; 68
     1fc:	69 34       	cpi	r22, 0x49	; 73
     1fe:	6e 34       	cpi	r22, 0x4E	; 78
     200:	73 34       	cpi	r23, 0x43	; 67
     202:	78 34       	cpi	r23, 0x48	; 72
     204:	7d 34       	cpi	r23, 0x4D	; 77
     206:	82 34       	cpi	r24, 0x42	; 66
     208:	87 34       	cpi	r24, 0x47	; 71
     20a:	8c 34       	cpi	r24, 0x4C	; 76
     20c:	a5 34       	cpi	r26, 0x45	; 69
     20e:	91 34       	cpi	r25, 0x41	; 65
     210:	a5 34       	cpi	r26, 0x45	; 69
     212:	a5 34       	cpi	r26, 0x45	; 69
     214:	a5 34       	cpi	r26, 0x45	; 69
     216:	a5 34       	cpi	r26, 0x45	; 69
     218:	a5 34       	cpi	r26, 0x45	; 69
     21a:	a5 34       	cpi	r26, 0x45	; 69
     21c:	9b 34       	cpi	r25, 0x4B	; 75
     21e:	96 34       	cpi	r25, 0x46	; 70
     220:	a0 34       	cpi	r26, 0x40	; 64
     222:	8e 37       	cpi	r24, 0x7E	; 126
     224:	93 37       	cpi	r25, 0x73	; 115
     226:	98 37       	cpi	r25, 0x78	; 120
     228:	9d 37       	cpi	r25, 0x7D	; 125
     22a:	a2 37       	cpi	r26, 0x72	; 114
     22c:	a7 37       	cpi	r26, 0x77	; 119
     22e:	ac 37       	cpi	r26, 0x7C	; 124
     230:	b1 37       	cpi	r27, 0x71	; 113
     232:	b6 37       	cpi	r27, 0x76	; 118
     234:	08 4a       	sbci	r16, 0xA8	; 168
     236:	d7 3b       	cpi	r29, 0xB7	; 183
     238:	3b ce       	rjmp	.-906    	; 0xfffffeb0 <__eeprom_end+0xff7efeb0>
     23a:	01 6e       	ori	r16, 0xE1	; 225
     23c:	84 bc       	out	0x24, r8	; 36
     23e:	bf fd       	.word	0xfdbf	; ????
     240:	c1 2f       	mov	r28, r17
     242:	3d 6c       	ori	r19, 0xCD	; 205
     244:	74 31       	cpi	r23, 0x14	; 20
     246:	9a bd       	out	0x2a, r25	; 42
     248:	56 83       	std	Z+6, r21	; 0x06
     24a:	3d da       	rcall	.-2950   	; 0xfffff6c6 <__eeprom_end+0xff7ef6c6>
     24c:	3d 00       	.word	0x003d	; ????
     24e:	c7 7f       	andi	r28, 0xF7	; 247
     250:	11 be       	out	0x31, r1	; 49
     252:	d9 e4       	ldi	r29, 0x49	; 73
     254:	bb 4c       	sbci	r27, 0xCB	; 203
     256:	3e 91       	ld	r19, -X
     258:	6b aa       	std	Y+51, r6	; 0x33
     25a:	aa be       	out	0x3a, r10	; 58
     25c:	00 00       	nop
     25e:	00 80       	ld	r0, Z
     260:	3f 05       	cpc	r19, r15
     262:	a8 4c       	sbci	r26, 0xC8	; 200
     264:	cd b2       	in	r12, 0x1d	; 29
     266:	d4 4e       	sbci	r29, 0xE4	; 228
     268:	b9 38       	cpi	r27, 0x89	; 137
     26a:	36 a9       	ldd	r19, Z+54	; 0x36
     26c:	02 0c       	add	r0, r2
     26e:	50 b9       	out	0x00, r21	; 0
     270:	91 86       	std	Z+9, r9	; 0x09
     272:	88 08       	sbc	r8, r8
     274:	3c a6       	std	Y+44, r3	; 0x2c
     276:	aa aa       	std	Y+50, r10	; 0x32
     278:	2a be       	out	0x3a, r2	; 58
     27a:	00 00       	nop
     27c:	00 80       	ld	r0, Z
     27e:	3f 00       	.word	0x003f	; ????

00000280 <__trampolines_end>:
     280:	4a 6f       	ori	r20, 0xFA	; 250
     282:	67 46       	sbci	r22, 0x67	; 103
     284:	0d 0a       	sbc	r0, r29
	...

00000287 <__c.2350>:
     287:	4a 6f 67 00                                         Jog.

0000028b <__c.2725>:
     28b:	3e 0d 0a 00                                         >...

0000028f <__c.2723>:
     28f:	2c 52 58 3a 00                                      ,RX:.

00000294 <__c.2721>:
     294:	2c 42 75 66 3a 00                                   ,Buf:.

0000029a <__c.2716>:
     29a:	2c 00                                               ,.

0000029c <__c.2714>:
     29c:	2c 57 50 6f 73 3a 00                                ,WPos:.

000002a3 <__c.2709>:
     2a3:	2c 00                                               ,.

000002a5 <__c.2707>:
     2a5:	2c 4d 50 6f 73 3a 00                                ,MPos:.

000002ac <__c.2705>:
     2ac:	3c 4a 6f 67 00                                      <Jog.

000002b1 <__c.2702>:
     2b1:	3c 44 6f 6f 72 00                                   <Door.

000002b7 <__c.2699>:
     2b7:	3c 43 68 65 63 6b 00                                <Check.

000002be <__c.2696>:
     2be:	3c 41 6c 61 72 6d 00                                <Alarm.

000002c5 <__c.2693>:
     2c5:	3c 48 6f 6d 65 00                                   <Home.

000002cb <__c.2690>:
     2cb:	3c 48 6f 6c 64 00                                   <Hold.

000002d1 <__c.2687>:
     2d1:	3c 52 75 6e 00                                      <Run.

000002d6 <__c.2682>:
     2d6:	3c 49 64 6c 65 00                                   <Idle.

000002dc <__c.2674>:
     2dc:	5d 0d 0a 00                                         ]...

000002e0 <__c.2672>:
     2e0:	5b 30 2e 39 68 2f 47 52 42 4c 2d 4a 4f 47 2e 32     [0.9h/GRBL-JOG.2
     2f0:	30 31 35 30 32 31 30 3a 00                          0150210:.

000002f9 <__c.2667>:
     2f9:	0d 0a 00                                            ...

000002fc <__c.2665>:
     2fc:	3d 00                                               =.

000002fe <__c.2663>:
     2fe:	24 4e 00                                            $N.

00000301 <__c.2657>:
     301:	5d 0d 0a 00                                         ]...

00000305 <__c.2655>:
     305:	20 46 00                                             F.

00000308 <__c.2653>:
     308:	20 54 00                                             T.

0000030b <__c.2651>:
     30b:	20 4d 38 00                                          M8.

0000030f <__c.2647>:
     30f:	20 4d 39 00                                          M9.

00000313 <__c.2644>:
     313:	20 4d 35 00                                          M5.

00000317 <__c.2641>:
     317:	20 4d 34 00                                          M4.

0000031b <__c.2637>:
     31b:	20 4d 33 00                                          M3.

0000031f <__c.2634>:
     31f:	20 4d 32 00                                          M2.

00000323 <__c.2631>:
     323:	20 4d 31 00                                          M1.

00000327 <__c.2627>:
     327:	20 4d 30 00                                          M0.

0000032b <__c.2624>:
     32b:	20 47 39 34 00                                       G94.

00000330 <__c.2622>:
     330:	20 47 39 33 00                                       G93.

00000335 <__c.2620>:
     335:	20 47 39 31 00                                       G91.

0000033a <__c.2618>:
     33a:	20 47 39 30 00                                       G90.

0000033f <__c.2616>:
     33f:	20 47 32 30 00                                       G20.

00000344 <__c.2614>:
     344:	20 47 32 31 00                                       G21.

00000349 <__c.2612>:
     349:	20 47 31 39 00                                       G19.

0000034e <__c.2609>:
     34e:	20 47 31 38 00                                       G18.

00000353 <__c.2605>:
     353:	20 47 31 37 00                                       G17.

00000358 <__c.2602>:
     358:	20 47 00                                             G.

0000035b <__c.2600>:
     35b:	47 38 30 00                                         G80.

0000035f <__c.2597>:
     35f:	47 33 38 2e 35 00                                   G38.5.

00000365 <__c.2594>:
     365:	47 33 38 2e 34 00                                   G38.4.

0000036b <__c.2591>:
     36b:	47 33 38 2e 33 00                                   G38.3.

00000371 <__c.2588>:
     371:	47 33 38 2e 32 00                                   G38.2.

00000377 <__c.2585>:
     377:	47 33 00                                            G3.

0000037a <__c.2582>:
     37a:	47 32 00                                            G2.

0000037d <__c.2579>:
     37d:	47 31 00                                            G1.

00000380 <__c.2575>:
     380:	47 30 00                                            G0.

00000383 <__c.2572>:
     383:	5b 00                                               [.

00000385 <__c.2568>:
     385:	5d 0d 0a 00                                         ]...

00000389 <__c.2566>:
     389:	5b 54 4c 4f 3a 00                                   [TLO:.

0000038f <__c.2561>:
     38f:	5d 0d 0a 00                                         ]...

00000393 <__c.2559>:
     393:	2c 00                                               ,.

00000395 <__c.2557>:
     395:	5b 47 39 32 3a 00                                   [G92:.

0000039b <__c.2549>:
     39b:	5d 0d 0a 00                                         ]...

0000039f <__c.2547>:
     39f:	2c 00                                               ,.

000003a1 <__c.2545>:
     3a1:	3a 00                                               :.

000003a3 <__c.2542>:
     3a3:	33 30 00                                            30.

000003a6 <__c.2538>:
     3a6:	32 38 00                                            28.

000003a9 <__c.2535>:
     3a9:	5b 47 00                                            [G.

000003ac <__c.2528>:
     3ac:	5d 0d 0a 00                                         ]...

000003b0 <__c.2526>:
     3b0:	3a 00                                               :.

000003b2 <__c.2521>:
     3b2:	2c 00                                               ,.

000003b4 <__c.2519>:
     3b4:	5b 50 52 42 3a 00                                   [PRB:.

000003ba <__c.2507>:
     3ba:	29 0d 0a 00                                         )...

000003be <__c.2505>:
     3be:	20 6d 61 78 20 74 72 61 76 65 6c 2c 20 6d 6d 00      max travel, mm.

000003ce <__c.2502>:
     3ce:	20 61 63 63 65 6c 2c 20 6d 6d 2f 73 65 63 5e 32      accel, mm/sec^2
	...

000003df <__c.2499>:
     3df:	20 6d 61 78 20 72 61 74 65 2c 20 6d 6d 2f 6d 69      max rate, mm/mi
     3ef:	6e 00                                               n.

000003f1 <__c.2495>:
     3f1:	2c 20 73 74 65 70 2f 6d 6d 00                       , step/mm.

000003fb <__c.2492>:
     3fb:	7a 00                                               z.

000003fd <__c.2489>:
     3fd:	79 00                                               y.

000003ff <__c.2485>:
     3ff:	78 00                                               x.

00000401 <__c.2482>:
     401:	20 28 00                                             (.

00000404 <__c.2475>:
     404:	3d 00                                               =.

00000406 <__c.2473>:
     406:	24 00                                               $.

00000408 <__c.2468>:
     408:	20 28 5a 20 7a 65 72 6f 20 67 61 75 67 65 2c 20      (Z zero gauge, 
     418:	6d 6d 29 0d 0a 00                                   mm)...

0000041e <__c.2466>:
     41e:	20 28 5a 20 7a 65 72 6f 20 70 75 6c 6c 2d 6f 66      (Z zero pull-of
     42e:	66 2c 20 6d 6d 29 0d 0a 24 33 31 3d 00              f, mm)..$31=.

0000043b <__c.2464>:
     43b:	20 28 68 6f 6d 69 6e 67 20 70 75 6c 6c 2d 6f 66      (homing pull-of
     44b:	66 2c 20 6d 6d 29 0d 0a 24 33 30 3d 00              f, mm)..$30=.

00000458 <__c.2462>:
     458:	20 28 68 6f 6d 69 6e 67 20 64 65 62 6f 75 6e 63      (homing debounc
     468:	65 2c 20 6d 73 65 63 29 0d 0a 24 32 37 3d 00        e, msec)..$27=.

00000477 <__c.2460>:
     477:	20 28 68 6f 6d 69 6e 67 20 73 65 65 6b 2c 20 6d      (homing seek, m
     487:	6d 2f 6d 69 6e 29 0d 0a 24 32 36 3d 00              m/min)..$26=.

00000494 <__c.2458>:
     494:	20 28 68 6f 6d 69 6e 67 20 66 65 65 64 2c 20 6d      (homing feed, m
     4a4:	6d 2f 6d 69 6e 29 0d 0a 24 32 35 3d 00              m/min)..$25=.

000004b1 <__c.2456>:
     4b1:	29 0d 0a 24 32 34 3d 00                             )..$24=.

000004b9 <__c.2454>:
     4b9:	20 28 68 6f 6d 69 6e 67 20 64 69 72 20 69 6e 76      (homing dir inv
     4c9:	65 72 74 20 6d 61 73 6b 3a 00                       ert mask:.

000004d3 <__c.2452>:
     4d3:	20 28 68 6f 6d 69 6e 67 20 63 79 63 6c 65 2c 20      (homing cycle, 
     4e3:	62 6f 6f 6c 29 0d 0a 24 32 33 3d 00                 bool)..$23=.

000004ef <__c.2450>:
     4ef:	20 28 68 61 72 64 20 6c 69 6d 69 74 73 2c 20 62      (hard limits, b
     4ff:	6f 6f 6c 29 0d 0a 24 32 32 3d 00                    ool)..$22=.

0000050a <__c.2448>:
     50a:	20 28 73 6f 66 74 20 6c 69 6d 69 74 73 2c 20 62      (soft limits, b
     51a:	6f 6f 6c 29 0d 0a 24 32 31 3d 00                    ool)..$21=.

00000525 <__c.2446>:
     525:	20 28 72 65 70 6f 72 74 20 69 6e 63 68 65 73 2c      (report inches,
     535:	20 62 6f 6f 6c 29 0d 0a 24 32 30 3d 00               bool)..$20=.

00000542 <__c.2444>:
     542:	20 28 61 72 63 20 74 6f 6c 65 72 61 6e 63 65 2c      (arc tolerance,
     552:	20 6d 6d 29 0d 0a 24 31 33 3d 00                     mm)..$13=.

0000055d <__c.2442>:
     55d:	20 28 6a 75 6e 63 74 69 6f 6e 20 64 65 76 69 61      (junction devia
     56d:	74 69 6f 6e 2c 20 6d 6d 29 0d 0a 24 31 32 3d 00     tion, mm)..$12=.

0000057d <__c.2440>:
     57d:	29 0d 0a 24 31 31 3d 00                             )..$11=.

00000585 <__c.2438>:
     585:	20 28 73 74 61 74 75 73 20 72 65 70 6f 72 74 20      (status report 
     595:	6d 61 73 6b 3a 00                                   mask:.

0000059b <__c.2436>:
     59b:	20 28 70 72 6f 62 65 20 70 69 6e 20 69 6e 76 65      (probe pin inve
     5ab:	72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 31 30 3d 00     rt, bool)..$10=.

000005bb <__c.2434>:
     5bb:	20 28 6c 69 6d 69 74 20 70 69 6e 73 20 69 6e 76      (limit pins inv
     5cb:	65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 36 3d 00     ert, bool)..$6=.

000005db <__c.2432>:
     5db:	20 28 73 74 65 70 20 65 6e 61 62 6c 65 20 69 6e      (step enable in
     5eb:	76 65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 35 3d     vert, bool)..$5=
	...

000005fc <__c.2430>:
     5fc:	29 0d 0a 24 34 3d 00                                )..$4=.

00000603 <__c.2428>:
     603:	20 28 64 69 72 20 70 6f 72 74 20 69 6e 76 65 72      (dir port inver
     613:	74 20 6d 61 73 6b 3a 00                             t mask:.

0000061b <__c.2426>:
     61b:	29 0d 0a 24 33 3d 00                                )..$3=.

00000622 <__c.2424>:
     622:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     632:	72 74 20 6d 61 73 6b 3a 00                          rt mask:.

0000063b <__c.2422>:
     63b:	20 28 73 74 65 70 20 69 64 6c 65 20 64 65 6c 61      (step idle dela
     64b:	79 2c 20 6d 73 65 63 29 0d 0a 24 32 3d 00           y, msec)..$2=.

00000659 <__c.2420>:
     659:	20 28 73 74 65 70 20 70 75 6c 73 65 2c 20 75 73      (step pulse, us
     669:	65 63 29 0d 0a 24 31 3d 00                          ec)..$1=.

00000672 <__c.2418>:
     672:	24 30 3d 00                                         $0=.

00000676 <__c.2414>:
     676:	24 24 20 28 76 69 65 77 20 47 72 62 6c 20 73 65     $$ (view Grbl se
     686:	74 74 69 6e 67 73 29 0d 0a 24 23 20 28 76 69 65     ttings)..$# (vie
     696:	77 20 23 20 70 61 72 61 6d 65 74 65 72 73 29 0d     w # parameters).
     6a6:	0a 24 47 20 28 76 69 65 77 20 70 61 72 73 65 72     .$G (view parser
     6b6:	20 73 74 61 74 65 29 0d 0a 24 49 20 28 76 69 65      state)..$I (vie
     6c6:	77 20 62 75 69 6c 64 20 69 6e 66 6f 29 0d 0a 24     w build info)..$
     6d6:	4e 20 28 76 69 65 77 20 73 74 61 72 74 75 70 20     N (view startup 
     6e6:	62 6c 6f 63 6b 73 29 0d 0a 24 78 3d 76 61 6c 75     blocks)..$x=valu
     6f6:	65 20 28 73 61 76 65 20 47 72 62 6c 20 73 65 74     e (save Grbl set
     706:	74 69 6e 67 29 0d 0a 24 4e 78 3d 6c 69 6e 65 20     ting)..$Nx=line 
     716:	28 73 61 76 65 20 73 74 61 72 74 75 70 20 62 6c     (save startup bl
     726:	6f 63 6b 29 0d 0a 24 43 20 28 63 68 65 63 6b 20     ock)..$C (check 
     736:	67 63 6f 64 65 20 6d 6f 64 65 29 0d 0a 24 58 20     gcode mode)..$X 
     746:	28 6b 69 6c 6c 20 61 6c 61 72 6d 20 6c 6f 63 6b     (kill alarm lock
     756:	29 0d 0a 24 48 20 28 72 75 6e 20 68 6f 6d 69 6e     )..$H (run homin
     766:	67 20 63 79 63 6c 65 29 0d 0a 7e 20 28 63 79 63     g cycle)..~ (cyc
     776:	6c 65 20 73 74 61 72 74 29 0d 0a 21 20 28 66 65     le start)..! (fe
     786:	65 64 20 68 6f 6c 64 29 0d 0a 3f 20 28 63 75 72     ed hold)..? (cur
     796:	72 65 6e 74 20 73 74 61 74 75 73 29 0d 0a 63 74     rent status)..ct
     7a6:	72 6c 2d 78 20 28 72 65 73 65 74 20 47 72 62 6c     rl-x (reset Grbl
     7b6:	29 0d 0a 00                                         )...

000007ba <__c.2410>:
     7ba:	0d 0a 47 72 62 6c 20 30 2e 39 68 2f 47 52 42 4c     ..Grbl 0.9h/GRBL
     7ca:	2d 4a 4f 47 20 5b 27 24 27 20 66 6f 72 20 68 65     -JOG ['$' for he
     7da:	6c 70 5d 0d 0a 00                                   lp]...

000007e0 <__c.2406>:
     7e0:	5d 0d 0a 00                                         ]...

000007e4 <__c.2404>:
     7e4:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

000007ef <__c.2401>:
     7ef:	44 69 73 61 62 6c 65 64 00                          Disabled.

000007f8 <__c.2398>:
     7f8:	45 6e 61 62 6c 65 64 00                             Enabled.

00000800 <__c.2395>:
     800:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     810:	64 00                                               d.

00000812 <__c.2392>:
     812:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     822:	6f 63 6b 00                                         ock.

00000826 <__c.2388>:
     826:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     836:	65 00                                               e.

00000838 <__c.2385>:
     838:	5b 00                                               [.

0000083a <__c.2380>:
     83a:	0d 0a 00                                            ...

0000083d <__c.2378>:
     83d:	50 72 6f 62 65 20 66 61 69 6c 00                    Probe fail.

00000848 <__c.2375>:
     848:	41 62 6f 72 74 20 64 75 72 69 6e 67 20 63 79 63     Abort during cyc
     858:	6c 65 00                                            le.

0000085b <__c.2372>:
     85b:	53 6f 66 74 20 6c 69 6d 69 74 00                    Soft limit.

00000866 <__c.2368>:
     866:	48 61 72 64 20 6c 69 6d 69 74 00                    Hard limit.

00000871 <__c.2365>:
     871:	41 4c 41 52 4d 3a 20 00                             ALARM: .

00000879 <__c.2360>:
     879:	0d 0a 00                                            ...

0000087c <__c.2358>:
     87c:	49 6e 76 61 6c 69 64 20 67 63 6f 64 65 20 49 44     Invalid gcode ID
     88c:	3a 00                                               :.

0000088e <__c.2355>:
     88e:	55 6e 64 65 66 69 6e 65 64 20 66 65 65 64 20 72     Undefined feed r
     89e:	61 74 65 00                                         ate.

000008a2 <__c.2352>:
     8a2:	55 6e 73 75 70 70 6f 72 74 65 64 20 63 6f 6d 6d     Unsupported comm
     8b2:	61 6e 64 00                                         and.

000008b6 <__c.2349>:
     8b6:	4d 6f 64 61 6c 20 67 72 6f 75 70 20 76 69 6f 6c     Modal group viol
     8c6:	61 74 69 6f 6e 00                                   ation.

000008cc <__c.2346>:
     8cc:	4a 6f 67 67 69 6e 67 20 6f 6e 67 6f 69 6e 67 3b     Jogging ongoing;
     8dc:	20 49 67 6e 6f 72 69 6e 67 20 47 43 6f 64 65 00      Ignoring GCode.

000008ec <__c.2343>:
     8ec:	4c 69 6e 65 20 6f 76 65 72 66 6c 6f 77 00           Line overflow.

000008fa <__c.2340>:
     8fa:	48 6f 6d 69 6e 67 20 6e 6f 74 20 65 6e 61 62 6c     Homing not enabl
     90a:	65 64 00                                            ed.

0000090d <__c.2337>:
     90d:	41 6c 61 72 6d 20 6c 6f 63 6b 00                    Alarm lock.

00000918 <__c.2334>:
     918:	4e 6f 74 20 69 64 6c 65 00                          Not idle.

00000921 <__c.2331>:
     921:	45 45 50 52 4f 4d 20 72 65 61 64 20 66 61 69 6c     EEPROM read fail
     931:	2e 20 55 73 69 6e 67 20 64 65 66 61 75 6c 74 73     . Using defaults
	...

00000942 <__c.2328>:
     942:	56 61 6c 75 65 20 3c 20 33 20 75 73 65 63 00        Value < 3 usec.

00000951 <__c.2325>:
     951:	53 65 74 74 69 6e 67 20 64 69 73 61 62 6c 65 64     Setting disabled
	...

00000962 <__c.2322>:
     962:	56 61 6c 75 65 20 3c 20 30 00                       Value < 0.

0000096c <__c.2319>:
     96c:	49 6e 76 61 6c 69 64 20 73 74 61 74 65 6d 65 6e     Invalid statemen
     97c:	74 00                                               t.

0000097e <__c.2316>:
     97e:	42 61 64 20 6e 75 6d 62 65 72 20 66 6f 72 6d 61     Bad number forma
     98e:	74 00                                               t.

00000990 <__c.2312>:
     990:	45 78 70 65 63 74 65 64 20 63 6f 6d 6d 61 6e 64     Expected command
     9a0:	20 6c 65 74 74 65 72 00                              letter.

000009a8 <__c.2309>:
     9a8:	65 72 72 6f 72 3a 20 00                             error: .

000009b0 <__c.2307>:
     9b0:	6f 6b 0d 0a 00 00                                   ok....

000009b6 <__ctors_end>:
     9b6:	11 24       	eor	r1, r1
     9b8:	1f be       	out	0x3f, r1	; 63
     9ba:	cf ef       	ldi	r28, 0xFF	; 255
     9bc:	d0 e1       	ldi	r29, 0x10	; 16
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	cd bf       	out	0x3d, r28	; 61

000009c2 <__do_copy_data>:
     9c2:	11 e0       	ldi	r17, 0x01	; 1
     9c4:	a0 e0       	ldi	r26, 0x00	; 0
     9c6:	b1 e0       	ldi	r27, 0x01	; 1
     9c8:	e6 ef       	ldi	r30, 0xF6	; 246
     9ca:	ff e7       	ldi	r31, 0x7F	; 127
     9cc:	02 c0       	rjmp	.+4      	; 0x9d2 <__do_copy_data+0x10>
     9ce:	05 90       	lpm	r0, Z+
     9d0:	0d 92       	st	X+, r0
     9d2:	a0 30       	cpi	r26, 0x00	; 0
     9d4:	b1 07       	cpc	r27, r17
     9d6:	d9 f7       	brne	.-10     	; 0x9ce <__do_copy_data+0xc>

000009d8 <__do_clear_bss>:
     9d8:	29 e0       	ldi	r18, 0x09	; 9
     9da:	a0 e0       	ldi	r26, 0x00	; 0
     9dc:	b1 e0       	ldi	r27, 0x01	; 1
     9de:	01 c0       	rjmp	.+2      	; 0x9e2 <.do_clear_bss_start>

000009e0 <.do_clear_bss_loop>:
     9e0:	1d 92       	st	X+, r1

000009e2 <.do_clear_bss_start>:
     9e2:	a5 35       	cpi	r26, 0x55	; 85
     9e4:	b2 07       	cpc	r27, r18
     9e6:	e1 f7       	brne	.-8      	; 0x9e0 <.do_clear_bss_loop>
     9e8:	0e 94 15 08 	call	0x102a	; 0x102a <main>
     9ec:	0c 94 f9 3f 	jmp	0x7ff2	; 0x7ff2 <_exit>

000009f0 <__bad_interrupt>:
     9f0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000009f4 <jog_init>:
#define ADMUX_init  0x20  // ADLAR =1 (left adjusted, 8-Bit-Result on ADCH)

void jog_init() {
	// Initialize jog switch port bits and DDR
	#ifdef LED_PRESENT
	LED_DDR |= ((1<<LED_RUN_BIT) | (1<<LED_ERROR_BIT));
     9f4:	87 b1       	in	r24, 0x07	; 7
     9f6:	80 63       	ori	r24, 0x30	; 48
     9f8:	87 b9       	out	0x07, r24	; 7
	LED_PORT |= ((1<<LED_RUN_BIT) | (1<<LED_ERROR_BIT)); // active low, so set high
     9fa:	88 b1       	in	r24, 0x08	; 8
     9fc:	80 63       	ori	r24, 0x30	; 48
     9fe:	88 b9       	out	0x08, r24	; 8
	#endif
	JOGSW_DDR &= ~(JOGSW_MASK); // Set as input pins
     a00:	81 b1       	in	r24, 0x01	; 1
     a02:	80 78       	andi	r24, 0x80	; 128
     a04:	81 b9       	out	0x01, r24	; 1
	JOGSW_PORT |= (JOGSW_MASK); // Enable internal pull-up resistors. Active low operation.
     a06:	82 b1       	in	r24, 0x02	; 2
     a08:	8f 67       	ori	r24, 0x7F	; 127
     a0a:	82 b9       	out	0x02, r24	; 2

	CONTROL_DDR &= ~(1<<SPIN_TOGGLE);  // Set as input pin
     a0c:	3b 98       	cbi	0x07, 3	; 7
	CONTROL_PORT|= (1<<SPIN_TOGGLE);   // Pullup
     a0e:	43 9a       	sbi	0x08, 3	; 8
	
	ADCSRA = ADCSRA_init;
     a10:	ea e7       	ldi	r30, 0x7A	; 122
     a12:	f0 e0       	ldi	r31, 0x00	; 0
     a14:	83 e8       	ldi	r24, 0x83	; 131
     a16:	80 83       	st	Z, r24
	ADMUX = ADMUX_init | JOG_POT;     // Kanal, ADLAR =1 (left adjustet, 8-Bit-Result on ADCH)
     a18:	87 e2       	ldi	r24, 0x27	; 39
     a1a:	80 93 7c 00 	sts	0x007C, r24
	
	ADCSRA |= (1<<ADSC);
     a1e:	80 81       	ld	r24, Z
     a20:	80 64       	ori	r24, 0x40	; 64
     a22:	80 83       	st	Z, r24
	while (ADCSRA & (1<<ADSC) ) {}         // wait until initial conversion is done
     a24:	80 81       	ld	r24, Z
     a26:	86 fd       	sbrc	r24, 6
     a28:	fd cf       	rjmp	.-6      	; 0xa24 <jog_init+0x30>
	(void) ADCH; // ADCH needs to be read one time
     a2a:	80 91 79 00 	lds	r24, 0x0079
     a2e:	08 95       	ret

00000a30 <jog_btn_release>:
}

void jog_btn_release() {
     a30:	cf 93       	push	r28
	uint8_t jog_bits;
	do {
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     a32:	c0 b1       	in	r28, 0x00	; 0
		protocol_process(); // process the serial protocol while waiting
     a34:	0e 94 2e 1a 	call	0x345c	; 0x345c <protocol_process>
		protocol_execute_realtime();
     a38:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
}

void jog_btn_release() {
	uint8_t jog_bits;
	do {
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     a3c:	c0 95       	com	r28
     a3e:	cf 77       	andi	r28, 0x7F	; 127
		protocol_process(); // process the serial protocol while waiting
		protocol_execute_realtime();
	}
	while (jog_bits); // until released
     a40:	c1 f7       	brne	.-16     	; 0xa32 <jog_btn_release+0x2>
}
     a42:	cf 91       	pop	r28
     a44:	08 95       	ret

00000a46 <spindle_btn_release>:

void spindle_btn_release() {
     a46:	cf 93       	push	r28
	uint8_t spindle_bits;
	do {
		spindle_bits = (~CONTROL_PIN) & (1<<SPIN_TOGGLE); // active low
     a48:	c6 b1       	in	r28, 0x06	; 6
		protocol_process(); // process the serial protocol while waiting
     a4a:	0e 94 2e 1a 	call	0x345c	; 0x345c <protocol_process>
		protocol_execute_realtime();
     a4e:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
	}
	while (spindle_bits); // until released
     a52:	c3 ff       	sbrs	r28, 3
     a54:	f9 cf       	rjmp	.-14     	; 0xa48 <spindle_btn_release+0x2>
}
     a56:	cf 91       	pop	r28
     a58:	08 95       	ret

00000a5a <jogging>:

void jogging()
// Tests jog port pins and moves steppers
{
     a5a:	2f 92       	push	r2
     a5c:	3f 92       	push	r3
     a5e:	4f 92       	push	r4
     a60:	5f 92       	push	r5
     a62:	6f 92       	push	r6
     a64:	7f 92       	push	r7
     a66:	8f 92       	push	r8
     a68:	9f 92       	push	r9
     a6a:	af 92       	push	r10
     a6c:	bf 92       	push	r11
     a6e:	cf 92       	push	r12
     a70:	df 92       	push	r13
     a72:	ef 92       	push	r14
     a74:	ff 92       	push	r15
     a76:	0f 93       	push	r16
     a78:	1f 93       	push	r17
     a7a:	cf 93       	push	r28
     a7c:	df 93       	push	r29
     a7e:	cd b7       	in	r28, 0x3d	; 61
     a80:	de b7       	in	r29, 0x3e	; 62
     a82:	69 97       	sbiw	r28, 0x19	; 25
     a84:	0f b6       	in	r0, 0x3f	; 63
     a86:	f8 94       	cli
     a88:	de bf       	out	0x3e, r29	; 62
     a8a:	0f be       	out	0x3f, r0	; 63
     a8c:	cd bf       	out	0x3d, r28	; 61
	uint8_t i, spindle_bits;
	
	uint32_t dest_step_rate, step_rate, step_delay; // Step delay after pulse
	float work_position, mm_per_step;

	switch (sys.state) {
     a8e:	80 91 68 07 	lds	r24, 0x0768
     a92:	84 30       	cpi	r24, 0x04	; 4
     a94:	49 f0       	breq	.+18     	; 0xaa8 <jogging+0x4e>
     a96:	18 f4       	brcc	.+6      	; 0xa9e <jogging+0x44>
     a98:	81 30       	cpi	r24, 0x01	; 1
     a9a:	41 f0       	breq	.+16     	; 0xaac <jogging+0x52>
     a9c:	09 c0       	rjmp	.+18     	; 0xab0 <jogging+0x56>
     a9e:	88 30       	cpi	r24, 0x08	; 8
     aa0:	19 f0       	breq	.+6      	; 0xaa8 <jogging+0x4e>
     aa2:	80 32       	cpi	r24, 0x20	; 32
     aa4:	19 f0       	breq	.+6      	; 0xaac <jogging+0x52>
     aa6:	04 c0       	rjmp	.+8      	; 0xab0 <jogging+0x56>
		case STATE_CYCLE: case STATE_HOMING:
		LED_PORT |= (1<<LED_ERROR_BIT);
     aa8:	45 9a       	sbi	0x08, 5	; 8
		return;
     aaa:	a6 c2       	rjmp	.+1356   	; 0xff8 <jogging+0x59e>
		case STATE_ALARM: case STATE_SAFETY_DOOR:
		LED_PORT &= ~(1<<LED_ERROR_BIT);  break;
     aac:	45 98       	cbi	0x08, 5	; 8
     aae:	01 c0       	rjmp	.+2      	; 0xab2 <jogging+0x58>
		default:
		LED_PORT |= (1<<LED_ERROR_BIT);
     ab0:	45 9a       	sbi	0x08, 5	; 8
	}
	last_sys_state = sys.state;
     ab2:	80 90 68 07 	lds	r8, 0x0768
     ab6:	89 8e       	std	Y+25, r8	; 0x19


	spindle_bits = (~CONTROL_PIN) & (1<<SPIN_TOGGLE); // active low
	if (spindle_bits) {
     ab8:	33 99       	sbic	0x06, 3	; 6
     aba:	15 c0       	rjmp	.+42     	; 0xae6 <jogging+0x8c>
		if (bit_istrue(SPINDLE_ENABLE_PORT,bit(SPINDLE_ENABLE_BIT))) {
     abc:	47 9b       	sbis	0x08, 7	; 8
     abe:	07 c0       	rjmp	.+14     	; 0xace <jogging+0x74>
			//      gc.spindle_direction = 0;
			spindle_run(0, 0.0);
     ac0:	40 e0       	ldi	r20, 0x00	; 0
     ac2:	50 e0       	ldi	r21, 0x00	; 0
     ac4:	ba 01       	movw	r22, r20
     ac6:	80 e0       	ldi	r24, 0x00	; 0
     ac8:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <spindle_run>
     acc:	06 c0       	rjmp	.+12     	; 0xada <jogging+0x80>
		}
		else {
			//      gc.spindle_direction = 1;   // also update gcode spindle status
			spindle_run(1, 0.0);
     ace:	40 e0       	ldi	r20, 0x00	; 0
     ad0:	50 e0       	ldi	r21, 0x00	; 0
     ad2:	ba 01       	movw	r22, r20
     ad4:	81 e0       	ldi	r24, 0x01	; 1
     ad6:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <spindle_run>
		}
		spindle_btn_release();
     ada:	0e 94 23 05 	call	0xa46	; 0xa46 <spindle_btn_release>
		delay_ms(20);
     ade:	84 e1       	ldi	r24, 0x14	; 20
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <delay_ms>
	}

	jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     ae6:	80 b1       	in	r24, 0x00	; 0
     ae8:	80 95       	com	r24
     aea:	28 2f       	mov	r18, r24
     aec:	2f 77       	andi	r18, 0x7F	; 127
     aee:	2a 8b       	std	Y+18, r18	; 0x12
	if (!jog_bits) { return; }  // nothing pressed
     af0:	22 23       	and	r18, r18
     af2:	09 f4       	brne	.+2      	; 0xaf6 <jogging+0x9c>
     af4:	81 c2       	rjmp	.+1282   	; 0xff8 <jogging+0x59e>
	
	// At least one jog/joystick switch is active
	if (jog_bits & (1<<JOG_ZERO)) {     // Zero-Button gedrückt
     af6:	86 ff       	sbrs	r24, 6
     af8:	a1 c0       	rjmp	.+322    	; 0xc3c <jogging+0x1e2>
		jog_btn_release();
     afa:	0e 94 18 05 	call	0xa30	; 0xa30 <jog_btn_release>
		sys.state = last_sys_state;
     afe:	89 8c       	ldd	r8, Y+25	; 0x19
     b00:	80 92 68 07 	sts	0x0768, r8
		if (bit_isfalse(CONTROL_PIN,bit(RESET_BIT))) { // RESET und zusätzlich ZERO gedrückt: Homing
     b04:	30 99       	sbic	0x06, 0	; 6
     b06:	13 c0       	rjmp	.+38     	; 0xb2e <jogging+0xd4>
			if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) {
     b08:	80 91 3c 09 	lds	r24, 0x093C
     b0c:	84 ff       	sbrs	r24, 4
     b0e:	74 c2       	rjmp	.+1256   	; 0xff8 <jogging+0x59e>
				// Only perform homing if Grbl is idle or lost.
				if ( sys.state==STATE_IDLE || sys.state==STATE_ALARM ) {
     b10:	28 2d       	mov	r18, r8
     b12:	22 30       	cpi	r18, 0x02	; 2
     b14:	08 f0       	brcs	.+2      	; 0xb18 <jogging+0xbe>
     b16:	70 c2       	rjmp	.+1248   	; 0xff8 <jogging+0x59e>
					mc_homing_cycle();
     b18:	0e 94 0a 0c 	call	0x1814	; 0x1814 <mc_homing_cycle>
					if (!sys.abort) { 
     b1c:	80 91 67 07 	lds	r24, 0x0767
     b20:	81 11       	cpse	r24, r1
     b22:	6a c2       	rjmp	.+1236   	; 0xff8 <jogging+0x59e>
						sys.state = STATE_IDLE; // Set to IDLE when complete.
     b24:	10 92 68 07 	sts	0x0768, r1
						st_go_idle(); // Set steppers to the settings idle state before returning.
     b28:	0e 94 4b 1b 	call	0x3696	; 0x3696 <st_go_idle>
     b2c:	65 c2       	rjmp	.+1226   	; 0xff8 <jogging+0x59e>
				}
			}
		} 
		else { // Zero current work position

			plan_sync_position();
     b2e:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <plan_sync_position>
			gc_sync_position();
     b32:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <gc_sync_position>
     b36:	0e e9       	ldi	r16, 0x9E	; 158
     b38:	17 e0       	ldi	r17, 0x07	; 7
     b3a:	0f 2e       	mov	r0, r31
     b3c:	fa ea       	ldi	r31, 0xAA	; 170
     b3e:	ef 2e       	mov	r14, r31
     b40:	f7 e0       	ldi	r31, 0x07	; 7
     b42:	ff 2e       	mov	r15, r31
     b44:	f0 2d       	mov	r31, r0
			//                            position in mm. Loaded from EEPROM when called.
			//      gc.coord_offset[i]    Retains the G92 coordinate offset (work coordinates) relative to
			//                            machine zero in mm. Non-persistent. Cleared upon reset and boot.

			for (i=0; i<=2; i++) { // Axes indices are consistent, so loop may be used.
				gc_state.coord_offset[i] = gc_state.position[i] - gc_state.coord_system[i];
     b46:	f8 01       	movw	r30, r16
     b48:	61 91       	ld	r22, Z+
     b4a:	71 91       	ld	r23, Z+
     b4c:	81 91       	ld	r24, Z+
     b4e:	91 91       	ld	r25, Z+
     b50:	8f 01       	movw	r16, r30
     b52:	20 85       	ldd	r18, Z+8	; 0x08
     b54:	31 85       	ldd	r19, Z+9	; 0x09
     b56:	42 85       	ldd	r20, Z+10	; 0x0a
     b58:	53 85       	ldd	r21, Z+11	; 0x0b
     b5a:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
     b5e:	f8 01       	movw	r30, r16
     b60:	64 8b       	std	Z+20, r22	; 0x14
     b62:	75 8b       	std	Z+21, r23	; 0x15
     b64:	86 8b       	std	Z+22, r24	; 0x16
     b66:	97 8b       	std	Z+23, r25	; 0x17
			//      gc.coord_system[i]    Current work coordinate system (G54+). Stores offset from absolute machine
			//                            position in mm. Loaded from EEPROM when called.
			//      gc.coord_offset[i]    Retains the G92 coordinate offset (work coordinates) relative to
			//                            machine zero in mm. Non-persistent. Cleared upon reset and boot.

			for (i=0; i<=2; i++) { // Axes indices are consistent, so loop may be used.
     b68:	0e 15       	cp	r16, r14
     b6a:	1f 05       	cpc	r17, r15
     b6c:	61 f7       	brne	.-40     	; 0xb46 <jogging+0xec>
				gc_state.coord_offset[i] = gc_state.position[i] - gc_state.coord_system[i];
			}

			// Z-Achse um bestimmten Betrag zurückziehen
			float xyz[3] = {gc_state.position[X_AXIS], gc_state.position[Y_AXIS], gc_state.position[Z_AXIS] + settings.z_zero_pulloff};
     b6e:	80 91 9e 07 	lds	r24, 0x079E
     b72:	90 91 9f 07 	lds	r25, 0x079F
     b76:	a0 91 a0 07 	lds	r26, 0x07A0
     b7a:	b0 91 a1 07 	lds	r27, 0x07A1
     b7e:	89 83       	std	Y+1, r24	; 0x01
     b80:	9a 83       	std	Y+2, r25	; 0x02
     b82:	ab 83       	std	Y+3, r26	; 0x03
     b84:	bc 83       	std	Y+4, r27	; 0x04
     b86:	80 91 a2 07 	lds	r24, 0x07A2
     b8a:	90 91 a3 07 	lds	r25, 0x07A3
     b8e:	a0 91 a4 07 	lds	r26, 0x07A4
     b92:	b0 91 a5 07 	lds	r27, 0x07A5
     b96:	8d 83       	std	Y+5, r24	; 0x05
     b98:	9e 83       	std	Y+6, r25	; 0x06
     b9a:	af 83       	std	Y+7, r26	; 0x07
     b9c:	b8 87       	std	Y+8, r27	; 0x08
     b9e:	06 ea       	ldi	r16, 0xA6	; 166
     ba0:	17 e0       	ldi	r17, 0x07	; 7
     ba2:	20 91 4c 09 	lds	r18, 0x094C
     ba6:	30 91 4d 09 	lds	r19, 0x094D
     baa:	40 91 4e 09 	lds	r20, 0x094E
     bae:	50 91 4f 09 	lds	r21, 0x094F
     bb2:	f8 01       	movw	r30, r16
     bb4:	60 81       	ld	r22, Z
     bb6:	71 81       	ldd	r23, Z+1	; 0x01
     bb8:	82 81       	ldd	r24, Z+2	; 0x02
     bba:	93 81       	ldd	r25, Z+3	; 0x03
     bbc:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
     bc0:	69 87       	std	Y+9, r22	; 0x09
     bc2:	7a 87       	std	Y+10, r23	; 0x0a
     bc4:	8b 87       	std	Y+11, r24	; 0x0b
     bc6:	9c 87       	std	Y+12, r25	; 0x0c
			mc_line(xyz, settings.homing_seek_rate, false);
     bc8:	40 91 42 09 	lds	r20, 0x0942
     bcc:	50 91 43 09 	lds	r21, 0x0943
     bd0:	60 91 44 09 	lds	r22, 0x0944
     bd4:	70 91 45 09 	lds	r23, 0x0945
     bd8:	20 e0       	ldi	r18, 0x00	; 0
     bda:	ce 01       	movw	r24, r28
     bdc:	01 96       	adiw	r24, 0x01	; 1
     bde:	0e 94 52 08 	call	0x10a4	; 0x10a4 <mc_line>
			
			protocol_buffer_synchronize(); // Make sure the motion completes
     be2:	0e 94 f0 1a 	call	0x35e0	; 0x35e0 <protocol_buffer_synchronize>
			
			gc_state.position[Z_AXIS] = gc_state.position[Z_AXIS] - (settings.z_zero_gauge);
     be6:	20 91 50 09 	lds	r18, 0x0950
     bea:	30 91 51 09 	lds	r19, 0x0951
     bee:	40 91 52 09 	lds	r20, 0x0952
     bf2:	50 91 53 09 	lds	r21, 0x0953
     bf6:	f8 01       	movw	r30, r16
     bf8:	60 81       	ld	r22, Z
     bfa:	71 81       	ldd	r23, Z+1	; 0x01
     bfc:	82 81       	ldd	r24, Z+2	; 0x02
     bfe:	93 81       	ldd	r25, Z+3	; 0x03
     c00:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
     c04:	f8 01       	movw	r30, r16
     c06:	60 83       	st	Z, r22
     c08:	71 83       	std	Z+1, r23	; 0x01
     c0a:	82 83       	std	Z+2, r24	; 0x02
     c0c:	93 83       	std	Z+3, r25	; 0x03
			gc_state.coord_offset[Z_AXIS] = gc_state.position[Z_AXIS] - gc_state.coord_system[Z_AXIS];
     c0e:	20 91 b2 07 	lds	r18, 0x07B2
     c12:	30 91 b3 07 	lds	r19, 0x07B3
     c16:	40 91 b4 07 	lds	r20, 0x07B4
     c1a:	50 91 b5 07 	lds	r21, 0x07B5
     c1e:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
     c22:	60 93 be 07 	sts	0x07BE, r22
     c26:	70 93 bf 07 	sts	0x07BF, r23
     c2a:	80 93 c0 07 	sts	0x07C0, r24
     c2e:	90 93 c1 07 	sts	0x07C1, r25
			
			// The gcode parser position circumvented by the pull-off maneuver, so sync position vectors.
			// Sets the planner position vector to current steps. Called by the system abort routine.
			// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
			plan_sync_position();
     c32:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <plan_sync_position>
			gc_sync_position(); // Syncs all internal position vectors to the current system position.
     c36:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <gc_sync_position>
     c3a:	de c1       	rjmp	.+956    	; 0xff8 <jogging+0x59e>
	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
	
	ADCSRA |= (1<<ADSC); //start conversion
     c3c:	ea e7       	ldi	r30, 0x7A	; 122
     c3e:	f0 e0       	ldi	r31, 0x00	; 0
     c40:	90 81       	ld	r25, Z
     c42:	90 64       	ori	r25, 0x40	; 64
     c44:	90 83       	st	Z, r25
	
	sys.state = STATE_JOG;
     c46:	90 e8       	ldi	r25, 0x80	; 128
     c48:	90 93 68 07 	sts	0x0768, r25
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
     c4c:	80 fd       	sbrc	r24, 0
     c4e:	04 c0       	rjmp	.+8      	; 0xc58 <jogging+0x1fe>
		}
		return;
	}

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
     c50:	10 e0       	ldi	r17, 0x00	; 0

		}
		return;
	}

	uint8_t reverse_flag = 0;
     c52:	19 8a       	std	Y+17, r1	; 0x11
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	04 c0       	rjmp	.+8      	; 0xc60 <jogging+0x206>
	sys.state = STATE_JOG;
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
		out_bits0 ^= (1<<X_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
     c58:	10 ec       	ldi	r17, 0xC0	; 192
		reverse_flag = 1;
     c5a:	f1 e0       	ldi	r31, 0x01	; 1
     c5c:	f9 8b       	std	Y+17, r31	; 0x11
	
	sys.state = STATE_JOG;
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
		out_bits0 ^= (1<<X_DIRECTION_BIT);
     c5e:	90 e8       	ldi	r25, 0x80	; 128
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
		reverse_flag = 1;
	}
	if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
     c60:	82 ff       	sbrs	r24, 2
     c62:	09 c0       	rjmp	.+18     	; 0xc76 <jogging+0x21c>
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
     c64:	10 e3       	ldi	r17, 0x30	; 48
     c66:	19 27       	eor	r17, r25
		out_bits0 ^= (1<<X_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
		reverse_flag = 1;
	}
	if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
     c68:	20 e2       	ldi	r18, 0x20	; 32
     c6a:	92 27       	eor	r25, r18
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
     c6c:	21 e0       	ldi	r18, 0x01	; 1
     c6e:	28 8f       	std	Y+24, r18	; 0x18
		reverse_flag = 1;
	}
	if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
     c70:	31 e0       	ldi	r19, 0x01	; 1
     c72:	39 8b       	std	Y+17, r19	; 0x11
     c74:	01 c0       	rjmp	.+2      	; 0xc78 <jogging+0x21e>
		return;
	}

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
     c76:	18 8e       	std	Y+24, r1	; 0x18
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
	}
	if (jog_bits & (1<<JOGREV_Z_BIT)) { // Z reverse switch on
     c78:	84 ff       	sbrs	r24, 4
     c7a:	06 c0       	rjmp	.+12     	; 0xc88 <jogging+0x22e>
		out_bits0 ^= (1<<Z_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
     c7c:	1c e0       	ldi	r17, 0x0C	; 12
     c7e:	19 27       	eor	r17, r25
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
	}
	if (jog_bits & (1<<JOGREV_Z_BIT)) { // Z reverse switch on
		out_bits0 ^= (1<<Z_DIRECTION_BIT);
     c80:	28 e0       	ldi	r18, 0x08	; 8
     c82:	92 27       	eor	r25, r18
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
		// reverse_flag = 1; // positive Z dir!
		jog_select = 2;
     c84:	e2 e0       	ldi	r30, 0x02	; 2
     c86:	e8 8f       	std	Y+24, r30	; 0x18
	}
	
	// check for forward switches
	if (jog_bits & (1<<JOGFWD_X_BIT)) { // X forward switch on
     c88:	81 ff       	sbrs	r24, 1
     c8a:	02 c0       	rjmp	.+4      	; 0xc90 <jogging+0x236>
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
     c8c:	10 e4       	ldi	r17, 0x40	; 64
     c8e:	19 27       	eor	r17, r25
	}
	if (jog_bits & (1<<JOGFWD_Y_BIT)) { // Y forward switch on
     c90:	83 ff       	sbrs	r24, 3
     c92:	04 c0       	rjmp	.+8      	; 0xc9c <jogging+0x242>
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
     c94:	10 e1       	ldi	r17, 0x10	; 16
     c96:	19 27       	eor	r17, r25
		jog_select = 1;
     c98:	f1 e0       	ldi	r31, 0x01	; 1
     c9a:	f8 8f       	std	Y+24, r31	; 0x18
	}
	if (jog_bits & (1<<JOGFWD_Z_BIT)) { // Z forward switch on
     c9c:	85 ff       	sbrs	r24, 5
     c9e:	06 c0       	rjmp	.+12     	; 0xcac <jogging+0x252>
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
     ca0:	14 e0       	ldi	r17, 0x04	; 4
     ca2:	19 27       	eor	r17, r25
		reverse_flag = 1; // positive Z dir!
		jog_select = 2;
     ca4:	22 e0       	ldi	r18, 0x02	; 2
     ca6:	28 8f       	std	Y+24, r18	; 0x18
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		jog_select = 1;
	}
	if (jog_bits & (1<<JOGFWD_Z_BIT)) { // Z forward switch on
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
		reverse_flag = 1; // positive Z dir!
     ca8:	31 e0       	ldi	r19, 0x01	; 1
     caa:	39 8b       	std	Y+17, r19	; 0x11
		jog_select = 2;
	}

	while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
     cac:	ea e7       	ldi	r30, 0x7A	; 122
     cae:	f0 e0       	ldi	r31, 0x00	; 0
     cb0:	80 81       	ld	r24, Z
     cb2:	86 fd       	sbrc	r24, 6
     cb4:	fd cf       	rjmp	.-6      	; 0xcb0 <jogging+0x256>
	dest_step_rate = ADCH;    // set initial dest_step_rate according to analog input
     cb6:	20 91 79 00 	lds	r18, 0x0079
	dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     cba:	30 e0       	ldi	r19, 0x00	; 0
     cbc:	a7 e2       	ldi	r26, 0x27	; 39
     cbe:	bf e1       	ldi	r27, 0x1F	; 31
     cc0:	0e 94 df 3f 	call	0x7fbe	; 0x7fbe <__umulhisi3>
     cc4:	2f ef       	ldi	r18, 0xFF	; 255
     cc6:	30 e0       	ldi	r19, 0x00	; 0
     cc8:	40 e0       	ldi	r20, 0x00	; 0
     cca:	50 e0       	ldi	r21, 0x00	; 0
     ccc:	0e 94 b7 3f 	call	0x7f6e	; 0x7f6e <__udivmodsi4>
     cd0:	49 01       	movw	r8, r18
     cd2:	5a 01       	movw	r10, r20
     cd4:	89 e1       	ldi	r24, 0x19	; 25
     cd6:	88 0e       	add	r8, r24
     cd8:	91 1c       	adc	r9, r1
     cda:	a1 1c       	adc	r10, r1
     cdc:	b1 1c       	adc	r11, r1
	step_rate = JOG_MIN_SPEED;   // set initial step rate
	jog_exit = 0;
	
	st_wake_up();
     cde:	0e 94 0c 1b 	call	0x3618	; 0x3618 <st_wake_up>
	
	
	// prepare direction with small delay, direction settle time
	STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits0 & STEP_MASK);
     ce2:	8b b1       	in	r24, 0x0b	; 11
     ce4:	8b 7a       	andi	r24, 0xAB	; 171
     ce6:	8b b9       	out	0x0b, r24	; 11
	delay_us(10);
     ce8:	6a e0       	ldi	r22, 0x0A	; 10
     cea:	70 e0       	ldi	r23, 0x00	; 0
     cec:	80 e0       	ldi	r24, 0x00	; 0
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <delay_us>
	jog_bits_old = jog_bits;
	i = 0;  // now index for sending position data
	
	// Report machine position;
	if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
     cf4:	80 91 3c 09 	lds	r24, 0x093C
     cf8:	80 ff       	sbrs	r24, 0
     cfa:	20 c0       	rjmp	.+64     	; 0xd3c <jogging+0x2e2>
		mm_per_step = 1/(settings.steps_per_mm[jog_select] * INCH_PER_MM);
     cfc:	98 8d       	ldd	r25, Y+24	; 0x18
     cfe:	e9 2f       	mov	r30, r25
     d00:	f0 e0       	ldi	r31, 0x00	; 0
     d02:	ee 0f       	add	r30, r30
     d04:	ff 1f       	adc	r31, r31
     d06:	ee 0f       	add	r30, r30
     d08:	ff 1f       	adc	r31, r31
     d0a:	e1 50       	subi	r30, 0x01	; 1
     d0c:	f7 4f       	sbci	r31, 0xF7	; 247
     d0e:	2b e8       	ldi	r18, 0x8B	; 139
     d10:	32 e4       	ldi	r19, 0x42	; 66
     d12:	41 e2       	ldi	r20, 0x21	; 33
     d14:	5d e3       	ldi	r21, 0x3D	; 61
     d16:	60 81       	ld	r22, Z
     d18:	71 81       	ldd	r23, Z+1	; 0x01
     d1a:	82 81       	ldd	r24, Z+2	; 0x02
     d1c:	93 81       	ldd	r25, Z+3	; 0x03
     d1e:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
     d22:	9b 01       	movw	r18, r22
     d24:	ac 01       	movw	r20, r24
     d26:	60 e0       	ldi	r22, 0x00	; 0
     d28:	70 e0       	ldi	r23, 0x00	; 0
     d2a:	80 e8       	ldi	r24, 0x80	; 128
     d2c:	9f e3       	ldi	r25, 0x3F	; 63
     d2e:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
     d32:	6b 8b       	std	Y+19, r22	; 0x13
     d34:	7c 8b       	std	Y+20, r23	; 0x14
     d36:	8d 8b       	std	Y+21, r24	; 0x15
     d38:	9e 8b       	std	Y+22, r25	; 0x16
     d3a:	17 c0       	rjmp	.+46     	; 0xd6a <jogging+0x310>
		} else {
		mm_per_step = 1/settings.steps_per_mm[jog_select];
     d3c:	28 8d       	ldd	r18, Y+24	; 0x18
     d3e:	e2 2f       	mov	r30, r18
     d40:	f0 e0       	ldi	r31, 0x00	; 0
     d42:	ee 0f       	add	r30, r30
     d44:	ff 1f       	adc	r31, r31
     d46:	ee 0f       	add	r30, r30
     d48:	ff 1f       	adc	r31, r31
     d4a:	e1 50       	subi	r30, 0x01	; 1
     d4c:	f7 4f       	sbci	r31, 0xF7	; 247
     d4e:	20 81       	ld	r18, Z
     d50:	31 81       	ldd	r19, Z+1	; 0x01
     d52:	42 81       	ldd	r20, Z+2	; 0x02
     d54:	53 81       	ldd	r21, Z+3	; 0x03
     d56:	60 e0       	ldi	r22, 0x00	; 0
     d58:	70 e0       	ldi	r23, 0x00	; 0
     d5a:	80 e8       	ldi	r24, 0x80	; 128
     d5c:	9f e3       	ldi	r25, 0x3F	; 63
     d5e:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
     d62:	6b 8b       	std	Y+19, r22	; 0x13
     d64:	7c 8b       	std	Y+20, r23	; 0x14
     d66:	8d 8b       	std	Y+21, r24	; 0x15
     d68:	9e 8b       	std	Y+22, r25	; 0x16
	}
	
	work_position = sys.position[jog_select] / mm_per_step;
     d6a:	98 8d       	ldd	r25, Y+24	; 0x18
     d6c:	89 2f       	mov	r24, r25
     d6e:	90 e0       	ldi	r25, 0x00	; 0
     d70:	9e 87       	std	Y+14, r25	; 0x0e
     d72:	8d 87       	std	Y+13, r24	; 0x0d
     d74:	fc 01       	movw	r30, r24
     d76:	ee 0f       	add	r30, r30
     d78:	ff 1f       	adc	r31, r31
     d7a:	ee 0f       	add	r30, r30
     d7c:	ff 1f       	adc	r31, r31
     d7e:	e9 59       	subi	r30, 0x99	; 153
     d80:	f8 4f       	sbci	r31, 0xF8	; 248
     d82:	65 81       	ldd	r22, Z+5	; 0x05
     d84:	76 81       	ldd	r23, Z+6	; 0x06
     d86:	87 81       	ldd	r24, Z+7	; 0x07
     d88:	90 85       	ldd	r25, Z+8	; 0x08
     d8a:	0e 94 2e 3d 	call	0x7a5c	; 0x7a5c <__floatsisf>
     d8e:	2b 89       	ldd	r18, Y+19	; 0x13
     d90:	3c 89       	ldd	r19, Y+20	; 0x14
     d92:	4d 89       	ldd	r20, Y+21	; 0x15
     d94:	5e 89       	ldd	r21, Y+22	; 0x16
     d96:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
     d9a:	2b 01       	movw	r4, r22
     d9c:	3c 01       	movw	r6, r24
	}

	while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
	dest_step_rate = ADCH;    // set initial dest_step_rate according to analog input
	dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
	step_rate = JOG_MIN_SPEED;   // set initial step rate
     d9e:	0f 2e       	mov	r0, r31
     da0:	f9 e1       	ldi	r31, 0x19	; 25
     da2:	cf 2e       	mov	r12, r31
     da4:	d1 2c       	mov	r13, r1
     da6:	e1 2c       	mov	r14, r1
     da8:	f1 2c       	mov	r15, r1
     daa:	f0 2d       	mov	r31, r0
			gc_sync_position(); // Syncs all internal position vectors to the current system position.
			return;
		}
		

		ADCSRA |= (1<<ADSC); //start ADC conversion
     dac:	0f 2e       	mov	r0, r31
     dae:	fa e7       	ldi	r31, 0x7A	; 122
     db0:	2f 2e       	mov	r2, r31
     db2:	31 2c       	mov	r3, r1
     db4:	f0 2d       	mov	r31, r0
		// Both direction and step pins appropriately inverted and set. Perform one step
		STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits & STEP_MASK);
     db6:	01 2f       	mov	r16, r17
     db8:	04 75       	andi	r16, 0x54	; 84
		if (reverse_flag) {
			sys.position[jog_select]--;       // sys.position ist in Steps!
			work_position -= mm_per_step;
		}
		else {
			sys.position[jog_select]++;
     dba:	8d 85       	ldd	r24, Y+13	; 0x0d
     dbc:	9e 85       	ldd	r25, Y+14	; 0x0e
     dbe:	88 0f       	add	r24, r24
     dc0:	99 1f       	adc	r25, r25
     dc2:	88 0f       	add	r24, r24
     dc4:	99 1f       	adc	r25, r25
     dc6:	fc 01       	movw	r30, r24
     dc8:	e4 59       	subi	r30, 0x94	; 148
     dca:	f8 4f       	sbci	r31, 0xF8	; 248
     dcc:	fe 87       	std	Y+14, r31	; 0x0e
     dce:	ed 87       	std	Y+13, r30	; 0x0d
		
		if (sys.rt_exec_state & EXEC_STATUS_REPORT) {
			if (step_delay > 250) {
				// status report requested, print short msg only
				printPgmString(PSTR("Jog"));
				serial_write(88 + jog_select); // 88 = X + 1 = Y etc.
     dd0:	f8 8d       	ldd	r31, Y+24	; 0x18
     dd2:	f8 5a       	subi	r31, 0xA8	; 168
     dd4:	f8 8f       	std	Y+24, r31	; 0x18
		
		delay_us(step_delay);
		
		while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
		dest_step_rate = ADCH;    // set next dest_step_rate according to analog input
		dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     dd6:	a5 01       	movw	r20, r10
     dd8:	94 01       	movw	r18, r8
     dda:	0f 8b       	std	Y+23, r16	; 0x17
     ddc:	0d 85       	ldd	r16, Y+13	; 0x0d
     dde:	1e 85       	ldd	r17, Y+14	; 0x0e
	
	for(;;) { // repeat until button/joystick released
		//    report_realtime_status(); // benötigt viel Zeit!

		// Get limit pin state
		uint8_t bits = LIMIT_PIN;
     de0:	83 b1       	in	r24, 0x03	; 3
		if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { bits ^= LIMIT_MASK; }
     de2:	ec e3       	ldi	r30, 0x3C	; 60
     de4:	f9 e0       	ldi	r31, 0x09	; 9
     de6:	90 81       	ld	r25, Z
     de8:	96 fd       	sbrc	r25, 6
     dea:	02 c0       	rjmp	.+4      	; 0xdf0 <jogging+0x396>
     dec:	9e e0       	ldi	r25, 0x0E	; 14
     dee:	89 27       	eor	r24, r25
		if (bit_istrue(bits,LIMIT_MASK) && reverse_flag) { jog_exit = 1; } // immediate stop on any switch
     df0:	8e 70       	andi	r24, 0x0E	; 14
     df2:	39 f0       	breq	.+14     	; 0xe02 <jogging+0x3a8>
     df4:	bb 24       	eor	r11, r11
     df6:	b3 94       	inc	r11
     df8:	89 88       	ldd	r8, Y+17	; 0x11
     dfa:	81 10       	cpse	r8, r1
     dfc:	03 c0       	rjmp	.+6      	; 0xe04 <jogging+0x3aa>
     dfe:	b1 2c       	mov	r11, r1
     e00:	01 c0       	rjmp	.+2      	; 0xe04 <jogging+0x3aa>
     e02:	b1 2c       	mov	r11, r1
		
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     e04:	80 b1       	in	r24, 0x00	; 0
     e06:	80 95       	com	r24
     e08:	8f 77       	andi	r24, 0x7F	; 127
		if (jog_bits == jog_bits_old) { // nothing changed
     e0a:	9a 88       	ldd	r9, Y+18	; 0x12
     e0c:	98 12       	cpse	r9, r24
     e0e:	1f c0       	rjmp	.+62     	; 0xe4e <jogging+0x3f4>
			if (step_rate < (dest_step_rate - 5)) { // Hysteresis for A/D-conversion
     e10:	da 01       	movw	r26, r20
     e12:	c9 01       	movw	r24, r18
     e14:	05 97       	sbiw	r24, 0x05	; 5
     e16:	a1 09       	sbc	r26, r1
     e18:	b1 09       	sbc	r27, r1
     e1a:	c8 16       	cp	r12, r24
     e1c:	d9 06       	cpc	r13, r25
     e1e:	ea 06       	cpc	r14, r26
     e20:	fb 06       	cpc	r15, r27
     e22:	28 f4       	brcc	.+10     	; 0xe2e <jogging+0x3d4>
				step_rate += JOG_RAMP; // accelerate
     e24:	85 e0       	ldi	r24, 0x05	; 5
     e26:	c8 0e       	add	r12, r24
     e28:	d1 1c       	adc	r13, r1
     e2a:	e1 1c       	adc	r14, r1
     e2c:	f1 1c       	adc	r15, r1
			}
			if (step_rate > (dest_step_rate + 5)) { // Hysteresis for A/D-conversion
     e2e:	da 01       	movw	r26, r20
     e30:	c9 01       	movw	r24, r18
     e32:	05 96       	adiw	r24, 0x05	; 5
     e34:	a1 1d       	adc	r26, r1
     e36:	b1 1d       	adc	r27, r1
     e38:	8c 15       	cp	r24, r12
     e3a:	9d 05       	cpc	r25, r13
     e3c:	ae 05       	cpc	r26, r14
     e3e:	bf 05       	cpc	r27, r15
     e40:	f8 f4       	brcc	.+62     	; 0xe80 <jogging+0x426>
				step_rate -= JOG_RAMP; // brake
     e42:	95 e0       	ldi	r25, 0x05	; 5
     e44:	c9 1a       	sub	r12, r25
     e46:	d1 08       	sbc	r13, r1
     e48:	e1 08       	sbc	r14, r1
     e4a:	f1 08       	sbc	r15, r1
     e4c:	19 c0       	rjmp	.+50     	; 0xe80 <jogging+0x426>
			}
		}
		else {
			if (step_rate > (JOG_MIN_SPEED*2)) {  // switch change happened, fast brake to complete stop
     e4e:	e3 e3       	ldi	r30, 0x33	; 51
     e50:	ce 16       	cp	r12, r30
     e52:	d1 04       	cpc	r13, r1
     e54:	e1 04       	cpc	r14, r1
     e56:	f1 04       	cpc	r15, r1
     e58:	d0 f0       	brcs	.+52     	; 0xe8e <jogging+0x434>
				step_rate = ((step_rate * 99) / 100) - 5;
     e5a:	a3 e6       	ldi	r26, 0x63	; 99
     e5c:	b0 e0       	ldi	r27, 0x00	; 0
     e5e:	a7 01       	movw	r20, r14
     e60:	96 01       	movw	r18, r12
     e62:	0e 94 ee 3f 	call	0x7fdc	; 0x7fdc <__muluhisi3>
     e66:	24 e6       	ldi	r18, 0x64	; 100
     e68:	30 e0       	ldi	r19, 0x00	; 0
     e6a:	40 e0       	ldi	r20, 0x00	; 0
     e6c:	50 e0       	ldi	r21, 0x00	; 0
     e6e:	0e 94 b7 3f 	call	0x7f6e	; 0x7f6e <__udivmodsi4>
     e72:	69 01       	movw	r12, r18
     e74:	7a 01       	movw	r14, r20
     e76:	f5 e0       	ldi	r31, 0x05	; 5
     e78:	cf 1a       	sub	r12, r31
     e7a:	d1 08       	sbc	r13, r1
     e7c:	e1 08       	sbc	r14, r1
     e7e:	f1 08       	sbc	r15, r1
			else { jog_exit = 1; } // finished to stop and exit
		}
		
		
		// stop and exit if done
		if (jog_exit || (sys.rt_exec_state & EXEC_RESET)) {
     e80:	b1 10       	cpse	r11, r1
     e82:	05 c0       	rjmp	.+10     	; 0xe8e <jogging+0x434>
     e84:	ea e6       	ldi	r30, 0x6A	; 106
     e86:	f7 e0       	ldi	r31, 0x07	; 7
     e88:	80 81       	ld	r24, Z
     e8a:	84 ff       	sbrs	r24, 4
     e8c:	0a c0       	rjmp	.+20     	; 0xea2 <jogging+0x448>
			st_go_idle();
     e8e:	0e 94 4b 1b 	call	0x3696	; 0x3696 <st_go_idle>
			sys.state = last_sys_state;
     e92:	89 8c       	ldd	r8, Y+25	; 0x19
     e94:	80 92 68 07 	sts	0x0768, r8
			plan_sync_position();
     e98:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <plan_sync_position>
			gc_sync_position(); // Syncs all internal position vectors to the current system position.
     e9c:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <gc_sync_position>
			return;
     ea0:	ab c0       	rjmp	.+342    	; 0xff8 <jogging+0x59e>
		}
		

		ADCSRA |= (1<<ADSC); //start ADC conversion
     ea2:	f1 01       	movw	r30, r2
     ea4:	80 81       	ld	r24, Z
     ea6:	80 64       	ori	r24, 0x40	; 64
     ea8:	80 83       	st	Z, r24
		// Both direction and step pins appropriately inverted and set. Perform one step
		STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits & STEP_MASK);
     eaa:	8b b1       	in	r24, 0x0b	; 11
     eac:	8b 7a       	andi	r24, 0xAB	; 171
     eae:	8f 88       	ldd	r8, Y+23	; 0x17
     eb0:	88 29       	or	r24, r8
     eb2:	8b b9       	out	0x0b, r24	; 11
		delay_us(settings.pulse_microseconds/2);
     eb4:	ef e2       	ldi	r30, 0x2F	; 47
     eb6:	f9 e0       	ldi	r31, 0x09	; 9
     eb8:	60 81       	ld	r22, Z
     eba:	66 95       	lsr	r22
     ebc:	70 e0       	ldi	r23, 0x00	; 0
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <delay_us>
		step_delay = (1000000/step_rate) - settings.pulse_microseconds - 100; // 100 = fixed value for loop time
     ec6:	60 e4       	ldi	r22, 0x40	; 64
     ec8:	72 e4       	ldi	r23, 0x42	; 66
     eca:	8f e0       	ldi	r24, 0x0F	; 15
     ecc:	90 e0       	ldi	r25, 0x00	; 0
     ece:	a7 01       	movw	r20, r14
     ed0:	96 01       	movw	r18, r12
     ed2:	0e 94 b7 3f 	call	0x7f6e	; 0x7f6e <__udivmodsi4>
     ed6:	ef e2       	ldi	r30, 0x2F	; 47
     ed8:	f9 e0       	ldi	r31, 0x09	; 9
     eda:	80 81       	ld	r24, Z
     edc:	49 01       	movw	r8, r18
     ede:	5a 01       	movw	r10, r20
     ee0:	88 1a       	sub	r8, r24
     ee2:	91 08       	sbc	r9, r1
     ee4:	a1 08       	sbc	r10, r1
     ee6:	b1 08       	sbc	r11, r1
     ee8:	8d 86       	std	Y+13, r8	; 0x0d
     eea:	9e 86       	std	Y+14, r9	; 0x0e
     eec:	af 86       	std	Y+15, r10	; 0x0f
     eee:	b8 8a       	std	Y+16, r11	; 0x10
     ef0:	24 e6       	ldi	r18, 0x64	; 100
     ef2:	82 1a       	sub	r8, r18
     ef4:	91 08       	sbc	r9, r1
     ef6:	a1 08       	sbc	r10, r1
     ef8:	b1 08       	sbc	r11, r1
		STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits0 & STEP_MASK);
     efa:	8b b1       	in	r24, 0x0b	; 11
     efc:	8b 7a       	andi	r24, 0xAB	; 171
     efe:	8b b9       	out	0x0b, r24	; 11
		
	
		if (reverse_flag) {
     f00:	39 89       	ldd	r19, Y+17	; 0x11
     f02:	33 23       	and	r19, r19
     f04:	b9 f0       	breq	.+46     	; 0xf34 <jogging+0x4da>
			sys.position[jog_select]--;       // sys.position ist in Steps!
     f06:	f8 01       	movw	r30, r16
     f08:	80 81       	ld	r24, Z
     f0a:	91 81       	ldd	r25, Z+1	; 0x01
     f0c:	a2 81       	ldd	r26, Z+2	; 0x02
     f0e:	b3 81       	ldd	r27, Z+3	; 0x03
     f10:	01 97       	sbiw	r24, 0x01	; 1
     f12:	a1 09       	sbc	r26, r1
     f14:	b1 09       	sbc	r27, r1
     f16:	80 83       	st	Z, r24
     f18:	91 83       	std	Z+1, r25	; 0x01
     f1a:	a2 83       	std	Z+2, r26	; 0x02
     f1c:	b3 83       	std	Z+3, r27	; 0x03
			work_position -= mm_per_step;
     f1e:	2b 89       	ldd	r18, Y+19	; 0x13
     f20:	3c 89       	ldd	r19, Y+20	; 0x14
     f22:	4d 89       	ldd	r20, Y+21	; 0x15
     f24:	5e 89       	ldd	r21, Y+22	; 0x16
     f26:	c3 01       	movw	r24, r6
     f28:	b2 01       	movw	r22, r4
     f2a:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
     f2e:	2b 01       	movw	r4, r22
     f30:	3c 01       	movw	r6, r24
     f32:	16 c0       	rjmp	.+44     	; 0xf60 <jogging+0x506>
		}
		else {
			sys.position[jog_select]++;
     f34:	f8 01       	movw	r30, r16
     f36:	80 81       	ld	r24, Z
     f38:	91 81       	ldd	r25, Z+1	; 0x01
     f3a:	a2 81       	ldd	r26, Z+2	; 0x02
     f3c:	b3 81       	ldd	r27, Z+3	; 0x03
     f3e:	01 96       	adiw	r24, 0x01	; 1
     f40:	a1 1d       	adc	r26, r1
     f42:	b1 1d       	adc	r27, r1
     f44:	80 83       	st	Z, r24
     f46:	91 83       	std	Z+1, r25	; 0x01
     f48:	a2 83       	std	Z+2, r26	; 0x02
     f4a:	b3 83       	std	Z+3, r27	; 0x03
			work_position += mm_per_step;    // relative print_position in mm since last report
     f4c:	2b 89       	ldd	r18, Y+19	; 0x13
     f4e:	3c 89       	ldd	r19, Y+20	; 0x14
     f50:	4d 89       	ldd	r20, Y+21	; 0x15
     f52:	5e 89       	ldd	r21, Y+22	; 0x16
     f54:	c3 01       	movw	r24, r6
     f56:	b2 01       	movw	r22, r4
     f58:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
     f5c:	2b 01       	movw	r4, r22
     f5e:	3c 01       	movw	r6, r24
		}
		
		if (sys.rt_exec_state & EXEC_STATUS_REPORT) {
     f60:	ea e6       	ldi	r30, 0x6A	; 106
     f62:	f7 e0       	ldi	r31, 0x07	; 7
     f64:	80 81       	ld	r24, Z
     f66:	80 ff       	sbrs	r24, 0
     f68:	2d c0       	rjmp	.+90     	; 0xfc4 <jogging+0x56a>
			if (step_delay > 250) {
     f6a:	fb ef       	ldi	r31, 0xFB	; 251
     f6c:	8f 16       	cp	r8, r31
     f6e:	91 04       	cpc	r9, r1
     f70:	a1 04       	cpc	r10, r1
     f72:	b1 04       	cpc	r11, r1
     f74:	00 f1       	brcs	.+64     	; 0xfb6 <jogging+0x55c>
				// status report requested, print short msg only
				printPgmString(PSTR("Jog"));
     f76:	87 e8       	ldi	r24, 0x87	; 135
     f78:	92 e0       	ldi	r25, 0x02	; 2
     f7a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
				serial_write(88 + jog_select); // 88 = X + 1 = Y etc.
     f7e:	88 8d       	ldd	r24, Y+24	; 0x18
     f80:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
				serial_write(44);
     f84:	8c e2       	ldi	r24, 0x2C	; 44
     f86:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
				printFloat(work_position, 3);
     f8a:	43 e0       	ldi	r20, 0x03	; 3
     f8c:	c3 01       	movw	r24, r6
     f8e:	b2 01       	movw	r22, r4
     f90:	0e 94 28 33 	call	0x6650	; 0x6650 <printFloat>
				serial_write(13);
     f94:	8d e0       	ldi	r24, 0x0D	; 13
     f96:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
				serial_write(10);
     f9a:	8a e0       	ldi	r24, 0x0A	; 10
     f9c:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>

				step_delay -= 250;
     fa0:	8d 84       	ldd	r8, Y+13	; 0x0d
     fa2:	9e 84       	ldd	r9, Y+14	; 0x0e
     fa4:	af 84       	ldd	r10, Y+15	; 0x0f
     fa6:	b8 88       	ldd	r11, Y+16	; 0x10
     fa8:	2e e5       	ldi	r18, 0x5E	; 94
     faa:	82 1a       	sub	r8, r18
     fac:	21 e0       	ldi	r18, 0x01	; 1
     fae:	92 0a       	sbc	r9, r18
     fb0:	a1 08       	sbc	r10, r1
     fb2:	b1 08       	sbc	r11, r1
     fb4:	04 c0       	rjmp	.+8      	; 0xfbe <jogging+0x564>
			}
			else
			{
				printPgmString(PSTR("JogF\r\n"));
     fb6:	80 e8       	ldi	r24, 0x80	; 128
     fb8:	92 e0       	ldi	r25, 0x02	; 2
     fba:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
			}
			sys.rt_exec_state = 0;
     fbe:	ea e6       	ldi	r30, 0x6A	; 106
     fc0:	f7 e0       	ldi	r31, 0x07	; 7
     fc2:	10 82       	st	Z, r1
		}
		
		delay_us(step_delay);
     fc4:	c5 01       	movw	r24, r10
     fc6:	b4 01       	movw	r22, r8
     fc8:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <delay_us>
		
		while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
     fcc:	f1 01       	movw	r30, r2
     fce:	80 81       	ld	r24, Z
     fd0:	86 fd       	sbrc	r24, 6
     fd2:	fc cf       	rjmp	.-8      	; 0xfcc <jogging+0x572>
		dest_step_rate = ADCH;    // set next dest_step_rate according to analog input
     fd4:	20 91 79 00 	lds	r18, 0x0079
		dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     fd8:	30 e0       	ldi	r19, 0x00	; 0
     fda:	a7 e2       	ldi	r26, 0x27	; 39
     fdc:	bf e1       	ldi	r27, 0x1F	; 31
     fde:	0e 94 df 3f 	call	0x7fbe	; 0x7fbe <__umulhisi3>
     fe2:	2f ef       	ldi	r18, 0xFF	; 255
     fe4:	30 e0       	ldi	r19, 0x00	; 0
     fe6:	40 e0       	ldi	r20, 0x00	; 0
     fe8:	50 e0       	ldi	r21, 0x00	; 0
     fea:	0e 94 b7 3f 	call	0x7f6e	; 0x7f6e <__udivmodsi4>
     fee:	27 5e       	subi	r18, 0xE7	; 231
     ff0:	3f 4f       	sbci	r19, 0xFF	; 255
     ff2:	4f 4f       	sbci	r20, 0xFF	; 255
     ff4:	5f 4f       	sbci	r21, 0xFF	; 255

	}
     ff6:	f4 ce       	rjmp	.-536    	; 0xde0 <jogging+0x386>
     ff8:	69 96       	adiw	r28, 0x19	; 25
     ffa:	0f b6       	in	r0, 0x3f	; 63
     ffc:	f8 94       	cli
     ffe:	de bf       	out	0x3e, r29	; 62
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	cd bf       	out	0x3d, r28	; 61
    1004:	df 91       	pop	r29
    1006:	cf 91       	pop	r28
    1008:	1f 91       	pop	r17
    100a:	0f 91       	pop	r16
    100c:	ff 90       	pop	r15
    100e:	ef 90       	pop	r14
    1010:	df 90       	pop	r13
    1012:	cf 90       	pop	r12
    1014:	bf 90       	pop	r11
    1016:	af 90       	pop	r10
    1018:	9f 90       	pop	r9
    101a:	8f 90       	pop	r8
    101c:	7f 90       	pop	r7
    101e:	6f 90       	pop	r6
    1020:	5f 90       	pop	r5
    1022:	4f 90       	pop	r4
    1024:	3f 90       	pop	r3
    1026:	2f 90       	pop	r2
    1028:	08 95       	ret

0000102a <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
    102a:	0e 94 f6 17 	call	0x2fec	; 0x2fec <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
    102e:	0e 94 b0 28 	call	0x5160	; 0x5160 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
    1032:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
    1036:	0e 94 85 39 	call	0x730a	; 0x730a <system_init>
  
  memset(&sys, 0, sizeof(sys));  // Clear all system variables
    103a:	e7 e6       	ldi	r30, 0x67	; 103
    103c:	f7 e0       	ldi	r31, 0x07	; 7
    103e:	80 e2       	ldi	r24, 0x20	; 32
    1040:	df 01       	movw	r26, r30
    1042:	1d 92       	st	X+, r1
    1044:	8a 95       	dec	r24
    1046:	e9 f7       	brne	.-6      	; 0x1042 <main+0x18>
  sys.abort = true;   // Set abort to complete initialization
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	80 83       	st	Z, r24
  sei(); // Enable interrupts
    104c:	78 94       	sei
    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    gc_sync_position();

    // Reset system variables.
    sys.abort = false;
    104e:	6f 01       	movw	r12, r30
    sys.rt_exec_state = 0;
    1050:	0f 2e       	mov	r0, r31
    1052:	fa e6       	ldi	r31, 0x6A	; 106
    1054:	ef 2e       	mov	r14, r31
    1056:	f7 e0       	ldi	r31, 0x07	; 7
    1058:	ff 2e       	mov	r15, r31
    105a:	f0 2d       	mov	r31, r0
    sys.rt_exec_alarm = 0;
    105c:	0b e6       	ldi	r16, 0x6B	; 107
    105e:	17 e0       	ldi	r17, 0x07	; 7
    sys.suspend = false;
    1060:	c9 e6       	ldi	r28, 0x69	; 105
    1062:	d7 e0       	ldi	r29, 0x07	; 7

    // TODO: Separate configure task that require interrupts to be disabled, especially upon
    // a system abort and ensuring any active interrupts are cleanly reset.
  
    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
    1064:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
    1068:	0e 94 c8 0c 	call	0x1990	; 0x1990 <gc_init>
    spindle_init();
    106c:	0e 94 ad 17 	call	0x2f5a	; 0x2f5a <spindle_init>
    coolant_init();
    1070:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <coolant_init>
    limits_init(); 
    1074:	0e 94 37 2f 	call	0x5e6e	; 0x5e6e <limits_init>
    probe_init();
    1078:	0e 94 0d 34 	call	0x681a	; 0x681a <probe_init>
    plan_reset(); // Clear block buffer and planner variables
    107c:	0e 94 34 2a 	call	0x5468	; 0x5468 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
    1080:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <st_reset>
	jog_init();
    1084:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <jog_init>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    1088:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <plan_sync_position>
    gc_sync_position();
    108c:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <gc_sync_position>

    // Reset system variables.
    sys.abort = false;
    1090:	f6 01       	movw	r30, r12
    1092:	10 82       	st	Z, r1
    sys.rt_exec_state = 0;
    1094:	d7 01       	movw	r26, r14
    1096:	1c 92       	st	X, r1
    sys.rt_exec_alarm = 0;
    1098:	f8 01       	movw	r30, r16
    109a:	10 82       	st	Z, r1
    sys.suspend = false;
    109c:	18 82       	st	Y, r1
          
    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
    109e:	0e 94 c2 1a 	call	0x3584	; 0x3584 <protocol_main_loop>
    10a2:	e0 cf       	rjmp	.-64     	; 0x1064 <main+0x3a>

000010a4 <mc_line>:
#ifdef USE_LINE_NUMBERS
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{
    10a4:	bf 92       	push	r11
    10a6:	cf 92       	push	r12
    10a8:	df 92       	push	r13
    10aa:	ef 92       	push	r14
    10ac:	ff 92       	push	r15
    10ae:	0f 93       	push	r16
    10b0:	1f 93       	push	r17
    10b2:	cf 93       	push	r28
    10b4:	df 93       	push	r29
    10b6:	8c 01       	movw	r16, r24
    10b8:	6a 01       	movw	r12, r20
    10ba:	7b 01       	movw	r14, r22
    10bc:	b2 2e       	mov	r11, r18
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) { limits_soft_check(target); }    
    10be:	80 91 3c 09 	lds	r24, 0x093C
    10c2:	85 ff       	sbrs	r24, 5
    10c4:	03 c0       	rjmp	.+6      	; 0x10cc <mc_line+0x28>
    10c6:	c8 01       	movw	r24, r16
    10c8:	0e 94 36 32 	call	0x646c	; 0x646c <limits_soft_check>
      
  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
    10cc:	80 91 68 07 	lds	r24, 0x0768
    10d0:	82 30       	cpi	r24, 0x02	; 2
    10d2:	a1 f0       	breq	.+40     	; 0x10fc <mc_line+0x58>

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
    10d4:	c7 e6       	ldi	r28, 0x67	; 103
    10d6:	d7 e0       	ldi	r29, 0x07	; 7
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    10d8:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
    10dc:	88 81       	ld	r24, Y
    10de:	81 11       	cpse	r24, r1
    10e0:	0d c0       	rjmp	.+26     	; 0x10fc <mc_line+0x58>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
    10e2:	0e 94 84 2a 	call	0x5508	; 0x5508 <plan_check_full_buffer>
    10e6:	88 23       	and	r24, r24
    10e8:	19 f0       	breq	.+6      	; 0x10f0 <mc_line+0x4c>
    10ea:	0e 94 b9 1a 	call	0x3572	; 0x3572 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
    10ee:	f4 cf       	rjmp	.-24     	; 0x10d8 <mc_line+0x34>

  // Plan and queue motion into planner buffer
  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    plan_buffer_line(target, feed_rate, invert_feed_rate);
    10f0:	2b 2d       	mov	r18, r11
    10f2:	b7 01       	movw	r22, r14
    10f4:	a6 01       	movw	r20, r12
    10f6:	c8 01       	movw	r24, r16
    10f8:	0e 94 8c 2a 	call	0x5518	; 0x5518 <plan_buffer_line>
  #endif
}
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	1f 91       	pop	r17
    1102:	0f 91       	pop	r16
    1104:	ff 90       	pop	r15
    1106:	ef 90       	pop	r14
    1108:	df 90       	pop	r13
    110a:	cf 90       	pop	r12
    110c:	bf 90       	pop	r11
    110e:	08 95       	ret

00001110 <mc_arc>:
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc, int32_t line_number)
#else
  void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate,
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
#endif
{
    1110:	2f 92       	push	r2
    1112:	3f 92       	push	r3
    1114:	4f 92       	push	r4
    1116:	5f 92       	push	r5
    1118:	6f 92       	push	r6
    111a:	7f 92       	push	r7
    111c:	8f 92       	push	r8
    111e:	9f 92       	push	r9
    1120:	af 92       	push	r10
    1122:	bf 92       	push	r11
    1124:	cf 92       	push	r12
    1126:	df 92       	push	r13
    1128:	ef 92       	push	r14
    112a:	ff 92       	push	r15
    112c:	0f 93       	push	r16
    112e:	1f 93       	push	r17
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	cd b7       	in	r28, 0x3d	; 61
    1136:	de b7       	in	r29, 0x3e	; 62
    1138:	e9 97       	sbiw	r28, 0x39	; 57
    113a:	0f b6       	in	r0, 0x3f	; 63
    113c:	f8 94       	cli
    113e:	de bf       	out	0x3e, r29	; 62
    1140:	0f be       	out	0x3f, r0	; 63
    1142:	cd bf       	out	0x3d, r28	; 61
    1144:	9a 8b       	std	Y+18, r25	; 0x12
    1146:	89 8b       	std	Y+17, r24	; 0x11
    1148:	79 af       	std	Y+57, r23	; 0x39
    114a:	68 af       	std	Y+56, r22	; 0x38
    114c:	3a 01       	movw	r6, r20
    114e:	09 87       	std	Y+9, r16	; 0x09
    1150:	1a 87       	std	Y+10, r17	; 0x0a
    1152:	2b 87       	std	Y+11, r18	; 0x0b
    1154:	3c 87       	std	Y+12, r19	; 0x0c
    1156:	ab 8a       	std	Y+19, r10	; 0x13
  float center_axis0 = position[axis_0] + offset[axis_0];
    1158:	48 2c       	mov	r4, r8
    115a:	51 2c       	mov	r5, r1
    115c:	12 01       	movw	r2, r4
    115e:	22 0c       	add	r2, r2
    1160:	33 1c       	adc	r3, r3
    1162:	22 0c       	add	r2, r2
    1164:	33 1c       	adc	r3, r3
    1166:	82 0d       	add	r24, r2
    1168:	93 1d       	adc	r25, r3
    116a:	9d 8b       	std	Y+21, r25	; 0x15
    116c:	8c 8b       	std	Y+20, r24	; 0x14
    116e:	9a 01       	movw	r18, r20
    1170:	22 0d       	add	r18, r2
    1172:	33 1d       	adc	r19, r3
    1174:	3d ab       	std	Y+53, r19	; 0x35
    1176:	2c ab       	std	Y+52, r18	; 0x34
    1178:	d9 01       	movw	r26, r18
    117a:	8d 90       	ld	r8, X+
    117c:	9d 90       	ld	r9, X+
    117e:	ad 90       	ld	r10, X+
    1180:	bc 90       	ld	r11, X
    1182:	fc 01       	movw	r30, r24
    1184:	20 81       	ld	r18, Z
    1186:	31 81       	ldd	r19, Z+1	; 0x01
    1188:	42 81       	ldd	r20, Z+2	; 0x02
    118a:	53 81       	ldd	r21, Z+3	; 0x03
    118c:	c5 01       	movw	r24, r10
    118e:	b4 01       	movw	r22, r8
    1190:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    1194:	6e 8b       	std	Y+22, r22	; 0x16
    1196:	7f 8b       	std	Y+23, r23	; 0x17
    1198:	88 8f       	std	Y+24, r24	; 0x18
    119a:	99 8f       	std	Y+25, r25	; 0x19
  float center_axis1 = position[axis_1] + offset[axis_1];
    119c:	2f 96       	adiw	r28, 0x0f	; 15
    119e:	0f ad       	ldd	r16, Y+63	; 0x3f
    11a0:	2f 97       	sbiw	r28, 0x0f	; 15
    11a2:	10 e0       	ldi	r17, 0x00	; 0
    11a4:	00 0f       	add	r16, r16
    11a6:	11 1f       	adc	r17, r17
    11a8:	00 0f       	add	r16, r16
    11aa:	11 1f       	adc	r17, r17
    11ac:	29 89       	ldd	r18, Y+17	; 0x11
    11ae:	3a 89       	ldd	r19, Y+18	; 0x12
    11b0:	20 0f       	add	r18, r16
    11b2:	31 1f       	adc	r19, r17
    11b4:	3b 8f       	std	Y+27, r19	; 0x1b
    11b6:	2a 8f       	std	Y+26, r18	; 0x1a
    11b8:	a3 01       	movw	r20, r6
    11ba:	40 0f       	add	r20, r16
    11bc:	51 1f       	adc	r21, r17
    11be:	5f ab       	std	Y+55, r21	; 0x37
    11c0:	4e ab       	std	Y+54, r20	; 0x36
    11c2:	da 01       	movw	r26, r20
    11c4:	8d 91       	ld	r24, X+
    11c6:	9d 91       	ld	r25, X+
    11c8:	0d 90       	ld	r0, X+
    11ca:	bc 91       	ld	r27, X
    11cc:	a0 2d       	mov	r26, r0
    11ce:	89 83       	std	Y+1, r24	; 0x01
    11d0:	9a 83       	std	Y+2, r25	; 0x02
    11d2:	ab 83       	std	Y+3, r26	; 0x03
    11d4:	bc 83       	std	Y+4, r27	; 0x04
    11d6:	f9 01       	movw	r30, r18
    11d8:	20 81       	ld	r18, Z
    11da:	31 81       	ldd	r19, Z+1	; 0x01
    11dc:	42 81       	ldd	r20, Z+2	; 0x02
    11de:	53 81       	ldd	r21, Z+3	; 0x03
    11e0:	bc 01       	movw	r22, r24
    11e2:	cd 01       	movw	r24, r26
    11e4:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    11e8:	6c 8f       	std	Y+28, r22	; 0x1c
    11ea:	7d 8f       	std	Y+29, r23	; 0x1d
    11ec:	8e 8f       	std	Y+30, r24	; 0x1e
    11ee:	9f 8f       	std	Y+31, r25	; 0x1f
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
    11f0:	24 01       	movw	r4, r8
    11f2:	35 01       	movw	r6, r10
    11f4:	77 fa       	bst	r7, 7
    11f6:	70 94       	com	r7
    11f8:	77 f8       	bld	r7, 7
    11fa:	70 94       	com	r7
  float r_axis1 = -offset[axis_1];
    11fc:	89 80       	ldd	r8, Y+1	; 0x01
    11fe:	9a 80       	ldd	r9, Y+2	; 0x02
    1200:	ab 80       	ldd	r10, Y+3	; 0x03
    1202:	bc 80       	ldd	r11, Y+4	; 0x04
    1204:	b7 fa       	bst	r11, 7
    1206:	b0 94       	com	r11
    1208:	b7 f8       	bld	r11, 7
    120a:	b0 94       	com	r11
  float rt_axis0 = target[axis_0] - center_axis0;
    120c:	e8 ad       	ldd	r30, Y+56	; 0x38
    120e:	f9 ad       	ldd	r31, Y+57	; 0x39
    1210:	e2 0d       	add	r30, r2
    1212:	f3 1d       	adc	r31, r3
    1214:	2e 89       	ldd	r18, Y+22	; 0x16
    1216:	3f 89       	ldd	r19, Y+23	; 0x17
    1218:	48 8d       	ldd	r20, Y+24	; 0x18
    121a:	59 8d       	ldd	r21, Y+25	; 0x19
    121c:	60 81       	ld	r22, Z
    121e:	71 81       	ldd	r23, Z+1	; 0x01
    1220:	82 81       	ldd	r24, Z+2	; 0x02
    1222:	93 81       	ldd	r25, Z+3	; 0x03
    1224:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    1228:	69 83       	std	Y+1, r22	; 0x01
    122a:	7a 83       	std	Y+2, r23	; 0x02
    122c:	8b 83       	std	Y+3, r24	; 0x03
    122e:	9c 83       	std	Y+4, r25	; 0x04
  float rt_axis1 = target[axis_1] - center_axis1;
    1230:	e8 ad       	ldd	r30, Y+56	; 0x38
    1232:	f9 ad       	ldd	r31, Y+57	; 0x39
    1234:	e0 0f       	add	r30, r16
    1236:	f1 1f       	adc	r31, r17
    1238:	2c 8d       	ldd	r18, Y+28	; 0x1c
    123a:	3d 8d       	ldd	r19, Y+29	; 0x1d
    123c:	4e 8d       	ldd	r20, Y+30	; 0x1e
    123e:	5f 8d       	ldd	r21, Y+31	; 0x1f
    1240:	60 81       	ld	r22, Z
    1242:	71 81       	ldd	r23, Z+1	; 0x01
    1244:	82 81       	ldd	r24, Z+2	; 0x02
    1246:	93 81       	ldd	r25, Z+3	; 0x03
    1248:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    124c:	6d 83       	std	Y+5, r22	; 0x05
    124e:	7e 83       	std	Y+6, r23	; 0x06
    1250:	8f 83       	std	Y+7, r24	; 0x07
    1252:	98 87       	std	Y+8, r25	; 0x08
  
  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
    1254:	29 81       	ldd	r18, Y+1	; 0x01
    1256:	3a 81       	ldd	r19, Y+2	; 0x02
    1258:	4b 81       	ldd	r20, Y+3	; 0x03
    125a:	5c 81       	ldd	r21, Y+4	; 0x04
    125c:	c3 01       	movw	r24, r6
    125e:	b2 01       	movw	r22, r4
    1260:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    1264:	6d 87       	std	Y+13, r22	; 0x0d
    1266:	7e 87       	std	Y+14, r23	; 0x0e
    1268:	8f 87       	std	Y+15, r24	; 0x0f
    126a:	98 8b       	std	Y+16, r25	; 0x10
    126c:	2d 81       	ldd	r18, Y+5	; 0x05
    126e:	3e 81       	ldd	r19, Y+6	; 0x06
    1270:	4f 81       	ldd	r20, Y+7	; 0x07
    1272:	58 85       	ldd	r21, Y+8	; 0x08
    1274:	c5 01       	movw	r24, r10
    1276:	b4 01       	movw	r22, r8
    1278:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    127c:	9b 01       	movw	r18, r22
    127e:	ac 01       	movw	r20, r24
    1280:	6d 85       	ldd	r22, Y+13	; 0x0d
    1282:	7e 85       	ldd	r23, Y+14	; 0x0e
    1284:	8f 85       	ldd	r24, Y+15	; 0x0f
    1286:	98 89       	ldd	r25, Y+16	; 0x10
    1288:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    128c:	6d 87       	std	Y+13, r22	; 0x0d
    128e:	7e 87       	std	Y+14, r23	; 0x0e
    1290:	8f 87       	std	Y+15, r24	; 0x0f
    1292:	98 8b       	std	Y+16, r25	; 0x10
    1294:	2d 81       	ldd	r18, Y+5	; 0x05
    1296:	3e 81       	ldd	r19, Y+6	; 0x06
    1298:	4f 81       	ldd	r20, Y+7	; 0x07
    129a:	58 85       	ldd	r21, Y+8	; 0x08
    129c:	c3 01       	movw	r24, r6
    129e:	b2 01       	movw	r22, r4
    12a0:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    12a4:	6d 83       	std	Y+5, r22	; 0x05
    12a6:	7e 83       	std	Y+6, r23	; 0x06
    12a8:	8f 83       	std	Y+7, r24	; 0x07
    12aa:	98 87       	std	Y+8, r25	; 0x08
    12ac:	29 81       	ldd	r18, Y+1	; 0x01
    12ae:	3a 81       	ldd	r19, Y+2	; 0x02
    12b0:	4b 81       	ldd	r20, Y+3	; 0x03
    12b2:	5c 81       	ldd	r21, Y+4	; 0x04
    12b4:	c5 01       	movw	r24, r10
    12b6:	b4 01       	movw	r22, r8
    12b8:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    12bc:	9b 01       	movw	r18, r22
    12be:	ac 01       	movw	r20, r24
    12c0:	6d 81       	ldd	r22, Y+5	; 0x05
    12c2:	7e 81       	ldd	r23, Y+6	; 0x06
    12c4:	8f 81       	ldd	r24, Y+7	; 0x07
    12c6:	98 85       	ldd	r25, Y+8	; 0x08
    12c8:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    12cc:	2d 85       	ldd	r18, Y+13	; 0x0d
    12ce:	3e 85       	ldd	r19, Y+14	; 0x0e
    12d0:	4f 85       	ldd	r20, Y+15	; 0x0f
    12d2:	58 89       	ldd	r21, Y+16	; 0x10
    12d4:	0e 94 26 3c 	call	0x784c	; 0x784c <atan2>
    12d8:	69 83       	std	Y+1, r22	; 0x01
    12da:	7a 83       	std	Y+2, r23	; 0x02
    12dc:	8b 83       	std	Y+3, r24	; 0x03
    12de:	9c 83       	std	Y+4, r25	; 0x04
  if (is_clockwise_arc) { // Correct atan2 output per direction
    12e0:	61 96       	adiw	r28, 0x11	; 17
    12e2:	8f ad       	ldd	r24, Y+63	; 0x3f
    12e4:	61 97       	sbiw	r28, 0x11	; 17
    12e6:	88 23       	and	r24, r24
    12e8:	d1 f0       	breq	.+52     	; 0x131e <mc_arc+0x20e>
    if (angular_travel >= 0) { angular_travel -= 2*M_PI; }
    12ea:	20 e0       	ldi	r18, 0x00	; 0
    12ec:	30 e0       	ldi	r19, 0x00	; 0
    12ee:	a9 01       	movw	r20, r18
    12f0:	69 81       	ldd	r22, Y+1	; 0x01
    12f2:	7a 81       	ldd	r23, Y+2	; 0x02
    12f4:	8b 81       	ldd	r24, Y+3	; 0x03
    12f6:	9c 81       	ldd	r25, Y+4	; 0x04
    12f8:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    12fc:	88 23       	and	r24, r24
    12fe:	44 f1       	brlt	.+80     	; 0x1350 <mc_arc+0x240>
    1300:	2b ed       	ldi	r18, 0xDB	; 219
    1302:	3f e0       	ldi	r19, 0x0F	; 15
    1304:	49 ec       	ldi	r20, 0xC9	; 201
    1306:	50 e4       	ldi	r21, 0x40	; 64
    1308:	69 81       	ldd	r22, Y+1	; 0x01
    130a:	7a 81       	ldd	r23, Y+2	; 0x02
    130c:	8b 81       	ldd	r24, Y+3	; 0x03
    130e:	9c 81       	ldd	r25, Y+4	; 0x04
    1310:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    1314:	69 83       	std	Y+1, r22	; 0x01
    1316:	7a 83       	std	Y+2, r23	; 0x02
    1318:	8b 83       	std	Y+3, r24	; 0x03
    131a:	9c 83       	std	Y+4, r25	; 0x04
    131c:	19 c0       	rjmp	.+50     	; 0x1350 <mc_arc+0x240>
  } else {
    if (angular_travel <= 0) { angular_travel += 2*M_PI; }
    131e:	20 e0       	ldi	r18, 0x00	; 0
    1320:	30 e0       	ldi	r19, 0x00	; 0
    1322:	a9 01       	movw	r20, r18
    1324:	69 81       	ldd	r22, Y+1	; 0x01
    1326:	7a 81       	ldd	r23, Y+2	; 0x02
    1328:	8b 81       	ldd	r24, Y+3	; 0x03
    132a:	9c 81       	ldd	r25, Y+4	; 0x04
    132c:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    1330:	18 16       	cp	r1, r24
    1332:	74 f0       	brlt	.+28     	; 0x1350 <mc_arc+0x240>
    1334:	2b ed       	ldi	r18, 0xDB	; 219
    1336:	3f e0       	ldi	r19, 0x0F	; 15
    1338:	49 ec       	ldi	r20, 0xC9	; 201
    133a:	50 e4       	ldi	r21, 0x40	; 64
    133c:	69 81       	ldd	r22, Y+1	; 0x01
    133e:	7a 81       	ldd	r23, Y+2	; 0x02
    1340:	8b 81       	ldd	r24, Y+3	; 0x03
    1342:	9c 81       	ldd	r25, Y+4	; 0x04
    1344:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    1348:	69 83       	std	Y+1, r22	; 0x01
    134a:	7a 83       	std	Y+2, r23	; 0x02
    134c:	8b 83       	std	Y+3, r24	; 0x03
    134e:	9c 83       	std	Y+4, r25	; 0x04
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
    1350:	20 91 38 09 	lds	r18, 0x0938
    1354:	30 91 39 09 	lds	r19, 0x0939
    1358:	40 91 3a 09 	lds	r20, 0x093A
    135c:	50 91 3b 09 	lds	r21, 0x093B
    1360:	2d 83       	std	Y+5, r18	; 0x05
    1362:	3e 83       	std	Y+6, r19	; 0x06
    1364:	4f 83       	std	Y+7, r20	; 0x07
    1366:	58 87       	std	Y+8, r21	; 0x08
    1368:	29 85       	ldd	r18, Y+9	; 0x09
    136a:	3a 85       	ldd	r19, Y+10	; 0x0a
    136c:	4b 85       	ldd	r20, Y+11	; 0x0b
    136e:	5c 85       	ldd	r21, Y+12	; 0x0c
    1370:	ca 01       	movw	r24, r20
    1372:	b9 01       	movw	r22, r18
    1374:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    1378:	2d 81       	ldd	r18, Y+5	; 0x05
    137a:	3e 81       	ldd	r19, Y+6	; 0x06
    137c:	4f 81       	ldd	r20, Y+7	; 0x07
    137e:	58 85       	ldd	r21, Y+8	; 0x08
    1380:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    1384:	9b 01       	movw	r18, r22
    1386:	ac 01       	movw	r20, r24
    1388:	6d 81       	ldd	r22, Y+5	; 0x05
    138a:	7e 81       	ldd	r23, Y+6	; 0x06
    138c:	8f 81       	ldd	r24, Y+7	; 0x07
    138e:	98 85       	ldd	r25, Y+8	; 0x08
    1390:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    1394:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    1398:	6d 83       	std	Y+5, r22	; 0x05
    139a:	7e 83       	std	Y+6, r23	; 0x06
    139c:	8f 83       	std	Y+7, r24	; 0x07
    139e:	98 87       	std	Y+8, r25	; 0x08

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
    13a0:	20 e0       	ldi	r18, 0x00	; 0
    13a2:	30 e0       	ldi	r19, 0x00	; 0
    13a4:	40 e0       	ldi	r20, 0x00	; 0
    13a6:	5f e3       	ldi	r21, 0x3F	; 63
    13a8:	69 81       	ldd	r22, Y+1	; 0x01
    13aa:	7a 81       	ldd	r23, Y+2	; 0x02
    13ac:	8b 81       	ldd	r24, Y+3	; 0x03
    13ae:	9c 81       	ldd	r25, Y+4	; 0x04
    13b0:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    13b4:	29 85       	ldd	r18, Y+9	; 0x09
    13b6:	3a 85       	ldd	r19, Y+10	; 0x0a
    13b8:	4b 85       	ldd	r20, Y+11	; 0x0b
    13ba:	5c 85       	ldd	r21, Y+12	; 0x0c
    13bc:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    13c0:	9f 77       	andi	r25, 0x7F	; 127
    13c2:	2d 81       	ldd	r18, Y+5	; 0x05
    13c4:	3e 81       	ldd	r19, Y+6	; 0x06
    13c6:	4f 81       	ldd	r20, Y+7	; 0x07
    13c8:	58 85       	ldd	r21, Y+8	; 0x08
    13ca:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    13ce:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <floor>
    13d2:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
    13d6:	69 87       	std	Y+9, r22	; 0x09
    13d8:	7a 87       	std	Y+10, r23	; 0x0a
    13da:	8b 87       	std	Y+11, r24	; 0x0b
    13dc:	9c 87       	std	Y+12, r25	; 0x0c
    13de:	49 85       	ldd	r20, Y+9	; 0x09
    13e0:	5a 85       	ldd	r21, Y+10	; 0x0a
    13e2:	5e 87       	std	Y+14, r21	; 0x0e
    13e4:	4d 87       	std	Y+13, r20	; 0x0d
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
  
  if (segments) { 
    13e6:	45 2b       	or	r20, r21
    13e8:	09 f4       	brne	.+2      	; 0x13ec <mc_arc+0x2dc>
    13ea:	8e c1       	rjmp	.+796    	; 0x1708 <mc_arc+0x5f8>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of 
    // all segments.
    if (invert_feed_rate) { feed_rate *= segments; }
    13ec:	5b 89       	ldd	r21, Y+19	; 0x13
    13ee:	55 23       	and	r21, r21
    13f0:	79 f0       	breq	.+30     	; 0x1410 <mc_arc+0x300>
    13f2:	a9 85       	ldd	r26, Y+9	; 0x09
    13f4:	ba 85       	ldd	r27, Y+10	; 0x0a
    13f6:	bd 01       	movw	r22, r26
    13f8:	80 e0       	ldi	r24, 0x00	; 0
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	0e 94 2c 3d 	call	0x7a58	; 0x7a58 <__floatunsisf>
    1400:	9b 01       	movw	r18, r22
    1402:	ac 01       	movw	r20, r24
    1404:	c7 01       	movw	r24, r14
    1406:	b6 01       	movw	r22, r12
    1408:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    140c:	6b 01       	movw	r12, r22
    140e:	7c 01       	movw	r14, r24
   
    float theta_per_segment = angular_travel/segments;
    1410:	e9 85       	ldd	r30, Y+9	; 0x09
    1412:	fa 85       	ldd	r31, Y+10	; 0x0a
    1414:	bf 01       	movw	r22, r30
    1416:	80 e0       	ldi	r24, 0x00	; 0
    1418:	90 e0       	ldi	r25, 0x00	; 0
    141a:	0e 94 2c 3d 	call	0x7a58	; 0x7a58 <__floatunsisf>
    141e:	69 87       	std	Y+9, r22	; 0x09
    1420:	7a 87       	std	Y+10, r23	; 0x0a
    1422:	8b 87       	std	Y+11, r24	; 0x0b
    1424:	9c 87       	std	Y+12, r25	; 0x0c
    1426:	9b 01       	movw	r18, r22
    1428:	ac 01       	movw	r20, r24
    142a:	69 81       	ldd	r22, Y+1	; 0x01
    142c:	7a 81       	ldd	r23, Y+2	; 0x02
    142e:	8b 81       	ldd	r24, Y+3	; 0x03
    1430:	9c 81       	ldd	r25, Y+4	; 0x04
    1432:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    1436:	68 ab       	std	Y+48, r22	; 0x30
    1438:	79 ab       	std	Y+49, r23	; 0x31
    143a:	8a ab       	std	Y+50, r24	; 0x32
    143c:	9b ab       	std	Y+51, r25	; 0x33
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
    143e:	60 96       	adiw	r28, 0x10	; 16
    1440:	8f ad       	ldd	r24, Y+63	; 0x3f
    1442:	60 97       	sbiw	r28, 0x10	; 16
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	88 0f       	add	r24, r24
    1448:	99 1f       	adc	r25, r25
    144a:	88 0f       	add	r24, r24
    144c:	99 1f       	adc	r25, r25
    144e:	29 89       	ldd	r18, Y+17	; 0x11
    1450:	3a 89       	ldd	r19, Y+18	; 0x12
    1452:	28 0f       	add	r18, r24
    1454:	39 1f       	adc	r19, r25
    1456:	3a 83       	std	Y+2, r19	; 0x02
    1458:	29 83       	std	Y+1, r18	; 0x01
    145a:	e8 ad       	ldd	r30, Y+56	; 0x38
    145c:	f9 ad       	ldd	r31, Y+57	; 0x39
    145e:	e8 0f       	add	r30, r24
    1460:	f9 1f       	adc	r31, r25
    1462:	d9 01       	movw	r26, r18
    1464:	2d 91       	ld	r18, X+
    1466:	3d 91       	ld	r19, X+
    1468:	4d 91       	ld	r20, X+
    146a:	5c 91       	ld	r21, X
    146c:	60 81       	ld	r22, Z
    146e:	71 81       	ldd	r23, Z+1	; 0x01
    1470:	82 81       	ldd	r24, Z+2	; 0x02
    1472:	93 81       	ldd	r25, Z+3	; 0x03
    1474:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    1478:	29 85       	ldd	r18, Y+9	; 0x09
    147a:	3a 85       	ldd	r19, Y+10	; 0x0a
    147c:	4b 85       	ldd	r20, Y+11	; 0x0b
    147e:	5c 85       	ldd	r21, Y+12	; 0x0c
    1480:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    1484:	6c a3       	std	Y+36, r22	; 0x24
    1486:	7d a3       	std	Y+37, r23	; 0x25
    1488:	8e a3       	std	Y+38, r24	; 0x26
    148a:	9f a3       	std	Y+39, r25	; 0x27
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. 
       This is important when there are successive arc motions. 
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
    148c:	28 a9       	ldd	r18, Y+48	; 0x30
    148e:	39 a9       	ldd	r19, Y+49	; 0x31
    1490:	4a a9       	ldd	r20, Y+50	; 0x32
    1492:	5b a9       	ldd	r21, Y+51	; 0x33
    1494:	ca 01       	movw	r24, r20
    1496:	b9 01       	movw	r22, r18
    1498:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    149c:	9b 01       	movw	r18, r22
    149e:	ac 01       	movw	r20, r24
    14a0:	60 e0       	ldi	r22, 0x00	; 0
    14a2:	70 e0       	ldi	r23, 0x00	; 0
    14a4:	80 e0       	ldi	r24, 0x00	; 0
    14a6:	90 e4       	ldi	r25, 0x40	; 64
    14a8:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    14ac:	69 87       	std	Y+9, r22	; 0x09
    14ae:	7a 87       	std	Y+10, r23	; 0x0a
    14b0:	8b 87       	std	Y+11, r24	; 0x0b
    14b2:	9c 87       	std	Y+12, r25	; 0x0c
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
    14b4:	2b ea       	ldi	r18, 0xAB	; 171
    14b6:	3a ea       	ldi	r19, 0xAA	; 170
    14b8:	4a e2       	ldi	r20, 0x2A	; 42
    14ba:	5e e3       	ldi	r21, 0x3E	; 62
    14bc:	68 a9       	ldd	r22, Y+48	; 0x30
    14be:	79 a9       	ldd	r23, Y+49	; 0x31
    14c0:	8a a9       	ldd	r24, Y+50	; 0x32
    14c2:	9b a9       	ldd	r25, Y+51	; 0x33
    14c4:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    14c8:	6d 83       	std	Y+5, r22	; 0x05
    14ca:	7e 83       	std	Y+6, r23	; 0x06
    14cc:	8f 83       	std	Y+7, r24	; 0x07
    14ce:	98 87       	std	Y+8, r25	; 0x08
    14d0:	20 e0       	ldi	r18, 0x00	; 0
    14d2:	30 e0       	ldi	r19, 0x00	; 0
    14d4:	40 e8       	ldi	r20, 0x80	; 128
    14d6:	50 e4       	ldi	r21, 0x40	; 64
    14d8:	69 85       	ldd	r22, Y+9	; 0x09
    14da:	7a 85       	ldd	r23, Y+10	; 0x0a
    14dc:	8b 85       	ldd	r24, Y+11	; 0x0b
    14de:	9c 85       	ldd	r25, Y+12	; 0x0c
    14e0:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    14e4:	9b 01       	movw	r18, r22
    14e6:	ac 01       	movw	r20, r24
    14e8:	6d 81       	ldd	r22, Y+5	; 0x05
    14ea:	7e 81       	ldd	r23, Y+6	; 0x06
    14ec:	8f 81       	ldd	r24, Y+7	; 0x07
    14ee:	98 85       	ldd	r25, Y+8	; 0x08
    14f0:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    14f4:	68 a7       	std	Y+40, r22	; 0x28
    14f6:	79 a7       	std	Y+41, r23	; 0x29
    14f8:	8a a7       	std	Y+42, r24	; 0x2a
    14fa:	9b a7       	std	Y+43, r25	; 0x2b
    cos_T *= 0.5;
    14fc:	20 e0       	ldi	r18, 0x00	; 0
    14fe:	30 e0       	ldi	r19, 0x00	; 0
    1500:	40 e0       	ldi	r20, 0x00	; 0
    1502:	5f e3       	ldi	r21, 0x3F	; 63
    1504:	69 85       	ldd	r22, Y+9	; 0x09
    1506:	7a 85       	ldd	r23, Y+10	; 0x0a
    1508:	8b 85       	ldd	r24, Y+11	; 0x0b
    150a:	9c 85       	ldd	r25, Y+12	; 0x0c
    150c:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    1510:	6c a7       	std	Y+44, r22	; 0x2c
    1512:	7d a7       	std	Y+45, r23	; 0x2d
    1514:	8e a7       	std	Y+46, r24	; 0x2e
    1516:	9f a7       	std	Y+47, r25	; 0x2f
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    1518:	ed 85       	ldd	r30, Y+13	; 0x0d
    151a:	fe 85       	ldd	r31, Y+14	; 0x0e
    151c:	32 97       	sbiw	r30, 0x02	; 2
    151e:	08 f4       	brcc	.+2      	; 0x1522 <mc_arc+0x412>
    1520:	f3 c0       	rjmp	.+486    	; 0x1708 <mc_arc+0x5f8>

    float sin_Ti;
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
    1522:	10 e0       	ldi	r17, 0x00	; 0
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    1524:	22 24       	eor	r2, r2
    1526:	23 94       	inc	r2
    1528:	31 2c       	mov	r3, r1
      #else
        mc_line(position, feed_rate, invert_feed_rate);
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    152a:	c8 a2       	std	Y+32, r12	; 0x20
    152c:	d9 a2       	std	Y+33, r13	; 0x21
    152e:	ea a2       	std	Y+34, r14	; 0x22
    1530:	fb a2       	std	Y+35, r15	; 0x23
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
      
      if (count < N_ARC_CORRECTION) {
    1532:	1c 30       	cpi	r17, 0x0C	; 12
    1534:	d0 f5       	brcc	.+116    	; 0x15aa <mc_arc+0x49a>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
    1536:	2c a5       	ldd	r18, Y+44	; 0x2c
    1538:	3d a5       	ldd	r19, Y+45	; 0x2d
    153a:	4e a5       	ldd	r20, Y+46	; 0x2e
    153c:	5f a5       	ldd	r21, Y+47	; 0x2f
    153e:	c5 01       	movw	r24, r10
    1540:	b4 01       	movw	r22, r8
    1542:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    1546:	6b 01       	movw	r12, r22
    1548:	7c 01       	movw	r14, r24
    154a:	28 a5       	ldd	r18, Y+40	; 0x28
    154c:	39 a5       	ldd	r19, Y+41	; 0x29
    154e:	4a a5       	ldd	r20, Y+42	; 0x2a
    1550:	5b a5       	ldd	r21, Y+43	; 0x2b
    1552:	c3 01       	movw	r24, r6
    1554:	b2 01       	movw	r22, r4
    1556:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    155a:	a7 01       	movw	r20, r14
    155c:	96 01       	movw	r18, r12
    155e:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    1562:	d6 2e       	mov	r13, r22
    1564:	e7 2e       	mov	r14, r23
    1566:	f8 2e       	mov	r15, r24
    1568:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
    156a:	2c a5       	ldd	r18, Y+44	; 0x2c
    156c:	3d a5       	ldd	r19, Y+45	; 0x2d
    156e:	4e a5       	ldd	r20, Y+46	; 0x2e
    1570:	5f a5       	ldd	r21, Y+47	; 0x2f
    1572:	c3 01       	movw	r24, r6
    1574:	b2 01       	movw	r22, r4
    1576:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    157a:	2b 01       	movw	r4, r22
    157c:	3c 01       	movw	r6, r24
    157e:	28 a5       	ldd	r18, Y+40	; 0x28
    1580:	39 a5       	ldd	r19, Y+41	; 0x29
    1582:	4a a5       	ldd	r20, Y+42	; 0x2a
    1584:	5b a5       	ldd	r21, Y+43	; 0x2b
    1586:	c5 01       	movw	r24, r10
    1588:	b4 01       	movw	r22, r8
    158a:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    158e:	9b 01       	movw	r18, r22
    1590:	ac 01       	movw	r20, r24
    1592:	c3 01       	movw	r24, r6
    1594:	b2 01       	movw	r22, r4
    1596:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    159a:	2b 01       	movw	r4, r22
    159c:	3c 01       	movw	r6, r24
        r_axis1 = r_axisi;
        count++;
    159e:	1f 5f       	subi	r17, 0xFF	; 255
      
      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
    15a0:	8d 2c       	mov	r8, r13
    15a2:	9e 2c       	mov	r9, r14
    15a4:	af 2c       	mov	r10, r15
    15a6:	b0 2e       	mov	r11, r16
    15a8:	64 c0       	rjmp	.+200    	; 0x1672 <mc_arc+0x562>
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
    15aa:	b1 01       	movw	r22, r2
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	90 e0       	ldi	r25, 0x00	; 0
    15b0:	0e 94 2c 3d 	call	0x7a58	; 0x7a58 <__floatunsisf>
    15b4:	28 a9       	ldd	r18, Y+48	; 0x30
    15b6:	39 a9       	ldd	r19, Y+49	; 0x31
    15b8:	4a a9       	ldd	r20, Y+50	; 0x32
    15ba:	5b a9       	ldd	r21, Y+51	; 0x33
    15bc:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    15c0:	4b 01       	movw	r8, r22
    15c2:	5c 01       	movw	r10, r24
    15c4:	0e 94 90 3c 	call	0x7920	; 0x7920 <cos>
    15c8:	6b 01       	movw	r12, r22
    15ca:	7c 01       	movw	r14, r24
        sin_Ti = sin(i*theta_per_segment);
    15cc:	c5 01       	movw	r24, r10
    15ce:	b4 01       	movw	r22, r8
    15d0:	0e 94 4d 3f 	call	0x7e9a	; 0x7e9a <sin>
    15d4:	4b 01       	movw	r8, r22
    15d6:	5c 01       	movw	r10, r24
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
    15d8:	ec a9       	ldd	r30, Y+52	; 0x34
    15da:	fd a9       	ldd	r31, Y+53	; 0x35
    15dc:	80 81       	ld	r24, Z
    15de:	91 81       	ldd	r25, Z+1	; 0x01
    15e0:	a2 81       	ldd	r26, Z+2	; 0x02
    15e2:	b3 81       	ldd	r27, Z+3	; 0x03
    15e4:	9c 01       	movw	r18, r24
    15e6:	ad 01       	movw	r20, r26
    15e8:	50 58       	subi	r21, 0x80	; 128
    15ea:	29 87       	std	Y+9, r18	; 0x09
    15ec:	3a 87       	std	Y+10, r19	; 0x0a
    15ee:	4b 87       	std	Y+11, r20	; 0x0b
    15f0:	5c 87       	std	Y+12, r21	; 0x0c
    15f2:	ae a9       	ldd	r26, Y+54	; 0x36
    15f4:	bf a9       	ldd	r27, Y+55	; 0x37
    15f6:	8d 91       	ld	r24, X+
    15f8:	9d 91       	ld	r25, X+
    15fa:	0d 90       	ld	r0, X+
    15fc:	bc 91       	ld	r27, X
    15fe:	a0 2d       	mov	r26, r0
    1600:	8d 83       	std	Y+5, r24	; 0x05
    1602:	9e 83       	std	Y+6, r25	; 0x06
    1604:	af 83       	std	Y+7, r26	; 0x07
    1606:	b8 87       	std	Y+8, r27	; 0x08
    1608:	a7 01       	movw	r20, r14
    160a:	96 01       	movw	r18, r12
    160c:	69 85       	ldd	r22, Y+9	; 0x09
    160e:	7a 85       	ldd	r23, Y+10	; 0x0a
    1610:	8b 85       	ldd	r24, Y+11	; 0x0b
    1612:	9c 85       	ldd	r25, Y+12	; 0x0c
    1614:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    1618:	2b 01       	movw	r4, r22
    161a:	3c 01       	movw	r6, r24
    161c:	a5 01       	movw	r20, r10
    161e:	94 01       	movw	r18, r8
    1620:	6d 81       	ldd	r22, Y+5	; 0x05
    1622:	7e 81       	ldd	r23, Y+6	; 0x06
    1624:	8f 81       	ldd	r24, Y+7	; 0x07
    1626:	98 85       	ldd	r25, Y+8	; 0x08
    1628:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    162c:	9b 01       	movw	r18, r22
    162e:	ac 01       	movw	r20, r24
    1630:	c3 01       	movw	r24, r6
    1632:	b2 01       	movw	r22, r4
    1634:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    1638:	2b 01       	movw	r4, r22
    163a:	3c 01       	movw	r6, r24
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
    163c:	29 85       	ldd	r18, Y+9	; 0x09
    163e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1640:	4b 85       	ldd	r20, Y+11	; 0x0b
    1642:	5c 85       	ldd	r21, Y+12	; 0x0c
    1644:	c5 01       	movw	r24, r10
    1646:	b4 01       	movw	r22, r8
    1648:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    164c:	4b 01       	movw	r8, r22
    164e:	5c 01       	movw	r10, r24
    1650:	2d 81       	ldd	r18, Y+5	; 0x05
    1652:	3e 81       	ldd	r19, Y+6	; 0x06
    1654:	4f 81       	ldd	r20, Y+7	; 0x07
    1656:	58 85       	ldd	r21, Y+8	; 0x08
    1658:	c7 01       	movw	r24, r14
    165a:	b6 01       	movw	r22, r12
    165c:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    1660:	9b 01       	movw	r18, r22
    1662:	ac 01       	movw	r20, r24
    1664:	c5 01       	movw	r24, r10
    1666:	b4 01       	movw	r22, r8
    1668:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    166c:	4b 01       	movw	r8, r22
    166e:	5c 01       	movw	r10, r24
        count = 0;
    1670:	10 e0       	ldi	r17, 0x00	; 0
      }
  
      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
    1672:	a3 01       	movw	r20, r6
    1674:	92 01       	movw	r18, r4
    1676:	6e 89       	ldd	r22, Y+22	; 0x16
    1678:	7f 89       	ldd	r23, Y+23	; 0x17
    167a:	88 8d       	ldd	r24, Y+24	; 0x18
    167c:	99 8d       	ldd	r25, Y+25	; 0x19
    167e:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    1682:	ec 89       	ldd	r30, Y+20	; 0x14
    1684:	fd 89       	ldd	r31, Y+21	; 0x15
    1686:	60 83       	st	Z, r22
    1688:	71 83       	std	Z+1, r23	; 0x01
    168a:	82 83       	std	Z+2, r24	; 0x02
    168c:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
    168e:	a5 01       	movw	r20, r10
    1690:	94 01       	movw	r18, r8
    1692:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1694:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1696:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1698:	9f 8d       	ldd	r25, Y+31	; 0x1f
    169a:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    169e:	aa 8d       	ldd	r26, Y+26	; 0x1a
    16a0:	bb 8d       	ldd	r27, Y+27	; 0x1b
    16a2:	6d 93       	st	X+, r22
    16a4:	7d 93       	st	X+, r23
    16a6:	8d 93       	st	X+, r24
    16a8:	9c 93       	st	X, r25
    16aa:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
    16ac:	2c a1       	ldd	r18, Y+36	; 0x24
    16ae:	3d a1       	ldd	r19, Y+37	; 0x25
    16b0:	4e a1       	ldd	r20, Y+38	; 0x26
    16b2:	5f a1       	ldd	r21, Y+39	; 0x27
    16b4:	e9 81       	ldd	r30, Y+1	; 0x01
    16b6:	fa 81       	ldd	r31, Y+2	; 0x02
    16b8:	60 81       	ld	r22, Z
    16ba:	71 81       	ldd	r23, Z+1	; 0x01
    16bc:	82 81       	ldd	r24, Z+2	; 0x02
    16be:	93 81       	ldd	r25, Z+3	; 0x03
    16c0:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    16c4:	a9 81       	ldd	r26, Y+1	; 0x01
    16c6:	ba 81       	ldd	r27, Y+2	; 0x02
    16c8:	6d 93       	st	X+, r22
    16ca:	7d 93       	st	X+, r23
    16cc:	8d 93       	st	X+, r24
    16ce:	9c 93       	st	X, r25
    16d0:	13 97       	sbiw	r26, 0x03	; 3
      
      #ifdef USE_LINE_NUMBERS
        mc_line(position, feed_rate, invert_feed_rate, line_number);
      #else
        mc_line(position, feed_rate, invert_feed_rate);
    16d2:	2b 89       	ldd	r18, Y+19	; 0x13
    16d4:	48 a1       	ldd	r20, Y+32	; 0x20
    16d6:	59 a1       	ldd	r21, Y+33	; 0x21
    16d8:	6a a1       	ldd	r22, Y+34	; 0x22
    16da:	7b a1       	ldd	r23, Y+35	; 0x23
    16dc:	89 89       	ldd	r24, Y+17	; 0x11
    16de:	9a 89       	ldd	r25, Y+18	; 0x12
    16e0:	0e 94 52 08 	call	0x10a4	; 0x10a4 <mc_line>
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    16e4:	e7 e6       	ldi	r30, 0x67	; 103
    16e6:	f7 e0       	ldi	r31, 0x07	; 7
    16e8:	80 81       	ld	r24, Z
    16ea:	81 11       	cpse	r24, r1
    16ec:	14 c0       	rjmp	.+40     	; 0x1716 <mc_arc+0x606>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    16ee:	ff ef       	ldi	r31, 0xFF	; 255
    16f0:	2f 1a       	sub	r2, r31
    16f2:	3f 0a       	sbc	r3, r31
    16f4:	2d 85       	ldd	r18, Y+13	; 0x0d
    16f6:	3e 85       	ldd	r19, Y+14	; 0x0e
    16f8:	22 16       	cp	r2, r18
    16fa:	33 06       	cpc	r3, r19
    16fc:	09 f0       	breq	.+2      	; 0x1700 <mc_arc+0x5f0>
    16fe:	19 cf       	rjmp	.-462    	; 0x1532 <mc_arc+0x422>
    1700:	c8 a0       	ldd	r12, Y+32	; 0x20
    1702:	d9 a0       	ldd	r13, Y+33	; 0x21
    1704:	ea a0       	ldd	r14, Y+34	; 0x22
    1706:	fb a0       	ldd	r15, Y+35	; 0x23
  }
  // Ensure last segment arrives at target location.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    1708:	2b 89       	ldd	r18, Y+19	; 0x13
    170a:	b7 01       	movw	r22, r14
    170c:	a6 01       	movw	r20, r12
    170e:	88 ad       	ldd	r24, Y+56	; 0x38
    1710:	99 ad       	ldd	r25, Y+57	; 0x39
    1712:	0e 94 52 08 	call	0x10a4	; 0x10a4 <mc_line>
  #endif
}
    1716:	e9 96       	adiw	r28, 0x39	; 57
    1718:	0f b6       	in	r0, 0x3f	; 63
    171a:	f8 94       	cli
    171c:	de bf       	out	0x3e, r29	; 62
    171e:	0f be       	out	0x3f, r0	; 63
    1720:	cd bf       	out	0x3d, r28	; 61
    1722:	df 91       	pop	r29
    1724:	cf 91       	pop	r28
    1726:	1f 91       	pop	r17
    1728:	0f 91       	pop	r16
    172a:	ff 90       	pop	r15
    172c:	ef 90       	pop	r14
    172e:	df 90       	pop	r13
    1730:	cf 90       	pop	r12
    1732:	bf 90       	pop	r11
    1734:	af 90       	pop	r10
    1736:	9f 90       	pop	r9
    1738:	8f 90       	pop	r8
    173a:	7f 90       	pop	r7
    173c:	6f 90       	pop	r6
    173e:	5f 90       	pop	r5
    1740:	4f 90       	pop	r4
    1742:	3f 90       	pop	r3
    1744:	2f 90       	pop	r2
    1746:	08 95       	ret

00001748 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
    1748:	8f 92       	push	r8
    174a:	9f 92       	push	r9
    174c:	af 92       	push	r10
    174e:	bf 92       	push	r11
    1750:	cf 92       	push	r12
    1752:	df 92       	push	r13
    1754:	ef 92       	push	r14
    1756:	ff 92       	push	r15
    1758:	cf 93       	push	r28
    175a:	df 93       	push	r29
    175c:	4b 01       	movw	r8, r22
    175e:	5c 01       	movw	r10, r24
   if (sys.state == STATE_CHECK_MODE) { return; }
    1760:	80 91 68 07 	lds	r24, 0x0768
    1764:	82 30       	cpi	r24, 0x02	; 2
    1766:	09 f4       	brne	.+2      	; 0x176a <mc_dwell+0x22>
    1768:	4a c0       	rjmp	.+148    	; 0x17fe <mc_dwell+0xb6>
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
    176a:	20 e0       	ldi	r18, 0x00	; 0
    176c:	30 e0       	ldi	r19, 0x00	; 0
    176e:	40 ea       	ldi	r20, 0xA0	; 160
    1770:	51 e4       	ldi	r21, 0x41	; 65
    1772:	c5 01       	movw	r24, r10
    1774:	b4 01       	movw	r22, r8
    1776:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    177a:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <floor>
    177e:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
    1782:	6b 01       	movw	r12, r22
    1784:	7c 01       	movw	r14, r24
    1786:	eb 01       	movw	r28, r22
   protocol_buffer_synchronize();
    1788:	0e 94 f0 1a 	call	0x35e0	; 0x35e0 <protocol_buffer_synchronize>
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
    178c:	20 e0       	ldi	r18, 0x00	; 0
    178e:	30 e0       	ldi	r19, 0x00	; 0
    1790:	4a e7       	ldi	r20, 0x7A	; 122
    1792:	54 e4       	ldi	r21, 0x44	; 68
    1794:	c5 01       	movw	r24, r10
    1796:	b4 01       	movw	r22, r8
    1798:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    179c:	4b 01       	movw	r8, r22
    179e:	5c 01       	movw	r10, r24
    17a0:	82 e3       	ldi	r24, 0x32	; 50
    17a2:	8c 9d       	mul	r24, r12
    17a4:	b0 01       	movw	r22, r0
    17a6:	8d 9d       	mul	r24, r13
    17a8:	70 0d       	add	r23, r0
    17aa:	11 24       	eor	r1, r1
    17ac:	80 e0       	ldi	r24, 0x00	; 0
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	0e 94 2c 3d 	call	0x7a58	; 0x7a58 <__floatunsisf>
    17b4:	9b 01       	movw	r18, r22
    17b6:	ac 01       	movw	r20, r24
    17b8:	c5 01       	movw	r24, r10
    17ba:	b4 01       	movw	r22, r8
    17bc:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    17c0:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <floor>
    17c4:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
    17c8:	cb 01       	movw	r24, r22
    17ca:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <delay_ms>
   while (i-- > 0) {
    17ce:	cd 2b       	or	r28, r29
    17d0:	b1 f0       	breq	.+44     	; 0x17fe <mc_dwell+0xb6>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
    17d2:	c7 e6       	ldi	r28, 0x67	; 103
    17d4:	d7 e0       	ldi	r29, 0x07	; 7
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
    17d6:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
     if (sys.abort) { return; }
    17da:	88 81       	ld	r24, Y
    17dc:	81 11       	cpse	r24, r1
    17de:	0f c0       	rjmp	.+30     	; 0x17fe <mc_dwell+0xb6>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17e0:	2f ef       	ldi	r18, 0xFF	; 255
    17e2:	8f ec       	ldi	r24, 0xCF	; 207
    17e4:	92 e0       	ldi	r25, 0x02	; 2
    17e6:	21 50       	subi	r18, 0x01	; 1
    17e8:	80 40       	sbci	r24, 0x00	; 0
    17ea:	90 40       	sbci	r25, 0x00	; 0
    17ec:	e1 f7       	brne	.-8      	; 0x17e6 <mc_dwell+0x9e>
    17ee:	00 c0       	rjmp	.+0      	; 0x17f0 <mc_dwell+0xa8>
    17f0:	00 00       	nop
    17f2:	21 e0       	ldi	r18, 0x01	; 1
    17f4:	c2 1a       	sub	r12, r18
    17f6:	d1 08       	sbc	r13, r1
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
    17f8:	c1 14       	cp	r12, r1
    17fa:	d1 04       	cpc	r13, r1
    17fc:	61 f7       	brne	.-40     	; 0x17d6 <mc_dwell+0x8e>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   }
}
    17fe:	df 91       	pop	r29
    1800:	cf 91       	pop	r28
    1802:	ff 90       	pop	r15
    1804:	ef 90       	pop	r14
    1806:	df 90       	pop	r13
    1808:	cf 90       	pop	r12
    180a:	bf 90       	pop	r11
    180c:	af 90       	pop	r10
    180e:	9f 90       	pop	r9
    1810:	8f 90       	pop	r8
    1812:	08 95       	ret

00001814 <mc_homing_cycle>:
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT));
      return;
    }
  #endif
   
  limits_disable(); // Disable hard limits pin change register for cycle duration
    1814:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <limits_disable>
    
  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  // Search to engage all axes limit switches at faster homing seek rate.
  limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    1818:	84 e0       	ldi	r24, 0x04	; 4
    181a:	0e 94 83 2f 	call	0x5f06	; 0x5f06 <limits_go_home>
  #ifdef HOMING_CYCLE_1
    limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
    181e:	83 e0       	ldi	r24, 0x03	; 3
    1820:	0e 94 83 2f 	call	0x5f06	; 0x5f06 <limits_go_home>
  #endif
  #ifdef HOMING_CYCLE_2
    limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
  #endif
    
  protocol_execute_realtime(); // Check for reset and set system abort.
    1824:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
    1828:	80 91 67 07 	lds	r24, 0x0767
    182c:	81 11       	cpse	r24, r1
    182e:	04 c0       	rjmp	.+8      	; 0x1838 <mc_homing_cycle+0x24>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Gcode parser position was circumvented by the limits_go_home() routine, so sync position now.
  gc_sync_position();
    1830:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <gc_sync_position>
  
  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
    1834:	0e 94 37 2f 	call	0x5e6e	; 0x5e6e <limits_init>
    1838:	08 95       	ret

0000183a <mc_probe_cycle>:
    uint8_t is_no_error, int32_t line_number)
#else
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate, uint8_t is_probe_away,
    uint8_t is_no_error)
#endif
{ 
    183a:	8f 92       	push	r8
    183c:	9f 92       	push	r9
    183e:	af 92       	push	r10
    1840:	bf 92       	push	r11
    1842:	cf 92       	push	r12
    1844:	df 92       	push	r13
    1846:	ef 92       	push	r14
    1848:	0f 93       	push	r16
    184a:	1f 93       	push	r17
    184c:	cf 93       	push	r28
    184e:	df 93       	push	r29
    1850:	6c 01       	movw	r12, r24
    1852:	4a 01       	movw	r8, r20
    1854:	5b 01       	movw	r10, r22
    1856:	c2 2f       	mov	r28, r18
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return; }
    1858:	90 91 68 07 	lds	r25, 0x0768
    185c:	92 30       	cpi	r25, 0x02	; 2
    185e:	09 f4       	brne	.+2      	; 0x1862 <mc_probe_cycle+0x28>
    1860:	68 c0       	rjmp	.+208    	; 0x1932 <mc_probe_cycle+0xf8>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
    1862:	0e 94 f0 1a 	call	0x35e0	; 0x35e0 <protocol_buffer_synchronize>

  // Initialize probing control variables
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.  
    1866:	10 92 86 07 	sts	0x0786, r1
  probe_configure_invert_mask(is_probe_away);
    186a:	80 2f       	mov	r24, r16
    186c:	0e 94 10 34 	call	0x6820	; 0x6820 <probe_configure_invert_mask>
  
  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
    1870:	0e 94 22 34 	call	0x6844	; 0x6844 <probe_get_state>
    1874:	88 23       	and	r24, r24
    1876:	51 f0       	breq	.+20     	; 0x188c <mc_probe_cycle+0x52>
    bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_PROBE_FAIL);
    1878:	8f b7       	in	r24, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	eb e6       	ldi	r30, 0x6B	; 107
    187e:	f7 e0       	ldi	r31, 0x07	; 7
    1880:	90 81       	ld	r25, Z
    1882:	90 61       	ori	r25, 0x10	; 16
    1884:	90 83       	st	Z, r25
    1886:	8f bf       	out	0x3f, r24	; 63
    protocol_execute_realtime();
    1888:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
  }
  if (sys.abort) { return; } // Return if system reset has been issued.
    188c:	80 91 67 07 	lds	r24, 0x0767
    1890:	81 11       	cpse	r24, r1
    1892:	4f c0       	rjmp	.+158    	; 0x1932 <mc_probe_cycle+0xf8>

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    1894:	2c 2f       	mov	r18, r28
    1896:	b5 01       	movw	r22, r10
    1898:	a4 01       	movw	r20, r8
    189a:	c6 01       	movw	r24, r12
    189c:	0e 94 52 08 	call	0x10a4	; 0x10a4 <mc_line>
  #endif
  
  // Activate the probing state monitor in the stepper module.
  sys.probe_state = PROBE_ACTIVE;
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	80 93 79 07 	sts	0x0779, r24

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
    18a6:	8f b7       	in	r24, 0x3f	; 63
    18a8:	f8 94       	cli
    18aa:	ea e6       	ldi	r30, 0x6A	; 106
    18ac:	f7 e0       	ldi	r31, 0x07	; 7
    18ae:	90 81       	ld	r25, Z
    18b0:	92 60       	ori	r25, 0x02	; 2
    18b2:	90 83       	st	Z, r25
    18b4:	8f bf       	out	0x3f, r24	; 63
  do {
    protocol_execute_realtime(); 
    if (sys.abort) { return; } // Check for system abort
    18b6:	c7 e6       	ldi	r28, 0x67	; 103
    18b8:	d7 e0       	ldi	r29, 0x07	; 7
  } while (sys.state != STATE_IDLE);
    18ba:	08 e6       	ldi	r16, 0x68	; 104
    18bc:	17 e0       	ldi	r17, 0x07	; 7
  sys.probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
  do {
    protocol_execute_realtime(); 
    18be:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    18c2:	88 81       	ld	r24, Y
    18c4:	81 11       	cpse	r24, r1
    18c6:	35 c0       	rjmp	.+106    	; 0x1932 <mc_probe_cycle+0xf8>
  } while (sys.state != STATE_IDLE);
    18c8:	f8 01       	movw	r30, r16
    18ca:	80 81       	ld	r24, Z
    18cc:	81 11       	cpse	r24, r1
    18ce:	f7 cf       	rjmp	.-18     	; 0x18be <mc_probe_cycle+0x84>
  
  // Probing cycle complete!
  
  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys.probe_state == PROBE_ACTIVE) {
    18d0:	80 91 79 07 	lds	r24, 0x0779
    18d4:	81 30       	cpi	r24, 0x01	; 1
    18d6:	a9 f4       	brne	.+42     	; 0x1902 <mc_probe_cycle+0xc8>
    if (is_no_error) { memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS); }
    18d8:	ee 20       	and	r14, r14
    18da:	51 f0       	breq	.+20     	; 0x18f0 <mc_probe_cycle+0xb6>
    18dc:	8c e0       	ldi	r24, 0x0C	; 12
    18de:	ec e6       	ldi	r30, 0x6C	; 108
    18e0:	f7 e0       	ldi	r31, 0x07	; 7
    18e2:	aa e7       	ldi	r26, 0x7A	; 122
    18e4:	b7 e0       	ldi	r27, 0x07	; 7
    18e6:	01 90       	ld	r0, Z+
    18e8:	0d 92       	st	X+, r0
    18ea:	8a 95       	dec	r24
    18ec:	e1 f7       	brne	.-8      	; 0x18e6 <mc_probe_cycle+0xac>
    18ee:	0c c0       	rjmp	.+24     	; 0x1908 <mc_probe_cycle+0xce>
    else { bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_PROBE_FAIL); }
    18f0:	8f b7       	in	r24, 0x3f	; 63
    18f2:	f8 94       	cli
    18f4:	eb e6       	ldi	r30, 0x6B	; 107
    18f6:	f7 e0       	ldi	r31, 0x07	; 7
    18f8:	90 81       	ld	r25, Z
    18fa:	90 61       	ori	r25, 0x10	; 16
    18fc:	90 83       	st	Z, r25
    18fe:	8f bf       	out	0x3f, r24	; 63
    1900:	03 c0       	rjmp	.+6      	; 0x1908 <mc_probe_cycle+0xce>
  } else { 
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
    1902:	81 e0       	ldi	r24, 0x01	; 1
    1904:	80 93 86 07 	sts	0x0786, r24
  }
  sys.probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
    1908:	10 92 79 07 	sts	0x0779, r1
  protocol_execute_realtime();   // Check and execute run-time commands
    190c:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
  if (sys.abort) { return; } // Check for system abort
    1910:	80 91 67 07 	lds	r24, 0x0767
    1914:	81 11       	cpse	r24, r1
    1916:	0d c0       	rjmp	.+26     	; 0x1932 <mc_probe_cycle+0xf8>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reest step segment buffer.
    1918:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
    191c:	0e 94 34 2a 	call	0x5468	; 0x5468 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    1920:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <plan_sync_position>

  // TODO: Update the g-code parser code to not require this target calculation but uses a gc_sync_position() call.
  // NOTE: The target[] variable updated here will be sent back and synced with the g-code parser.
  system_convert_array_steps_to_mpos(target, sys.position);
    1924:	6c e6       	ldi	r22, 0x6C	; 108
    1926:	77 e0       	ldi	r23, 0x07	; 7
    1928:	c6 01       	movw	r24, r12
    192a:	0e 94 98 3b 	call	0x7730	; 0x7730 <system_convert_array_steps_to_mpos>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
    192e:	0e 94 c0 36 	call	0x6d80	; 0x6d80 <report_probe_parameters>
  #endif
}
    1932:	df 91       	pop	r29
    1934:	cf 91       	pop	r28
    1936:	1f 91       	pop	r17
    1938:	0f 91       	pop	r16
    193a:	ef 90       	pop	r14
    193c:	df 90       	pop	r13
    193e:	cf 90       	pop	r12
    1940:	bf 90       	pop	r11
    1942:	af 90       	pop	r10
    1944:	9f 90       	pop	r9
    1946:	8f 90       	pop	r8
    1948:	08 95       	ret

0000194a <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
    194a:	80 91 6a 07 	lds	r24, 0x076A
    194e:	84 fd       	sbrc	r24, 4
    1950:	1e c0       	rjmp	.+60     	; 0x198e <mc_reset+0x44>
    bit_true_atomic(sys.rt_exec_state, EXEC_RESET);
    1952:	8f b7       	in	r24, 0x3f	; 63
    1954:	f8 94       	cli
    1956:	ea e6       	ldi	r30, 0x6A	; 106
    1958:	f7 e0       	ldi	r31, 0x07	; 7
    195a:	90 81       	ld	r25, Z
    195c:	90 61       	ori	r25, 0x10	; 16
    195e:	90 83       	st	Z, r25
    1960:	8f bf       	out	0x3f, r24	; 63

    // Kill spindle and coolant.   
    spindle_stop();
    1962:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <spindle_stop>
    coolant_stop();
    1966:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING)) || (sys.suspend == SUSPEND_ENABLE_HOLD)) {
    196a:	80 91 68 07 	lds	r24, 0x0768
    196e:	8c 70       	andi	r24, 0x0C	; 12
    1970:	21 f4       	brne	.+8      	; 0x197a <mc_reset+0x30>
    1972:	80 91 69 07 	lds	r24, 0x0769
    1976:	81 30       	cpi	r24, 0x01	; 1
    1978:	51 f4       	brne	.+20     	; 0x198e <mc_reset+0x44>
      bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_ABORT_CYCLE);
    197a:	8f b7       	in	r24, 0x3f	; 63
    197c:	f8 94       	cli
    197e:	eb e6       	ldi	r30, 0x6B	; 107
    1980:	f7 e0       	ldi	r31, 0x07	; 7
    1982:	90 81       	ld	r25, Z
    1984:	98 60       	ori	r25, 0x08	; 8
    1986:	90 83       	st	Z, r25
    1988:	8f bf       	out	0x3f, r24	; 63
      st_go_idle(); // Force kill steppers. Position has likely been lost.
    198a:	0e 94 4b 1b 	call	0x3696	; 0x3696 <st_go_idle>
    198e:	08 95       	ret

00001990 <gc_init>:
#define FAIL(status) return(status);


void gc_init() 
{
  memset(&gc_state, 0, sizeof(gc_state));
    1990:	8f e3       	ldi	r24, 0x3F	; 63
    1992:	e7 e8       	ldi	r30, 0x87	; 135
    1994:	f7 e0       	ldi	r31, 0x07	; 7
    1996:	df 01       	movw	r26, r30
    1998:	1d 92       	st	X+, r1
    199a:	8a 95       	dec	r24
    199c:	e9 f7       	brne	.-6      	; 0x1998 <gc_init+0x8>
  
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
    199e:	6a ea       	ldi	r22, 0xAA	; 170
    19a0:	77 e0       	ldi	r23, 0x07	; 7
    19a2:	80 e0       	ldi	r24, 0x00	; 0
    19a4:	0e 94 1a 27 	call	0x4e34	; 0x4e34 <settings_read_coord_data>
    19a8:	81 11       	cpse	r24, r1
    19aa:	03 c0       	rjmp	.+6      	; 0x19b2 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL); 
    19ac:	87 e0       	ldi	r24, 0x07	; 7
    19ae:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
    19b2:	08 95       	ret

000019b4 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
    19b4:	6c e6       	ldi	r22, 0x6C	; 108
    19b6:	77 e0       	ldi	r23, 0x07	; 7
    19b8:	8e e9       	ldi	r24, 0x9E	; 158
    19ba:	97 e0       	ldi	r25, 0x07	; 7
    19bc:	0e 94 98 3b 	call	0x7730	; 0x7730 <system_convert_array_steps_to_mpos>
    19c0:	08 95       	ret

000019c2 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and 
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine 
// coordinates, respectively.
uint8_t gc_execute_line(char *line) 
{
    19c2:	2f 92       	push	r2
    19c4:	3f 92       	push	r3
    19c6:	4f 92       	push	r4
    19c8:	5f 92       	push	r5
    19ca:	6f 92       	push	r6
    19cc:	7f 92       	push	r7
    19ce:	8f 92       	push	r8
    19d0:	9f 92       	push	r9
    19d2:	af 92       	push	r10
    19d4:	bf 92       	push	r11
    19d6:	cf 92       	push	r12
    19d8:	df 92       	push	r13
    19da:	ef 92       	push	r14
    19dc:	ff 92       	push	r15
    19de:	0f 93       	push	r16
    19e0:	1f 93       	push	r17
    19e2:	cf 93       	push	r28
    19e4:	df 93       	push	r29
    19e6:	cd b7       	in	r28, 0x3d	; 61
    19e8:	de b7       	in	r29, 0x3e	; 62
    19ea:	ab 97       	sbiw	r28, 0x2b	; 43
    19ec:	0f b6       	in	r0, 0x3f	; 63
    19ee:	f8 94       	cli
    19f0:	de bf       	out	0x3e, r29	; 62
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	cd bf       	out	0x3d, r28	; 61
    19f6:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
    19f8:	89 e3       	ldi	r24, 0x39	; 57
    19fa:	e6 ec       	ldi	r30, 0xC6	; 198
    19fc:	f7 e0       	ldi	r31, 0x07	; 7
    19fe:	df 01       	movw	r26, r30
    1a00:	1d 92       	st	X+, r1
    1a02:	8a 95       	dec	r24
    1a04:	e9 f7       	brne	.-6      	; 0x1a00 <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
    1a06:	8a e0       	ldi	r24, 0x0A	; 10
    1a08:	e7 e8       	ldi	r30, 0x87	; 135
    1a0a:	f7 e0       	ldi	r31, 0x07	; 7
    1a0c:	a7 ec       	ldi	r26, 0xC7	; 199
    1a0e:	b7 e0       	ldi	r27, 0x07	; 7
    1a10:	01 90       	ld	r0, Z+
    1a12:	0d 92       	st	X+, r0
    1a14:	8a 95       	dec	r24
    1a16:	e1 f7       	brne	.-8      	; 0x1a10 <gc_execute_line+0x4e>
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also, 
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */
     
  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter = 0;  
    1a18:	19 8e       	std	Y+25, r1	; 0x19
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Value words. 
    1a1a:	21 2c       	mov	r2, r1
    1a1c:	31 2c       	mov	r3, r1
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
    1a1e:	e1 2c       	mov	r14, r1
    1a20:	f1 2c       	mov	r15, r1
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 
    1a22:	1b a2       	std	Y+35, r1	; 0x23
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
    1a24:	1f 8e       	std	Y+31, r1	; 0x1f
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
    1a26:	1e 8e       	std	Y+30, r1	; 0x1e
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1a28:	cc 24       	eor	r12, r12
    1a2a:	c3 94       	inc	r12
    1a2c:	d1 2c       	mov	r13, r1
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1a2e:	0f 2e       	mov	r0, r31
    1a30:	f1 e6       	ldi	r31, 0x61	; 97
    1a32:	8f 2e       	mov	r8, r31
    1a34:	f3 e0       	ldi	r31, 0x03	; 3
    1a36:	9f 2e       	mov	r9, r31
    1a38:	f0 2d       	mov	r31, r0
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1a3a:	ad c2       	rjmp	.+1370   	; 0x1f96 <gc_execute_line+0x5d4>
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    1a3c:	9f eb       	ldi	r25, 0xBF	; 191
    1a3e:	9b 0d       	add	r25, r11
    1a40:	9a 31       	cpi	r25, 0x1A	; 26
    1a42:	10 f0       	brcs	.+4      	; 0x1a48 <gc_execute_line+0x86>
    1a44:	0c 94 23 17 	jmp	0x2e46	; 0x2e46 <gc_execute_line+0x1484>
    char_counter++;
    1a48:	8f 5f       	subi	r24, 0xFF	; 255
    1a4a:	89 8f       	std	Y+25, r24	; 0x19
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    1a4c:	ae 01       	movw	r20, r28
    1a4e:	46 5e       	subi	r20, 0xE6	; 230
    1a50:	5f 4f       	sbci	r21, 0xFF	; 255
    1a52:	be 01       	movw	r22, r28
    1a54:	67 5e       	subi	r22, 0xE7	; 231
    1a56:	7f 4f       	sbci	r23, 0xFF	; 255
    1a58:	c8 01       	movw	r24, r16
    1a5a:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <read_float>
    1a5e:	88 23       	and	r24, r24
    1a60:	11 f4       	brne	.+4      	; 0x1a66 <gc_execute_line+0xa4>
    1a62:	0c 94 25 17 	jmp	0x2e4a	; 0x2e4a <gc_execute_line+0x1488>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant, 
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later. 
    int_value = trunc(value);
    1a66:	4a 8c       	ldd	r4, Y+26	; 0x1a
    1a68:	5b 8c       	ldd	r5, Y+27	; 0x1b
    1a6a:	6c 8c       	ldd	r6, Y+28	; 0x1c
    1a6c:	7d 8c       	ldd	r7, Y+29	; 0x1d
    1a6e:	c3 01       	movw	r24, r6
    1a70:	b2 01       	movw	r22, r4
    1a72:	0e 94 98 3f 	call	0x7f30	; 0x7f30 <trunc>
    1a76:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
    1a7a:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
    1a7c:	70 e0       	ldi	r23, 0x00	; 0
    1a7e:	80 e0       	ldi	r24, 0x00	; 0
    1a80:	90 e0       	ldi	r25, 0x00	; 0
    1a82:	0e 94 2e 3d 	call	0x7a5c	; 0x7a5c <__floatsisf>
    1a86:	9b 01       	movw	r18, r22
    1a88:	ac 01       	movw	r20, r24
    1a8a:	c3 01       	movw	r24, r6
    1a8c:	b2 01       	movw	r22, r4
    1a8e:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    1a92:	20 e0       	ldi	r18, 0x00	; 0
    1a94:	30 e0       	ldi	r19, 0x00	; 0
    1a96:	48 ec       	ldi	r20, 0xC8	; 200
    1a98:	52 e4       	ldi	r21, 0x42	; 66
    1a9a:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    1a9e:	0e 94 2d 3f 	call	0x7e5a	; 0x7e5a <round>
    1aa2:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
        // NOTE: Rounding must be used to catch small floating point errors. 

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
    1aa6:	b7 e4       	ldi	r27, 0x47	; 71
    1aa8:	bb 16       	cp	r11, r27
    1aaa:	29 f0       	breq	.+10     	; 0x1ab6 <gc_execute_line+0xf4>
    1aac:	ed e4       	ldi	r30, 0x4D	; 77
    1aae:	be 16       	cp	r11, r30
    1ab0:	09 f4       	brne	.+2      	; 0x1ab4 <gc_execute_line+0xf2>
    1ab2:	5c c1       	rjmp	.+696    	; 0x1d6c <gc_execute_line+0x3aa>
    1ab4:	b9 c1       	rjmp	.+882    	; 0x1e28 <gc_execute_line+0x466>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
         
      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
    1ab6:	8a 2d       	mov	r24, r10
    1ab8:	90 e0       	ldi	r25, 0x00	; 0
    1aba:	8f 35       	cpi	r24, 0x5F	; 95
    1abc:	91 05       	cpc	r25, r1
    1abe:	10 f0       	brcs	.+4      	; 0x1ac4 <gc_execute_line+0x102>
    1ac0:	0c 94 27 17 	jmp	0x2e4e	; 0x2e4e <gc_execute_line+0x148c>
    1ac4:	fc 01       	movw	r30, r24
    1ac6:	e8 5c       	subi	r30, 0xC8	; 200
    1ac8:	ff 4f       	sbci	r31, 0xFF	; 255
    1aca:	0c 94 d9 3f 	jmp	0x7fb2	; 0x7fb2 <__tablejump2__>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
    1ace:	61 15       	cp	r22, r1
    1ad0:	71 05       	cpc	r23, r1
    1ad2:	31 f4       	brne	.+12     	; 0x1ae0 <gc_execute_line+0x11e>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1ad4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1ad6:	f1 11       	cpse	r31, r1
    1ad8:	0c 94 29 17 	jmp	0x2e52	; 0x2e52 <gc_execute_line+0x1490>
              axis_command = AXIS_COMMAND_NON_MODAL;
    1adc:	21 e0       	ldi	r18, 0x01	; 1
    1ade:	2e 8f       	std	Y+30, r18	; 0x1e
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
    1ae0:	3c e1       	ldi	r19, 0x1C	; 28
    1ae2:	a3 16       	cp	r10, r19
    1ae4:	01 f1       	breq	.+64     	; 0x1b26 <gc_execute_line+0x164>
    1ae6:	3a 15       	cp	r19, r10
    1ae8:	38 f0       	brcs	.+14     	; 0x1af8 <gc_execute_line+0x136>
    1aea:	84 e0       	ldi	r24, 0x04	; 4
    1aec:	a8 16       	cp	r10, r24
    1aee:	79 f0       	breq	.+30     	; 0x1b0e <gc_execute_line+0x14c>
    1af0:	9a e0       	ldi	r25, 0x0A	; 10
    1af2:	a9 16       	cp	r10, r25
    1af4:	91 f0       	breq	.+36     	; 0x1b1a <gc_execute_line+0x158>
    1af6:	21 c1       	rjmp	.+578    	; 0x1d3a <gc_execute_line+0x378>
    1af8:	a5 e3       	ldi	r26, 0x35	; 53
    1afa:	aa 16       	cp	r10, r26
    1afc:	e1 f1       	breq	.+120    	; 0x1b76 <gc_execute_line+0x1b4>
    1afe:	bc e5       	ldi	r27, 0x5C	; 92
    1b00:	ab 16       	cp	r10, r27
    1b02:	09 f4       	brne	.+2      	; 0x1b06 <gc_execute_line+0x144>
    1b04:	3e c0       	rjmp	.+124    	; 0x1b82 <gc_execute_line+0x1c0>
    1b06:	ee e1       	ldi	r30, 0x1E	; 30
    1b08:	ae 12       	cpse	r10, r30
    1b0a:	17 c1       	rjmp	.+558    	; 0x1d3a <gc_execute_line+0x378>
    1b0c:	20 c0       	rjmp	.+64     	; 0x1b4e <gc_execute_line+0x18c>
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
    1b0e:	81 e0       	ldi	r24, 0x01	; 1
    1b10:	a6 ec       	ldi	r26, 0xC6	; 198
    1b12:	b7 e0       	ldi	r27, 0x07	; 7
    1b14:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b16:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
    1b18:	15 c1       	rjmp	.+554    	; 0x1d44 <gc_execute_line+0x382>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
    1b1a:	82 e0       	ldi	r24, 0x02	; 2
    1b1c:	e6 ec       	ldi	r30, 0xC6	; 198
    1b1e:	f7 e0       	ldi	r31, 0x07	; 7
    1b20:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b22:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
    1b24:	0f c1       	rjmp	.+542    	; 0x1d44 <gc_execute_line+0x382>
              case 28:
                switch(mantissa) {
    1b26:	61 15       	cp	r22, r1
    1b28:	71 05       	cpc	r23, r1
    1b2a:	29 f0       	breq	.+10     	; 0x1b36 <gc_execute_line+0x174>
    1b2c:	6a 30       	cpi	r22, 0x0A	; 10
    1b2e:	71 05       	cpc	r23, r1
    1b30:	41 f0       	breq	.+16     	; 0x1b42 <gc_execute_line+0x180>
    1b32:	0c 94 2b 17 	jmp	0x2e56	; 0x2e56 <gc_execute_line+0x1494>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
    1b36:	83 e0       	ldi	r24, 0x03	; 3
    1b38:	a6 ec       	ldi	r26, 0xC6	; 198
    1b3a:	b7 e0       	ldi	r27, 0x07	; 7
    1b3c:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b3e:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
    1b40:	05 c1       	rjmp	.+522    	; 0x1d4c <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
    1b42:	84 e0       	ldi	r24, 0x04	; 4
    1b44:	e6 ec       	ldi	r30, 0xC6	; 198
    1b46:	f7 e0       	ldi	r31, 0x07	; 7
    1b48:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b4a:	80 e0       	ldi	r24, 0x00	; 0
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
    1b4c:	ff c0       	rjmp	.+510    	; 0x1d4c <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
    1b4e:	61 15       	cp	r22, r1
    1b50:	71 05       	cpc	r23, r1
    1b52:	29 f0       	breq	.+10     	; 0x1b5e <gc_execute_line+0x19c>
    1b54:	6a 30       	cpi	r22, 0x0A	; 10
    1b56:	71 05       	cpc	r23, r1
    1b58:	41 f0       	breq	.+16     	; 0x1b6a <gc_execute_line+0x1a8>
    1b5a:	0c 94 2d 17 	jmp	0x2e5a	; 0x2e5a <gc_execute_line+0x1498>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
    1b5e:	85 e0       	ldi	r24, 0x05	; 5
    1b60:	a6 ec       	ldi	r26, 0xC6	; 198
    1b62:	b7 e0       	ldi	r27, 0x07	; 7
    1b64:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b66:	80 e0       	ldi	r24, 0x00	; 0
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
    1b68:	f1 c0       	rjmp	.+482    	; 0x1d4c <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
    1b6a:	86 e0       	ldi	r24, 0x06	; 6
    1b6c:	e6 ec       	ldi	r30, 0xC6	; 198
    1b6e:	f7 e0       	ldi	r31, 0x07	; 7
    1b70:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b72:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
    1b74:	eb c0       	rjmp	.+470    	; 0x1d4c <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
    1b76:	87 e0       	ldi	r24, 0x07	; 7
    1b78:	a6 ec       	ldi	r26, 0xC6	; 198
    1b7a:	b7 e0       	ldi	r27, 0x07	; 7
    1b7c:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b7e:	80 e0       	ldi	r24, 0x00	; 0
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
    1b80:	e1 c0       	rjmp	.+450    	; 0x1d44 <gc_execute_line+0x382>
              case 92: 
                switch(mantissa) {
    1b82:	61 15       	cp	r22, r1
    1b84:	71 05       	cpc	r23, r1
    1b86:	29 f0       	breq	.+10     	; 0x1b92 <gc_execute_line+0x1d0>
    1b88:	6a 30       	cpi	r22, 0x0A	; 10
    1b8a:	71 05       	cpc	r23, r1
    1b8c:	41 f0       	breq	.+16     	; 0x1b9e <gc_execute_line+0x1dc>
    1b8e:	0c 94 2f 17 	jmp	0x2e5e	; 0x2e5e <gc_execute_line+0x149c>
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
    1b92:	88 e0       	ldi	r24, 0x08	; 8
    1b94:	e6 ec       	ldi	r30, 0xC6	; 198
    1b96:	f7 e0       	ldi	r31, 0x07	; 7
    1b98:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b9a:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
    1b9c:	d7 c0       	rjmp	.+430    	; 0x1d4c <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
    1b9e:	89 e0       	ldi	r24, 0x09	; 9
    1ba0:	a6 ec       	ldi	r26, 0xC6	; 198
    1ba2:	b7 e0       	ldi	r27, 0x07	; 7
    1ba4:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1ba6:	80 e0       	ldi	r24, 0x00	; 0
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
    1ba8:	d1 c0       	rjmp	.+418    	; 0x1d4c <gc_execute_line+0x38a>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1baa:	be 8d       	ldd	r27, Y+30	; 0x1e
    1bac:	b1 11       	cpse	r27, r1
    1bae:	0c 94 31 17 	jmp	0x2e62	; 0x2e62 <gc_execute_line+0x14a0>
            axis_command = AXIS_COMMAND_MOTION_MODE; 
    1bb2:	e2 e0       	ldi	r30, 0x02	; 2
    1bb4:	ee 8f       	std	Y+30, r30	; 0x1e
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
            switch(int_value) {
    1bb6:	f2 e0       	ldi	r31, 0x02	; 2
    1bb8:	af 16       	cp	r10, r31
    1bba:	e9 f0       	breq	.+58     	; 0x1bf6 <gc_execute_line+0x234>
    1bbc:	fa 15       	cp	r31, r10
    1bbe:	30 f0       	brcs	.+12     	; 0x1bcc <gc_execute_line+0x20a>
    1bc0:	aa 20       	and	r10, r10
    1bc2:	79 f0       	breq	.+30     	; 0x1be2 <gc_execute_line+0x220>
    1bc4:	21 e0       	ldi	r18, 0x01	; 1
    1bc6:	a2 16       	cp	r10, r18
    1bc8:	89 f0       	breq	.+34     	; 0x1bec <gc_execute_line+0x22a>
    1bca:	b9 c0       	rjmp	.+370    	; 0x1d3e <gc_execute_line+0x37c>
    1bcc:	36 e2       	ldi	r19, 0x26	; 38
    1bce:	a3 16       	cp	r10, r19
    1bd0:	f1 f0       	breq	.+60     	; 0x1c0e <gc_execute_line+0x24c>
    1bd2:	80 e5       	ldi	r24, 0x50	; 80
    1bd4:	a8 16       	cp	r10, r24
    1bd6:	09 f4       	brne	.+2      	; 0x1bda <gc_execute_line+0x218>
    1bd8:	43 c0       	rjmp	.+134    	; 0x1c60 <gc_execute_line+0x29e>
    1bda:	93 e0       	ldi	r25, 0x03	; 3
    1bdc:	a9 12       	cpse	r10, r25
    1bde:	af c0       	rjmp	.+350    	; 0x1d3e <gc_execute_line+0x37c>
    1be0:	10 c0       	rjmp	.+32     	; 0x1c02 <gc_execute_line+0x240>
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
    1be2:	a7 ec       	ldi	r26, 0xC7	; 199
    1be4:	b7 e0       	ldi	r27, 0x07	; 7
    1be6:	1c 92       	st	X, r1
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1be8:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
    1bea:	ac c0       	rjmp	.+344    	; 0x1d44 <gc_execute_line+0x382>
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	e7 ec       	ldi	r30, 0xC7	; 199
    1bf0:	f7 e0       	ldi	r31, 0x07	; 7
    1bf2:	80 83       	st	Z, r24
    1bf4:	a7 c0       	rjmp	.+334    	; 0x1d44 <gc_execute_line+0x382>
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
    1bf6:	82 e0       	ldi	r24, 0x02	; 2
    1bf8:	a7 ec       	ldi	r26, 0xC7	; 199
    1bfa:	b7 e0       	ldi	r27, 0x07	; 7
    1bfc:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
    1c00:	a1 c0       	rjmp	.+322    	; 0x1d44 <gc_execute_line+0x382>
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
    1c02:	83 e0       	ldi	r24, 0x03	; 3
    1c04:	e7 ec       	ldi	r30, 0xC7	; 199
    1c06:	f7 e0       	ldi	r31, 0x07	; 7
    1c08:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c0a:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
    1c0c:	9b c0       	rjmp	.+310    	; 0x1d44 <gc_execute_line+0x382>
              case 38: 
                switch(mantissa) {
    1c0e:	6e 31       	cpi	r22, 0x1E	; 30
    1c10:	71 05       	cpc	r23, r1
    1c12:	a1 f0       	breq	.+40     	; 0x1c3c <gc_execute_line+0x27a>
    1c14:	28 f4       	brcc	.+10     	; 0x1c20 <gc_execute_line+0x25e>
    1c16:	64 31       	cpi	r22, 0x14	; 20
    1c18:	71 05       	cpc	r23, r1
    1c1a:	51 f0       	breq	.+20     	; 0x1c30 <gc_execute_line+0x26e>
    1c1c:	0c 94 33 17 	jmp	0x2e66	; 0x2e66 <gc_execute_line+0x14a4>
    1c20:	68 32       	cpi	r22, 0x28	; 40
    1c22:	71 05       	cpc	r23, r1
    1c24:	89 f0       	breq	.+34     	; 0x1c48 <gc_execute_line+0x286>
    1c26:	62 33       	cpi	r22, 0x32	; 50
    1c28:	71 05       	cpc	r23, r1
    1c2a:	a1 f0       	breq	.+40     	; 0x1c54 <gc_execute_line+0x292>
    1c2c:	0c 94 33 17 	jmp	0x2e66	; 0x2e66 <gc_execute_line+0x14a4>
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
    1c30:	84 e0       	ldi	r24, 0x04	; 4
    1c32:	a7 ec       	ldi	r26, 0xC7	; 199
    1c34:	b7 e0       	ldi	r27, 0x07	; 7
    1c36:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c38:	81 e0       	ldi	r24, 0x01	; 1
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
    1c3a:	88 c0       	rjmp	.+272    	; 0x1d4c <gc_execute_line+0x38a>
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
    1c3c:	85 e0       	ldi	r24, 0x05	; 5
    1c3e:	e7 ec       	ldi	r30, 0xC7	; 199
    1c40:	f7 e0       	ldi	r31, 0x07	; 7
    1c42:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c44:	81 e0       	ldi	r24, 0x01	; 1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
    1c46:	82 c0       	rjmp	.+260    	; 0x1d4c <gc_execute_line+0x38a>
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
    1c48:	86 e0       	ldi	r24, 0x06	; 6
    1c4a:	a7 ec       	ldi	r26, 0xC7	; 199
    1c4c:	b7 e0       	ldi	r27, 0x07	; 7
    1c4e:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c50:	81 e0       	ldi	r24, 0x01	; 1
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
    1c52:	7c c0       	rjmp	.+248    	; 0x1d4c <gc_execute_line+0x38a>
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
    1c54:	87 e0       	ldi	r24, 0x07	; 7
    1c56:	e7 ec       	ldi	r30, 0xC7	; 199
    1c58:	f7 e0       	ldi	r31, 0x07	; 7
    1c5a:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c5c:	81 e0       	ldi	r24, 0x01	; 1
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
    1c5e:	76 c0       	rjmp	.+236    	; 0x1d4c <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
    1c60:	88 e0       	ldi	r24, 0x08	; 8
    1c62:	a7 ec       	ldi	r26, 0xC7	; 199
    1c64:	b7 e0       	ldi	r27, 0x07	; 7
    1c66:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c68:	81 e0       	ldi	r24, 0x01	; 1
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
    1c6a:	6c c0       	rjmp	.+216    	; 0x1d44 <gc_execute_line+0x382>
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
            switch(int_value) {
    1c6c:	b2 e1       	ldi	r27, 0x12	; 18
    1c6e:	ab 16       	cp	r10, r27
    1c70:	59 f0       	breq	.+22     	; 0x1c88 <gc_execute_line+0x2c6>
    1c72:	e3 e1       	ldi	r30, 0x13	; 19
    1c74:	ae 16       	cp	r10, r30
    1c76:	71 f0       	breq	.+28     	; 0x1c94 <gc_execute_line+0x2d2>
    1c78:	f1 e1       	ldi	r31, 0x11	; 17
    1c7a:	af 12       	cpse	r10, r31
    1c7c:	62 c0       	rjmp	.+196    	; 0x1d42 <gc_execute_line+0x380>
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
    1c7e:	ab ec       	ldi	r26, 0xCB	; 203
    1c80:	b7 e0       	ldi	r27, 0x07	; 7
    1c82:	1c 92       	st	X, r1
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1c84:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
    1c86:	5e c0       	rjmp	.+188    	; 0x1d44 <gc_execute_line+0x382>
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	eb ec       	ldi	r30, 0xCB	; 203
    1c8c:	f7 e0       	ldi	r31, 0x07	; 7
    1c8e:	80 83       	st	Z, r24
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1c90:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
    1c92:	58 c0       	rjmp	.+176    	; 0x1d44 <gc_execute_line+0x382>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
    1c94:	82 e0       	ldi	r24, 0x02	; 2
    1c96:	ab ec       	ldi	r26, 0xCB	; 203
    1c98:	b7 e0       	ldi	r27, 0x07	; 7
    1c9a:	8c 93       	st	X, r24
    1c9c:	53 c0       	rjmp	.+166    	; 0x1d44 <gc_execute_line+0x382>
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
    1c9e:	ba e5       	ldi	r27, 0x5A	; 90
    1ca0:	ab 12       	cpse	r10, r27
    1ca2:	05 c0       	rjmp	.+10     	; 0x1cae <gc_execute_line+0x2ec>
    1ca4:	ea ec       	ldi	r30, 0xCA	; 202
    1ca6:	f7 e0       	ldi	r31, 0x07	; 7
    1ca8:	10 82       	st	Z, r1
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
    1caa:	83 e0       	ldi	r24, 0x03	; 3
    1cac:	4b c0       	rjmp	.+150    	; 0x1d44 <gc_execute_line+0x382>
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
    1cae:	81 e0       	ldi	r24, 0x01	; 1
    1cb0:	aa ec       	ldi	r26, 0xCA	; 202
    1cb2:	b7 e0       	ldi	r27, 0x07	; 7
    1cb4:	8c 93       	st	X, r24
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
    1cb6:	83 e0       	ldi	r24, 0x03	; 3
    1cb8:	45 c0       	rjmp	.+138    	; 0x1d44 <gc_execute_line+0x382>
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
    1cba:	bd e5       	ldi	r27, 0x5D	; 93
    1cbc:	ab 12       	cpse	r10, r27
    1cbe:	06 c0       	rjmp	.+12     	; 0x1ccc <gc_execute_line+0x30a>
    1cc0:	81 e0       	ldi	r24, 0x01	; 1
    1cc2:	e8 ec       	ldi	r30, 0xC8	; 200
    1cc4:	f7 e0       	ldi	r31, 0x07	; 7
    1cc6:	80 83       	st	Z, r24
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
    1cc8:	84 e0       	ldi	r24, 0x04	; 4
    1cca:	3c c0       	rjmp	.+120    	; 0x1d44 <gc_execute_line+0x382>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
    1ccc:	a8 ec       	ldi	r26, 0xC8	; 200
    1cce:	b7 e0       	ldi	r27, 0x07	; 7
    1cd0:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
    1cd2:	84 e0       	ldi	r24, 0x04	; 4
    1cd4:	37 c0       	rjmp	.+110    	; 0x1d44 <gc_execute_line+0x382>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
    1cd6:	b4 e1       	ldi	r27, 0x14	; 20
    1cd8:	ab 12       	cpse	r10, r27
    1cda:	06 c0       	rjmp	.+12     	; 0x1ce8 <gc_execute_line+0x326>
    1cdc:	81 e0       	ldi	r24, 0x01	; 1
    1cde:	e9 ec       	ldi	r30, 0xC9	; 201
    1ce0:	f7 e0       	ldi	r31, 0x07	; 7
    1ce2:	80 83       	st	Z, r24
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
    1ce4:	85 e0       	ldi	r24, 0x05	; 5
    1ce6:	2e c0       	rjmp	.+92     	; 0x1d44 <gc_execute_line+0x382>
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
    1ce8:	a9 ec       	ldi	r26, 0xC9	; 201
    1cea:	b7 e0       	ldi	r27, 0x07	; 7
    1cec:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
    1cee:	85 e0       	ldi	r24, 0x05	; 5
    1cf0:	29 c0       	rjmp	.+82     	; 0x1d44 <gc_execute_line+0x382>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    1cf2:	be 8d       	ldd	r27, Y+30	; 0x1e
    1cf4:	b1 11       	cpse	r27, r1
    1cf6:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <gc_execute_line+0x14a8>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
    1cfa:	e1 e3       	ldi	r30, 0x31	; 49
    1cfc:	ae 12       	cpse	r10, r30
    1cfe:	07 c0       	rjmp	.+14     	; 0x1d0e <gc_execute_line+0x34c>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
    1d00:	ac ec       	ldi	r26, 0xCC	; 204
    1d02:	b7 e0       	ldi	r27, 0x07	; 7
    1d04:	1c 92       	st	X, r1
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1d06:	87 e0       	ldi	r24, 0x07	; 7
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1d08:	b3 e0       	ldi	r27, 0x03	; 3
    1d0a:	be 8f       	std	Y+30, r27	; 0x1e
    1d0c:	1f c0       	rjmp	.+62     	; 0x1d4c <gc_execute_line+0x38a>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
    1d0e:	6a 30       	cpi	r22, 0x0A	; 10
    1d10:	71 05       	cpc	r23, r1
    1d12:	11 f0       	breq	.+4      	; 0x1d18 <gc_execute_line+0x356>
    1d14:	0c 94 37 17 	jmp	0x2e6e	; 0x2e6e <gc_execute_line+0x14ac>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	ec ec       	ldi	r30, 0xCC	; 204
    1d1c:	f7 e0       	ldi	r31, 0x07	; 7
    1d1e:	80 83       	st	Z, r24
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1d20:	87 e0       	ldi	r24, 0x07	; 7
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1d22:	f3 e0       	ldi	r31, 0x03	; 3
    1d24:	fe 8f       	std	Y+30, r31	; 0x1e
    1d26:	12 c0       	rjmp	.+36     	; 0x1d4c <gc_execute_line+0x38a>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
    1d28:	8a ec       	ldi	r24, 0xCA	; 202
    1d2a:	8a 0d       	add	r24, r10
    1d2c:	ad ec       	ldi	r26, 0xCD	; 205
    1d2e:	b7 e0       	ldi	r27, 0x07	; 7
    1d30:	8c 93       	st	X, r24
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    1d32:	88 e0       	ldi	r24, 0x08	; 8
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
    1d34:	07 c0       	rjmp	.+14     	; 0x1d44 <gc_execute_line+0x382>
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
    1d36:	86 e0       	ldi	r24, 0x06	; 6
    1d38:	05 c0       	rjmp	.+10     	; 0x1d44 <gc_execute_line+0x382>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1d3a:	80 e0       	ldi	r24, 0x00	; 0
    1d3c:	03 c0       	rjmp	.+6      	; 0x1d44 <gc_execute_line+0x382>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1d3e:	81 e0       	ldi	r24, 0x01	; 1
    1d40:	01 c0       	rjmp	.+2      	; 0x1d44 <gc_execute_line+0x382>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1d42:	82 e0       	ldi	r24, 0x02	; 2
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1d44:	67 2b       	or	r22, r23
    1d46:	11 f0       	breq	.+4      	; 0x1d4c <gc_execute_line+0x38a>
    1d48:	0c 94 39 17 	jmp	0x2e72	; 0x2e72 <gc_execute_line+0x14b0>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1d4c:	f6 01       	movw	r30, r12
    1d4e:	02 c0       	rjmp	.+4      	; 0x1d54 <gc_execute_line+0x392>
    1d50:	ee 0f       	add	r30, r30
    1d52:	ff 1f       	adc	r31, r31
    1d54:	8a 95       	dec	r24
    1d56:	e2 f7       	brpl	.-8      	; 0x1d50 <gc_execute_line+0x38e>
    1d58:	9f 01       	movw	r18, r30
    1d5a:	2e 21       	and	r18, r14
    1d5c:	3f 21       	and	r19, r15
    1d5e:	23 2b       	or	r18, r19
    1d60:	11 f0       	breq	.+4      	; 0x1d66 <gc_execute_line+0x3a4>
    1d62:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <gc_execute_line+0x14b4>
        command_words |= bit(word_bit);
    1d66:	ee 2a       	or	r14, r30
    1d68:	ff 2a       	or	r15, r31
        break;
    1d6a:	15 c1       	rjmp	.+554    	; 0x1f96 <gc_execute_line+0x5d4>
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    1d6c:	67 2b       	or	r22, r23
    1d6e:	11 f0       	breq	.+4      	; 0x1d74 <gc_execute_line+0x3b2>
    1d70:	0c 94 3d 17 	jmp	0x2e7a	; 0x2e7a <gc_execute_line+0x14b8>
        switch(int_value) {
    1d74:	8a 2d       	mov	r24, r10
    1d76:	90 e0       	ldi	r25, 0x00	; 0
    1d78:	8f 31       	cpi	r24, 0x1F	; 31
    1d7a:	91 05       	cpc	r25, r1
    1d7c:	10 f0       	brcs	.+4      	; 0x1d82 <gc_execute_line+0x3c0>
    1d7e:	0c 94 3f 17 	jmp	0x2e7e	; 0x2e7e <gc_execute_line+0x14bc>
    1d82:	fc 01       	movw	r30, r24
    1d84:	e9 56       	subi	r30, 0x69	; 105
    1d86:	ff 4f       	sbci	r31, 0xFF	; 255
    1d88:	0c 94 d9 3f 	jmp	0x7fb2	; 0x7fb2 <__tablejump2__>
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
            switch(int_value) {
    1d8c:	f2 e0       	ldi	r31, 0x02	; 2
    1d8e:	af 16       	cp	r10, r31
    1d90:	51 f0       	breq	.+20     	; 0x1da6 <gc_execute_line+0x3e4>
    1d92:	2e e1       	ldi	r18, 0x1E	; 30
    1d94:	a2 16       	cp	r10, r18
    1d96:	39 f0       	breq	.+14     	; 0x1da6 <gc_execute_line+0x3e4>
    1d98:	a1 10       	cpse	r10, r1
    1d9a:	31 c0       	rjmp	.+98     	; 0x1dfe <gc_execute_line+0x43c>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1d9c:	81 e0       	ldi	r24, 0x01	; 1
    1d9e:	80 93 ce 07 	sts	0x07CE, r24
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1da2:	89 e0       	ldi	r24, 0x09	; 9
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1da4:	31 c0       	rjmp	.+98     	; 0x1e08 <gc_execute_line+0x446>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1da6:	82 e0       	ldi	r24, 0x02	; 2
    1da8:	80 93 ce 07 	sts	0x07CE, r24
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1dac:	89 e0       	ldi	r24, 0x09	; 9
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1dae:	2c c0       	rjmp	.+88     	; 0x1e08 <gc_execute_line+0x446>
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
            switch(int_value) {
    1db0:	34 e0       	ldi	r19, 0x04	; 4
    1db2:	a3 16       	cp	r10, r19
    1db4:	59 f0       	breq	.+22     	; 0x1dcc <gc_execute_line+0x40a>
    1db6:	85 e0       	ldi	r24, 0x05	; 5
    1db8:	a8 16       	cp	r10, r24
    1dba:	69 f0       	breq	.+26     	; 0x1dd6 <gc_execute_line+0x414>
    1dbc:	93 e0       	ldi	r25, 0x03	; 3
    1dbe:	a9 12       	cpse	r10, r25
    1dc0:	20 c0       	rjmp	.+64     	; 0x1e02 <gc_execute_line+0x440>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1dc2:	81 e0       	ldi	r24, 0x01	; 1
    1dc4:	80 93 d0 07 	sts	0x07D0, r24
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1dc8:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1dca:	1e c0       	rjmp	.+60     	; 0x1e08 <gc_execute_line+0x446>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1dcc:	82 e0       	ldi	r24, 0x02	; 2
    1dce:	80 93 d0 07 	sts	0x07D0, r24
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1dd2:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1dd4:	19 c0       	rjmp	.+50     	; 0x1e08 <gc_execute_line+0x446>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1dd6:	10 92 d0 07 	sts	0x07D0, r1
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1dda:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1ddc:	15 c0       	rjmp	.+42     	; 0x1e08 <gc_execute_line+0x446>
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    1dde:	a8 e0       	ldi	r26, 0x08	; 8
    1de0:	aa 16       	cp	r10, r26
    1de2:	21 f0       	breq	.+8      	; 0x1dec <gc_execute_line+0x42a>
    1de4:	b9 e0       	ldi	r27, 0x09	; 9
    1de6:	ab 16       	cp	r10, r27
    1de8:	31 f0       	breq	.+12     	; 0x1df6 <gc_execute_line+0x434>
    1dea:	0d c0       	rjmp	.+26     	; 0x1e06 <gc_execute_line+0x444>
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1dec:	82 e0       	ldi	r24, 0x02	; 2
    1dee:	80 93 cf 07 	sts	0x07CF, r24
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1df2:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1df4:	09 c0       	rjmp	.+18     	; 0x1e08 <gc_execute_line+0x446>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1df6:	10 92 cf 07 	sts	0x07CF, r1
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1dfa:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1dfc:	05 c0       	rjmp	.+10     	; 0x1e08 <gc_execute_line+0x446>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1dfe:	89 e0       	ldi	r24, 0x09	; 9
    1e00:	03 c0       	rjmp	.+6      	; 0x1e08 <gc_execute_line+0x446>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1e02:	8a e0       	ldi	r24, 0x0A	; 10
    1e04:	01 c0       	rjmp	.+2      	; 0x1e08 <gc_execute_line+0x446>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1e06:	8b e0       	ldi	r24, 0x0B	; 11
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1e08:	f6 01       	movw	r30, r12
    1e0a:	02 c0       	rjmp	.+4      	; 0x1e10 <gc_execute_line+0x44e>
    1e0c:	ee 0f       	add	r30, r30
    1e0e:	ff 1f       	adc	r31, r31
    1e10:	8a 95       	dec	r24
    1e12:	e2 f7       	brpl	.-8      	; 0x1e0c <gc_execute_line+0x44a>
    1e14:	9f 01       	movw	r18, r30
    1e16:	2e 21       	and	r18, r14
    1e18:	3f 21       	and	r19, r15
    1e1a:	23 2b       	or	r18, r19
    1e1c:	11 f0       	breq	.+4      	; 0x1e22 <gc_execute_line+0x460>
    1e1e:	0c 94 41 17 	jmp	0x2e82	; 0x2e82 <gc_execute_line+0x14c0>
        command_words |= bit(word_bit);
    1e22:	ee 2a       	or	r14, r30
    1e24:	ff 2a       	or	r15, r31
        break;
    1e26:	b7 c0       	rjmp	.+366    	; 0x1f96 <gc_execute_line+0x5d4>
      default: 
  
        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    1e28:	8b 2d       	mov	r24, r11
    1e2a:	90 e0       	ldi	r25, 0x00	; 0
    1e2c:	fc 01       	movw	r30, r24
    1e2e:	e6 54       	subi	r30, 0x46	; 70
    1e30:	f1 09       	sbc	r31, r1
    1e32:	e5 31       	cpi	r30, 0x15	; 21
    1e34:	f1 05       	cpc	r31, r1
    1e36:	10 f0       	brcs	.+4      	; 0x1e3c <gc_execute_line+0x47a>
    1e38:	0c 94 43 17 	jmp	0x2e86	; 0x2e86 <gc_execute_line+0x14c4>
    1e3c:	ea 54       	subi	r30, 0x4A	; 74
    1e3e:	ff 4f       	sbci	r31, 0xFF	; 255
    1e40:	0c 94 d9 3f 	jmp	0x7fb2	; 0x7fb2 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    1e44:	40 92 d1 07 	sts	0x07D1, r4
    1e48:	50 92 d2 07 	sts	0x07D2, r5
    1e4c:	60 92 d3 07 	sts	0x07D3, r6
    1e50:	70 92 d4 07 	sts	0x07D4, r7
    1e54:	20 e0       	ldi	r18, 0x00	; 0
    1e56:	7e c0       	rjmp	.+252    	; 0x1f54 <gc_execute_line+0x592>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    1e58:	40 92 d5 07 	sts	0x07D5, r4
    1e5c:	50 92 d6 07 	sts	0x07D6, r5
    1e60:	60 92 d7 07 	sts	0x07D7, r6
    1e64:	70 92 d8 07 	sts	0x07D8, r7
    1e68:	fb a1       	ldd	r31, Y+35	; 0x23
    1e6a:	f1 60       	ori	r31, 0x01	; 1
    1e6c:	fb a3       	std	Y+35, r31	; 0x23
    1e6e:	21 e0       	ldi	r18, 0x01	; 1
    1e70:	71 c0       	rjmp	.+226    	; 0x1f54 <gc_execute_line+0x592>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    1e72:	40 92 d9 07 	sts	0x07D9, r4
    1e76:	50 92 da 07 	sts	0x07DA, r5
    1e7a:	60 92 db 07 	sts	0x07DB, r6
    1e7e:	70 92 dc 07 	sts	0x07DC, r7
    1e82:	2b a1       	ldd	r18, Y+35	; 0x23
    1e84:	22 60       	ori	r18, 0x02	; 2
    1e86:	2b a3       	std	Y+35, r18	; 0x23
    1e88:	22 e0       	ldi	r18, 0x02	; 2
    1e8a:	64 c0       	rjmp	.+200    	; 0x1f54 <gc_execute_line+0x592>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    1e8c:	40 92 dd 07 	sts	0x07DD, r4
    1e90:	50 92 de 07 	sts	0x07DE, r5
    1e94:	60 92 df 07 	sts	0x07DF, r6
    1e98:	70 92 e0 07 	sts	0x07E0, r7
    1e9c:	3b a1       	ldd	r19, Y+35	; 0x23
    1e9e:	34 60       	ori	r19, 0x04	; 4
    1ea0:	3b a3       	std	Y+35, r19	; 0x23
    1ea2:	23 e0       	ldi	r18, 0x03	; 3
    1ea4:	57 c0       	rjmp	.+174    	; 0x1f54 <gc_execute_line+0x592>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    1ea6:	a0 92 e1 07 	sts	0x07E1, r10
    1eaa:	24 e0       	ldi	r18, 0x04	; 4
    1eac:	53 c0       	rjmp	.+166    	; 0x1f54 <gc_execute_line+0x592>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    1eae:	c3 01       	movw	r24, r6
    1eb0:	b2 01       	movw	r22, r4
    1eb2:	0e 94 fb 3c 	call	0x79f6	; 0x79f6 <__fixsfsi>
    1eb6:	60 93 e2 07 	sts	0x07E2, r22
    1eba:	70 93 e3 07 	sts	0x07E3, r23
    1ebe:	80 93 e4 07 	sts	0x07E4, r24
    1ec2:	90 93 e5 07 	sts	0x07E5, r25
    1ec6:	25 e0       	ldi	r18, 0x05	; 5
    1ec8:	45 c0       	rjmp	.+138    	; 0x1f54 <gc_execute_line+0x592>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    1eca:	40 92 e6 07 	sts	0x07E6, r4
    1ece:	50 92 e7 07 	sts	0x07E7, r5
    1ed2:	60 92 e8 07 	sts	0x07E8, r6
    1ed6:	70 92 e9 07 	sts	0x07E9, r7
    1eda:	26 e0       	ldi	r18, 0x06	; 6
    1edc:	3b c0       	rjmp	.+118    	; 0x1f54 <gc_execute_line+0x592>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1ede:	40 92 ea 07 	sts	0x07EA, r4
    1ee2:	50 92 eb 07 	sts	0x07EB, r5
    1ee6:	60 92 ec 07 	sts	0x07EC, r6
    1eea:	70 92 ed 07 	sts	0x07ED, r7
    1eee:	27 e0       	ldi	r18, 0x07	; 7
    1ef0:	31 c0       	rjmp	.+98     	; 0x1f54 <gc_execute_line+0x592>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    1ef2:	40 92 ee 07 	sts	0x07EE, r4
    1ef6:	50 92 ef 07 	sts	0x07EF, r5
    1efa:	60 92 f0 07 	sts	0x07F0, r6
    1efe:	70 92 f1 07 	sts	0x07F1, r7
    1f02:	28 e0       	ldi	r18, 0x08	; 8
    1f04:	27 c0       	rjmp	.+78     	; 0x1f54 <gc_execute_line+0x592>
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    1f06:	40 92 f3 07 	sts	0x07F3, r4
    1f0a:	50 92 f4 07 	sts	0x07F4, r5
    1f0e:	60 92 f5 07 	sts	0x07F5, r6
    1f12:	70 92 f6 07 	sts	0x07F6, r7
    1f16:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1f18:	81 60       	ori	r24, 0x01	; 1
    1f1a:	8f 8f       	std	Y+31, r24	; 0x1f
    1f1c:	2a e0       	ldi	r18, 0x0A	; 10
    1f1e:	1a c0       	rjmp	.+52     	; 0x1f54 <gc_execute_line+0x592>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    1f20:	40 92 f7 07 	sts	0x07F7, r4
    1f24:	50 92 f8 07 	sts	0x07F8, r5
    1f28:	60 92 f9 07 	sts	0x07F9, r6
    1f2c:	70 92 fa 07 	sts	0x07FA, r7
    1f30:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1f32:	92 60       	ori	r25, 0x02	; 2
    1f34:	9f 8f       	std	Y+31, r25	; 0x1f
    1f36:	2b e0       	ldi	r18, 0x0B	; 11
    1f38:	0d c0       	rjmp	.+26     	; 0x1f54 <gc_execute_line+0x592>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    1f3a:	ab ef       	ldi	r26, 0xFB	; 251
    1f3c:	b7 e0       	ldi	r27, 0x07	; 7
    1f3e:	4d 92       	st	X+, r4
    1f40:	5d 92       	st	X+, r5
    1f42:	6d 92       	st	X+, r6
    1f44:	7c 92       	st	X, r7
    1f46:	13 97       	sbiw	r26, 0x03	; 3
    1f48:	bf 8d       	ldd	r27, Y+31	; 0x1f
    1f4a:	b4 60       	ori	r27, 0x04	; 4
    1f4c:	bf 8f       	std	Y+31, r27	; 0x1f
    1f4e:	2c e0       	ldi	r18, 0x0C	; 12
    1f50:	01 c0       	rjmp	.+2      	; 0x1f54 <gc_execute_line+0x592>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
    1f52:	29 e0       	ldi	r18, 0x09	; 9
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1f54:	56 01       	movw	r10, r12
    1f56:	02 2e       	mov	r0, r18
    1f58:	02 c0       	rjmp	.+4      	; 0x1f5e <gc_execute_line+0x59c>
    1f5a:	aa 0c       	add	r10, r10
    1f5c:	bb 1c       	adc	r11, r11
    1f5e:	0a 94       	dec	r0
    1f60:	e2 f7       	brpl	.-8      	; 0x1f5a <gc_execute_line+0x598>
    1f62:	c5 01       	movw	r24, r10
    1f64:	82 21       	and	r24, r2
    1f66:	93 21       	and	r25, r3
    1f68:	89 2b       	or	r24, r25
    1f6a:	09 f0       	breq	.+2      	; 0x1f6e <gc_execute_line+0x5ac>
    1f6c:	8e c7       	rjmp	.+3868   	; 0x2e8a <gc_execute_line+0x14c8>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1f6e:	c4 01       	movw	r24, r8
    1f70:	02 c0       	rjmp	.+4      	; 0x1f76 <gc_execute_line+0x5b4>
    1f72:	95 95       	asr	r25
    1f74:	87 95       	ror	r24
    1f76:	2a 95       	dec	r18
    1f78:	e2 f7       	brpl	.-8      	; 0x1f72 <gc_execute_line+0x5b0>
    1f7a:	80 ff       	sbrs	r24, 0
    1f7c:	0a c0       	rjmp	.+20     	; 0x1f92 <gc_execute_line+0x5d0>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    1f7e:	20 e0       	ldi	r18, 0x00	; 0
    1f80:	30 e0       	ldi	r19, 0x00	; 0
    1f82:	a9 01       	movw	r20, r18
    1f84:	c3 01       	movw	r24, r6
    1f86:	b2 01       	movw	r22, r4
    1f88:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    1f8c:	88 23       	and	r24, r24
    1f8e:	0c f4       	brge	.+2      	; 0x1f92 <gc_execute_line+0x5d0>
    1f90:	7e c7       	rjmp	.+3836   	; 0x2e8e <gc_execute_line+0x14cc>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    1f92:	2a 28       	or	r2, r10
    1f94:	3b 28       	or	r3, r11
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1f96:	89 8d       	ldd	r24, Y+25	; 0x19
    1f98:	f8 01       	movw	r30, r16
    1f9a:	e8 0f       	add	r30, r24
    1f9c:	f1 1d       	adc	r31, r1
    1f9e:	b0 80       	ld	r11, Z
    1fa0:	b1 10       	cpse	r11, r1
    1fa2:	4c cd       	rjmp	.-1384   	; 0x1a3c <gc_execute_line+0x7a>
    1fa4:	81 01       	movw	r16, r2
    1fa6:	8e 8d       	ldd	r24, Y+30	; 0x1e
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  
  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    1fa8:	ef 8d       	ldd	r30, Y+31	; 0x1f
    1faa:	ee 23       	and	r30, r30
    1fac:	21 f0       	breq	.+8      	; 0x1fb6 <gc_execute_line+0x5f4>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    1fae:	81 11       	cpse	r24, r1
    1fb0:	02 c0       	rjmp	.+4      	; 0x1fb6 <gc_execute_line+0x5f4>
    1fb2:	f2 e0       	ldi	r31, 0x02	; 2
    1fb4:	fe 8f       	std	Y+30, r31	; 0x1e
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1fb6:	05 ff       	sbrs	r16, 5
    1fb8:	0e c0       	rjmp	.+28     	; 0x1fd6 <gc_execute_line+0x614>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1fba:	80 91 e2 07 	lds	r24, 0x07E2
    1fbe:	90 91 e3 07 	lds	r25, 0x07E3
    1fc2:	a0 91 e4 07 	lds	r26, 0x07E4
    1fc6:	b0 91 e5 07 	lds	r27, 0x07E5
    1fca:	80 38       	cpi	r24, 0x80	; 128
    1fcc:	96 49       	sbci	r25, 0x96	; 150
    1fce:	a8 49       	sbci	r26, 0x98	; 152
    1fd0:	b1 05       	cpc	r27, r1
    1fd2:	0c f0       	brlt	.+2      	; 0x1fd6 <gc_execute_line+0x614>
    1fd4:	5e c7       	rjmp	.+3772   	; 0x2e92 <gc_execute_line+0x14d0>
  
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
  
  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1fd6:	80 91 c8 07 	lds	r24, 0x07C8
    1fda:	81 30       	cpi	r24, 0x01	; 1
    1fdc:	31 f4       	brne	.+12     	; 0x1fea <gc_execute_line+0x628>
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
    1fde:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1fe0:	32 30       	cpi	r19, 0x02	; 2
    1fe2:	a1 f5       	brne	.+104    	; 0x204c <gc_execute_line+0x68a>
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1fe4:	00 ff       	sbrs	r16, 0
    1fe6:	57 c7       	rjmp	.+3758   	; 0x2e96 <gc_execute_line+0x14d4>
    1fe8:	31 c0       	rjmp	.+98     	; 0x204c <gc_execute_line+0x68a>
    // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error 
    // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
  } else { // = G94
    // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    1fea:	80 91 88 07 	lds	r24, 0x0788
    1fee:	81 11       	cpse	r24, r1
    1ff0:	2d c0       	rjmp	.+90     	; 0x204c <gc_execute_line+0x68a>
      if (bit_istrue(value_words,bit(WORD_F))) {
    1ff2:	00 ff       	sbrs	r16, 0
    1ff4:	1b c0       	rjmp	.+54     	; 0x202c <gc_execute_line+0x66a>
        if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    1ff6:	80 91 c9 07 	lds	r24, 0x07C9
    1ffa:	81 30       	cpi	r24, 0x01	; 1
    1ffc:	39 f5       	brne	.+78     	; 0x204c <gc_execute_line+0x68a>
    1ffe:	0f 2e       	mov	r0, r31
    2000:	f1 ed       	ldi	r31, 0xD1	; 209
    2002:	cf 2e       	mov	r12, r31
    2004:	f7 e0       	ldi	r31, 0x07	; 7
    2006:	df 2e       	mov	r13, r31
    2008:	f0 2d       	mov	r31, r0
    200a:	23 e3       	ldi	r18, 0x33	; 51
    200c:	33 e3       	ldi	r19, 0x33	; 51
    200e:	4b ec       	ldi	r20, 0xCB	; 203
    2010:	51 e4       	ldi	r21, 0x41	; 65
    2012:	d6 01       	movw	r26, r12
    2014:	6d 91       	ld	r22, X+
    2016:	7d 91       	ld	r23, X+
    2018:	8d 91       	ld	r24, X+
    201a:	9c 91       	ld	r25, X
    201c:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    2020:	f6 01       	movw	r30, r12
    2022:	60 83       	st	Z, r22
    2024:	71 83       	std	Z+1, r23	; 0x01
    2026:	82 83       	std	Z+2, r24	; 0x02
    2028:	93 83       	std	Z+3, r25	; 0x03
    202a:	10 c0       	rjmp	.+32     	; 0x204c <gc_execute_line+0x68a>
      } else {
        gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    202c:	80 91 95 07 	lds	r24, 0x0795
    2030:	90 91 96 07 	lds	r25, 0x0796
    2034:	a0 91 97 07 	lds	r26, 0x0797
    2038:	b0 91 98 07 	lds	r27, 0x0798
    203c:	80 93 d1 07 	sts	0x07D1, r24
    2040:	90 93 d2 07 	sts	0x07D2, r25
    2044:	a0 93 d3 07 	sts	0x07D3, r26
    2048:	b0 93 d4 07 	sts	0x07D4, r27
    } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
  } 
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
  
  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    204c:	10 fd       	sbrc	r17, 0
    204e:	10 c0       	rjmp	.+32     	; 0x2070 <gc_execute_line+0x6ae>
    2050:	80 91 91 07 	lds	r24, 0x0791
    2054:	90 91 92 07 	lds	r25, 0x0792
    2058:	a0 91 93 07 	lds	r26, 0x0793
    205c:	b0 91 94 07 	lds	r27, 0x0794
    2060:	80 93 ee 07 	sts	0x07EE, r24
    2064:	90 93 ef 07 	sts	0x07EF, r25
    2068:	a0 93 f0 07 	sts	0x07F0, r26
    206c:	b0 93 f1 07 	sts	0x07F1, r27
  // [7. Spindle control ]: N/A
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    2070:	80 91 c6 07 	lds	r24, 0x07C6
    2074:	81 30       	cpi	r24, 0x01	; 1
    2076:	29 f4       	brne	.+10     	; 0x2082 <gc_execute_line+0x6c0>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2078:	06 ff       	sbrs	r16, 6
    207a:	0f c7       	rjmp	.+3614   	; 0x2e9a <gc_execute_line+0x14d8>
    bit_false(value_words,bit(WORD_P));
    207c:	18 01       	movw	r2, r16
    207e:	e8 94       	clt
    2080:	26 f8       	bld	r2, 6
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    2082:	80 91 cb 07 	lds	r24, 0x07CB
    2086:	88 23       	and	r24, r24
    2088:	19 f0       	breq	.+6      	; 0x2090 <gc_execute_line+0x6ce>
    208a:	81 30       	cpi	r24, 0x01	; 1
    208c:	69 f0       	breq	.+26     	; 0x20a8 <gc_execute_line+0x6e6>
    208e:	06 c0       	rjmp	.+12     	; 0x209c <gc_execute_line+0x6da>
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    2090:	f2 e0       	ldi	r31, 0x02	; 2
    2092:	fe a3       	std	Y+38, r31	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    2094:	21 e0       	ldi	r18, 0x01	; 1
    2096:	2d a3       	std	Y+37, r18	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    2098:	1c a2       	std	Y+36, r1	; 0x24
    209a:	0b c0       	rjmp	.+22     	; 0x20b2 <gc_execute_line+0x6f0>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    209c:	1e a2       	std	Y+38, r1	; 0x26
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    209e:	32 e0       	ldi	r19, 0x02	; 2
    20a0:	3d a3       	std	Y+37, r19	; 0x25
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	8c a3       	std	Y+36, r24	; 0x24
    20a6:	05 c0       	rjmp	.+10     	; 0x20b2 <gc_execute_line+0x6f0>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    20a8:	91 e0       	ldi	r25, 0x01	; 1
    20aa:	9e a3       	std	Y+38, r25	; 0x26
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    20ac:	1d a2       	std	Y+37, r1	; 0x25
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    20ae:	a2 e0       	ldi	r26, 0x02	; 2
    20b0:	ac a3       	std	Y+36, r26	; 0x24
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    20b2:	80 91 c9 07 	lds	r24, 0x07C9
    20b6:	81 30       	cpi	r24, 0x01	; 1
    20b8:	69 f5       	brne	.+90     	; 0x2114 <gc_execute_line+0x752>
    20ba:	0f 2e       	mov	r0, r31
    20bc:	f3 ef       	ldi	r31, 0xF3	; 243
    20be:	af 2e       	mov	r10, r31
    20c0:	f7 e0       	ldi	r31, 0x07	; 7
    20c2:	bf 2e       	mov	r11, r31
    20c4:	f0 2d       	mov	r31, r0
    20c6:	00 e0       	ldi	r16, 0x00	; 0
    20c8:	10 e0       	ldi	r17, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    20ca:	bf 8d       	ldd	r27, Y+31	; 0x1f
    20cc:	cb 2e       	mov	r12, r27
    20ce:	d1 2c       	mov	r13, r1
    20d0:	c6 01       	movw	r24, r12
    20d2:	00 2e       	mov	r0, r16
    20d4:	02 c0       	rjmp	.+4      	; 0x20da <gc_execute_line+0x718>
    20d6:	95 95       	asr	r25
    20d8:	87 95       	ror	r24
    20da:	0a 94       	dec	r0
    20dc:	e2 f7       	brpl	.-8      	; 0x20d6 <gc_execute_line+0x714>
    20de:	80 ff       	sbrs	r24, 0
    20e0:	11 c0       	rjmp	.+34     	; 0x2104 <gc_execute_line+0x742>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    20e2:	23 e3       	ldi	r18, 0x33	; 51
    20e4:	33 e3       	ldi	r19, 0x33	; 51
    20e6:	4b ec       	ldi	r20, 0xCB	; 203
    20e8:	51 e4       	ldi	r21, 0x41	; 65
    20ea:	f5 01       	movw	r30, r10
    20ec:	60 81       	ld	r22, Z
    20ee:	71 81       	ldd	r23, Z+1	; 0x01
    20f0:	82 81       	ldd	r24, Z+2	; 0x02
    20f2:	93 81       	ldd	r25, Z+3	; 0x03
    20f4:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    20f8:	d5 01       	movw	r26, r10
    20fa:	6d 93       	st	X+, r22
    20fc:	7d 93       	st	X+, r23
    20fe:	8d 93       	st	X+, r24
    2100:	9c 93       	st	X, r25
    2102:	13 97       	sbiw	r26, 0x03	; 3
    2104:	0f 5f       	subi	r16, 0xFF	; 255
    2106:	1f 4f       	sbci	r17, 0xFF	; 255
    2108:	b4 e0       	ldi	r27, 0x04	; 4
    210a:	ab 0e       	add	r10, r27
    210c:	b1 1c       	adc	r11, r1
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    210e:	03 30       	cpi	r16, 0x03	; 3
    2110:	11 05       	cpc	r17, r1
    2112:	f1 f6       	brne	.-68     	; 0x20d0 <gc_execute_line+0x70e>
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are. 
  // [G43.1 Errors]: Motion command in same line. 
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    2114:	ee 8d       	ldd	r30, Y+30	; 0x1e
    2116:	e3 30       	cpi	r30, 0x03	; 3
    2118:	41 f4       	brne	.+16     	; 0x212a <gc_execute_line+0x768>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    211a:	80 91 cc 07 	lds	r24, 0x07CC
    211e:	81 30       	cpi	r24, 0x01	; 1
    2120:	21 f4       	brne	.+8      	; 0x212a <gc_execute_line+0x768>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    2122:	ff 8d       	ldd	r31, Y+31	; 0x1f
    2124:	f4 30       	cpi	r31, 0x04	; 4
    2126:	09 f0       	breq	.+2      	; 0x212a <gc_execute_line+0x768>
    2128:	ba c6       	rjmp	.+3444   	; 0x2e9e <gc_execute_line+0x14dc>
  // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
    212a:	8c e0       	ldi	r24, 0x0C	; 12
    212c:	ea ea       	ldi	r30, 0xAA	; 170
    212e:	f7 e0       	ldi	r31, 0x07	; 7
    2130:	de 01       	movw	r26, r28
    2132:	11 96       	adiw	r26, 0x01	; 1
    2134:	01 90       	ld	r0, Z+
    2136:	0d 92       	st	X+, r0
    2138:	8a 95       	dec	r24
    213a:	e1 f7       	brne	.-8      	; 0x2134 <gc_execute_line+0x772>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    213c:	f0 fe       	sbrs	r15, 0
    213e:	11 c0       	rjmp	.+34     	; 0x2162 <gc_execute_line+0x7a0>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2140:	80 91 cd 07 	lds	r24, 0x07CD
    2144:	87 30       	cpi	r24, 0x07	; 7
    2146:	08 f0       	brcs	.+2      	; 0x214a <gc_execute_line+0x788>
    2148:	ac c6       	rjmp	.+3416   	; 0x2ea2 <gc_execute_line+0x14e0>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    214a:	90 91 8d 07 	lds	r25, 0x078D
    214e:	89 17       	cp	r24, r25
    2150:	41 f0       	breq	.+16     	; 0x2162 <gc_execute_line+0x7a0>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2152:	be 01       	movw	r22, r28
    2154:	6f 5f       	subi	r22, 0xFF	; 255
    2156:	7f 4f       	sbci	r23, 0xFF	; 255
    2158:	0e 94 1a 27 	call	0x4e34	; 0x4e34 <settings_read_coord_data>
    215c:	88 23       	and	r24, r24
    215e:	09 f4       	brne	.+2      	; 0x2162 <gc_execute_line+0x7a0>
    2160:	a2 c6       	rjmp	.+3396   	; 0x2ea6 <gc_execute_line+0x14e4>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets. 
  switch (gc_block.non_modal_command) {
    2162:	50 90 c6 07 	lds	r5, 0x07C6
    2166:	22 e0       	ldi	r18, 0x02	; 2
    2168:	52 16       	cp	r5, r18
    216a:	29 f0       	breq	.+10     	; 0x2176 <gc_execute_line+0x7b4>
    216c:	38 e0       	ldi	r19, 0x08	; 8
    216e:	53 16       	cp	r5, r19
    2170:	09 f4       	brne	.+2      	; 0x2174 <gc_execute_line+0x7b2>
    2172:	a2 c0       	rjmp	.+324    	; 0x22b8 <gc_execute_line+0x8f6>
    2174:	0d c1       	rjmp	.+538    	; 0x2390 <gc_execute_line+0x9ce>
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2176:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2178:	88 23       	and	r24, r24
    217a:	09 f4       	brne	.+2      	; 0x217e <gc_execute_line+0x7bc>
    217c:	96 c6       	rjmp	.+3372   	; 0x2eaa <gc_execute_line+0x14e8>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    217e:	c1 01       	movw	r24, r2
    2180:	80 75       	andi	r24, 0x50	; 80
    2182:	99 27       	eor	r25, r25
    2184:	89 2b       	or	r24, r25
    2186:	09 f4       	brne	.+2      	; 0x218a <gc_execute_line+0x7c8>
    2188:	92 c6       	rjmp	.+3364   	; 0x2eae <gc_execute_line+0x14ec>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    218a:	60 91 e6 07 	lds	r22, 0x07E6
    218e:	70 91 e7 07 	lds	r23, 0x07E7
    2192:	80 91 e8 07 	lds	r24, 0x07E8
    2196:	90 91 e9 07 	lds	r25, 0x07E9
    219a:	0e 94 98 3f 	call	0x7f30	; 0x7f30 <trunc>
    219e:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    21a2:	67 30       	cpi	r22, 0x07	; 7
    21a4:	08 f0       	brcs	.+2      	; 0x21a8 <gc_execute_line+0x7e6>
    21a6:	85 c6       	rjmp	.+3338   	; 0x2eb2 <gc_execute_line+0x14f0>
      if (gc_block.values.l != 20) {
    21a8:	80 91 e1 07 	lds	r24, 0x07E1
    21ac:	84 31       	cpi	r24, 0x14	; 20
    21ae:	29 f0       	breq	.+10     	; 0x21ba <gc_execute_line+0x7f8>
        if (gc_block.values.l == 2) {
    21b0:	82 30       	cpi	r24, 0x02	; 2
    21b2:	09 f0       	breq	.+2      	; 0x21b6 <gc_execute_line+0x7f4>
    21b4:	80 c6       	rjmp	.+3328   	; 0x2eb6 <gc_execute_line+0x14f4>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    21b6:	27 fc       	sbrc	r2, 7
    21b8:	80 c6       	rjmp	.+3328   	; 0x2eba <gc_execute_line+0x14f8>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    21ba:	9f ea       	ldi	r25, 0xAF	; 175
    21bc:	29 22       	and	r2, r25
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    21be:	66 23       	and	r22, r22
    21c0:	19 f0       	breq	.+6      	; 0x21c8 <gc_execute_line+0x806>
    21c2:	61 50       	subi	r22, 0x01	; 1
    21c4:	6f a3       	std	Y+39, r22	; 0x27
    21c6:	03 c0       	rjmp	.+6      	; 0x21ce <gc_execute_line+0x80c>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    21c8:	a0 91 cd 07 	lds	r26, 0x07CD
    21cc:	af a3       	std	Y+39, r26	; 0x27
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    21ce:	be 01       	movw	r22, r28
    21d0:	63 5f       	subi	r22, 0xF3	; 243
    21d2:	7f 4f       	sbci	r23, 0xFF	; 255
    21d4:	8f a1       	ldd	r24, Y+39	; 0x27
    21d6:	0e 94 1a 27 	call	0x4e34	; 0x4e34 <settings_read_coord_data>
    21da:	88 23       	and	r24, r24
    21dc:	09 f4       	brne	.+2      	; 0x21e0 <gc_execute_line+0x81e>
    21de:	6f c6       	rjmp	.+3294   	; 0x2ebe <gc_execute_line+0x14fc>
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    21e0:	b0 91 e1 07 	lds	r27, 0x07E1
    21e4:	b8 a7       	std	Y+40, r27	; 0x28
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    21e6:	c0 90 c2 07 	lds	r12, 0x07C2
    21ea:	d0 90 c3 07 	lds	r13, 0x07C3
    21ee:	e0 90 c4 07 	lds	r14, 0x07C4
    21f2:	f0 90 c5 07 	lds	r15, 0x07C5
    21f6:	5e 01       	movw	r10, r28
    21f8:	ed e0       	ldi	r30, 0x0D	; 13
    21fa:	ae 0e       	add	r10, r30
    21fc:	b1 1c       	adc	r11, r1
    21fe:	0f 2e       	mov	r0, r31
    2200:	f3 ef       	ldi	r31, 0xF3	; 243
    2202:	8f 2e       	mov	r8, r31
    2204:	f7 e0       	ldi	r31, 0x07	; 7
    2206:	9f 2e       	mov	r9, r31
    2208:	f0 2d       	mov	r31, r0
    220a:	0f 2e       	mov	r0, r31
    220c:	fe e9       	ldi	r31, 0x9E	; 158
    220e:	6f 2e       	mov	r6, r31
    2210:	f7 e0       	ldi	r31, 0x07	; 7
    2212:	7f 2e       	mov	r7, r31
    2214:	f0 2d       	mov	r31, r0
    2216:	00 e0       	ldi	r16, 0x00	; 0
    2218:	10 e0       	ldi	r17, 0x00	; 0
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    221a:	ff 8d       	ldd	r31, Y+31	; 0x1f
    221c:	4f 2e       	mov	r4, r31
    221e:	51 2c       	mov	r5, r1
    2220:	c2 01       	movw	r24, r4
    2222:	00 2e       	mov	r0, r16
    2224:	02 c0       	rjmp	.+4      	; 0x222a <gc_execute_line+0x868>
    2226:	95 95       	asr	r25
    2228:	87 95       	ror	r24
    222a:	0a 94       	dec	r0
    222c:	e2 f7       	brpl	.-8      	; 0x2226 <gc_execute_line+0x864>
    222e:	80 ff       	sbrs	r24, 0
    2230:	33 c0       	rjmp	.+102    	; 0x2298 <gc_execute_line+0x8d6>
          if (gc_block.values.l == 20) {
    2232:	28 a5       	ldd	r18, Y+40	; 0x28
    2234:	24 31       	cpi	r18, 0x14	; 20
    2236:	31 f5       	brne	.+76     	; 0x2284 <gc_execute_line+0x8c2>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    2238:	d3 01       	movw	r26, r6
    223a:	58 96       	adiw	r26, 0x18	; 24
    223c:	2d 91       	ld	r18, X+
    223e:	3d 91       	ld	r19, X+
    2240:	4d 91       	ld	r20, X+
    2242:	5c 91       	ld	r21, X
    2244:	5b 97       	sbiw	r26, 0x1b	; 27
    2246:	6d 91       	ld	r22, X+
    2248:	7d 91       	ld	r23, X+
    224a:	8d 91       	ld	r24, X+
    224c:	9c 91       	ld	r25, X
    224e:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    2252:	f4 01       	movw	r30, r8
    2254:	20 81       	ld	r18, Z
    2256:	31 81       	ldd	r19, Z+1	; 0x01
    2258:	42 81       	ldd	r20, Z+2	; 0x02
    225a:	53 81       	ldd	r21, Z+3	; 0x03
    225c:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    2260:	d5 01       	movw	r26, r10
    2262:	6d 93       	st	X+, r22
    2264:	7d 93       	st	X+, r23
    2266:	8d 93       	st	X+, r24
    2268:	9c 93       	st	X, r25
    226a:	13 97       	sbiw	r26, 0x03	; 3
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    226c:	02 30       	cpi	r16, 0x02	; 2
    226e:	a1 f4       	brne	.+40     	; 0x2298 <gc_execute_line+0x8d6>
    2270:	a7 01       	movw	r20, r14
    2272:	96 01       	movw	r18, r12
    2274:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    2278:	f5 01       	movw	r30, r10
    227a:	60 83       	st	Z, r22
    227c:	71 83       	std	Z+1, r23	; 0x01
    227e:	82 83       	std	Z+2, r24	; 0x02
    2280:	93 83       	std	Z+3, r25	; 0x03
    2282:	0a c0       	rjmp	.+20     	; 0x2298 <gc_execute_line+0x8d6>
          } else {
            // L2: Update coordinate system axis to programmed value.
            parameter_data[idx] = gc_block.values.xyz[idx]; 
    2284:	f4 01       	movw	r30, r8
    2286:	80 81       	ld	r24, Z
    2288:	91 81       	ldd	r25, Z+1	; 0x01
    228a:	a2 81       	ldd	r26, Z+2	; 0x02
    228c:	b3 81       	ldd	r27, Z+3	; 0x03
    228e:	f5 01       	movw	r30, r10
    2290:	80 83       	st	Z, r24
    2292:	91 83       	std	Z+1, r25	; 0x01
    2294:	a2 83       	std	Z+2, r26	; 0x02
    2296:	b3 83       	std	Z+3, r27	; 0x03
    2298:	0f 5f       	subi	r16, 0xFF	; 255
    229a:	1f 4f       	sbci	r17, 0xFF	; 255
    229c:	f4 e0       	ldi	r31, 0x04	; 4
    229e:	af 0e       	add	r10, r31
    22a0:	b1 1c       	adc	r11, r1
    22a2:	24 e0       	ldi	r18, 0x04	; 4
    22a4:	82 0e       	add	r8, r18
    22a6:	91 1c       	adc	r9, r1
    22a8:	34 e0       	ldi	r19, 0x04	; 4
    22aa:	63 0e       	add	r6, r19
    22ac:	71 1c       	adc	r7, r1
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    22ae:	03 30       	cpi	r16, 0x03	; 3
    22b0:	11 05       	cpc	r17, r1
    22b2:	09 f0       	breq	.+2      	; 0x22b6 <gc_execute_line+0x8f4>
    22b4:	b5 cf       	rjmp	.-150    	; 0x2220 <gc_execute_line+0x85e>
    22b6:	24 c6       	rjmp	.+3144   	; 0x2f00 <gc_execute_line+0x153e>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    22b8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    22ba:	88 23       	and	r24, r24
    22bc:	09 f4       	brne	.+2      	; 0x22c0 <gc_execute_line+0x8fe>
    22be:	01 c6       	rjmp	.+3074   	; 0x2ec2 <gc_execute_line+0x1500>
    22c0:	0f 2e       	mov	r0, r31
    22c2:	fe e9       	ldi	r31, 0x9E	; 158
    22c4:	cf 2e       	mov	r12, r31
    22c6:	f7 e0       	ldi	r31, 0x07	; 7
    22c8:	df 2e       	mov	r13, r31
    22ca:	f0 2d       	mov	r31, r0
    22cc:	de 01       	movw	r26, r28
    22ce:	11 96       	adiw	r26, 0x01	; 1
    22d0:	5d 01       	movw	r10, r26
    22d2:	0f 2e       	mov	r0, r31
    22d4:	f3 ef       	ldi	r31, 0xF3	; 243
    22d6:	ef 2e       	mov	r14, r31
    22d8:	f7 e0       	ldi	r31, 0x07	; 7
    22da:	ff 2e       	mov	r15, r31
    22dc:	f0 2d       	mov	r31, r0
    22de:	00 e0       	ldi	r16, 0x00	; 0
    22e0:	10 e0       	ldi	r17, 0x00	; 0
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    22e2:	88 2e       	mov	r8, r24
    22e4:	91 2c       	mov	r9, r1
    22e6:	c4 01       	movw	r24, r8
    22e8:	00 2e       	mov	r0, r16
    22ea:	02 c0       	rjmp	.+4      	; 0x22f0 <gc_execute_line+0x92e>
    22ec:	95 95       	asr	r25
    22ee:	87 95       	ror	r24
    22f0:	0a 94       	dec	r0
    22f2:	e2 f7       	brpl	.-8      	; 0x22ec <gc_execute_line+0x92a>
    22f4:	80 ff       	sbrs	r24, 0
    22f6:	32 c0       	rjmp	.+100    	; 0x235c <gc_execute_line+0x99a>
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
    22f8:	f5 01       	movw	r30, r10
    22fa:	20 81       	ld	r18, Z
    22fc:	31 81       	ldd	r19, Z+1	; 0x01
    22fe:	42 81       	ldd	r20, Z+2	; 0x02
    2300:	53 81       	ldd	r21, Z+3	; 0x03
    2302:	d6 01       	movw	r26, r12
    2304:	6d 91       	ld	r22, X+
    2306:	7d 91       	ld	r23, X+
    2308:	8d 91       	ld	r24, X+
    230a:	9c 91       	ld	r25, X
    230c:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    2310:	f7 01       	movw	r30, r14
    2312:	20 81       	ld	r18, Z
    2314:	31 81       	ldd	r19, Z+1	; 0x01
    2316:	42 81       	ldd	r20, Z+2	; 0x02
    2318:	53 81       	ldd	r21, Z+3	; 0x03
    231a:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    231e:	d7 01       	movw	r26, r14
    2320:	6d 93       	st	X+, r22
    2322:	7d 93       	st	X+, r23
    2324:	8d 93       	st	X+, r24
    2326:	9c 93       	st	X, r25
    2328:	13 97       	sbiw	r26, 0x03	; 3
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    232a:	02 30       	cpi	r16, 0x02	; 2
    232c:	09 f5       	brne	.+66     	; 0x2370 <gc_execute_line+0x9ae>
    232e:	00 0f       	add	r16, r16
    2330:	11 1f       	adc	r17, r17
    2332:	00 0f       	add	r16, r16
    2334:	11 1f       	adc	r17, r17
    2336:	0a 53       	subi	r16, 0x3A	; 58
    2338:	18 4f       	sbci	r17, 0xF8	; 248
    233a:	20 91 c2 07 	lds	r18, 0x07C2
    233e:	30 91 c3 07 	lds	r19, 0x07C3
    2342:	40 91 c4 07 	lds	r20, 0x07C4
    2346:	50 91 c5 07 	lds	r21, 0x07C5
    234a:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    234e:	f8 01       	movw	r30, r16
    2350:	65 a7       	std	Z+45, r22	; 0x2d
    2352:	76 a7       	std	Z+46, r23	; 0x2e
    2354:	87 a7       	std	Z+47, r24	; 0x2f
    2356:	90 ab       	std	Z+48, r25	; 0x30
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    2358:	1f a2       	std	Y+39, r1	; 0x27
    235a:	d2 c5       	rjmp	.+2980   	; 0x2f00 <gc_execute_line+0x153e>
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    235c:	f6 01       	movw	r30, r12
    235e:	80 8d       	ldd	r24, Z+24	; 0x18
    2360:	91 8d       	ldd	r25, Z+25	; 0x19
    2362:	a2 8d       	ldd	r26, Z+26	; 0x1a
    2364:	b3 8d       	ldd	r27, Z+27	; 0x1b
    2366:	f7 01       	movw	r30, r14
    2368:	80 83       	st	Z, r24
    236a:	91 83       	std	Z+1, r25	; 0x01
    236c:	a2 83       	std	Z+2, r26	; 0x02
    236e:	b3 83       	std	Z+3, r27	; 0x03
    2370:	0f 5f       	subi	r16, 0xFF	; 255
    2372:	1f 4f       	sbci	r17, 0xFF	; 255
    2374:	f4 e0       	ldi	r31, 0x04	; 4
    2376:	cf 0e       	add	r12, r31
    2378:	d1 1c       	adc	r13, r1
    237a:	24 e0       	ldi	r18, 0x04	; 4
    237c:	a2 0e       	add	r10, r18
    237e:	b1 1c       	adc	r11, r1
    2380:	34 e0       	ldi	r19, 0x04	; 4
    2382:	e3 0e       	add	r14, r19
    2384:	f1 1c       	adc	r15, r1
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    2386:	03 30       	cpi	r16, 0x03	; 3
    2388:	11 05       	cpc	r17, r1
    238a:	09 f0       	breq	.+2      	; 0x238e <gc_execute_line+0x9cc>
    238c:	ac cf       	rjmp	.-168    	; 0x22e6 <gc_execute_line+0x924>
    238e:	b7 c5       	rjmp	.+2926   	; 0x2efe <gc_execute_line+0x153c>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    2390:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2392:	83 30       	cpi	r24, 0x03	; 3
    2394:	09 f4       	brne	.+2      	; 0x2398 <gc_execute_line+0x9d6>
    2396:	87 c0       	rjmp	.+270    	; 0x24a6 <gc_execute_line+0xae4>
        if (axis_words) {
    2398:	9f 8d       	ldd	r25, Y+31	; 0x1f
    239a:	99 23       	and	r25, r25
    239c:	09 f4       	brne	.+2      	; 0x23a0 <gc_execute_line+0x9de>
    239e:	83 c0       	rjmp	.+262    	; 0x24a6 <gc_execute_line+0xae4>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    23a0:	40 90 ca 07 	lds	r4, 0x07CA
    23a4:	0f 2e       	mov	r0, r31
    23a6:	fe e9       	ldi	r31, 0x9E	; 158
    23a8:	cf 2e       	mov	r12, r31
    23aa:	f7 e0       	ldi	r31, 0x07	; 7
    23ac:	df 2e       	mov	r13, r31
    23ae:	f0 2d       	mov	r31, r0
    23b0:	0f 2e       	mov	r0, r31
    23b2:	f3 ef       	ldi	r31, 0xF3	; 243
    23b4:	ef 2e       	mov	r14, r31
    23b6:	f7 e0       	ldi	r31, 0x07	; 7
    23b8:	ff 2e       	mov	r15, r31
    23ba:	f0 2d       	mov	r31, r0
    23bc:	de 01       	movw	r26, r28
    23be:	11 96       	adiw	r26, 0x01	; 1
    23c0:	5d 01       	movw	r10, r26
    23c2:	00 e0       	ldi	r16, 0x00	; 0
    23c4:	10 e0       	ldi	r17, 0x00	; 0
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    23c6:	89 2e       	mov	r8, r25
    23c8:	91 2c       	mov	r9, r1
    23ca:	c4 01       	movw	r24, r8
    23cc:	00 2e       	mov	r0, r16
    23ce:	02 c0       	rjmp	.+4      	; 0x23d4 <gc_execute_line+0xa12>
    23d0:	95 95       	asr	r25
    23d2:	87 95       	ror	r24
    23d4:	0a 94       	dec	r0
    23d6:	e2 f7       	brpl	.-8      	; 0x23d0 <gc_execute_line+0xa0e>
    23d8:	80 fd       	sbrc	r24, 0
    23da:	0b c0       	rjmp	.+22     	; 0x23f2 <gc_execute_line+0xa30>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    23dc:	f6 01       	movw	r30, r12
    23de:	80 81       	ld	r24, Z
    23e0:	91 81       	ldd	r25, Z+1	; 0x01
    23e2:	a2 81       	ldd	r26, Z+2	; 0x02
    23e4:	b3 81       	ldd	r27, Z+3	; 0x03
    23e6:	f7 01       	movw	r30, r14
    23e8:	80 83       	st	Z, r24
    23ea:	91 83       	std	Z+1, r25	; 0x01
    23ec:	a2 83       	std	Z+2, r26	; 0x02
    23ee:	b3 83       	std	Z+3, r27	; 0x03
    23f0:	4b c0       	rjmp	.+150    	; 0x2488 <gc_execute_line+0xac6>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    23f2:	f7 e0       	ldi	r31, 0x07	; 7
    23f4:	5f 16       	cp	r5, r31
    23f6:	09 f4       	brne	.+2      	; 0x23fa <gc_execute_line+0xa38>
    23f8:	47 c0       	rjmp	.+142    	; 0x2488 <gc_execute_line+0xac6>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    23fa:	41 10       	cpse	r4, r1
    23fc:	34 c0       	rjmp	.+104    	; 0x2466 <gc_execute_line+0xaa4>
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
    23fe:	d6 01       	movw	r26, r12
    2400:	58 96       	adiw	r26, 0x18	; 24
    2402:	2d 91       	ld	r18, X+
    2404:	3d 91       	ld	r19, X+
    2406:	4d 91       	ld	r20, X+
    2408:	5c 91       	ld	r21, X
    240a:	5b 97       	sbiw	r26, 0x1b	; 27
    240c:	f5 01       	movw	r30, r10
    240e:	60 81       	ld	r22, Z
    2410:	71 81       	ldd	r23, Z+1	; 0x01
    2412:	82 81       	ldd	r24, Z+2	; 0x02
    2414:	93 81       	ldd	r25, Z+3	; 0x03
    2416:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    241a:	d7 01       	movw	r26, r14
    241c:	2d 91       	ld	r18, X+
    241e:	3d 91       	ld	r19, X+
    2420:	4d 91       	ld	r20, X+
    2422:	5c 91       	ld	r21, X
    2424:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    2428:	f7 01       	movw	r30, r14
    242a:	60 83       	st	Z, r22
    242c:	71 83       	std	Z+1, r23	; 0x01
    242e:	82 83       	std	Z+2, r24	; 0x02
    2430:	93 83       	std	Z+3, r25	; 0x03
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    2432:	02 30       	cpi	r16, 0x02	; 2
    2434:	49 f5       	brne	.+82     	; 0x2488 <gc_execute_line+0xac6>
    2436:	00 0f       	add	r16, r16
    2438:	11 1f       	adc	r17, r17
    243a:	00 0f       	add	r16, r16
    243c:	11 1f       	adc	r17, r17
    243e:	0a 53       	subi	r16, 0x3A	; 58
    2440:	18 4f       	sbci	r17, 0xF8	; 248
    2442:	20 91 c2 07 	lds	r18, 0x07C2
    2446:	30 91 c3 07 	lds	r19, 0x07C3
    244a:	40 91 c4 07 	lds	r20, 0x07C4
    244e:	50 91 c5 07 	lds	r21, 0x07C5
    2452:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    2456:	d8 01       	movw	r26, r16
    2458:	9d 96       	adiw	r26, 0x2d	; 45
    245a:	6d 93       	st	X+, r22
    245c:	7d 93       	st	X+, r23
    245e:	8d 93       	st	X+, r24
    2460:	9c 93       	st	X, r25
    2462:	d0 97       	sbiw	r26, 0x30	; 48
    2464:	20 c0       	rjmp	.+64     	; 0x24a6 <gc_execute_line+0xae4>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    2466:	f6 01       	movw	r30, r12
    2468:	20 81       	ld	r18, Z
    246a:	31 81       	ldd	r19, Z+1	; 0x01
    246c:	42 81       	ldd	r20, Z+2	; 0x02
    246e:	53 81       	ldd	r21, Z+3	; 0x03
    2470:	d7 01       	movw	r26, r14
    2472:	6d 91       	ld	r22, X+
    2474:	7d 91       	ld	r23, X+
    2476:	8d 91       	ld	r24, X+
    2478:	9c 91       	ld	r25, X
    247a:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    247e:	f7 01       	movw	r30, r14
    2480:	60 83       	st	Z, r22
    2482:	71 83       	std	Z+1, r23	; 0x01
    2484:	82 83       	std	Z+2, r24	; 0x02
    2486:	93 83       	std	Z+3, r25	; 0x03
    2488:	0f 5f       	subi	r16, 0xFF	; 255
    248a:	1f 4f       	sbci	r17, 0xFF	; 255
    248c:	f4 e0       	ldi	r31, 0x04	; 4
    248e:	cf 0e       	add	r12, r31
    2490:	d1 1c       	adc	r13, r1
    2492:	24 e0       	ldi	r18, 0x04	; 4
    2494:	e2 0e       	add	r14, r18
    2496:	f1 1c       	adc	r15, r1
    2498:	34 e0       	ldi	r19, 0x04	; 4
    249a:	a3 0e       	add	r10, r19
    249c:	b1 1c       	adc	r11, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    249e:	03 30       	cpi	r16, 0x03	; 3
    24a0:	11 05       	cpc	r17, r1
    24a2:	09 f0       	breq	.+2      	; 0x24a6 <gc_execute_line+0xae4>
    24a4:	92 cf       	rjmp	.-220    	; 0x23ca <gc_execute_line+0xa08>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    24a6:	85 e0       	ldi	r24, 0x05	; 5
    24a8:	58 16       	cp	r5, r24
    24aa:	a1 f0       	breq	.+40     	; 0x24d4 <gc_execute_line+0xb12>
    24ac:	97 e0       	ldi	r25, 0x07	; 7
    24ae:	59 16       	cp	r5, r25
    24b0:	f9 f0       	breq	.+62     	; 0x24f0 <gc_execute_line+0xb2e>
    24b2:	a3 e0       	ldi	r26, 0x03	; 3
    24b4:	5a 12       	cpse	r5, r26
    24b6:	21 c0       	rjmp	.+66     	; 0x24fa <gc_execute_line+0xb38>
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    24b8:	bf 8d       	ldd	r27, Y+31	; 0x1f
    24ba:	b1 11       	cpse	r27, r1
    24bc:	01 c0       	rjmp	.+2      	; 0x24c0 <gc_execute_line+0xafe>
    24be:	1e 8e       	std	Y+30, r1	; 0x1e
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    24c0:	be 01       	movw	r22, r28
    24c2:	63 5f       	subi	r22, 0xF3	; 243
    24c4:	7f 4f       	sbci	r23, 0xFF	; 255
    24c6:	86 e0       	ldi	r24, 0x06	; 6
    24c8:	0e 94 1a 27 	call	0x4e34	; 0x4e34 <settings_read_coord_data>
    24cc:	88 23       	and	r24, r24
    24ce:	09 f4       	brne	.+2      	; 0x24d2 <gc_execute_line+0xb10>
    24d0:	fa c4       	rjmp	.+2548   	; 0x2ec6 <gc_execute_line+0x1504>
    24d2:	13 c0       	rjmp	.+38     	; 0x24fa <gc_execute_line+0xb38>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    24d4:	ef 8d       	ldd	r30, Y+31	; 0x1f
    24d6:	e1 11       	cpse	r30, r1
    24d8:	01 c0       	rjmp	.+2      	; 0x24dc <gc_execute_line+0xb1a>
    24da:	1e 8e       	std	Y+30, r1	; 0x1e
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    24dc:	be 01       	movw	r22, r28
    24de:	63 5f       	subi	r22, 0xF3	; 243
    24e0:	7f 4f       	sbci	r23, 0xFF	; 255
    24e2:	87 e0       	ldi	r24, 0x07	; 7
    24e4:	0e 94 1a 27 	call	0x4e34	; 0x4e34 <settings_read_coord_data>
    24e8:	88 23       	and	r24, r24
    24ea:	09 f4       	brne	.+2      	; 0x24ee <gc_execute_line+0xb2c>
    24ec:	ee c4       	rjmp	.+2524   	; 0x2eca <gc_execute_line+0x1508>
    24ee:	05 c0       	rjmp	.+10     	; 0x24fa <gc_execute_line+0xb38>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    24f0:	80 91 c7 07 	lds	r24, 0x07C7
    24f4:	82 30       	cpi	r24, 0x02	; 2
    24f6:	08 f0       	brcs	.+2      	; 0x24fa <gc_execute_line+0xb38>
    24f8:	ea c4       	rjmp	.+2516   	; 0x2ece <gc_execute_line+0x150c>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    24fa:	10 91 c7 07 	lds	r17, 0x07C7
    24fe:	18 30       	cpi	r17, 0x08	; 8
    2500:	51 f4       	brne	.+20     	; 0x2516 <gc_execute_line+0xb54>
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    2502:	ff 8d       	ldd	r31, Y+31	; 0x1f
    2504:	ff 23       	and	r31, r31
    2506:	09 f4       	brne	.+2      	; 0x250a <gc_execute_line+0xb48>
    2508:	8e c2       	rjmp	.+1308   	; 0x2a26 <gc_execute_line+0x1064>
    250a:	1f a2       	std	Y+39, r1	; 0x27
    250c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    250e:	21 30       	cpi	r18, 0x01	; 1
    2510:	09 f0       	breq	.+2      	; 0x2514 <gc_execute_line+0xb52>
    2512:	df c4       	rjmp	.+2494   	; 0x2ed2 <gc_execute_line+0x1510>
    2514:	91 c2       	rjmp	.+1314   	; 0x2a38 <gc_execute_line+0x1076>
    2516:	1f a2       	std	Y+39, r1	; 0x27
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    }

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or 
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    2518:	3e 8d       	ldd	r19, Y+30	; 0x1e
    251a:	32 30       	cpi	r19, 0x02	; 2
    251c:	09 f0       	breq	.+2      	; 0x2520 <gc_execute_line+0xb5e>
    251e:	84 c2       	rjmp	.+1288   	; 0x2a28 <gc_execute_line+0x1066>
  
    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    2520:	11 11       	cpse	r17, r1
    2522:	05 c0       	rjmp	.+10     	; 0x252e <gc_execute_line+0xb6c>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    2524:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2526:	88 23       	and	r24, r24
    2528:	09 f4       	brne	.+2      	; 0x252c <gc_execute_line+0xb6a>
    252a:	f6 c4       	rjmp	.+2540   	; 0x2f18 <gc_execute_line+0x1556>
    252c:	85 c2       	rjmp	.+1290   	; 0x2a38 <gc_execute_line+0x1076>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    252e:	20 e0       	ldi	r18, 0x00	; 0
    2530:	30 e0       	ldi	r19, 0x00	; 0
    2532:	a9 01       	movw	r20, r18
    2534:	60 91 d1 07 	lds	r22, 0x07D1
    2538:	70 91 d2 07 	lds	r23, 0x07D2
    253c:	80 91 d3 07 	lds	r24, 0x07D3
    2540:	90 91 d4 07 	lds	r25, 0x07D4
    2544:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    2548:	88 23       	and	r24, r24
    254a:	09 f4       	brne	.+2      	; 0x254e <gc_execute_line+0xb8c>
    254c:	c4 c4       	rjmp	.+2440   	; 0x2ed6 <gc_execute_line+0x1514>
     
      switch (gc_block.modal.motion) {
    254e:	14 30       	cpi	r17, 0x04	; 4
    2550:	28 f4       	brcc	.+10     	; 0x255c <gc_execute_line+0xb9a>
    2552:	12 30       	cpi	r17, 0x02	; 2
    2554:	60 f4       	brcc	.+24     	; 0x256e <gc_execute_line+0xbac>
    2556:	11 30       	cpi	r17, 0x01	; 1
    2558:	29 f0       	breq	.+10     	; 0x2564 <gc_execute_line+0xba2>
    255a:	66 c2       	rjmp	.+1228   	; 0x2a28 <gc_execute_line+0x1066>
    255c:	18 30       	cpi	r17, 0x08	; 8
    255e:	08 f4       	brcc	.+2      	; 0x2562 <gc_execute_line+0xba0>
    2560:	20 c2       	rjmp	.+1088   	; 0x29a2 <gc_execute_line+0xfe0>
    2562:	62 c2       	rjmp	.+1220   	; 0x2a28 <gc_execute_line+0x1066>
        case MOTION_MODE_LINEAR: 
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    2564:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2566:	99 23       	and	r25, r25
    2568:	09 f4       	brne	.+2      	; 0x256c <gc_execute_line+0xbaa>
    256a:	d6 c4       	rjmp	.+2476   	; 0x2f18 <gc_execute_line+0x1556>
    256c:	65 c2       	rjmp	.+1226   	; 0x2a38 <gc_execute_line+0x1076>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    256e:	af 8d       	ldd	r26, Y+31	; 0x1f
    2570:	aa 23       	and	r26, r26
    2572:	09 f4       	brne	.+2      	; 0x2576 <gc_execute_line+0xbb4>
    2574:	b2 c4       	rjmp	.+2404   	; 0x2eda <gc_execute_line+0x1518>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    2576:	fc a1       	ldd	r31, Y+36	; 0x24
    2578:	ef 2f       	mov	r30, r31
    257a:	f0 e0       	ldi	r31, 0x00	; 0
    257c:	f9 a7       	std	Y+41, r31	; 0x29
    257e:	e8 a7       	std	Y+40, r30	; 0x28
    2580:	3d a1       	ldd	r19, Y+37	; 0x25
    2582:	23 2f       	mov	r18, r19
    2584:	30 e0       	ldi	r19, 0x00	; 0
    2586:	3b a7       	std	Y+43, r19	; 0x2b
    2588:	2a a7       	std	Y+42, r18	; 0x2a
    258a:	81 e0       	ldi	r24, 0x01	; 1
    258c:	90 e0       	ldi	r25, 0x00	; 0
    258e:	9c 01       	movw	r18, r24
    2590:	0d a0       	ldd	r0, Y+37	; 0x25
    2592:	02 c0       	rjmp	.+4      	; 0x2598 <gc_execute_line+0xbd6>
    2594:	22 0f       	add	r18, r18
    2596:	33 1f       	adc	r19, r19
    2598:	0a 94       	dec	r0
    259a:	e2 f7       	brpl	.-8      	; 0x2594 <gc_execute_line+0xbd2>
    259c:	0c a0       	ldd	r0, Y+36	; 0x24
    259e:	02 c0       	rjmp	.+4      	; 0x25a4 <gc_execute_line+0xbe2>
    25a0:	88 0f       	add	r24, r24
    25a2:	99 1f       	adc	r25, r25
    25a4:	0a 94       	dec	r0
    25a6:	e2 f7       	brpl	.-8      	; 0x25a0 <gc_execute_line+0xbde>
    25a8:	89 01       	movw	r16, r18
    25aa:	08 2b       	or	r16, r24
    25ac:	19 2b       	or	r17, r25
    25ae:	8a 2f       	mov	r24, r26
    25b0:	90 e0       	ldi	r25, 0x00	; 0
    25b2:	80 23       	and	r24, r16
    25b4:	91 23       	and	r25, r17
    25b6:	89 2b       	or	r24, r25
    25b8:	09 f4       	brne	.+2      	; 0x25bc <gc_execute_line+0xbfa>
    25ba:	91 c4       	rjmp	.+2338   	; 0x2ede <gc_execute_line+0x151c>
        
          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    25bc:	cf 01       	movw	r24, r30
    25be:	88 0f       	add	r24, r24
    25c0:	99 1f       	adc	r25, r25
    25c2:	88 0f       	add	r24, r24
    25c4:	99 1f       	adc	r25, r25
    25c6:	fc 01       	movw	r30, r24
    25c8:	ea 53       	subi	r30, 0x3A	; 58
    25ca:	f8 4f       	sbci	r31, 0xF8	; 248
    25cc:	dc 01       	movw	r26, r24
    25ce:	a9 57       	subi	r26, 0x79	; 121
    25d0:	b8 4f       	sbci	r27, 0xF8	; 248
    25d2:	57 96       	adiw	r26, 0x17	; 23
    25d4:	2d 91       	ld	r18, X+
    25d6:	3d 91       	ld	r19, X+
    25d8:	4d 91       	ld	r20, X+
    25da:	5c 91       	ld	r21, X
    25dc:	5a 97       	sbiw	r26, 0x1a	; 26
    25de:	65 a5       	ldd	r22, Z+45	; 0x2d
    25e0:	76 a5       	ldd	r23, Z+46	; 0x2e
    25e2:	87 a5       	ldd	r24, Z+47	; 0x2f
    25e4:	90 a9       	ldd	r25, Z+48	; 0x30
    25e6:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    25ea:	6b 01       	movw	r12, r22
    25ec:	7c 01       	movw	r14, r24
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    25ee:	8a a5       	ldd	r24, Y+42	; 0x2a
    25f0:	9b a5       	ldd	r25, Y+43	; 0x2b
    25f2:	88 0f       	add	r24, r24
    25f4:	99 1f       	adc	r25, r25
    25f6:	88 0f       	add	r24, r24
    25f8:	99 1f       	adc	r25, r25
    25fa:	fc 01       	movw	r30, r24
    25fc:	ea 53       	subi	r30, 0x3A	; 58
    25fe:	f8 4f       	sbci	r31, 0xF8	; 248
    2600:	dc 01       	movw	r26, r24
    2602:	a9 57       	subi	r26, 0x79	; 121
    2604:	b8 4f       	sbci	r27, 0xF8	; 248
    2606:	57 96       	adiw	r26, 0x17	; 23
    2608:	2d 91       	ld	r18, X+
    260a:	3d 91       	ld	r19, X+
    260c:	4d 91       	ld	r20, X+
    260e:	5c 91       	ld	r21, X
    2610:	5a 97       	sbiw	r26, 0x1a	; 26
    2612:	65 a5       	ldd	r22, Z+45	; 0x2d
    2614:	76 a5       	ldd	r23, Z+46	; 0x2e
    2616:	87 a5       	ldd	r24, Z+47	; 0x2f
    2618:	90 a9       	ldd	r25, Z+48	; 0x30
    261a:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    261e:	4b 01       	movw	r8, r22
    2620:	5c 01       	movw	r10, r24

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
    2622:	27 fe       	sbrs	r2, 7
    2624:	10 c1       	rjmp	.+544    	; 0x2846 <gc_execute_line+0xe84>
            bit_false(value_words,bit(WORD_R));
    2626:	e8 94       	clt
    2628:	27 f8       	bld	r2, 7

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
    262a:	20 91 f3 07 	lds	r18, 0x07F3
    262e:	30 91 f4 07 	lds	r19, 0x07F4
    2632:	40 91 f5 07 	lds	r20, 0x07F5
    2636:	50 91 f6 07 	lds	r21, 0x07F6
    263a:	60 91 9e 07 	lds	r22, 0x079E
    263e:	70 91 9f 07 	lds	r23, 0x079F
    2642:	80 91 a0 07 	lds	r24, 0x07A0
    2646:	90 91 a1 07 	lds	r25, 0x07A1
    264a:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    264e:	81 11       	cpse	r24, r1
    2650:	5d c4       	rjmp	.+2234   	; 0x2f0c <gc_execute_line+0x154a>
    2652:	20 91 f7 07 	lds	r18, 0x07F7
    2656:	30 91 f8 07 	lds	r19, 0x07F8
    265a:	40 91 f9 07 	lds	r20, 0x07F9
    265e:	50 91 fa 07 	lds	r21, 0x07FA
    2662:	60 91 a2 07 	lds	r22, 0x07A2
    2666:	70 91 a3 07 	lds	r23, 0x07A3
    266a:	80 91 a4 07 	lds	r24, 0x07A4
    266e:	90 91 a5 07 	lds	r25, 0x07A5
    2672:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    2676:	81 11       	cpse	r24, r1
    2678:	49 c4       	rjmp	.+2194   	; 0x2f0c <gc_execute_line+0x154a>
    267a:	20 91 fb 07 	lds	r18, 0x07FB
    267e:	30 91 fc 07 	lds	r19, 0x07FC
    2682:	40 91 fd 07 	lds	r20, 0x07FD
    2686:	50 91 fe 07 	lds	r21, 0x07FE
    268a:	60 91 a6 07 	lds	r22, 0x07A6
    268e:	70 91 a7 07 	lds	r23, 0x07A7
    2692:	80 91 a8 07 	lds	r24, 0x07A8
    2696:	90 91 a9 07 	lds	r25, 0x07A9
    269a:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    269e:	81 11       	cpse	r24, r1
    26a0:	35 c4       	rjmp	.+2154   	; 0x2f0c <gc_execute_line+0x154a>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    26a2:	81 e2       	ldi	r24, 0x21	; 33
    26a4:	3f c4       	rjmp	.+2174   	; 0x2f24 <gc_execute_line+0x1562>
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    26a6:	0a ee       	ldi	r16, 0xEA	; 234
    26a8:	17 e0       	ldi	r17, 0x07	; 7
    26aa:	23 e3       	ldi	r18, 0x33	; 51
    26ac:	33 e3       	ldi	r19, 0x33	; 51
    26ae:	4b ec       	ldi	r20, 0xCB	; 203
    26b0:	51 e4       	ldi	r21, 0x41	; 65
    26b2:	d8 01       	movw	r26, r16
    26b4:	6d 91       	ld	r22, X+
    26b6:	7d 91       	ld	r23, X+
    26b8:	8d 91       	ld	r24, X+
    26ba:	9c 91       	ld	r25, X
    26bc:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    26c0:	f8 01       	movw	r30, r16
    26c2:	60 83       	st	Z, r22
    26c4:	71 83       	std	Z+1, r23	; 0x01
    26c6:	82 83       	std	Z+2, r24	; 0x02
    26c8:	93 83       	std	Z+3, r25	; 0x03
                j = (y + (x * h_x2_div_d))/2       
            */      

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    26ca:	40 90 ea 07 	lds	r4, 0x07EA
    26ce:	50 90 eb 07 	lds	r5, 0x07EB
    26d2:	60 90 ec 07 	lds	r6, 0x07EC
    26d6:	70 90 ed 07 	lds	r7, 0x07ED
    26da:	20 e0       	ldi	r18, 0x00	; 0
    26dc:	30 e0       	ldi	r19, 0x00	; 0
    26de:	40 e8       	ldi	r20, 0x80	; 128
    26e0:	50 e4       	ldi	r21, 0x40	; 64
    26e2:	c3 01       	movw	r24, r6
    26e4:	b2 01       	movw	r22, r4
    26e6:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    26ea:	9b 01       	movw	r18, r22
    26ec:	ac 01       	movw	r20, r24
    26ee:	c3 01       	movw	r24, r6
    26f0:	b2 01       	movw	r22, r4
    26f2:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    26f6:	2b 01       	movw	r4, r22
    26f8:	3c 01       	movw	r6, r24
    26fa:	a7 01       	movw	r20, r14
    26fc:	96 01       	movw	r18, r12
    26fe:	c7 01       	movw	r24, r14
    2700:	b6 01       	movw	r22, r12
    2702:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    2706:	9b 01       	movw	r18, r22
    2708:	ac 01       	movw	r20, r24
    270a:	c3 01       	movw	r24, r6
    270c:	b2 01       	movw	r22, r4
    270e:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    2712:	2b 01       	movw	r4, r22
    2714:	3c 01       	movw	r6, r24
    2716:	a5 01       	movw	r20, r10
    2718:	94 01       	movw	r18, r8
    271a:	c5 01       	movw	r24, r10
    271c:	b4 01       	movw	r22, r8
    271e:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    2722:	9b 01       	movw	r18, r22
    2724:	ac 01       	movw	r20, r24
    2726:	c3 01       	movw	r24, r6
    2728:	b2 01       	movw	r22, r4
    272a:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    272e:	2b 01       	movw	r4, r22
    2730:	3c 01       	movw	r6, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2732:	20 e0       	ldi	r18, 0x00	; 0
    2734:	30 e0       	ldi	r19, 0x00	; 0
    2736:	a9 01       	movw	r20, r18
    2738:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    273c:	88 23       	and	r24, r24
    273e:	0c f4       	brge	.+2      	; 0x2742 <gc_execute_line+0xd80>
    2740:	d0 c3       	rjmp	.+1952   	; 0x2ee2 <gc_execute_line+0x1520>
    
            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    2742:	c3 01       	movw	r24, r6
    2744:	b2 01       	movw	r22, r4
    2746:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    274a:	2b 01       	movw	r4, r22
    274c:	3c 01       	movw	r6, r24
    274e:	a5 01       	movw	r20, r10
    2750:	94 01       	movw	r18, r8
    2752:	c7 01       	movw	r24, r14
    2754:	b6 01       	movw	r22, r12
    2756:	0e 94 05 2f 	call	0x5e0a	; 0x5e0a <hypot_f>
    275a:	9b 01       	movw	r18, r22
    275c:	ac 01       	movw	r20, r24
    275e:	c3 01       	movw	r24, r6
    2760:	b2 01       	movw	r22, r4
    2762:	90 58       	subi	r25, 0x80	; 128
    2764:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    2768:	2b 01       	movw	r4, r22
    276a:	3c 01       	movw	r6, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }  
    276c:	80 91 c7 07 	lds	r24, 0x07C7
    2770:	83 30       	cpi	r24, 0x03	; 3
    2772:	21 f4       	brne	.+8      	; 0x277c <gc_execute_line+0xdba>
    2774:	77 fa       	bst	r7, 7
    2776:	70 94       	com	r7
    2778:	77 f8       	bld	r7, 7
    277a:	70 94       	com	r7
            */  
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
            // even though it is advised against ever generating such circles in a single line of g-code. By 
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) { 
    277c:	80 91 ea 07 	lds	r24, 0x07EA
    2780:	90 91 eb 07 	lds	r25, 0x07EB
    2784:	a0 91 ec 07 	lds	r26, 0x07EC
    2788:	b0 91 ed 07 	lds	r27, 0x07ED
    278c:	8f 8f       	std	Y+31, r24	; 0x1f
    278e:	98 a3       	std	Y+32, r25	; 0x20
    2790:	a9 a3       	std	Y+33, r26	; 0x21
    2792:	ba a3       	std	Y+34, r27	; 0x22
    2794:	20 e0       	ldi	r18, 0x00	; 0
    2796:	30 e0       	ldi	r19, 0x00	; 0
    2798:	a9 01       	movw	r20, r18
    279a:	bc 01       	movw	r22, r24
    279c:	cd 01       	movw	r24, r26
    279e:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    27a2:	88 23       	and	r24, r24
    27a4:	8c f4       	brge	.+34     	; 0x27c8 <gc_execute_line+0xe06>
                h_x2_div_d = -h_x2_div_d; 
    27a6:	77 fa       	bst	r7, 7
    27a8:	70 94       	com	r7
    27aa:	77 f8       	bld	r7, 7
    27ac:	70 94       	com	r7
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    27ae:	8f 8d       	ldd	r24, Y+31	; 0x1f
    27b0:	98 a1       	ldd	r25, Y+32	; 0x20
    27b2:	a9 a1       	ldd	r26, Y+33	; 0x21
    27b4:	ba a1       	ldd	r27, Y+34	; 0x22
    27b6:	b0 58       	subi	r27, 0x80	; 128
    27b8:	80 93 ea 07 	sts	0x07EA, r24
    27bc:	90 93 eb 07 	sts	0x07EB, r25
    27c0:	a0 93 ec 07 	sts	0x07EC, r26
    27c4:	b0 93 ed 07 	sts	0x07ED, r27
            }        
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    27c8:	08 a5       	ldd	r16, Y+40	; 0x28
    27ca:	19 a5       	ldd	r17, Y+41	; 0x29
    27cc:	00 0f       	add	r16, r16
    27ce:	11 1f       	adc	r17, r17
    27d0:	00 0f       	add	r16, r16
    27d2:	11 1f       	adc	r17, r17
    27d4:	06 53       	subi	r16, 0x36	; 54
    27d6:	18 4f       	sbci	r17, 0xF8	; 248
    27d8:	a3 01       	movw	r20, r6
    27da:	92 01       	movw	r18, r4
    27dc:	c5 01       	movw	r24, r10
    27de:	b4 01       	movw	r22, r8
    27e0:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    27e4:	9b 01       	movw	r18, r22
    27e6:	ac 01       	movw	r20, r24
    27e8:	c7 01       	movw	r24, r14
    27ea:	b6 01       	movw	r22, r12
    27ec:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    27f0:	20 e0       	ldi	r18, 0x00	; 0
    27f2:	30 e0       	ldi	r19, 0x00	; 0
    27f4:	40 e0       	ldi	r20, 0x00	; 0
    27f6:	5f e3       	ldi	r21, 0x3F	; 63
    27f8:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    27fc:	d8 01       	movw	r26, r16
    27fe:	1b 96       	adiw	r26, 0x0b	; 11
    2800:	6d 93       	st	X+, r22
    2802:	7d 93       	st	X+, r23
    2804:	8d 93       	st	X+, r24
    2806:	9c 93       	st	X, r25
    2808:	1e 97       	sbiw	r26, 0x0e	; 14
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    280a:	0a a5       	ldd	r16, Y+42	; 0x2a
    280c:	1b a5       	ldd	r17, Y+43	; 0x2b
    280e:	00 0f       	add	r16, r16
    2810:	11 1f       	adc	r17, r17
    2812:	00 0f       	add	r16, r16
    2814:	11 1f       	adc	r17, r17
    2816:	06 53       	subi	r16, 0x36	; 54
    2818:	18 4f       	sbci	r17, 0xF8	; 248
    281a:	a3 01       	movw	r20, r6
    281c:	92 01       	movw	r18, r4
    281e:	c7 01       	movw	r24, r14
    2820:	b6 01       	movw	r22, r12
    2822:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    2826:	a5 01       	movw	r20, r10
    2828:	94 01       	movw	r18, r8
    282a:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    282e:	20 e0       	ldi	r18, 0x00	; 0
    2830:	30 e0       	ldi	r19, 0x00	; 0
    2832:	40 e0       	ldi	r20, 0x00	; 0
    2834:	5f e3       	ldi	r21, 0x3F	; 63
    2836:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    283a:	f8 01       	movw	r30, r16
    283c:	63 87       	std	Z+11, r22	; 0x0b
    283e:	74 87       	std	Z+12, r23	; 0x0c
    2840:	85 87       	std	Z+13, r24	; 0x0d
    2842:	96 87       	std	Z+14, r25	; 0x0e
    2844:	f9 c0       	rjmp	.+498    	; 0x2a38 <gc_execute_line+0x1076>
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2846:	fb a1       	ldd	r31, Y+35	; 0x23
    2848:	4f 2e       	mov	r4, r31
    284a:	51 2c       	mov	r5, r1
    284c:	04 21       	and	r16, r4
    284e:	15 21       	and	r17, r5
    2850:	01 2b       	or	r16, r17
    2852:	09 f4       	brne	.+2      	; 0x2856 <gc_execute_line+0xe94>
    2854:	48 c3       	rjmp	.+1680   	; 0x2ee6 <gc_execute_line+0x1524>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
    2856:	21 ef       	ldi	r18, 0xF1	; 241
    2858:	22 22       	and	r2, r18
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    285a:	80 91 c9 07 	lds	r24, 0x07C9
    285e:	81 30       	cpi	r24, 0x01	; 1
    2860:	49 f5       	brne	.+82     	; 0x28b4 <gc_execute_line+0xef2>
    2862:	0f 2e       	mov	r0, r31
    2864:	f5 ed       	ldi	r31, 0xD5	; 213
    2866:	6f 2e       	mov	r6, r31
    2868:	f7 e0       	ldi	r31, 0x07	; 7
    286a:	7f 2e       	mov	r7, r31
    286c:	f0 2d       	mov	r31, r0
    286e:	00 e0       	ldi	r16, 0x00	; 0
    2870:	10 e0       	ldi	r17, 0x00	; 0
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    2872:	c2 01       	movw	r24, r4
    2874:	00 2e       	mov	r0, r16
    2876:	02 c0       	rjmp	.+4      	; 0x287c <gc_execute_line+0xeba>
    2878:	95 95       	asr	r25
    287a:	87 95       	ror	r24
    287c:	0a 94       	dec	r0
    287e:	e2 f7       	brpl	.-8      	; 0x2878 <gc_execute_line+0xeb6>
    2880:	80 ff       	sbrs	r24, 0
    2882:	10 c0       	rjmp	.+32     	; 0x28a4 <gc_execute_line+0xee2>
    2884:	23 e3       	ldi	r18, 0x33	; 51
    2886:	33 e3       	ldi	r19, 0x33	; 51
    2888:	4b ec       	ldi	r20, 0xCB	; 203
    288a:	51 e4       	ldi	r21, 0x41	; 65
    288c:	d3 01       	movw	r26, r6
    288e:	6d 91       	ld	r22, X+
    2890:	7d 91       	ld	r23, X+
    2892:	8d 91       	ld	r24, X+
    2894:	9c 91       	ld	r25, X
    2896:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    289a:	f3 01       	movw	r30, r6
    289c:	60 83       	st	Z, r22
    289e:	71 83       	std	Z+1, r23	; 0x01
    28a0:	82 83       	std	Z+2, r24	; 0x02
    28a2:	93 83       	std	Z+3, r25	; 0x03
    28a4:	0f 5f       	subi	r16, 0xFF	; 255
    28a6:	1f 4f       	sbci	r17, 0xFF	; 255
    28a8:	f4 e0       	ldi	r31, 0x04	; 4
    28aa:	6f 0e       	add	r6, r31
    28ac:	71 1c       	adc	r7, r1
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    28ae:	03 30       	cpi	r16, 0x03	; 3
    28b0:	11 05       	cpc	r17, r1
    28b2:	f9 f6       	brne	.-66     	; 0x2872 <gc_execute_line+0xeb0>
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    28b4:	0a a5       	ldd	r16, Y+42	; 0x2a
    28b6:	1b a5       	ldd	r17, Y+43	; 0x2b
    28b8:	00 0f       	add	r16, r16
    28ba:	11 1f       	adc	r17, r17
    28bc:	00 0f       	add	r16, r16
    28be:	11 1f       	adc	r17, r17
    28c0:	06 53       	subi	r16, 0x36	; 54
    28c2:	18 4f       	sbci	r17, 0xF8	; 248
    28c4:	d8 01       	movw	r26, r16
    28c6:	1b 96       	adiw	r26, 0x0b	; 11
    28c8:	2d 91       	ld	r18, X+
    28ca:	3d 91       	ld	r19, X+
    28cc:	4d 91       	ld	r20, X+
    28ce:	5c 91       	ld	r21, X
    28d0:	1e 97       	sbiw	r26, 0x0e	; 14
    28d2:	c5 01       	movw	r24, r10
    28d4:	b4 01       	movw	r22, r8
    28d6:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    28da:	2b 01       	movw	r4, r22
    28dc:	3c 01       	movw	r6, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    28de:	88 a5       	ldd	r24, Y+40	; 0x28
    28e0:	99 a5       	ldd	r25, Y+41	; 0x29
    28e2:	88 0f       	add	r24, r24
    28e4:	99 1f       	adc	r25, r25
    28e6:	88 0f       	add	r24, r24
    28e8:	99 1f       	adc	r25, r25
    28ea:	fc 01       	movw	r30, r24
    28ec:	e6 53       	subi	r30, 0x36	; 54
    28ee:	f8 4f       	sbci	r31, 0xF8	; 248
    28f0:	5f 01       	movw	r10, r30
    28f2:	23 85       	ldd	r18, Z+11	; 0x0b
    28f4:	34 85       	ldd	r19, Z+12	; 0x0c
    28f6:	45 85       	ldd	r20, Z+13	; 0x0d
    28f8:	56 85       	ldd	r21, Z+14	; 0x0e
    28fa:	c7 01       	movw	r24, r14
    28fc:	b6 01       	movw	r22, r12
    28fe:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y); 
    2902:	a3 01       	movw	r20, r6
    2904:	92 01       	movw	r18, r4
    2906:	0e 94 05 2f 	call	0x5e0a	; 0x5e0a <hypot_f>
    290a:	6b 01       	movw	r12, r22
    290c:	7c 01       	movw	r14, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
    290e:	d8 01       	movw	r26, r16
    2910:	1b 96       	adiw	r26, 0x0b	; 11
    2912:	2d 91       	ld	r18, X+
    2914:	3d 91       	ld	r19, X+
    2916:	4d 91       	ld	r20, X+
    2918:	5c 91       	ld	r21, X
    291a:	1e 97       	sbiw	r26, 0x0e	; 14
    291c:	f5 01       	movw	r30, r10
    291e:	63 85       	ldd	r22, Z+11	; 0x0b
    2920:	74 85       	ldd	r23, Z+12	; 0x0c
    2922:	85 85       	ldd	r24, Z+13	; 0x0d
    2924:	96 85       	ldd	r25, Z+14	; 0x0e
    2926:	0e 94 05 2f 	call	0x5e0a	; 0x5e0a <hypot_f>
    292a:	4b 01       	movw	r8, r22
    292c:	5c 01       	movw	r10, r24
    292e:	60 93 ea 07 	sts	0x07EA, r22
    2932:	70 93 eb 07 	sts	0x07EB, r23
    2936:	80 93 ec 07 	sts	0x07EC, r24
    293a:	90 93 ed 07 	sts	0x07ED, r25
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    293e:	9b 01       	movw	r18, r22
    2940:	ac 01       	movw	r20, r24
    2942:	c7 01       	movw	r24, r14
    2944:	b6 01       	movw	r22, r12
    2946:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    294a:	6b 01       	movw	r12, r22
    294c:	7c 01       	movw	r14, r24
    294e:	e8 94       	clt
    2950:	f7 f8       	bld	r15, 7
            if (delta_r > 0.005) { 
    2952:	2a e0       	ldi	r18, 0x0A	; 10
    2954:	37 ed       	ldi	r19, 0xD7	; 215
    2956:	43 ea       	ldi	r20, 0xA3	; 163
    2958:	5b e3       	ldi	r21, 0x3B	; 59
    295a:	c7 01       	movw	r24, r14
    295c:	b6 01       	movw	r22, r12
    295e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    2962:	18 16       	cp	r1, r24
    2964:	0c f0       	brlt	.+2      	; 0x2968 <gc_execute_line+0xfa6>
    2966:	68 c0       	rjmp	.+208    	; 0x2a38 <gc_execute_line+0x1076>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    2968:	20 e0       	ldi	r18, 0x00	; 0
    296a:	30 e0       	ldi	r19, 0x00	; 0
    296c:	40 e0       	ldi	r20, 0x00	; 0
    296e:	5f e3       	ldi	r21, 0x3F	; 63
    2970:	c7 01       	movw	r24, r14
    2972:	b6 01       	movw	r22, r12
    2974:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    2978:	18 16       	cp	r1, r24
    297a:	0c f4       	brge	.+2      	; 0x297e <gc_execute_line+0xfbc>
    297c:	b6 c2       	rjmp	.+1388   	; 0x2eea <gc_execute_line+0x1528>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    297e:	2f e6       	ldi	r18, 0x6F	; 111
    2980:	32 e1       	ldi	r19, 0x12	; 18
    2982:	43 e8       	ldi	r20, 0x83	; 131
    2984:	5a e3       	ldi	r21, 0x3A	; 58
    2986:	c5 01       	movw	r24, r10
    2988:	b4 01       	movw	r22, r8
    298a:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    298e:	9b 01       	movw	r18, r22
    2990:	ac 01       	movw	r20, r24
    2992:	c7 01       	movw	r24, r14
    2994:	b6 01       	movw	r22, r12
    2996:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    299a:	18 16       	cp	r1, r24
    299c:	0c f4       	brge	.+2      	; 0x29a0 <gc_execute_line+0xfde>
    299e:	a7 c2       	rjmp	.+1358   	; 0x2eee <gc_execute_line+0x152c>
    29a0:	4b c0       	rjmp	.+150    	; 0x2a38 <gc_execute_line+0x1076>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    29a2:	ff 8d       	ldd	r31, Y+31	; 0x1f
    29a4:	ff 23       	and	r31, r31
    29a6:	09 f4       	brne	.+2      	; 0x29aa <gc_execute_line+0xfe8>
    29a8:	a4 c2       	rjmp	.+1352   	; 0x2ef2 <gc_execute_line+0x1530>

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
    29aa:	20 91 f3 07 	lds	r18, 0x07F3
    29ae:	30 91 f4 07 	lds	r19, 0x07F4
    29b2:	40 91 f5 07 	lds	r20, 0x07F5
    29b6:	50 91 f6 07 	lds	r21, 0x07F6
    29ba:	60 91 9e 07 	lds	r22, 0x079E
    29be:	70 91 9f 07 	lds	r23, 0x079F
    29c2:	80 91 a0 07 	lds	r24, 0x07A0
    29c6:	90 91 a1 07 	lds	r25, 0x07A1
    29ca:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    29ce:	81 11       	cpse	r24, r1
    29d0:	33 c0       	rjmp	.+102    	; 0x2a38 <gc_execute_line+0x1076>
    29d2:	20 91 f7 07 	lds	r18, 0x07F7
    29d6:	30 91 f8 07 	lds	r19, 0x07F8
    29da:	40 91 f9 07 	lds	r20, 0x07F9
    29de:	50 91 fa 07 	lds	r21, 0x07FA
    29e2:	60 91 a2 07 	lds	r22, 0x07A2
    29e6:	70 91 a3 07 	lds	r23, 0x07A3
    29ea:	80 91 a4 07 	lds	r24, 0x07A4
    29ee:	90 91 a5 07 	lds	r25, 0x07A5
    29f2:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    29f6:	81 11       	cpse	r24, r1
    29f8:	1f c0       	rjmp	.+62     	; 0x2a38 <gc_execute_line+0x1076>
    29fa:	20 91 fb 07 	lds	r18, 0x07FB
    29fe:	30 91 fc 07 	lds	r19, 0x07FC
    2a02:	40 91 fd 07 	lds	r20, 0x07FD
    2a06:	50 91 fe 07 	lds	r21, 0x07FE
    2a0a:	60 91 a6 07 	lds	r22, 0x07A6
    2a0e:	70 91 a7 07 	lds	r23, 0x07A7
    2a12:	80 91 a8 07 	lds	r24, 0x07A8
    2a16:	90 91 a9 07 	lds	r25, 0x07A9
    2a1a:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    2a1e:	81 11       	cpse	r24, r1
    2a20:	0b c0       	rjmp	.+22     	; 0x2a38 <gc_execute_line+0x1076>
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2a22:	81 e2       	ldi	r24, 0x21	; 33
    2a24:	7f c2       	rjmp	.+1278   	; 0x2f24 <gc_execute_line+0x1562>
    2a26:	1f a2       	std	Y+39, r1	; 0x27
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    2a28:	2e 8d       	ldd	r18, Y+30	; 0x1e
    2a2a:	21 11       	cpse	r18, r1
    2a2c:	05 c0       	rjmp	.+10     	; 0x2a38 <gc_execute_line+0x1076>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    2a2e:	3e ed       	ldi	r19, 0xDE	; 222
    2a30:	23 22       	and	r2, r19
    2a32:	3c ef       	ldi	r19, 0xFC	; 252
    2a34:	33 22       	and	r3, r19
    2a36:	04 c0       	rjmp	.+8      	; 0x2a40 <gc_execute_line+0x107e>
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    2a38:	8e ed       	ldi	r24, 0xDE	; 222
    2a3a:	28 22       	and	r2, r24
    2a3c:	80 ee       	ldi	r24, 0xE0	; 224
    2a3e:	38 22       	and	r3, r24
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2a40:	23 28       	or	r2, r3
    2a42:	09 f0       	breq	.+2      	; 0x2a46 <gc_execute_line+0x1084>
    2a44:	58 c2       	rjmp	.+1200   	; 0x2ef6 <gc_execute_line+0x1534>
     Assumes that all error-checking has been completed and no failure modes exist. We just
     need to update the state and execute the block according to the order-of-execution.
  */ 
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  gc_state.line_number = gc_block.values.n;
    2a46:	80 91 e2 07 	lds	r24, 0x07E2
    2a4a:	90 91 e3 07 	lds	r25, 0x07E3
    2a4e:	a0 91 e4 07 	lds	r26, 0x07E4
    2a52:	b0 91 e5 07 	lds	r27, 0x07E5
    2a56:	80 93 9a 07 	sts	0x079A, r24
    2a5a:	90 93 9b 07 	sts	0x079B, r25
    2a5e:	a0 93 9c 07 	sts	0x079C, r26
    2a62:	b0 93 9d 07 	sts	0x079D, r27
  
  // [1. Comments feedback ]:  NOT SUPPORTED
  
  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    2a66:	80 91 c8 07 	lds	r24, 0x07C8
    2a6a:	80 93 88 07 	sts	0x0788, r24
  
  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    2a6e:	80 91 d1 07 	lds	r24, 0x07D1
    2a72:	90 91 d2 07 	lds	r25, 0x07D2
    2a76:	a0 91 d3 07 	lds	r26, 0x07D3
    2a7a:	b0 91 d4 07 	lds	r27, 0x07D4
    2a7e:	80 93 95 07 	sts	0x0795, r24
    2a82:	90 93 96 07 	sts	0x0796, r25
    2a86:	a0 93 97 07 	sts	0x0797, r26
    2a8a:	b0 93 98 07 	sts	0x0798, r27

  // [4. Set spindle speed ]:
  if (gc_state.spindle_speed != gc_block.values.s) { 
    2a8e:	c0 90 ee 07 	lds	r12, 0x07EE
    2a92:	d0 90 ef 07 	lds	r13, 0x07EF
    2a96:	e0 90 f0 07 	lds	r14, 0x07F0
    2a9a:	f0 90 f1 07 	lds	r15, 0x07F1
    2a9e:	a7 01       	movw	r20, r14
    2aa0:	96 01       	movw	r18, r12
    2aa2:	60 91 91 07 	lds	r22, 0x0791
    2aa6:	70 91 92 07 	lds	r23, 0x0792
    2aaa:	80 91 93 07 	lds	r24, 0x0793
    2aae:	90 91 94 07 	lds	r25, 0x0794
    2ab2:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    2ab6:	88 23       	and	r24, r24
    2ab8:	c1 f0       	breq	.+48     	; 0x2aea <gc_execute_line+0x1128>
    // Update running spindle only if not in check mode and not already enabled.
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { spindle_run(gc_state.modal.spindle, gc_block.values.s); }
    2aba:	80 91 90 07 	lds	r24, 0x0790
    2abe:	88 23       	and	r24, r24
    2ac0:	21 f0       	breq	.+8      	; 0x2aca <gc_execute_line+0x1108>
    2ac2:	b7 01       	movw	r22, r14
    2ac4:	a6 01       	movw	r20, r12
    2ac6:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <spindle_run>
    gc_state.spindle_speed = gc_block.values.s; 
    2aca:	80 91 ee 07 	lds	r24, 0x07EE
    2ace:	90 91 ef 07 	lds	r25, 0x07EF
    2ad2:	a0 91 f0 07 	lds	r26, 0x07F0
    2ad6:	b0 91 f1 07 	lds	r27, 0x07F1
    2ada:	80 93 91 07 	sts	0x0791, r24
    2ade:	90 93 92 07 	sts	0x0792, r25
    2ae2:	a0 93 93 07 	sts	0x0793, r26
    2ae6:	b0 93 94 07 	sts	0x0794, r27
  }
    
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    2aea:	80 91 f2 07 	lds	r24, 0x07F2
    2aee:	80 93 99 07 	sts	0x0799, r24

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    2af2:	80 91 d0 07 	lds	r24, 0x07D0
    2af6:	90 91 90 07 	lds	r25, 0x0790
    2afa:	98 17       	cp	r25, r24
    2afc:	71 f0       	breq	.+28     	; 0x2b1a <gc_execute_line+0x1158>
    // Update spindle control and apply spindle speed when enabling it in this block.    
    spindle_run(gc_block.modal.spindle, gc_state.spindle_speed);
    2afe:	40 91 91 07 	lds	r20, 0x0791
    2b02:	50 91 92 07 	lds	r21, 0x0792
    2b06:	60 91 93 07 	lds	r22, 0x0793
    2b0a:	70 91 94 07 	lds	r23, 0x0794
    2b0e:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <spindle_run>
    gc_state.modal.spindle = gc_block.modal.spindle;    
    2b12:	80 91 d0 07 	lds	r24, 0x07D0
    2b16:	80 93 90 07 	sts	0x0790, r24
  }

  // [8. Coolant control ]:  
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    2b1a:	80 91 cf 07 	lds	r24, 0x07CF
    2b1e:	90 91 8f 07 	lds	r25, 0x078F
    2b22:	98 17       	cp	r25, r24
    2b24:	31 f0       	breq	.+12     	; 0x2b32 <gc_execute_line+0x1170>
    coolant_run(gc_block.modal.coolant);
    2b26:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <coolant_run>
    gc_state.modal.coolant = gc_block.modal.coolant;
    2b2a:	80 91 cf 07 	lds	r24, 0x07CF
    2b2e:	80 93 8f 07 	sts	0x078F, r24
  }
  
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    2b32:	80 91 c6 07 	lds	r24, 0x07C6
    2b36:	81 30       	cpi	r24, 0x01	; 1
    2b38:	51 f4       	brne	.+20     	; 0x2b4e <gc_execute_line+0x118c>
    2b3a:	60 91 e6 07 	lds	r22, 0x07E6
    2b3e:	70 91 e7 07 	lds	r23, 0x07E7
    2b42:	80 91 e8 07 	lds	r24, 0x07E8
    2b46:	90 91 e9 07 	lds	r25, 0x07E9
    2b4a:	0e 94 a4 0b 	call	0x1748	; 0x1748 <mc_dwell>
  
  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;  
    2b4e:	80 91 cb 07 	lds	r24, 0x07CB
    2b52:	80 93 8b 07 	sts	0x078B, r24

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    2b56:	80 91 c9 07 	lds	r24, 0x07C9
    2b5a:	80 93 89 07 	sts	0x0789, r24

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array. 
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    2b5e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2b60:	93 30       	cpi	r25, 0x03	; 3
    2b62:	f9 f4       	brne	.+62     	; 0x2ba2 <gc_execute_line+0x11e0>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    2b64:	80 91 cc 07 	lds	r24, 0x07CC
    2b68:	80 93 8c 07 	sts	0x078C, r24
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) { // G43.1
    2b6c:	81 30       	cpi	r24, 0x01	; 1
    2b6e:	89 f4       	brne	.+34     	; 0x2b92 <gc_execute_line+0x11d0>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    2b70:	80 91 fb 07 	lds	r24, 0x07FB
    2b74:	90 91 fc 07 	lds	r25, 0x07FC
    2b78:	a0 91 fd 07 	lds	r26, 0x07FD
    2b7c:	b0 91 fe 07 	lds	r27, 0x07FE
    2b80:	80 93 c2 07 	sts	0x07C2, r24
    2b84:	90 93 c3 07 	sts	0x07C3, r25
    2b88:	a0 93 c4 07 	sts	0x07C4, r26
    2b8c:	b0 93 c5 07 	sts	0x07C5, r27
    2b90:	08 c0       	rjmp	.+16     	; 0x2ba2 <gc_execute_line+0x11e0>
    } else { // G49
      gc_state.tool_length_offset = 0.0;
    2b92:	10 92 c2 07 	sts	0x07C2, r1
    2b96:	10 92 c3 07 	sts	0x07C3, r1
    2b9a:	10 92 c4 07 	sts	0x07C4, r1
    2b9e:	10 92 c5 07 	sts	0x07C5, r1
    }
  }
  
  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    2ba2:	80 91 cd 07 	lds	r24, 0x07CD
    2ba6:	90 91 8d 07 	lds	r25, 0x078D
    2baa:	98 17       	cp	r25, r24
    2bac:	59 f0       	breq	.+22     	; 0x2bc4 <gc_execute_line+0x1202>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    2bae:	80 93 8d 07 	sts	0x078D, r24
    memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    2bb2:	8c e0       	ldi	r24, 0x0C	; 12
    2bb4:	fe 01       	movw	r30, r28
    2bb6:	31 96       	adiw	r30, 0x01	; 1
    2bb8:	aa ea       	ldi	r26, 0xAA	; 170
    2bba:	b7 e0       	ldi	r27, 0x07	; 7
    2bbc:	01 90       	ld	r0, Z+
    2bbe:	0d 92       	st	X+, r0
    2bc0:	8a 95       	dec	r24
    2bc2:	e1 f7       	brne	.-8      	; 0x2bbc <gc_execute_line+0x11fa>
  }
  
  // [16. Set path control mode ]: NOT SUPPORTED
  
  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    2bc4:	80 91 ca 07 	lds	r24, 0x07CA
    2bc8:	80 93 8a 07 	sts	0x078A, r24
  
  // [18. Set retract mode ]: NOT SUPPORTED
    
  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    2bcc:	80 91 c6 07 	lds	r24, 0x07C6
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	fc 01       	movw	r30, r24
    2bd4:	32 97       	sbiw	r30, 0x02	; 2
    2bd6:	e8 30       	cpi	r30, 0x08	; 8
    2bd8:	f1 05       	cpc	r31, r1
    2bda:	08 f0       	brcs	.+2      	; 0x2bde <gc_execute_line+0x121c>
    2bdc:	55 c0       	rjmp	.+170    	; 0x2c88 <gc_execute_line+0x12c6>
    2bde:	e5 53       	subi	r30, 0x35	; 53
    2be0:	ff 4f       	sbci	r31, 0xFF	; 255
    2be2:	0c 94 d9 3f 	jmp	0x7fb2	; 0x7fb2 <__tablejump2__>
    case NON_MODAL_SET_COORDINATE_DATA:    
      settings_write_coord_data(coord_select,parameter_data);
    2be6:	be 01       	movw	r22, r28
    2be8:	63 5f       	subi	r22, 0xF3	; 243
    2bea:	7f 4f       	sbci	r23, 0xFF	; 255
    2bec:	8f a1       	ldd	r24, Y+39	; 0x27
    2bee:	0e 94 d8 25 	call	0x4bb0	; 0x4bb0 <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) { memcpy(gc_state.coord_system,parameter_data,sizeof(parameter_data)); }
    2bf2:	80 91 8d 07 	lds	r24, 0x078D
    2bf6:	af a1       	ldd	r26, Y+39	; 0x27
    2bf8:	8a 13       	cpse	r24, r26
    2bfa:	46 c0       	rjmp	.+140    	; 0x2c88 <gc_execute_line+0x12c6>
    2bfc:	8c e0       	ldi	r24, 0x0C	; 12
    2bfe:	fe 01       	movw	r30, r28
    2c00:	3d 96       	adiw	r30, 0x0d	; 13
    2c02:	aa ea       	ldi	r26, 0xAA	; 170
    2c04:	b7 e0       	ldi	r27, 0x07	; 7
    2c06:	01 90       	ld	r0, Z+
    2c08:	0d 92       	st	X+, r0
    2c0a:	8a 95       	dec	r24
    2c0c:	e1 f7       	brne	.-8      	; 0x2c06 <gc_execute_line+0x1244>
    2c0e:	3c c0       	rjmp	.+120    	; 0x2c88 <gc_execute_line+0x12c6>
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1: 
      // Move to intermediate position before going home. Obeys current coordinate system and offsets 
      // and absolute and incremental modes.
      if (axis_command) {
    2c10:	be 8d       	ldd	r27, Y+30	; 0x1e
    2c12:	bb 23       	and	r27, r27
    2c14:	49 f0       	breq	.+18     	; 0x2c28 <gc_execute_line+0x1266>
        #ifdef USE_LINE_NUMBERS
          mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
        #else
          mc_line(gc_block.values.xyz, -1.0, false);
    2c16:	20 e0       	ldi	r18, 0x00	; 0
    2c18:	40 e0       	ldi	r20, 0x00	; 0
    2c1a:	50 e0       	ldi	r21, 0x00	; 0
    2c1c:	60 e8       	ldi	r22, 0x80	; 128
    2c1e:	7f eb       	ldi	r23, 0xBF	; 191
    2c20:	83 ef       	ldi	r24, 0xF3	; 243
    2c22:	97 e0       	ldi	r25, 0x07	; 7
    2c24:	0e 94 52 08 	call	0x10a4	; 0x10a4 <mc_line>
        #endif
      }
      #ifdef USE_LINE_NUMBERS
        mc_line(parameter_data, -1.0, false, gc_state.line_number); 
      #else
        mc_line(parameter_data, -1.0, false); 
    2c28:	20 e0       	ldi	r18, 0x00	; 0
    2c2a:	40 e0       	ldi	r20, 0x00	; 0
    2c2c:	50 e0       	ldi	r21, 0x00	; 0
    2c2e:	60 e8       	ldi	r22, 0x80	; 128
    2c30:	7f eb       	ldi	r23, 0xBF	; 191
    2c32:	ce 01       	movw	r24, r28
    2c34:	0d 96       	adiw	r24, 0x0d	; 13
    2c36:	0e 94 52 08 	call	0x10a4	; 0x10a4 <mc_line>
      #endif
      memcpy(gc_state.position, parameter_data, sizeof(parameter_data));
    2c3a:	8c e0       	ldi	r24, 0x0C	; 12
    2c3c:	fe 01       	movw	r30, r28
    2c3e:	3d 96       	adiw	r30, 0x0d	; 13
    2c40:	ae e9       	ldi	r26, 0x9E	; 158
    2c42:	b7 e0       	ldi	r27, 0x07	; 7
    2c44:	01 90       	ld	r0, Z+
    2c46:	0d 92       	st	X+, r0
    2c48:	8a 95       	dec	r24
    2c4a:	e1 f7       	brne	.-8      	; 0x2c44 <gc_execute_line+0x1282>
      break;
    2c4c:	1d c0       	rjmp	.+58     	; 0x2c88 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_HOME_0: 
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    2c4e:	6e e9       	ldi	r22, 0x9E	; 158
    2c50:	77 e0       	ldi	r23, 0x07	; 7
    2c52:	86 e0       	ldi	r24, 0x06	; 6
    2c54:	0e 94 d8 25 	call	0x4bb0	; 0x4bb0 <settings_write_coord_data>
      break;
    2c58:	17 c0       	rjmp	.+46     	; 0x2c88 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    2c5a:	6e e9       	ldi	r22, 0x9E	; 158
    2c5c:	77 e0       	ldi	r23, 0x07	; 7
    2c5e:	87 e0       	ldi	r24, 0x07	; 7
    2c60:	0e 94 d8 25 	call	0x4bb0	; 0x4bb0 <settings_write_coord_data>
      break;
    2c64:	11 c0       	rjmp	.+34     	; 0x2c88 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    2c66:	8c e0       	ldi	r24, 0x0C	; 12
    2c68:	e3 ef       	ldi	r30, 0xF3	; 243
    2c6a:	f7 e0       	ldi	r31, 0x07	; 7
    2c6c:	a6 eb       	ldi	r26, 0xB6	; 182
    2c6e:	b7 e0       	ldi	r27, 0x07	; 7
    2c70:	01 90       	ld	r0, Z+
    2c72:	0d 92       	st	X+, r0
    2c74:	8a 95       	dec	r24
    2c76:	e1 f7       	brne	.-8      	; 0x2c70 <gc_execute_line+0x12ae>
      break;
    2c78:	07 c0       	rjmp	.+14     	; 0x2c88 <gc_execute_line+0x12c6>
    case NON_MODAL_RESET_COORDINATE_OFFSET: 
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    2c7a:	8c e0       	ldi	r24, 0x0C	; 12
    2c7c:	e6 eb       	ldi	r30, 0xB6	; 182
    2c7e:	f7 e0       	ldi	r31, 0x07	; 7
    2c80:	df 01       	movw	r26, r30
    2c82:	1d 92       	st	X+, r1
    2c84:	8a 95       	dec	r24
    2c86:	e9 f7       	brne	.-6      	; 0x2c82 <gc_execute_line+0x12c0>

  
  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes. 
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    2c88:	80 91 c7 07 	lds	r24, 0x07C7
    2c8c:	80 93 87 07 	sts	0x0787, r24
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    2c90:	88 30       	cpi	r24, 0x08	; 8
    2c92:	09 f4       	brne	.+2      	; 0x2c96 <gc_execute_line+0x12d4>
    2c94:	be c0       	rjmp	.+380    	; 0x2e12 <gc_execute_line+0x1450>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    2c96:	be 8d       	ldd	r27, Y+30	; 0x1e
    2c98:	b2 30       	cpi	r27, 0x02	; 2
    2c9a:	09 f0       	breq	.+2      	; 0x2c9e <gc_execute_line+0x12dc>
    2c9c:	ba c0       	rjmp	.+372    	; 0x2e12 <gc_execute_line+0x1450>
      switch (gc_state.modal.motion) {
    2c9e:	90 e0       	ldi	r25, 0x00	; 0
    2ca0:	88 30       	cpi	r24, 0x08	; 8
    2ca2:	91 05       	cpc	r25, r1
    2ca4:	08 f0       	brcs	.+2      	; 0x2ca8 <gc_execute_line+0x12e6>
    2ca6:	ac c0       	rjmp	.+344    	; 0x2e00 <gc_execute_line+0x143e>
    2ca8:	fc 01       	movw	r30, r24
    2caa:	ed 52       	subi	r30, 0x2D	; 45
    2cac:	ff 4f       	sbci	r31, 0xFF	; 255
    2cae:	0c 94 d9 3f 	jmp	0x7fb2	; 0x7fb2 <__tablejump2__>
        case MOTION_MODE_SEEK:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, -1.0, false);
    2cb2:	20 e0       	ldi	r18, 0x00	; 0
    2cb4:	40 e0       	ldi	r20, 0x00	; 0
    2cb6:	50 e0       	ldi	r21, 0x00	; 0
    2cb8:	60 e8       	ldi	r22, 0x80	; 128
    2cba:	7f eb       	ldi	r23, 0xBF	; 191
    2cbc:	83 ef       	ldi	r24, 0xF3	; 243
    2cbe:	97 e0       	ldi	r25, 0x07	; 7
    2cc0:	0e 94 52 08 	call	0x10a4	; 0x10a4 <mc_line>
          #endif
          break;
    2cc4:	9d c0       	rjmp	.+314    	; 0x2e00 <gc_execute_line+0x143e>
        case MOTION_MODE_LINEAR:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
    2cc6:	40 91 95 07 	lds	r20, 0x0795
    2cca:	50 91 96 07 	lds	r21, 0x0796
    2cce:	60 91 97 07 	lds	r22, 0x0797
    2cd2:	70 91 98 07 	lds	r23, 0x0798
    2cd6:	20 91 88 07 	lds	r18, 0x0788
    2cda:	83 ef       	ldi	r24, 0xF3	; 243
    2cdc:	97 e0       	ldi	r25, 0x07	; 7
    2cde:	0e 94 52 08 	call	0x10a4	; 0x10a4 <mc_line>
          #endif
          break;
    2ce2:	8e c0       	rjmp	.+284    	; 0x2e00 <gc_execute_line+0x143e>
        case MOTION_MODE_CW_ARC: 
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    2ce4:	c0 90 95 07 	lds	r12, 0x0795
    2ce8:	d0 90 96 07 	lds	r13, 0x0796
    2cec:	e0 90 97 07 	lds	r14, 0x0797
    2cf0:	f0 90 98 07 	lds	r15, 0x0798
    2cf4:	00 91 ea 07 	lds	r16, 0x07EA
    2cf8:	10 91 eb 07 	lds	r17, 0x07EB
    2cfc:	20 91 ec 07 	lds	r18, 0x07EC
    2d00:	30 91 ed 07 	lds	r19, 0x07ED
    2d04:	81 e0       	ldi	r24, 0x01	; 1
    2d06:	8f 93       	push	r24
    2d08:	ee a1       	ldd	r30, Y+38	; 0x26
    2d0a:	ef 93       	push	r30
    2d0c:	fd a1       	ldd	r31, Y+37	; 0x25
    2d0e:	ff 93       	push	r31
    2d10:	8c a0       	ldd	r8, Y+36	; 0x24
    2d12:	a0 90 88 07 	lds	r10, 0x0788
    2d16:	45 ed       	ldi	r20, 0xD5	; 213
    2d18:	57 e0       	ldi	r21, 0x07	; 7
    2d1a:	63 ef       	ldi	r22, 0xF3	; 243
    2d1c:	77 e0       	ldi	r23, 0x07	; 7
    2d1e:	8e e9       	ldi	r24, 0x9E	; 158
    2d20:	97 e0       	ldi	r25, 0x07	; 7
    2d22:	0e 94 88 08 	call	0x1110	; 0x1110 <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true); 
          #endif
          break;        
    2d26:	0f 90       	pop	r0
    2d28:	0f 90       	pop	r0
    2d2a:	0f 90       	pop	r0
    2d2c:	69 c0       	rjmp	.+210    	; 0x2e00 <gc_execute_line+0x143e>
        case MOTION_MODE_CCW_ARC:
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    2d2e:	c0 90 95 07 	lds	r12, 0x0795
    2d32:	d0 90 96 07 	lds	r13, 0x0796
    2d36:	e0 90 97 07 	lds	r14, 0x0797
    2d3a:	f0 90 98 07 	lds	r15, 0x0798
    2d3e:	00 91 ea 07 	lds	r16, 0x07EA
    2d42:	10 91 eb 07 	lds	r17, 0x07EB
    2d46:	20 91 ec 07 	lds	r18, 0x07EC
    2d4a:	30 91 ed 07 	lds	r19, 0x07ED
    2d4e:	1f 92       	push	r1
    2d50:	8e a1       	ldd	r24, Y+38	; 0x26
    2d52:	8f 93       	push	r24
    2d54:	9d a1       	ldd	r25, Y+37	; 0x25
    2d56:	9f 93       	push	r25
    2d58:	8c a0       	ldd	r8, Y+36	; 0x24
    2d5a:	a0 90 88 07 	lds	r10, 0x0788
    2d5e:	45 ed       	ldi	r20, 0xD5	; 213
    2d60:	57 e0       	ldi	r21, 0x07	; 7
    2d62:	63 ef       	ldi	r22, 0xF3	; 243
    2d64:	77 e0       	ldi	r23, 0x07	; 7
    2d66:	8e e9       	ldi	r24, 0x9E	; 158
    2d68:	97 e0       	ldi	r25, 0x07	; 7
    2d6a:	0e 94 88 08 	call	0x1110	; 0x1110 <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false); 
          #endif
          break;
    2d6e:	0f 90       	pop	r0
    2d70:	0f 90       	pop	r0
    2d72:	0f 90       	pop	r0
    2d74:	45 c0       	rjmp	.+138    	; 0x2e00 <gc_execute_line+0x143e>
          // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
          // upon a successful probing cycle, the machine position and the returned value should be the same.
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false);
    2d76:	40 91 95 07 	lds	r20, 0x0795
    2d7a:	50 91 96 07 	lds	r21, 0x0796
    2d7e:	60 91 97 07 	lds	r22, 0x0797
    2d82:	70 91 98 07 	lds	r23, 0x0798
    2d86:	e1 2c       	mov	r14, r1
    2d88:	00 e0       	ldi	r16, 0x00	; 0
    2d8a:	20 91 88 07 	lds	r18, 0x0788
    2d8e:	83 ef       	ldi	r24, 0xF3	; 243
    2d90:	97 e0       	ldi	r25, 0x07	; 7
    2d92:	0e 94 1d 0c 	call	0x183a	; 0x183a <mc_probe_cycle>
          #endif
          break;
    2d96:	34 c0       	rjmp	.+104    	; 0x2e00 <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true);
    2d98:	40 91 95 07 	lds	r20, 0x0795
    2d9c:	50 91 96 07 	lds	r21, 0x0796
    2da0:	60 91 97 07 	lds	r22, 0x0797
    2da4:	70 91 98 07 	lds	r23, 0x0798
    2da8:	ee 24       	eor	r14, r14
    2daa:	e3 94       	inc	r14
    2dac:	00 e0       	ldi	r16, 0x00	; 0
    2dae:	20 91 88 07 	lds	r18, 0x0788
    2db2:	83 ef       	ldi	r24, 0xF3	; 243
    2db4:	97 e0       	ldi	r25, 0x07	; 7
    2db6:	0e 94 1d 0c 	call	0x183a	; 0x183a <mc_probe_cycle>
          #endif
          break;
    2dba:	22 c0       	rjmp	.+68     	; 0x2e00 <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_AWAY:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false);
    2dbc:	40 91 95 07 	lds	r20, 0x0795
    2dc0:	50 91 96 07 	lds	r21, 0x0796
    2dc4:	60 91 97 07 	lds	r22, 0x0797
    2dc8:	70 91 98 07 	lds	r23, 0x0798
    2dcc:	e1 2c       	mov	r14, r1
    2dce:	01 e0       	ldi	r16, 0x01	; 1
    2dd0:	20 91 88 07 	lds	r18, 0x0788
    2dd4:	83 ef       	ldi	r24, 0xF3	; 243
    2dd6:	97 e0       	ldi	r25, 0x07	; 7
    2dd8:	0e 94 1d 0c 	call	0x183a	; 0x183a <mc_probe_cycle>
          #endif
          break;
    2ddc:	11 c0       	rjmp	.+34     	; 0x2e00 <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true, gc_state.line_number);
          #else        
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true);
    2dde:	40 91 95 07 	lds	r20, 0x0795
    2de2:	50 91 96 07 	lds	r21, 0x0796
    2de6:	60 91 97 07 	lds	r22, 0x0797
    2dea:	70 91 98 07 	lds	r23, 0x0798
    2dee:	ee 24       	eor	r14, r14
    2df0:	e3 94       	inc	r14
    2df2:	01 e0       	ldi	r16, 0x01	; 1
    2df4:	20 91 88 07 	lds	r18, 0x0788
    2df8:	83 ef       	ldi	r24, 0xF3	; 243
    2dfa:	97 e0       	ldi	r25, 0x07	; 7
    2dfc:	0e 94 1d 0c 	call	0x183a	; 0x183a <mc_probe_cycle>
      }
    
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    2e00:	8c e0       	ldi	r24, 0x0C	; 12
    2e02:	e3 ef       	ldi	r30, 0xF3	; 243
    2e04:	f7 e0       	ldi	r31, 0x07	; 7
    2e06:	ae e9       	ldi	r26, 0x9E	; 158
    2e08:	b7 e0       	ldi	r27, 0x07	; 7
    2e0a:	01 90       	ld	r0, Z+
    2e0c:	0d 92       	st	X+, r0
    2e0e:	8a 95       	dec	r24
    2e10:	e1 f7       	brne	.-8      	; 0x2e0a <gc_execute_line+0x1448>
  }
  
  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may 
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    2e12:	80 91 ce 07 	lds	r24, 0x07CE
    2e16:	80 93 8e 07 	sts	0x078E, r24
  if (gc_state.modal.program_flow) { 
    2e1a:	88 23       	and	r24, r24
    2e1c:	09 f4       	brne	.+2      	; 0x2e20 <gc_execute_line+0x145e>
    2e1e:	6d c0       	rjmp	.+218    	; 0x2efa <gc_execute_line+0x1538>
    protocol_buffer_synchronize(); // Finish all remaining buffered motions. Program paused when complete.
    2e20:	0e 94 f0 1a 	call	0x35e0	; 0x35e0 <protocol_buffer_synchronize>

    sys.suspend = true;
    2e24:	81 e0       	ldi	r24, 0x01	; 1
    2e26:	80 93 69 07 	sts	0x0769, r24
    protocol_execute_realtime(); // Suspend execution. For both program pause or program end.
    2e2a:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
  
    // If complete, reset to reload defaults (G92.2,G54,G17,G90,G94,M48,G40,M5,M9). Otherwise,
    // re-enable program flow after pause complete, where cycle start will resume the program.
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    2e2e:	80 91 8e 07 	lds	r24, 0x078E
    2e32:	82 30       	cpi	r24, 0x02	; 2
    2e34:	21 f4       	brne	.+8      	; 0x2e3e <gc_execute_line+0x147c>
    2e36:	0e 94 a5 0c 	call	0x194a	; 0x194a <mc_reset>
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2e3a:	80 e0       	ldi	r24, 0x00	; 0
    2e3c:	73 c0       	rjmp	.+230    	; 0x2f24 <gc_execute_line+0x1562>
    protocol_execute_realtime(); // Suspend execution. For both program pause or program end.
  
    // If complete, reset to reload defaults (G92.2,G54,G17,G90,G94,M48,G40,M5,M9). Otherwise,
    // re-enable program flow after pause complete, where cycle start will resume the program.
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
    2e3e:	10 92 8e 07 	sts	0x078E, r1
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2e42:	80 e0       	ldi	r24, 0x00	; 0
    2e44:	6f c0       	rjmp	.+222    	; 0x2f24 <gc_execute_line+0x1562>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2e46:	81 e0       	ldi	r24, 0x01	; 1
    2e48:	6d c0       	rjmp	.+218    	; 0x2f24 <gc_execute_line+0x1562>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2e4a:	82 e0       	ldi	r24, 0x02	; 2
    2e4c:	6b c0       	rjmp	.+214    	; 0x2f24 <gc_execute_line+0x1562>
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    2e4e:	84 e1       	ldi	r24, 0x14	; 20
    2e50:	69 c0       	rjmp	.+210    	; 0x2f24 <gc_execute_line+0x1562>
        switch(int_value) {
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2e52:	88 e1       	ldi	r24, 0x18	; 24
    2e54:	67 c0       	rjmp	.+206    	; 0x2f24 <gc_execute_line+0x1562>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
    2e56:	84 e1       	ldi	r24, 0x14	; 20
    2e58:	65 c0       	rjmp	.+202    	; 0x2f24 <gc_execute_line+0x1562>
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
    2e5a:	84 e1       	ldi	r24, 0x14	; 20
    2e5c:	63 c0       	rjmp	.+198    	; 0x2f24 <gc_execute_line+0x1562>
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G92.x command]
    2e5e:	84 e1       	ldi	r24, 0x14	; 20
    2e60:	61 c0       	rjmp	.+194    	; 0x2f24 <gc_execute_line+0x1562>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2e62:	88 e1       	ldi	r24, 0x18	; 24
    2e64:	5f c0       	rjmp	.+190    	; 0x2f24 <gc_execute_line+0x1562>
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    2e66:	84 e1       	ldi	r24, 0x14	; 20
    2e68:	5d c0       	rjmp	.+186    	; 0x2f24 <gc_execute_line+0x1562>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    2e6a:	88 e1       	ldi	r24, 0x18	; 24
    2e6c:	5b c0       	rjmp	.+182    	; 0x2f24 <gc_execute_line+0x1562>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    2e6e:	84 e1       	ldi	r24, 0x14	; 20
    2e70:	59 c0       	rjmp	.+178    	; 0x2f24 <gc_execute_line+0x1562>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2e72:	87 e1       	ldi	r24, 0x17	; 23
    2e74:	57 c0       	rjmp	.+174    	; 0x2f24 <gc_execute_line+0x1562>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2e76:	85 e1       	ldi	r24, 0x15	; 21
    2e78:	55 c0       	rjmp	.+170    	; 0x2f24 <gc_execute_line+0x1562>
        break;
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    2e7a:	87 e1       	ldi	r24, 0x17	; 23
    2e7c:	53 c0       	rjmp	.+166    	; 0x2f24 <gc_execute_line+0x1562>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    2e7e:	84 e1       	ldi	r24, 0x14	; 20
    2e80:	51 c0       	rjmp	.+162    	; 0x2f24 <gc_execute_line+0x1562>
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2e82:	85 e1       	ldi	r24, 0x15	; 21
    2e84:	4f c0       	rjmp	.+158    	; 0x2f24 <gc_execute_line+0x1562>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2e86:	84 e1       	ldi	r24, 0x14	; 20
    2e88:	4d c0       	rjmp	.+154    	; 0x2f24 <gc_execute_line+0x1562>
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    2e8a:	89 e1       	ldi	r24, 0x19	; 25
    2e8c:	4b c0       	rjmp	.+150    	; 0x2f24 <gc_execute_line+0x1562>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    2e8e:	84 e0       	ldi	r24, 0x04	; 4
    2e90:	49 c0       	rjmp	.+146    	; 0x2f24 <gc_execute_line+0x1562>
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    2e92:	8b e1       	ldi	r24, 0x1B	; 27
    2e94:	47 c0       	rjmp	.+142    	; 0x2f24 <gc_execute_line+0x1562>
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    2e96:	86 e1       	ldi	r24, 0x16	; 22
    2e98:	45 c0       	rjmp	.+138    	; 0x2f24 <gc_execute_line+0x1562>
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2e9a:	8c e1       	ldi	r24, 0x1C	; 28
    2e9c:	43 c0       	rjmp	.+134    	; 0x2f24 <gc_execute_line+0x1562>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    2e9e:	85 e2       	ldi	r24, 0x25	; 37
    2ea0:	41 c0       	rjmp	.+130    	; 0x2f24 <gc_execute_line+0x1562>
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2ea2:	8d e1       	ldi	r24, 0x1D	; 29
    2ea4:	3f c0       	rjmp	.+126    	; 0x2f24 <gc_execute_line+0x1562>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2ea6:	87 e0       	ldi	r24, 0x07	; 7
    2ea8:	3d c0       	rjmp	.+122    	; 0x2f24 <gc_execute_line+0x1562>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2eaa:	8a e1       	ldi	r24, 0x1A	; 26
    2eac:	3b c0       	rjmp	.+118    	; 0x2f24 <gc_execute_line+0x1562>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    2eae:	8c e1       	ldi	r24, 0x1C	; 28
    2eb0:	39 c0       	rjmp	.+114    	; 0x2f24 <gc_execute_line+0x1562>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2eb2:	8d e1       	ldi	r24, 0x1D	; 29
    2eb4:	37 c0       	rjmp	.+110    	; 0x2f24 <gc_execute_line+0x1562>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    2eb6:	84 e1       	ldi	r24, 0x14	; 20
    2eb8:	35 c0       	rjmp	.+106    	; 0x2f24 <gc_execute_line+0x1562>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    2eba:	84 e1       	ldi	r24, 0x14	; 20
    2ebc:	33 c0       	rjmp	.+102    	; 0x2f24 <gc_execute_line+0x1562>
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    2ebe:	87 e0       	ldi	r24, 0x07	; 7
    2ec0:	31 c0       	rjmp	.+98     	; 0x2f24 <gc_execute_line+0x1562>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2ec2:	8a e1       	ldi	r24, 0x1A	; 26
    2ec4:	2f c0       	rjmp	.+94     	; 0x2f24 <gc_execute_line+0x1562>
      switch (gc_block.non_modal_command) {        
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2ec6:	87 e0       	ldi	r24, 0x07	; 7
    2ec8:	2d c0       	rjmp	.+90     	; 0x2f24 <gc_execute_line+0x1562>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2eca:	87 e0       	ldi	r24, 0x07	; 7
    2ecc:	2b c0       	rjmp	.+86     	; 0x2f24 <gc_execute_line+0x1562>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    2ece:	8e e1       	ldi	r24, 0x1E	; 30
    2ed0:	29 c0       	rjmp	.+82     	; 0x2f24 <gc_execute_line+0x1562>
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    2ed2:	8f e1       	ldi	r24, 0x1F	; 31
    2ed4:	27 c0       	rjmp	.+78     	; 0x2f24 <gc_execute_line+0x1562>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2ed6:	86 e1       	ldi	r24, 0x16	; 22
    2ed8:	25 c0       	rjmp	.+74     	; 0x2f24 <gc_execute_line+0x1562>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2eda:	8a e1       	ldi	r24, 0x1A	; 26
    2edc:	23 c0       	rjmp	.+70     	; 0x2f24 <gc_execute_line+0x1562>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    2ede:	80 e2       	ldi	r24, 0x20	; 32
    2ee0:	21 c0       	rjmp	.+66     	; 0x2f24 <gc_execute_line+0x1562>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2ee2:	82 e2       	ldi	r24, 0x22	; 34
    2ee4:	1f c0       	rjmp	.+62     	; 0x2f24 <gc_execute_line+0x1562>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2ee6:	83 e2       	ldi	r24, 0x23	; 35
    2ee8:	1d c0       	rjmp	.+58     	; 0x2f24 <gc_execute_line+0x1562>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) { 
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    2eea:	81 e2       	ldi	r24, 0x21	; 33
    2eec:	1b c0       	rjmp	.+54     	; 0x2f24 <gc_execute_line+0x1562>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    2eee:	81 e2       	ldi	r24, 0x21	; 33
    2ef0:	19 c0       	rjmp	.+50     	; 0x2f24 <gc_execute_line+0x1562>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2ef2:	8a e1       	ldi	r24, 0x1A	; 26
    2ef4:	17 c0       	rjmp	.+46     	; 0x2f24 <gc_execute_line+0x1562>

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2ef6:	84 e2       	ldi	r24, 0x24	; 36
    2ef8:	15 c0       	rjmp	.+42     	; 0x2f24 <gc_execute_line+0x1562>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2efa:	80 e0       	ldi	r24, 0x00	; 0
    2efc:	13 c0       	rjmp	.+38     	; 0x2f24 <gc_execute_line+0x1562>
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    2efe:	1f a2       	std	Y+39, r1	; 0x27
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    2f00:	10 91 c7 07 	lds	r17, 0x07C7
    2f04:	18 30       	cpi	r17, 0x08	; 8
    2f06:	09 f0       	breq	.+2      	; 0x2f0a <gc_execute_line+0x1548>
    2f08:	07 cb       	rjmp	.-2546   	; 0x2518 <gc_execute_line+0xb56>
    2f0a:	00 cb       	rjmp	.-2560   	; 0x250c <gc_execute_line+0xb4a>
          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    2f0c:	80 91 c9 07 	lds	r24, 0x07C9
    2f10:	81 30       	cpi	r24, 0x01	; 1
    2f12:	09 f0       	breq	.+2      	; 0x2f16 <gc_execute_line+0x1554>
    2f14:	da cb       	rjmp	.-2124   	; 0x26ca <gc_execute_line+0xd08>
    2f16:	c7 cb       	rjmp	.-2162   	; 0x26a6 <gc_execute_line+0xce4>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    2f18:	ae ed       	ldi	r26, 0xDE	; 222
    2f1a:	2a 22       	and	r2, r26
    2f1c:	ac ef       	ldi	r26, 0xFC	; 252
    2f1e:	3a 22       	and	r3, r26
    2f20:	1e 8e       	std	Y+30, r1	; 0x1e
    2f22:	8e cd       	rjmp	.-1252   	; 0x2a40 <gc_execute_line+0x107e>
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
}
    2f24:	ab 96       	adiw	r28, 0x2b	; 43
    2f26:	0f b6       	in	r0, 0x3f	; 63
    2f28:	f8 94       	cli
    2f2a:	de bf       	out	0x3e, r29	; 62
    2f2c:	0f be       	out	0x3f, r0	; 63
    2f2e:	cd bf       	out	0x3d, r28	; 61
    2f30:	df 91       	pop	r29
    2f32:	cf 91       	pop	r28
    2f34:	1f 91       	pop	r17
    2f36:	0f 91       	pop	r16
    2f38:	ff 90       	pop	r15
    2f3a:	ef 90       	pop	r14
    2f3c:	df 90       	pop	r13
    2f3e:	cf 90       	pop	r12
    2f40:	bf 90       	pop	r11
    2f42:	af 90       	pop	r10
    2f44:	9f 90       	pop	r9
    2f46:	8f 90       	pop	r8
    2f48:	7f 90       	pop	r7
    2f4a:	6f 90       	pop	r6
    2f4c:	5f 90       	pop	r5
    2f4e:	4f 90       	pop	r4
    2f50:	3f 90       	pop	r3
    2f52:	2f 90       	pop	r2
    2f54:	08 95       	ret

00002f56 <spindle_stop>:
    TCCRA_REGISTER &= ~(1<<COMB_BIT); // Disable PWM. Output voltage is zero.
    #ifndef CPU_MAP_ATMEGA328P 
      SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low.
    #endif
  #else
    SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low.
    2f56:	47 98       	cbi	0x08, 7	; 8
    2f58:	08 95       	ret

00002f5a <spindle_init>:
    SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    #ifndef CPU_MAP_ATMEGA328P 
      SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    #endif     
  #else
    SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    2f5a:	3f 9a       	sbi	0x07, 7	; 7
  #endif
  #ifdef SPINDLE_DIRECTION_PRESENT
  SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
  #endif
  spindle_stop();
    2f5c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <spindle_stop>
    2f60:	08 95       	ret

00002f62 <spindle_set_state>:


void spindle_set_state(uint8_t state, float rpm)
{
  // Halt or set spindle direction and rpm. 
  if (state == SPINDLE_DISABLE) {
    2f62:	81 11       	cpse	r24, r1
    2f64:	03 c0       	rjmp	.+6      	; 0x2f6c <spindle_set_state+0xa>

    spindle_stop();
    2f66:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <spindle_stop>
    2f6a:	08 95       	ret
    
      #ifdef CPU_MAP_ATMEGA2560 // On the Uno, spindle enable and PWM are shared.
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    #else   
      SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
    2f6c:	47 9a       	sbi	0x08, 7	; 8
    2f6e:	08 95       	ret

00002f70 <spindle_run>:
  }
}


void spindle_run(uint8_t state, float rpm)
{
    2f70:	cf 92       	push	r12
    2f72:	df 92       	push	r13
    2f74:	ef 92       	push	r14
    2f76:	ff 92       	push	r15
    2f78:	cf 93       	push	r28
    2f7a:	c8 2f       	mov	r28, r24
    2f7c:	6a 01       	movw	r12, r20
    2f7e:	7b 01       	movw	r14, r22
  if (sys.state == STATE_CHECK_MODE) { return; }
    2f80:	90 91 68 07 	lds	r25, 0x0768
    2f84:	92 30       	cpi	r25, 0x02	; 2
    2f86:	39 f0       	breq	.+14     	; 0x2f96 <spindle_run+0x26>
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.  
    2f88:	0e 94 f0 1a 	call	0x35e0	; 0x35e0 <protocol_buffer_synchronize>
  spindle_set_state(state, rpm);
    2f8c:	b7 01       	movw	r22, r14
    2f8e:	a6 01       	movw	r20, r12
    2f90:	8c 2f       	mov	r24, r28
    2f92:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <spindle_set_state>
}
    2f96:	cf 91       	pop	r28
    2f98:	ff 90       	pop	r15
    2f9a:	ef 90       	pop	r14
    2f9c:	df 90       	pop	r13
    2f9e:	cf 90       	pop	r12
    2fa0:	08 95       	ret

00002fa2 <coolant_stop>:
}


void coolant_stop()
{
  COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2fa2:	46 98       	cbi	0x08, 6	; 8
    2fa4:	08 95       	ret

00002fa6 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT);
    2fa6:	3e 9a       	sbi	0x07, 6	; 7
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
    2fa8:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <coolant_stop>
    2fac:	08 95       	ret

00002fae <coolant_set_state>:
}


void coolant_set_state(uint8_t mode)
{
  if (mode == COOLANT_FLOOD_ENABLE) {
    2fae:	82 30       	cpi	r24, 0x02	; 2
    2fb0:	11 f4       	brne	.+4      	; 0x2fb6 <coolant_set_state+0x8>
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    2fb2:	46 9a       	sbi	0x08, 6	; 8
    2fb4:	08 95       	ret
    } else if (mode == COOLANT_MIST_ENABLE) {
      COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #endif

  } else {
    coolant_stop();
    2fb6:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <coolant_stop>
    2fba:	08 95       	ret

00002fbc <coolant_run>:
  }
}


void coolant_run(uint8_t mode)
{
    2fbc:	cf 93       	push	r28
    2fbe:	c8 2f       	mov	r28, r24
  if (sys.state == STATE_CHECK_MODE) { return; }
    2fc0:	90 91 68 07 	lds	r25, 0x0768
    2fc4:	92 30       	cpi	r25, 0x02	; 2
    2fc6:	29 f0       	breq	.+10     	; 0x2fd2 <coolant_run+0x16>
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.  
    2fc8:	0e 94 f0 1a 	call	0x35e0	; 0x35e0 <protocol_buffer_synchronize>
  coolant_set_state(mode);
    2fcc:	8c 2f       	mov	r24, r28
    2fce:	0e 94 d7 17 	call	0x2fae	; 0x2fae <coolant_set_state>
}
    2fd2:	cf 91       	pop	r28
    2fd4:	08 95       	ret

00002fd6 <serial_get_rx_buffer_count>:
  

// Returns the number of bytes used in the RX serial buffer.
uint8_t serial_get_rx_buffer_count()
{
  uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
    2fd6:	90 91 02 01 	lds	r25, 0x0102
  if (serial_rx_buffer_head >= rtail) { return(serial_rx_buffer_head-rtail); }
    2fda:	80 91 03 01 	lds	r24, 0x0103
    2fde:	89 17       	cp	r24, r25
    2fe0:	10 f0       	brcs	.+4      	; 0x2fe6 <serial_get_rx_buffer_count+0x10>
    2fe2:	89 1b       	sub	r24, r25
    2fe4:	08 95       	ret
  return (RX_BUFFER_SIZE - (rtail-serial_rx_buffer_head));
    2fe6:	80 58       	subi	r24, 0x80	; 128
    2fe8:	89 1b       	sub	r24, r25
}
    2fea:	08 95       	ret

00002fec <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    2fec:	e0 ec       	ldi	r30, 0xC0	; 192
    2fee:	f0 e0       	ldi	r31, 0x00	; 0
    2ff0:	80 81       	ld	r24, Z
    2ff2:	82 60       	ori	r24, 0x02	; 2
    2ff4:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    2ff6:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = UBRR0_value;
    2ffa:	83 e1       	ldi	r24, 0x13	; 19
    2ffc:	80 93 c4 00 	sts	0x00C4, r24
            
  // enable rx and tx
  UCSR0B |= 1<<RXEN0;
    3000:	e1 ec       	ldi	r30, 0xC1	; 193
    3002:	f0 e0       	ldi	r31, 0x00	; 0
    3004:	80 81       	ld	r24, Z
    3006:	80 61       	ori	r24, 0x10	; 16
    3008:	80 83       	st	Z, r24
  UCSR0B |= 1<<TXEN0;
    300a:	80 81       	ld	r24, Z
    300c:	88 60       	ori	r24, 0x08	; 8
    300e:	80 83       	st	Z, r24
	
  // enable interrupt on complete reception of a byte
  UCSR0B |= 1<<RXCIE0;
    3010:	80 81       	ld	r24, Z
    3012:	80 68       	ori	r24, 0x80	; 128
    3014:	80 83       	st	Z, r24
    3016:	08 95       	ret

00003018 <serial_write>:

// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    3018:	30 91 01 01 	lds	r19, 0x0101
    301c:	21 e0       	ldi	r18, 0x01	; 1
    301e:	23 0f       	add	r18, r19
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    3020:	20 38       	cpi	r18, 0x80	; 128
    3022:	31 f4       	brne	.+12     	; 0x3030 <serial_write+0x18>
    3024:	04 c0       	rjmp	.+8      	; 0x302e <serial_write+0x16>

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    3026:	90 81       	ld	r25, Z
    3028:	94 ff       	sbrs	r25, 4
    302a:	04 c0       	rjmp	.+8      	; 0x3034 <serial_write+0x1c>
    302c:	08 95       	ret
// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    302e:	20 e0       	ldi	r18, 0x00	; 0

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    3030:	ea e6       	ldi	r30, 0x6A	; 106
    3032:	f7 e0       	ldi	r31, 0x07	; 7
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    3034:	90 91 00 01 	lds	r25, 0x0100
    3038:	92 17       	cp	r25, r18
    303a:	a9 f3       	breq	.-22     	; 0x3026 <serial_write+0xe>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    303c:	e3 2f       	mov	r30, r19
    303e:	f0 e0       	ldi	r31, 0x00	; 0
    3040:	e1 50       	subi	r30, 0x01	; 1
    3042:	f8 4f       	sbci	r31, 0xF8	; 248
    3044:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    3046:	20 93 01 01 	sts	0x0101, r18
  
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0); 
    304a:	e1 ec       	ldi	r30, 0xC1	; 193
    304c:	f0 e0       	ldi	r31, 0x00	; 0
    304e:	80 81       	ld	r24, Z
    3050:	80 62       	ori	r24, 0x20	; 32
    3052:	80 83       	st	Z, r24
    3054:	08 95       	ret

00003056 <__vector_21>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    3056:	1f 92       	push	r1
    3058:	0f 92       	push	r0
    305a:	0f b6       	in	r0, 0x3f	; 63
    305c:	0f 92       	push	r0
    305e:	11 24       	eor	r1, r1
    3060:	8f 93       	push	r24
    3062:	9f 93       	push	r25
    3064:	ef 93       	push	r30
    3066:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    3068:	80 91 00 01 	lds	r24, 0x0100
      flow_ctrl = XON_SENT; 
    } else
  #endif
  { 
    // Send a byte from the buffer	
    UDR0 = serial_tx_buffer[tail];
    306c:	e8 2f       	mov	r30, r24
    306e:	f0 e0       	ldi	r31, 0x00	; 0
    3070:	e1 50       	subi	r30, 0x01	; 1
    3072:	f8 4f       	sbci	r31, 0xF8	; 248
    3074:	90 81       	ld	r25, Z
    3076:	90 93 c6 00 	sts	0x00C6, r25
  
    // Update tail position
    tail++;
    307a:	8f 5f       	subi	r24, 0xFF	; 255
    if (tail == TX_BUFFER_SIZE) { tail = 0; }
    307c:	80 38       	cpi	r24, 0x80	; 128
    307e:	09 f4       	brne	.+2      	; 0x3082 <__vector_21+0x2c>
    3080:	80 e0       	ldi	r24, 0x00	; 0
  
    serial_tx_buffer_tail = tail;
    3082:	80 93 00 01 	sts	0x0100, r24
  }
  
  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    3086:	90 91 01 01 	lds	r25, 0x0101
    308a:	89 13       	cpse	r24, r25
    308c:	05 c0       	rjmp	.+10     	; 0x3098 <__vector_21+0x42>
    308e:	e1 ec       	ldi	r30, 0xC1	; 193
    3090:	f0 e0       	ldi	r31, 0x00	; 0
    3092:	80 81       	ld	r24, Z
    3094:	8f 7d       	andi	r24, 0xDF	; 223
    3096:	80 83       	st	Z, r24
}
    3098:	ff 91       	pop	r31
    309a:	ef 91       	pop	r30
    309c:	9f 91       	pop	r25
    309e:	8f 91       	pop	r24
    30a0:	0f 90       	pop	r0
    30a2:	0f be       	out	0x3f, r0	; 63
    30a4:	0f 90       	pop	r0
    30a6:	1f 90       	pop	r1
    30a8:	18 95       	reti

000030aa <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    30aa:	90 91 02 01 	lds	r25, 0x0102
  if (serial_rx_buffer_head == tail) {
    30ae:	80 91 03 01 	lds	r24, 0x0103
    30b2:	89 17       	cp	r24, r25
    30b4:	61 f0       	breq	.+24     	; 0x30ce <serial_read+0x24>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    30b6:	e9 2f       	mov	r30, r25
    30b8:	f0 e0       	ldi	r31, 0x00	; 0
    30ba:	e1 58       	subi	r30, 0x81	; 129
    30bc:	f7 4f       	sbci	r31, 0xF7	; 247
    30be:	80 81       	ld	r24, Z
    
    tail++;
    30c0:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_BUFFER_SIZE) { tail = 0; }
    30c2:	90 38       	cpi	r25, 0x80	; 128
    30c4:	09 f4       	brne	.+2      	; 0x30c8 <serial_read+0x1e>
    30c6:	90 e0       	ldi	r25, 0x00	; 0
    serial_rx_buffer_tail = tail;
    30c8:	90 93 02 01 	sts	0x0102, r25
        flow_ctrl = SEND_XON;
        UCSR0B |=  (1 << UDRIE0); // Force TX
      }
    #endif
    
    return data;
    30cc:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    30ce:	8f ef       	ldi	r24, 0xFF	; 255
      }
    #endif
    
    return data;
  }
}
    30d0:	08 95       	ret

000030d2 <__vector_20>:


ISR(SERIAL_RX)
{
    30d2:	1f 92       	push	r1
    30d4:	0f 92       	push	r0
    30d6:	0f b6       	in	r0, 0x3f	; 63
    30d8:	0f 92       	push	r0
    30da:	11 24       	eor	r1, r1
    30dc:	2f 93       	push	r18
    30de:	3f 93       	push	r19
    30e0:	4f 93       	push	r20
    30e2:	5f 93       	push	r21
    30e4:	6f 93       	push	r22
    30e6:	7f 93       	push	r23
    30e8:	8f 93       	push	r24
    30ea:	9f 93       	push	r25
    30ec:	af 93       	push	r26
    30ee:	bf 93       	push	r27
    30f0:	ef 93       	push	r30
    30f2:	ff 93       	push	r31
  uint8_t data = UDR0;
    30f4:	80 91 c6 00 	lds	r24, 0x00C6
  uint8_t next_head;
  
  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    30f8:	8f 33       	cpi	r24, 0x3F	; 63
    30fa:	59 f0       	breq	.+22     	; 0x3112 <__vector_20+0x40>
    30fc:	28 f4       	brcc	.+10     	; 0x3108 <__vector_20+0x36>
    30fe:	88 31       	cpi	r24, 0x18	; 24
    3100:	61 f1       	breq	.+88     	; 0x315a <__vector_20+0x88>
    3102:	81 32       	cpi	r24, 0x21	; 33
    3104:	c1 f0       	breq	.+48     	; 0x3136 <__vector_20+0x64>
    3106:	2c c0       	rjmp	.+88     	; 0x3160 <__vector_20+0x8e>
    3108:	80 34       	cpi	r24, 0x40	; 64
    310a:	f1 f0       	breq	.+60     	; 0x3148 <__vector_20+0x76>
    310c:	8e 37       	cpi	r24, 0x7E	; 126
    310e:	51 f0       	breq	.+20     	; 0x3124 <__vector_20+0x52>
    3110:	27 c0       	rjmp	.+78     	; 0x3160 <__vector_20+0x8e>
    case CMD_STATUS_REPORT: bit_true_atomic(sys.rt_exec_state, EXEC_STATUS_REPORT); break; // Set as true
    3112:	8f b7       	in	r24, 0x3f	; 63
    3114:	f8 94       	cli
    3116:	ea e6       	ldi	r30, 0x6A	; 106
    3118:	f7 e0       	ldi	r31, 0x07	; 7
    311a:	90 81       	ld	r25, Z
    311c:	91 60       	ori	r25, 0x01	; 1
    311e:	90 83       	st	Z, r25
    3120:	8f bf       	out	0x3f, r24	; 63
    3122:	2f c0       	rjmp	.+94     	; 0x3182 <__vector_20+0xb0>
    case CMD_CYCLE_START:   bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START); break; // Set as true
    3124:	8f b7       	in	r24, 0x3f	; 63
    3126:	f8 94       	cli
    3128:	ea e6       	ldi	r30, 0x6A	; 106
    312a:	f7 e0       	ldi	r31, 0x07	; 7
    312c:	90 81       	ld	r25, Z
    312e:	92 60       	ori	r25, 0x02	; 2
    3130:	90 83       	st	Z, r25
    3132:	8f bf       	out	0x3f, r24	; 63
    3134:	26 c0       	rjmp	.+76     	; 0x3182 <__vector_20+0xb0>
    case CMD_FEED_HOLD:     bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD); break; // Set as true
    3136:	8f b7       	in	r24, 0x3f	; 63
    3138:	f8 94       	cli
    313a:	ea e6       	ldi	r30, 0x6A	; 106
    313c:	f7 e0       	ldi	r31, 0x07	; 7
    313e:	90 81       	ld	r25, Z
    3140:	98 60       	ori	r25, 0x08	; 8
    3142:	90 83       	st	Z, r25
    3144:	8f bf       	out	0x3f, r24	; 63
    3146:	1d c0       	rjmp	.+58     	; 0x3182 <__vector_20+0xb0>
    case CMD_SAFETY_DOOR:   bit_true_atomic(sys.rt_exec_state, EXEC_SAFETY_DOOR); break; // Set as true
    3148:	8f b7       	in	r24, 0x3f	; 63
    314a:	f8 94       	cli
    314c:	ea e6       	ldi	r30, 0x6A	; 106
    314e:	f7 e0       	ldi	r31, 0x07	; 7
    3150:	90 81       	ld	r25, Z
    3152:	90 62       	ori	r25, 0x20	; 32
    3154:	90 83       	st	Z, r25
    3156:	8f bf       	out	0x3f, r24	; 63
    3158:	14 c0       	rjmp	.+40     	; 0x3182 <__vector_20+0xb0>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    315a:	0e 94 a5 0c 	call	0x194a	; 0x194a <mc_reset>
    315e:	11 c0       	rjmp	.+34     	; 0x3182 <__vector_20+0xb0>
    default: // Write character to buffer    
      next_head = serial_rx_buffer_head + 1;
    3160:	e0 91 03 01 	lds	r30, 0x0103
    3164:	91 e0       	ldi	r25, 0x01	; 1
    3166:	9e 0f       	add	r25, r30
      if (next_head == RX_BUFFER_SIZE) { next_head = 0; }
    3168:	90 38       	cpi	r25, 0x80	; 128
    316a:	09 f4       	brne	.+2      	; 0x316e <__vector_20+0x9c>
    316c:	90 e0       	ldi	r25, 0x00	; 0
    
      // Write data to buffer unless it is full.
      if (next_head != serial_rx_buffer_tail) {
    316e:	20 91 02 01 	lds	r18, 0x0102
    3172:	92 17       	cp	r25, r18
    3174:	31 f0       	breq	.+12     	; 0x3182 <__vector_20+0xb0>
        serial_rx_buffer[serial_rx_buffer_head] = data;
    3176:	f0 e0       	ldi	r31, 0x00	; 0
    3178:	e1 58       	subi	r30, 0x81	; 129
    317a:	f7 4f       	sbci	r31, 0xF7	; 247
    317c:	80 83       	st	Z, r24
        serial_rx_buffer_head = next_head;    
    317e:	90 93 03 01 	sts	0x0103, r25
        #endif
        
      }
      //TODO: else alarm on overflow?
  }
}
    3182:	ff 91       	pop	r31
    3184:	ef 91       	pop	r30
    3186:	bf 91       	pop	r27
    3188:	af 91       	pop	r26
    318a:	9f 91       	pop	r25
    318c:	8f 91       	pop	r24
    318e:	7f 91       	pop	r23
    3190:	6f 91       	pop	r22
    3192:	5f 91       	pop	r21
    3194:	4f 91       	pop	r20
    3196:	3f 91       	pop	r19
    3198:	2f 91       	pop	r18
    319a:	0f 90       	pop	r0
    319c:	0f be       	out	0x3f, r0	; 63
    319e:	0f 90       	pop	r0
    31a0:	1f 90       	pop	r1
    31a2:	18 95       	reti

000031a4 <serial_reset_read_buffer>:


void serial_reset_read_buffer() 
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    31a4:	80 91 03 01 	lds	r24, 0x0103
    31a8:	80 93 02 01 	sts	0x0102, r24
    31ac:	08 95       	ret

000031ae <protocol_execute_realtime>:
// execute certain tasks without having two or more instances of the same task, such as the planner
// recalculating the buffer upon a feedhold or override.
// NOTE: The sys.rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    31ae:	2f 92       	push	r2
    31b0:	3f 92       	push	r3
    31b2:	4f 92       	push	r4
    31b4:	5f 92       	push	r5
    31b6:	6f 92       	push	r6
    31b8:	7f 92       	push	r7
    31ba:	8f 92       	push	r8
    31bc:	9f 92       	push	r9
    31be:	af 92       	push	r10
    31c0:	bf 92       	push	r11
    31c2:	cf 92       	push	r12
    31c4:	df 92       	push	r13
    31c6:	ef 92       	push	r14
    31c8:	ff 92       	push	r15
    31ca:	0f 93       	push	r16
    31cc:	1f 93       	push	r17
    31ce:	cf 93       	push	r28
    31d0:	df 93       	push	r29
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys.rt_exec_alarm; // Copy volatile sys.rt_exec_alarm.
    31d2:	0f 2e       	mov	r0, r31
    31d4:	fb e6       	ldi	r31, 0x6B	; 107
    31d6:	ef 2e       	mov	r14, r31
    31d8:	f7 e0       	ldi	r31, 0x07	; 7
    31da:	ff 2e       	mov	r15, r31
    31dc:	f0 2d       	mov	r31, r0
  if (rt_exec) { // Enter only if any bit flag is true
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    31de:	0f 2e       	mov	r0, r31
    31e0:	f8 e6       	ldi	r31, 0x68	; 104
    31e2:	8f 2e       	mov	r8, r31
    31e4:	f7 e0       	ldi	r31, 0x07	; 7
    31e6:	9f 2e       	mov	r9, r31
    31e8:	f0 2d       	mov	r31, r0
    31ea:	44 24       	eor	r4, r4
    31ec:	43 94       	inc	r4
      report_alarm_message(ALARM_PROBE_FAIL);
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
      bit_false_atomic(sys.rt_exec_state,EXEC_RESET); // Disable any existing reset
    31ee:	ca e6       	ldi	r28, 0x6A	; 106
    31f0:	d7 e0       	ldi	r29, 0x07	; 7
          coolant_stop();
          // TODO: Install parking motion here.
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY); //Problem in Bezug auf Jogging?
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    31f2:	09 e6       	ldi	r16, 0x69	; 105
    31f4:	17 e0       	ldi	r17, 0x07	; 7
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    31f6:	0f 2e       	mov	r0, r31
    31f8:	f0 e9       	ldi	r31, 0x90	; 144
    31fa:	af 2e       	mov	r10, r31
    31fc:	f7 e0       	ldi	r31, 0x07	; 7
    31fe:	bf 2e       	mov	r11, r31
    3200:	f0 2d       	mov	r31, r0
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    3202:	0f 2e       	mov	r0, r31
    3204:	ff e8       	ldi	r31, 0x8F	; 143
    3206:	cf 2e       	mov	r12, r31
    3208:	f7 e0       	ldi	r31, 0x07	; 7
    320a:	df 2e       	mov	r13, r31
    320c:	f0 2d       	mov	r31, r0
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    320e:	0f 2e       	mov	r0, r31
    3210:	f1 e9       	ldi	r31, 0x91	; 145
    3212:	6f 2e       	mov	r6, r31
    3214:	f7 e0       	ldi	r31, 0x07	; 7
    3216:	7f 2e       	mov	r7, r31
    3218:	f0 2d       	mov	r31, r0
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    321a:	68 94       	set
    321c:	22 24       	eor	r2, r2
    321e:	24 f8       	bld	r2, 4
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    3220:	68 94       	set
    3222:	33 24       	eor	r3, r3
    3224:	31 f8       	bld	r3, 1
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys.rt_exec_alarm; // Copy volatile sys.rt_exec_alarm.
    3226:	f7 01       	movw	r30, r14
    3228:	50 80       	ld	r5, Z
  if (rt_exec) { // Enter only if any bit flag is true
    322a:	55 20       	and	r5, r5
    322c:	69 f1       	breq	.+90     	; 0x3288 <protocol_execute_realtime+0xda>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    322e:	f4 01       	movw	r30, r8
    3230:	40 82       	st	Z, r4
    if (rt_exec & EXEC_ALARM_HARD_LIMIT) {
    3232:	51 fe       	sbrs	r5, 1
    3234:	04 c0       	rjmp	.+8      	; 0x323e <protocol_execute_realtime+0x90>
      report_alarm_message(ALARM_HARD_LIMIT_ERROR); 
    3236:	8f ef       	ldi	r24, 0xFF	; 255
    3238:	0e 94 b2 34 	call	0x6964	; 0x6964 <report_alarm_message>
    323c:	11 c0       	rjmp	.+34     	; 0x3260 <protocol_execute_realtime+0xb2>
    } else if (rt_exec & EXEC_ALARM_SOFT_LIMIT) {
    323e:	52 fe       	sbrs	r5, 2
    3240:	04 c0       	rjmp	.+8      	; 0x324a <protocol_execute_realtime+0x9c>
      report_alarm_message(ALARM_SOFT_LIMIT_ERROR);
    3242:	8e ef       	ldi	r24, 0xFE	; 254
    3244:	0e 94 b2 34 	call	0x6964	; 0x6964 <report_alarm_message>
    3248:	0b c0       	rjmp	.+22     	; 0x3260 <protocol_execute_realtime+0xb2>
    } else if (rt_exec & EXEC_ALARM_ABORT_CYCLE) {      
    324a:	53 fe       	sbrs	r5, 3
    324c:	04 c0       	rjmp	.+8      	; 0x3256 <protocol_execute_realtime+0xa8>
      report_alarm_message(ALARM_ABORT_CYCLE);
    324e:	8d ef       	ldi	r24, 0xFD	; 253
    3250:	0e 94 b2 34 	call	0x6964	; 0x6964 <report_alarm_message>
    3254:	05 c0       	rjmp	.+10     	; 0x3260 <protocol_execute_realtime+0xb2>
    } else if (rt_exec & EXEC_ALARM_PROBE_FAIL) {
    3256:	54 fe       	sbrs	r5, 4
    3258:	03 c0       	rjmp	.+6      	; 0x3260 <protocol_execute_realtime+0xb2>
      report_alarm_message(ALARM_PROBE_FAIL);
    325a:	8c ef       	ldi	r24, 0xFC	; 252
    325c:	0e 94 b2 34 	call	0x6964	; 0x6964 <report_alarm_message>
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
    3260:	50 fe       	sbrs	r5, 0
    3262:	0c c0       	rjmp	.+24     	; 0x327c <protocol_execute_realtime+0xce>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    3264:	84 2d       	mov	r24, r4
    3266:	0e 94 df 34 	call	0x69be	; 0x69be <report_feedback_message>
      bit_false_atomic(sys.rt_exec_state,EXEC_RESET); // Disable any existing reset
    326a:	8f b7       	in	r24, 0x3f	; 63
    326c:	f8 94       	cli
    326e:	98 81       	ld	r25, Y
    3270:	9f 7e       	andi	r25, 0xEF	; 239
    3272:	98 83       	st	Y, r25
    3274:	8f bf       	out	0x3f, r24	; 63
        // Nothing. Block EVERYTHING until user issues reset or power cycles. Hard limits
        // typically occur while unattended or not paying attention. Gives the user time
        // to do what is needed before resetting, like killing the incoming stream. The 
        // same could be said about soft limits. While the position is not lost, the incoming
        // stream could be still engaged and cause a serious crash if it continues afterwards.
      } while (bit_isfalse(sys.rt_exec_state,EXEC_RESET));
    3276:	88 81       	ld	r24, Y
    3278:	84 ff       	sbrs	r24, 4
    327a:	fd cf       	rjmp	.-6      	; 0x3276 <protocol_execute_realtime+0xc8>
    }
    bit_false_atomic(sys.rt_exec_alarm,0xFF); // Clear all alarm flags
    327c:	8f b7       	in	r24, 0x3f	; 63
    327e:	f8 94       	cli
    3280:	f7 01       	movw	r30, r14
    3282:	90 81       	ld	r25, Z
    3284:	10 82       	st	Z, r1
    3286:	8f bf       	out	0x3f, r24	; 63
  }
  
  // Check amd execute realtime commands
  rt_exec = sys.rt_exec_state; // Copy volatile sys.rt_exec_state.
    3288:	58 80       	ld	r5, Y
  if (rt_exec) { // Enter only if any bit flag is true
    328a:	55 20       	and	r5, r5
    328c:	09 f4       	brne	.+2      	; 0x3290 <protocol_execute_realtime+0xe2>
    328e:	b7 c0       	rjmp	.+366    	; 0x33fe <protocol_execute_realtime+0x250>
  
    // Execute system abort. 
    if (rt_exec & EXEC_RESET) {
    3290:	54 fe       	sbrs	r5, 4
    3292:	04 c0       	rjmp	.+8      	; 0x329c <protocol_execute_realtime+0xee>
      sys.abort = true;  // Only place this is set true.
    3294:	81 e0       	ldi	r24, 0x01	; 1
    3296:	80 93 67 07 	sts	0x0767, r24
      return; // Nothing else to do but exit.
    329a:	cd c0       	rjmp	.+410    	; 0x3436 <protocol_execute_realtime+0x288>
    }
    
    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) { 
    329c:	50 fe       	sbrs	r5, 0
    329e:	08 c0       	rjmp	.+16     	; 0x32b0 <protocol_execute_realtime+0x102>
      report_realtime_status();
    32a0:	0e 94 83 38 	call	0x7106	; 0x7106 <report_realtime_status>
      bit_false_atomic(sys.rt_exec_state,EXEC_STATUS_REPORT);
    32a4:	8f b7       	in	r24, 0x3f	; 63
    32a6:	f8 94       	cli
    32a8:	98 81       	ld	r25, Y
    32aa:	9e 7f       	andi	r25, 0xFE	; 254
    32ac:	98 83       	st	Y, r25
    32ae:	8f bf       	out	0x3f, r24	; 63
  
    // Execute hold states.
    // NOTE: The math involved to calculate the hold should be low enough for most, if not all, 
    // operational scenarios. Once hold is initiated, the system enters a suspend state to block
    // all main program processes until either reset or resumed.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR)) {
    32b0:	85 2d       	mov	r24, r5
    32b2:	88 76       	andi	r24, 0x68	; 104
    32b4:	09 f4       	brne	.+2      	; 0x32b8 <protocol_execute_realtime+0x10a>
    32b6:	40 c0       	rjmp	.+128    	; 0x3338 <protocol_execute_realtime+0x18a>
      
      // TODO: CHECK MODE? How to handle this? Likely nothing, since it only works when IDLE and then resets Grbl.
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {
    32b8:	f4 01       	movw	r30, r8
    32ba:	80 81       	ld	r24, Z
    32bc:	88 23       	and	r24, r24
    32be:	71 f0       	breq	.+28     	; 0x32dc <protocol_execute_realtime+0x12e>
    32c0:	98 2f       	mov	r25, r24
    32c2:	9c 77       	andi	r25, 0x7C	; 124
    32c4:	99 f1       	breq	.+102    	; 0x332c <protocol_execute_realtime+0x17e>

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
    32c6:	88 30       	cpi	r24, 0x08	; 8
    32c8:	09 f0       	breq	.+2      	; 0x32cc <protocol_execute_realtime+0x11e>
    32ca:	b2 c0       	rjmp	.+356    	; 0x3430 <protocol_execute_realtime+0x282>
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    32cc:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <st_update_plan_block_parameters>
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
    32d0:	f8 01       	movw	r30, r16
    32d2:	40 82       	st	Z, r4
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    32d4:	f4 01       	movw	r30, r8
    32d6:	80 81       	ld	r24, Z
    32d8:	81 11       	cpse	r24, r1
    32da:	05 c0       	rjmp	.+10     	; 0x32e6 <protocol_execute_realtime+0x138>
    32dc:	f8 01       	movw	r30, r16
    32de:	30 82       	st	Z, r3
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    32e0:	56 fc       	sbrc	r5, 6
    32e2:	08 c0       	rjmp	.+16     	; 0x32f4 <protocol_execute_realtime+0x146>
    32e4:	0b c0       	rjmp	.+22     	; 0x32fc <protocol_execute_realtime+0x14e>
    32e6:	56 fe       	sbrs	r5, 6
    32e8:	09 c0       	rjmp	.+18     	; 0x32fc <protocol_execute_realtime+0x14e>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    32ea:	88 30       	cpi	r24, 0x08	; 8
    32ec:	19 f4       	brne	.+6      	; 0x32f4 <protocol_execute_realtime+0x146>
    32ee:	80 e4       	ldi	r24, 0x40	; 64
    32f0:	f4 01       	movw	r30, r8
    32f2:	80 83       	st	Z, r24
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
    32f4:	f8 01       	movw	r30, r16
    32f6:	80 81       	ld	r24, Z
    32f8:	88 60       	ori	r24, 0x08	; 8
    32fa:	80 83       	st	Z, r24
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    32fc:	53 fe       	sbrs	r5, 3
    32fe:	04 c0       	rjmp	.+8      	; 0x3308 <protocol_execute_realtime+0x15a>
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    3300:	f4 01       	movw	r30, r8
    3302:	80 81       	ld	r24, Z
    3304:	85 ff       	sbrs	r24, 5
    3306:	20 82       	st	Z, r2
  
        // Execute a safety door stop with a feed hold, only during a cycle, and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged. The power-down is 
        // executed here, if IDLE, or when the CYCLE completes via the EXEC_CYCLE_STOP flag.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    3308:	55 fe       	sbrs	r5, 5
    330a:	10 c0       	rjmp	.+32     	; 0x332c <protocol_execute_realtime+0x17e>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
    330c:	86 e0       	ldi	r24, 0x06	; 6
    330e:	0e 94 df 34 	call	0x69be	; 0x69be <report_feedback_message>
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
    3312:	f8 01       	movw	r30, r16
    3314:	80 81       	ld	r24, Z
    3316:	81 ff       	sbrs	r24, 1
    3318:	03 c0       	rjmp	.+6      	; 0x3320 <protocol_execute_realtime+0x172>
    331a:	f5 2d       	mov	r31, r5
    331c:	f4 60       	ori	r31, 0x04	; 4
    331e:	5f 2e       	mov	r5, r31
          sys.suspend |= SUSPEND_ENERGIZE;
    3320:	84 60       	ori	r24, 0x04	; 4
    3322:	f8 01       	movw	r30, r16
    3324:	80 83       	st	Z, r24
          sys.state = STATE_SAFETY_DOOR;
    3326:	80 e2       	ldi	r24, 0x20	; 32
    3328:	f4 01       	movw	r30, r8
    332a:	80 83       	st	Z, r24
        }
         
      }
      bit_false_atomic(sys.rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    332c:	8f b7       	in	r24, 0x3f	; 63
    332e:	f8 94       	cli
    3330:	98 81       	ld	r25, Y
    3332:	97 79       	andi	r25, 0x97	; 151
    3334:	98 83       	st	Y, r25
    3336:	8f bf       	out	0x3f, r24	; 63
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    3338:	51 fe       	sbrs	r5, 1
    333a:	44 c0       	rjmp	.+136    	; 0x33c4 <protocol_execute_realtime+0x216>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) { 
    333c:	85 2d       	mov	r24, r5
    333e:	88 76       	andi	r24, 0x68	; 104
    3340:	d9 f5       	brne	.+118    	; 0x33b8 <protocol_execute_realtime+0x20a>
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
    3342:	f4 01       	movw	r30, r8
    3344:	80 81       	ld	r24, Z
    3346:	88 23       	and	r24, r24
    3348:	31 f0       	breq	.+12     	; 0x3356 <protocol_execute_realtime+0x1a8>
    334a:	80 75       	andi	r24, 0x50	; 80
    334c:	a9 f1       	breq	.+106    	; 0x33b8 <protocol_execute_realtime+0x20a>
    334e:	f8 01       	movw	r30, r16
    3350:	80 81       	ld	r24, Z
    3352:	81 ff       	sbrs	r24, 1
    3354:	31 c0       	rjmp	.+98     	; 0x33b8 <protocol_execute_realtime+0x20a>
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
    3356:	f8 01       	movw	r30, r16
    3358:	80 81       	ld	r24, Z
    335a:	82 ff       	sbrs	r24, 2
    335c:	19 c0       	rjmp	.+50     	; 0x3390 <protocol_execute_realtime+0x1e2>
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    335e:	f5 01       	movw	r30, r10
    3360:	80 81       	ld	r24, Z
    3362:	88 23       	and	r24, r24
    3364:	59 f0       	breq	.+22     	; 0x337c <protocol_execute_realtime+0x1ce>
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    3366:	f3 01       	movw	r30, r6
    3368:	40 81       	ld	r20, Z
    336a:	51 81       	ldd	r21, Z+1	; 0x01
    336c:	62 81       	ldd	r22, Z+2	; 0x02
    336e:	73 81       	ldd	r23, Z+3	; 0x03
    3370:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <spindle_set_state>
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    3374:	80 ea       	ldi	r24, 0xA0	; 160
    3376:	9f e0       	ldi	r25, 0x0F	; 15
    3378:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <delay_ms>
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    337c:	f6 01       	movw	r30, r12
    337e:	80 81       	ld	r24, Z
    3380:	88 23       	and	r24, r24
    3382:	31 f0       	breq	.+12     	; 0x3390 <protocol_execute_realtime+0x1e2>
              coolant_set_state(gc_state.modal.coolant); 
    3384:	0e 94 d7 17 	call	0x2fae	; 0x2fae <coolant_set_state>
              delay_ms(SAFETY_DOOR_COOLANT_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    3388:	88 ee       	ldi	r24, 0xE8	; 232
    338a:	93 e0       	ldi	r25, 0x03	; 3
    338c:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <delay_ms>
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    3390:	0e 94 59 2a 	call	0x54b2	; 0x54b2 <plan_get_current_block>
    3394:	89 2b       	or	r24, r25
    3396:	61 f0       	breq	.+24     	; 0x33b0 <protocol_execute_realtime+0x202>
    3398:	f8 01       	movw	r30, r16
    339a:	80 81       	ld	r24, Z
    339c:	83 fd       	sbrc	r24, 3
    339e:	08 c0       	rjmp	.+16     	; 0x33b0 <protocol_execute_realtime+0x202>
            sys.state = STATE_CYCLE;
    33a0:	88 e0       	ldi	r24, 0x08	; 8
    33a2:	f4 01       	movw	r30, r8
    33a4:	80 83       	st	Z, r24
            st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    33a6:	0e 94 5f 1e 	call	0x3cbe	; 0x3cbe <st_prep_buffer>
            st_wake_up();
    33aa:	0e 94 0c 1b 	call	0x3618	; 0x3618 <st_wake_up>
    33ae:	02 c0       	rjmp	.+4      	; 0x33b4 <protocol_execute_realtime+0x206>
          } else { // Otherwise, do nothing. Set and resume IDLE state.
            sys.state = STATE_IDLE;
    33b0:	f4 01       	movw	r30, r8
    33b2:	10 82       	st	Z, r1
          }
          sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    33b4:	f8 01       	movw	r30, r16
    33b6:	10 82       	st	Z, r1
        }
      }    
      bit_false_atomic(sys.rt_exec_state,EXEC_CYCLE_START);
    33b8:	8f b7       	in	r24, 0x3f	; 63
    33ba:	f8 94       	cli
    33bc:	98 81       	ld	r25, Y
    33be:	9d 7f       	andi	r25, 0xFD	; 253
    33c0:	98 83       	st	Y, r25
    33c2:	8f bf       	out	0x3f, r24	; 63
    // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by 
    // realtime command execution in the main program, ensuring that the planner re-plans safely.
    // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
    // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.   
    // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
    if (rt_exec & EXEC_CYCLE_STOP) {
    33c4:	52 fe       	sbrs	r5, 2
    33c6:	1b c0       	rjmp	.+54     	; 0x33fe <protocol_execute_realtime+0x250>
      if (sys.state & (STATE_HOLD | STATE_SAFETY_DOOR)) {
    33c8:	f4 01       	movw	r30, r8
    33ca:	80 81       	ld	r24, Z
    33cc:	80 73       	andi	r24, 0x30	; 48
    33ce:	69 f0       	breq	.+26     	; 0x33ea <protocol_execute_realtime+0x23c>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        if (sys.suspend & SUSPEND_ENERGIZE) { // De-energize system if safety door has been opened.
    33d0:	f8 01       	movw	r30, r16
    33d2:	80 81       	ld	r24, Z
    33d4:	82 ff       	sbrs	r24, 2
    33d6:	04 c0       	rjmp	.+8      	; 0x33e0 <protocol_execute_realtime+0x232>
          spindle_stop();
    33d8:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <spindle_stop>
          coolant_stop();
    33dc:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <coolant_stop>
          // TODO: Install parking motion here.
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY); //Problem in Bezug auf Jogging?
    33e0:	f8 01       	movw	r30, r16
    33e2:	80 81       	ld	r24, Z
    33e4:	82 60       	ori	r24, 0x02	; 2
    33e6:	80 83       	st	Z, r24
    33e8:	04 c0       	rjmp	.+8      	; 0x33f2 <protocol_execute_realtime+0x244>
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    33ea:	f8 01       	movw	r30, r16
    33ec:	10 82       	st	Z, r1
        sys.state = STATE_IDLE;
    33ee:	f4 01       	movw	r30, r8
    33f0:	10 82       	st	Z, r1
      }
      bit_false_atomic(sys.rt_exec_state,EXEC_CYCLE_STOP);
    33f2:	8f b7       	in	r24, 0x3f	; 63
    33f4:	f8 94       	cli
    33f6:	98 81       	ld	r25, Y
    33f8:	9b 7f       	andi	r25, 0xFB	; 251
    33fa:	98 83       	st	Y, r25
    33fc:	8f bf       	out	0x3f, r24	; 63

  // Overrides flag byte (sys.override) and execution should be installed here, since they 
  // are realtime and require a direct and controlled interface to the main stepper program.

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_MOTION_CANCEL | STATE_SAFETY_DOOR | STATE_HOMING)) { st_prep_buffer(); }  
    33fe:	f4 01       	movw	r30, r8
    3400:	80 81       	ld	r24, Z
    3402:	8c 77       	andi	r24, 0x7C	; 124
    3404:	11 f0       	breq	.+4      	; 0x340a <protocol_execute_realtime+0x25c>
    3406:	0e 94 5f 1e 	call	0x3cbe	; 0x3cbe <st_prep_buffer>
  
  // If safety door was opened, actively check when safety door is closed and ready to resume.
  // NOTE: This unlocks the SAFETY_DOOR state to a HOLD state, such that CYCLE_START can activate a resume.
  if (sys.state == STATE_SAFETY_DOOR) { 
    340a:	f4 01       	movw	r30, r8
    340c:	80 81       	ld	r24, Z
    340e:	80 32       	cpi	r24, 0x20	; 32
    3410:	51 f4       	brne	.+20     	; 0x3426 <protocol_execute_realtime+0x278>
    if (bit_istrue(sys.suspend,SUSPEND_ENABLE_READY)) { 
    3412:	f8 01       	movw	r30, r16
    3414:	80 81       	ld	r24, Z
    3416:	81 ff       	sbrs	r24, 1
    3418:	06 c0       	rjmp	.+12     	; 0x3426 <protocol_execute_realtime+0x278>
      if (!(system_check_safety_door_ajar())) {
    341a:	0e 94 d1 39 	call	0x73a2	; 0x73a2 <system_check_safety_door_ajar>
    341e:	81 11       	cpse	r24, r1
    3420:	02 c0       	rjmp	.+4      	; 0x3426 <protocol_execute_realtime+0x278>
        sys.state = STATE_HOLD; // Update to HOLD state to indicate door is closed and ready to resume.
    3422:	f4 01       	movw	r30, r8
    3424:	20 82       	st	Z, r2
      }
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
    3426:	f8 01       	movw	r30, r16
    3428:	80 81       	ld	r24, Z
    342a:	81 11       	cpse	r24, r1
    342c:	fc ce       	rjmp	.-520    	; 0x3226 <protocol_execute_realtime+0x78>
    342e:	03 c0       	rjmp	.+6      	; 0x3436 <protocol_execute_realtime+0x288>
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    3430:	f4 01       	movw	r30, r8
    3432:	80 81       	ld	r24, Z
    3434:	58 cf       	rjmp	.-336    	; 0x32e6 <protocol_execute_realtime+0x138>
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
  
}  
    3436:	df 91       	pop	r29
    3438:	cf 91       	pop	r28
    343a:	1f 91       	pop	r17
    343c:	0f 91       	pop	r16
    343e:	ff 90       	pop	r15
    3440:	ef 90       	pop	r14
    3442:	df 90       	pop	r13
    3444:	cf 90       	pop	r12
    3446:	bf 90       	pop	r11
    3448:	af 90       	pop	r10
    344a:	9f 90       	pop	r9
    344c:	8f 90       	pop	r8
    344e:	7f 90       	pop	r7
    3450:	6f 90       	pop	r6
    3452:	5f 90       	pop	r5
    3454:	4f 90       	pop	r4
    3456:	3f 90       	pop	r3
    3458:	2f 90       	pop	r2
    345a:	08 95       	ret

0000345c <protocol_process>:
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
  }
}

void protocol_process() { //Extracted from main_loop function to use it while in Jogging State
    345c:	df 92       	push	r13
    345e:	ef 92       	push	r14
    3460:	ff 92       	push	r15
    3462:	0f 93       	push	r16
    3464:	1f 93       	push	r17
    3466:	cf 93       	push	r28
    3468:	df 93       	push	r29
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    346a:	c7 e6       	ldi	r28, 0x67	; 103
    346c:	d7 e0       	ldi	r29, 0x07	; 7

  if (line[0] == 0) {
    346e:	06 e0       	ldi	r16, 0x06	; 6
    3470:	11 e0       	ldi	r17, 0x01	; 1
  else if (line[0] == '$') {
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    
  }
  else if (sys.state == STATE_ALARM) {
    3472:	0f 2e       	mov	r0, r31
    3474:	f8 e6       	ldi	r31, 0x68	; 104
    3476:	ef 2e       	mov	r14, r31
    3478:	f7 e0       	ldi	r31, 0x07	; 7
    347a:	ff 2e       	mov	r15, r31
    347c:	f0 2d       	mov	r31, r0
				else if (c == '(') {
					// Enable comments flag and ignore all characters until ')' or EOL.
					// NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
					// In the future, we could simply remove the items within the comments, but retain the
					// comment control characters, so that the g-code parser can error-check it.
					iscomment = true;
    347e:	dd 24       	eor	r13, r13
    3480:	d3 94       	inc	r13
	// line buffer, which is limited in size. The g-code standard actually states a line can't
	// exceed 256 characters, but the Arduino Uno does not have the memory space for this.
	// With a better processor, it would be very easy to pull this initial parsing out as a
	// seperate task to be shared by the g-code parser and Grbl's system commands.
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
    3482:	6a c0       	rjmp	.+212    	; 0x3558 <protocol_process+0xfc>
		if ((c == '\n') || (c == '\r')) { // End of line reached
    3484:	8a 30       	cpi	r24, 0x0A	; 10
    3486:	11 f0       	breq	.+4      	; 0x348c <protocol_process+0x30>
    3488:	8d 30       	cpi	r24, 0x0D	; 13
    348a:	91 f5       	brne	.+100    	; 0x34f0 <protocol_process+0x94>
			line[char_counter] = 0; // Set string termination character.
    348c:	e0 91 05 01 	lds	r30, 0x0105
    3490:	f0 e0       	ldi	r31, 0x00	; 0
    3492:	ea 5f       	subi	r30, 0xFA	; 250
    3494:	fe 4f       	sbci	r31, 0xFE	; 254
    3496:	10 82       	st	Z, r1
// Directs and executes one line of formatted input from protocol_process. While mostly
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
    3498:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    349c:	88 81       	ld	r24, Y
    349e:	81 11       	cpse	r24, r1
    34a0:	22 c0       	rjmp	.+68     	; 0x34e6 <protocol_process+0x8a>

  if (line[0] == 0) {
    34a2:	f8 01       	movw	r30, r16
    34a4:	80 81       	ld	r24, Z
    34a6:	81 11       	cpse	r24, r1
    34a8:	03 c0       	rjmp	.+6      	; 0x34b0 <protocol_process+0x54>
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);
    34aa:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
    34ae:	1b c0       	rjmp	.+54     	; 0x34e6 <protocol_process+0x8a>

  }
  else if (line[0] == '$') {
    34b0:	84 32       	cpi	r24, 0x24	; 36
    34b2:	31 f4       	brne	.+12     	; 0x34c0 <protocol_process+0x64>
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    34b4:	c8 01       	movw	r24, r16
    34b6:	0e 94 f4 39 	call	0x73e8	; 0x73e8 <system_execute_line>
    34ba:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
    34be:	13 c0       	rjmp	.+38     	; 0x34e6 <protocol_process+0x8a>
    
  }
  else if (sys.state == STATE_ALARM) {
    34c0:	f7 01       	movw	r30, r14
    34c2:	80 81       	ld	r24, Z
    34c4:	81 30       	cpi	r24, 0x01	; 1
    34c6:	21 f4       	brne	.+8      	; 0x34d0 <protocol_process+0x74>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);
    34c8:	89 e0       	ldi	r24, 0x09	; 9
    34ca:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
    34ce:	0b c0       	rjmp	.+22     	; 0x34e6 <protocol_process+0x8a>

  } 
  else if (sys.state == STATE_JOG) {
    34d0:	80 38       	cpi	r24, 0x80	; 128
    34d2:	21 f4       	brne	.+8      	; 0x34dc <protocol_process+0x80>
	// GCode shall be ignored as long as jogging is ongoing
	report_status_message(STATUS_JOG_ONGOING_LOCK);
    34d4:	8d e0       	ldi	r24, 0x0D	; 13
    34d6:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
    34da:	05 c0       	rjmp	.+10     	; 0x34e6 <protocol_process+0x8a>
  }
  else {
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
    34dc:	c8 01       	movw	r24, r16
    34de:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <gc_execute_line>
    34e2:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
		if ((c == '\n') || (c == '\r')) { // End of line reached
			line[char_counter] = 0; // Set string termination character.
			protocol_execute_line(line); // Line is complete. Execute it!
			iscomment = false;
    34e6:	10 92 04 01 	sts	0x0104, r1
			char_counter = 0;
    34ea:	10 92 05 01 	sts	0x0105, r1
    34ee:	34 c0       	rjmp	.+104    	; 0x3558 <protocol_process+0xfc>
		} 
		else {
			if (iscomment) {
    34f0:	90 91 04 01 	lds	r25, 0x0104
    34f4:	99 23       	and	r25, r25
    34f6:	29 f0       	breq	.+10     	; 0x3502 <protocol_process+0xa6>
				// Throw away all comment characters
				if (c == ')') {
    34f8:	89 32       	cpi	r24, 0x29	; 41
    34fa:	71 f5       	brne	.+92     	; 0x3558 <protocol_process+0xfc>
					// End of comment. Resume line.
					iscomment = false;
    34fc:	10 92 04 01 	sts	0x0104, r1
    3500:	2b c0       	rjmp	.+86     	; 0x3558 <protocol_process+0xfc>
				}
			}
			else {
				if (c <= ' ') {
    3502:	81 32       	cpi	r24, 0x21	; 33
    3504:	48 f1       	brcs	.+82     	; 0x3558 <protocol_process+0xfc>
					// Throw away whitepace and control characters
				}
				else if (c == '/') {
    3506:	8f 32       	cpi	r24, 0x2F	; 47
    3508:	39 f1       	breq	.+78     	; 0x3558 <protocol_process+0xfc>
					// Block delete NOT SUPPORTED. Ignore character.
					// NOTE: If supported, would simply need to check the system if block delete is enabled.
				}
				else if (c == '(') {
    350a:	88 32       	cpi	r24, 0x28	; 40
    350c:	19 f4       	brne	.+6      	; 0x3514 <protocol_process+0xb8>
					// Enable comments flag and ignore all characters until ')' or EOL.
					// NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
					// In the future, we could simply remove the items within the comments, but retain the
					// comment control characters, so that the g-code parser can error-check it.
					iscomment = true;
    350e:	d0 92 04 01 	sts	0x0104, r13
    3512:	22 c0       	rjmp	.+68     	; 0x3558 <protocol_process+0xfc>
					// where, during a program, the system auto-cycle start will continue to execute
					// everything until the next '%' sign. This will help fix resuming issues with certain
					// functions that empty the planner buffer to execute its task on-time.

				}
				else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    3514:	e0 91 05 01 	lds	r30, 0x0105
    3518:	ef 34       	cpi	r30, 0x4F	; 79
    351a:	40 f0       	brcs	.+16     	; 0x352c <protocol_process+0xd0>
					// Detect line buffer overflow. Report error and reset line buffer.
					report_status_message(STATUS_OVERFLOW);
    351c:	8b e0       	ldi	r24, 0x0B	; 11
    351e:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
					iscomment = false;
    3522:	10 92 04 01 	sts	0x0104, r1
					char_counter = 0;
    3526:	10 92 05 01 	sts	0x0105, r1
    352a:	16 c0       	rjmp	.+44     	; 0x3558 <protocol_process+0xfc>
				}
				else if (c >= 'a' && c <= 'z') { // Uppercase lowercase
    352c:	9f e9       	ldi	r25, 0x9F	; 159
    352e:	98 0f       	add	r25, r24
    3530:	9a 31       	cpi	r25, 0x1A	; 26
    3532:	50 f4       	brcc	.+20     	; 0x3548 <protocol_process+0xec>
					line[char_counter++] = c-'a'+'A';
    3534:	91 e0       	ldi	r25, 0x01	; 1
    3536:	9e 0f       	add	r25, r30
    3538:	90 93 05 01 	sts	0x0105, r25
    353c:	f0 e0       	ldi	r31, 0x00	; 0
    353e:	ea 5f       	subi	r30, 0xFA	; 250
    3540:	fe 4f       	sbci	r31, 0xFE	; 254
    3542:	80 52       	subi	r24, 0x20	; 32
    3544:	80 83       	st	Z, r24
    3546:	08 c0       	rjmp	.+16     	; 0x3558 <protocol_process+0xfc>
				}
				else {
					line[char_counter++] = c;
    3548:	91 e0       	ldi	r25, 0x01	; 1
    354a:	9e 0f       	add	r25, r30
    354c:	90 93 05 01 	sts	0x0105, r25
    3550:	f0 e0       	ldi	r31, 0x00	; 0
    3552:	ea 5f       	subi	r30, 0xFA	; 250
    3554:	fe 4f       	sbci	r31, 0xFE	; 254
    3556:	80 83       	st	Z, r24
	// line buffer, which is limited in size. The g-code standard actually states a line can't
	// exceed 256 characters, but the Arduino Uno does not have the memory space for this.
	// With a better processor, it would be very easy to pull this initial parsing out as a
	// seperate task to be shared by the g-code parser and Grbl's system commands.
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
    3558:	0e 94 55 18 	call	0x30aa	; 0x30aa <serial_read>
    355c:	8f 3f       	cpi	r24, 0xFF	; 255
    355e:	09 f0       	breq	.+2      	; 0x3562 <protocol_process+0x106>
    3560:	91 cf       	rjmp	.-222    	; 0x3484 <protocol_process+0x28>
					line[char_counter++] = c;
				}
			}
		}
	}	
}
    3562:	df 91       	pop	r29
    3564:	cf 91       	pop	r28
    3566:	1f 91       	pop	r17
    3568:	0f 91       	pop	r16
    356a:	ff 90       	pop	r15
    356c:	ef 90       	pop	r14
    356e:	df 90       	pop	r13
    3570:	08 95       	ret

00003572 <protocol_auto_cycle_start>:
// command in the planner queue.
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes 
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming 
// is finished, single commands), a command that needs to wait for the motions in the buffer to 
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start() { bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START); } 
    3572:	8f b7       	in	r24, 0x3f	; 63
    3574:	f8 94       	cli
    3576:	ea e6       	ldi	r30, 0x6A	; 106
    3578:	f7 e0       	ldi	r31, 0x07	; 7
    357a:	90 81       	ld	r25, Z
    357c:	92 60       	ori	r25, 0x02	; 2
    357e:	90 83       	st	Z, r25
    3580:	8f bf       	out	0x3f, r24	; 63
    3582:	08 95       	ret

00003584 <protocol_main_loop>:

/* 
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    3584:	cf 93       	push	r28
    3586:	df 93       	push	r29
  // ------------------------------------------------------------
  // Complete initialization procedures upon a power-up or reset.
  // ------------------------------------------------------------
  
  // Print welcome message   
  report_init_message();
    3588:	0e 94 16 35 	call	0x6a2c	; 0x6a2c <report_init_message>

  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    358c:	80 91 68 07 	lds	r24, 0x0768
    3590:	81 30       	cpi	r24, 0x01	; 1
    3592:	21 f4       	brne	.+8      	; 0x359c <protocol_main_loop+0x18>
    report_feedback_message(MESSAGE_ALARM_LOCK); 
    3594:	82 e0       	ldi	r24, 0x02	; 2
    3596:	0e 94 df 34 	call	0x69be	; 0x69be <report_feedback_message>
    359a:	12 c0       	rjmp	.+36     	; 0x35c0 <protocol_main_loop+0x3c>
  } else {
    // All systems go! But first check for safety door.
    if (system_check_safety_door_ajar()) {
    359c:	0e 94 d1 39 	call	0x73a2	; 0x73a2 <system_check_safety_door_ajar>
    35a0:	88 23       	and	r24, r24
    35a2:	41 f0       	breq	.+16     	; 0x35b4 <protocol_main_loop+0x30>
      bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
    35a4:	ea e6       	ldi	r30, 0x6A	; 106
    35a6:	f7 e0       	ldi	r31, 0x07	; 7
    35a8:	80 81       	ld	r24, Z
    35aa:	80 62       	ori	r24, 0x20	; 32
    35ac:	80 83       	st	Z, r24
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    35ae:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
    35b2:	02 c0       	rjmp	.+4      	; 0x35b8 <protocol_main_loop+0x34>
    } else {
      sys.state = STATE_IDLE; // Set system to ready. Clear all state flags.
    35b4:	10 92 68 07 	sts	0x0768, r1
    } 
    system_execute_startup(line); // Execute startup script.
    35b8:	86 e0       	ldi	r24, 0x06	; 6
    35ba:	91 e0       	ldi	r25, 0x01	; 1
    35bc:	0e 94 d3 39 	call	0x73a6	; 0x73a6 <system_execute_startup>
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
	jogging();
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    35c0:	c7 e6       	ldi	r28, 0x67	; 103
    35c2:	d7 e0       	ldi	r29, 0x07	; 7
  

  for (;;) {

    
    protocol_process();
    35c4:	0e 94 2e 1a 	call	0x345c	; 0x345c <protocol_process>
    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    35c8:	0e 94 b9 1a 	call	0x3572	; 0x3572 <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
    35cc:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
	jogging();
    35d0:	0e 94 2d 05 	call	0xa5a	; 0xa5a <jogging>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    35d4:	88 81       	ld	r24, Y
    35d6:	88 23       	and	r24, r24
    35d8:	a9 f3       	breq	.-22     	; 0x35c4 <protocol_main_loop+0x40>
              
  }
  
  return; /* Never reached */
}
    35da:	df 91       	pop	r29
    35dc:	cf 91       	pop	r28
    35de:	08 95       	ret

000035e0 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    35e0:	0f 93       	push	r16
    35e2:	1f 93       	push	r17
    35e4:	cf 93       	push	r28
    35e6:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    35e8:	0e 94 b9 1a 	call	0x3572	; 0x3572 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    35ec:	c7 e6       	ldi	r28, 0x67	; 103
    35ee:	d7 e0       	ldi	r29, 0x07	; 7
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    35f0:	08 e6       	ldi	r16, 0x68	; 104
    35f2:	17 e0       	ldi	r17, 0x07	; 7
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    35f4:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    35f8:	88 81       	ld	r24, Y
    35fa:	81 11       	cpse	r24, r1
    35fc:	08 c0       	rjmp	.+16     	; 0x360e <protocol_buffer_synchronize+0x2e>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    35fe:	0e 94 59 2a 	call	0x54b2	; 0x54b2 <plan_get_current_block>
    3602:	89 2b       	or	r24, r25
    3604:	b9 f7       	brne	.-18     	; 0x35f4 <protocol_buffer_synchronize+0x14>
    3606:	f8 01       	movw	r30, r16
    3608:	80 81       	ld	r24, Z
    360a:	88 30       	cpi	r24, 0x08	; 8
    360c:	99 f3       	breq	.-26     	; 0x35f4 <protocol_buffer_synchronize+0x14>
}
    360e:	df 91       	pop	r29
    3610:	cf 91       	pop	r28
    3612:	1f 91       	pop	r17
    3614:	0f 91       	pop	r16
    3616:	08 95       	ret

00003618 <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up() 
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    3618:	80 91 3c 09 	lds	r24, 0x093C
    361c:	82 ff       	sbrs	r24, 2
    361e:	02 c0       	rjmp	.+4      	; 0x3624 <st_wake_up+0xc>
    3620:	28 9a       	sbi	0x05, 0	; 5
    3622:	01 c0       	rjmp	.+2      	; 0x3626 <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    3624:	28 98       	cbi	0x05, 0	; 5

  #ifdef LED_PRESENT
  LED_PORT &= ~(1<<LED_RUN_BIT); // active low
    3626:	44 98       	cbi	0x08, 4	; 8
  #endif

  if (sys.state & (STATE_CYCLE | STATE_HOMING)){
    3628:	80 91 68 07 	lds	r24, 0x0768
    362c:	8c 70       	andi	r24, 0x0C	; 12
    362e:	91 f1       	breq	.+100    	; 0x3694 <st_wake_up+0x7c>
    // Initialize stepper output bits
    st.dir_outbits = dir_port_invert_mask; 
    3630:	80 91 86 01 	lds	r24, 0x0186
    3634:	80 93 9a 01 	sts	0x019A, r24
    st.step_outbits = step_port_invert_mask;
    3638:	80 91 87 01 	lds	r24, 0x0187
    363c:	80 93 99 01 	sts	0x0199, r24
      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
      // Set delay between direction pin write and step command.
      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    #else // Normal operation
      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    3640:	80 91 2f 09 	lds	r24, 0x092F
    3644:	90 e0       	ldi	r25, 0x00	; 0
    3646:	02 97       	sbiw	r24, 0x02	; 2
    3648:	aa 27       	eor	r26, r26
    364a:	97 fd       	sbrc	r25, 7
    364c:	a0 95       	com	r26
    364e:	ba 2f       	mov	r27, r26
    3650:	ac 01       	movw	r20, r24
    3652:	bd 01       	movw	r22, r26
    3654:	44 0f       	add	r20, r20
    3656:	55 1f       	adc	r21, r21
    3658:	66 1f       	adc	r22, r22
    365a:	77 1f       	adc	r23, r23
    365c:	44 0f       	add	r20, r20
    365e:	55 1f       	adc	r21, r21
    3660:	66 1f       	adc	r22, r22
    3662:	77 1f       	adc	r23, r23
    3664:	44 0f       	add	r20, r20
    3666:	55 1f       	adc	r21, r21
    3668:	66 1f       	adc	r22, r22
    366a:	77 1f       	adc	r23, r23
    366c:	84 0f       	add	r24, r20
    366e:	95 1f       	adc	r25, r21
    3670:	a6 1f       	adc	r26, r22
    3672:	b7 1f       	adc	r27, r23
    3674:	b5 95       	asr	r27
    3676:	a7 95       	ror	r26
    3678:	97 95       	ror	r25
    367a:	87 95       	ror	r24
    367c:	b5 95       	asr	r27
    367e:	a7 95       	ror	r26
    3680:	97 95       	ror	r25
    3682:	87 95       	ror	r24
    3684:	81 95       	neg	r24
    3686:	80 93 98 01 	sts	0x0198, r24
    #endif

    // Enable Stepper Driver Interrupt
    TIMSK1 |= (1<<OCIE1A);
    368a:	ef e6       	ldi	r30, 0x6F	; 111
    368c:	f0 e0       	ldi	r31, 0x00	; 0
    368e:	80 81       	ld	r24, Z
    3690:	82 60       	ori	r24, 0x02	; 2
    3692:	80 83       	st	Z, r24
    3694:	08 95       	ret

00003696 <st_go_idle>:

// Stepper shutdown
void st_go_idle() 
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    3696:	ef e6       	ldi	r30, 0x6F	; 111
    3698:	f0 e0       	ldi	r31, 0x00	; 0
    369a:	80 81       	ld	r24, Z
    369c:	8d 7f       	andi	r24, 0xFD	; 253
    369e:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    36a0:	e1 e8       	ldi	r30, 0x81	; 129
    36a2:	f0 e0       	ldi	r31, 0x00	; 0
    36a4:	80 81       	ld	r24, Z
    36a6:	88 7f       	andi	r24, 0xF8	; 248
    36a8:	81 60       	ori	r24, 0x01	; 1
    36aa:	80 83       	st	Z, r24
  busy = false;
    36ac:	10 92 85 01 	sts	0x0185, r1
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys.rt_exec_alarm) && sys.state != STATE_HOMING) {
    36b0:	80 91 32 09 	lds	r24, 0x0932
    36b4:	8f 3f       	cpi	r24, 0xFF	; 255
    36b6:	21 f4       	brne	.+8      	; 0x36c0 <st_go_idle+0x2a>
    36b8:	90 91 6b 07 	lds	r25, 0x076B
    36bc:	99 23       	and	r25, r25
    36be:	49 f0       	breq	.+18     	; 0x36d2 <st_go_idle+0x3c>
    36c0:	90 91 68 07 	lds	r25, 0x0768
    36c4:	94 30       	cpi	r25, 0x04	; 4
    36c6:	39 f0       	breq	.+14     	; 0x36d6 <st_go_idle+0x40>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    36c8:	90 e0       	ldi	r25, 0x00	; 0
    36ca:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <delay_ms>
    pin_state = true; // Override. Disable steppers.
    36ce:	81 e0       	ldi	r24, 0x01	; 1
    36d0:	03 c0       	rjmp	.+6      	; 0x36d8 <st_go_idle+0x42>
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
  busy = false;
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
    36d2:	80 e0       	ldi	r24, 0x00	; 0
    36d4:	01 c0       	rjmp	.+2      	; 0x36d8 <st_go_idle+0x42>
    36d6:	80 e0       	ldi	r24, 0x00	; 0
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    36d8:	90 91 3c 09 	lds	r25, 0x093C
    36dc:	92 ff       	sbrs	r25, 2
    36de:	02 c0       	rjmp	.+4      	; 0x36e4 <st_go_idle+0x4e>
    36e0:	91 e0       	ldi	r25, 0x01	; 1
    36e2:	89 27       	eor	r24, r25
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    36e4:	88 23       	and	r24, r24
    36e6:	11 f0       	breq	.+4      	; 0x36ec <st_go_idle+0x56>
    36e8:	28 9a       	sbi	0x05, 0	; 5
    36ea:	01 c0       	rjmp	.+2      	; 0x36ee <st_go_idle+0x58>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    36ec:	28 98       	cbi	0x05, 0	; 5
	  
  #ifdef LED_PRESENT
  LED_PORT |= (1<<LED_RUN_BIT); // active low, so set high
    36ee:	44 9a       	sbi	0x08, 4	; 8
    36f0:	08 95       	ret

000036f2 <__vector_13>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated 
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{        
    36f2:	1f 92       	push	r1
    36f4:	0f 92       	push	r0
    36f6:	0f b6       	in	r0, 0x3f	; 63
    36f8:	0f 92       	push	r0
    36fa:	11 24       	eor	r1, r1
    36fc:	2f 93       	push	r18
    36fe:	3f 93       	push	r19
    3700:	4f 93       	push	r20
    3702:	5f 93       	push	r21
    3704:	6f 93       	push	r22
    3706:	7f 93       	push	r23
    3708:	8f 93       	push	r24
    370a:	9f 93       	push	r25
    370c:	af 93       	push	r26
    370e:	bf 93       	push	r27
    3710:	cf 93       	push	r28
    3712:	df 93       	push	r29
    3714:	ef 93       	push	r30
    3716:	ff 93       	push	r31
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    3718:	80 91 85 01 	lds	r24, 0x0185
    371c:	81 11       	cpse	r24, r1
    371e:	ec c1       	rjmp	.+984    	; 0x3af8 <__vector_13+0x406>
  
  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    3720:	8b b1       	in	r24, 0x0b	; 11
    3722:	90 91 9a 01 	lds	r25, 0x019A
    3726:	98 7a       	andi	r25, 0xA8	; 168
    3728:	87 75       	andi	r24, 0x57	; 87
    372a:	89 2b       	or	r24, r25
    372c:	8b b9       	out	0x0b, r24	; 11

  // Then pulse the stepping pins
  #ifdef STEP_PULSE_DELAY
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    372e:	8b b1       	in	r24, 0x0b	; 11
    3730:	8b 7a       	andi	r24, 0xAB	; 171
    3732:	90 91 99 01 	lds	r25, 0x0199
    3736:	89 2b       	or	r24, r25
    3738:	8b b9       	out	0x0b, r24	; 11
  #endif  

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    373a:	80 91 98 01 	lds	r24, 0x0198
    373e:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    3740:	82 e0       	ldi	r24, 0x02	; 2
    3742:	85 bd       	out	0x25, r24	; 37

  busy = true;
    3744:	81 e0       	ldi	r24, 0x01	; 1
    3746:	80 93 85 01 	sts	0x0185, r24
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. 
    374a:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.
    
  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    374c:	80 91 ac 01 	lds	r24, 0x01AC
    3750:	90 91 ad 01 	lds	r25, 0x01AD
    3754:	89 2b       	or	r24, r25
    3756:	09 f0       	breq	.+2      	; 0x375a <__vector_13+0x68>
    3758:	a9 c0       	rjmp	.+338    	; 0x38ac <__vector_13+0x1ba>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    375a:	80 91 8a 01 	lds	r24, 0x018A
    375e:	90 91 89 01 	lds	r25, 0x0189
    3762:	98 17       	cp	r25, r24
    3764:	09 f4       	brne	.+2      	; 0x3768 <__vector_13+0x76>
    3766:	97 c0       	rjmp	.+302    	; 0x3896 <__vector_13+0x1a4>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    3768:	80 91 8a 01 	lds	r24, 0x018A
    376c:	90 e0       	ldi	r25, 0x00	; 0
    376e:	fc 01       	movw	r30, r24
    3770:	ee 0f       	add	r30, r30
    3772:	ff 1f       	adc	r31, r31
    3774:	8e 0f       	add	r24, r30
    3776:	9f 1f       	adc	r25, r31
    3778:	fc 01       	movw	r30, r24
    377a:	ee 0f       	add	r30, r30
    377c:	ff 1f       	adc	r31, r31
    377e:	e2 55       	subi	r30, 0x52	; 82
    3780:	fe 4f       	sbci	r31, 0xFE	; 254
    3782:	f0 93 ad 01 	sts	0x01AD, r31
    3786:	e0 93 ac 01 	sts	0x01AC, r30
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    378a:	83 81       	ldd	r24, Z+3	; 0x03
    378c:	94 81       	ldd	r25, Z+4	; 0x04
    378e:	90 93 89 00 	sts	0x0089, r25
    3792:	80 93 88 00 	sts	0x0088, r24
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    3796:	80 81       	ld	r24, Z
    3798:	91 81       	ldd	r25, Z+1	; 0x01
    379a:	90 93 a8 01 	sts	0x01A8, r25
    379e:	80 93 a7 01 	sts	0x01A7, r24
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    37a2:	a2 81       	ldd	r26, Z+2	; 0x02
    37a4:	80 91 a9 01 	lds	r24, 0x01A9
    37a8:	8a 17       	cp	r24, r26
    37aa:	71 f1       	breq	.+92     	; 0x3808 <__vector_13+0x116>
        st.exec_block_index = st.exec_segment->st_block_index;
    37ac:	a0 93 a9 01 	sts	0x01A9, r26
        st.exec_block = &st_block_buffer[st.exec_block_index];
    37b0:	81 e1       	ldi	r24, 0x11	; 17
    37b2:	a8 9f       	mul	r26, r24
    37b4:	d0 01       	movw	r26, r0
    37b6:	11 24       	eor	r1, r1
    37b8:	ae 52       	subi	r26, 0x2E	; 46
    37ba:	be 4f       	sbci	r27, 0xFE	; 254
    37bc:	b0 93 ab 01 	sts	0x01AB, r27
    37c0:	a0 93 aa 01 	sts	0x01AA, r26
        
        // Initialize Bresenham line and distance counters
        st.counter_x = (st.exec_block->step_event_count >> 1);
    37c4:	1d 96       	adiw	r26, 0x0d	; 13
    37c6:	8d 91       	ld	r24, X+
    37c8:	9d 91       	ld	r25, X+
    37ca:	0d 90       	ld	r0, X+
    37cc:	bc 91       	ld	r27, X
    37ce:	a0 2d       	mov	r26, r0
    37d0:	b6 95       	lsr	r27
    37d2:	a7 95       	ror	r26
    37d4:	97 95       	ror	r25
    37d6:	87 95       	ror	r24
    37d8:	80 93 8b 01 	sts	0x018B, r24
    37dc:	90 93 8c 01 	sts	0x018C, r25
    37e0:	a0 93 8d 01 	sts	0x018D, r26
    37e4:	b0 93 8e 01 	sts	0x018E, r27
        st.counter_y = st.counter_x;
    37e8:	80 93 8f 01 	sts	0x018F, r24
    37ec:	90 93 90 01 	sts	0x0190, r25
    37f0:	a0 93 91 01 	sts	0x0191, r26
    37f4:	b0 93 92 01 	sts	0x0192, r27
        st.counter_z = st.counter_x;        
    37f8:	80 93 93 01 	sts	0x0193, r24
    37fc:	90 93 94 01 	sts	0x0194, r25
    3800:	a0 93 95 01 	sts	0x0195, r26
    3804:	b0 93 96 01 	sts	0x0196, r27
      }

      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask; 
    3808:	c0 91 aa 01 	lds	r28, 0x01AA
    380c:	d0 91 ab 01 	lds	r29, 0x01AB
    3810:	90 91 86 01 	lds	r25, 0x0186
    3814:	88 81       	ld	r24, Y
    3816:	89 27       	eor	r24, r25
    3818:	80 93 9a 01 	sts	0x019A, r24

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    381c:	89 81       	ldd	r24, Y+1	; 0x01
    381e:	9a 81       	ldd	r25, Y+2	; 0x02
    3820:	ab 81       	ldd	r26, Y+3	; 0x03
    3822:	bc 81       	ldd	r27, Y+4	; 0x04
    3824:	05 80       	ldd	r0, Z+5	; 0x05
    3826:	04 c0       	rjmp	.+8      	; 0x3830 <__vector_13+0x13e>
    3828:	b6 95       	lsr	r27
    382a:	a7 95       	ror	r26
    382c:	97 95       	ror	r25
    382e:	87 95       	ror	r24
    3830:	0a 94       	dec	r0
    3832:	d2 f7       	brpl	.-12     	; 0x3828 <__vector_13+0x136>
    3834:	80 93 9b 01 	sts	0x019B, r24
    3838:	90 93 9c 01 	sts	0x019C, r25
    383c:	a0 93 9d 01 	sts	0x019D, r26
    3840:	b0 93 9e 01 	sts	0x019E, r27
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    3844:	8d 81       	ldd	r24, Y+5	; 0x05
    3846:	9e 81       	ldd	r25, Y+6	; 0x06
    3848:	af 81       	ldd	r26, Y+7	; 0x07
    384a:	b8 85       	ldd	r27, Y+8	; 0x08
    384c:	05 80       	ldd	r0, Z+5	; 0x05
    384e:	04 c0       	rjmp	.+8      	; 0x3858 <__vector_13+0x166>
    3850:	b6 95       	lsr	r27
    3852:	a7 95       	ror	r26
    3854:	97 95       	ror	r25
    3856:	87 95       	ror	r24
    3858:	0a 94       	dec	r0
    385a:	d2 f7       	brpl	.-12     	; 0x3850 <__vector_13+0x15e>
    385c:	80 93 9f 01 	sts	0x019F, r24
    3860:	90 93 a0 01 	sts	0x01A0, r25
    3864:	a0 93 a1 01 	sts	0x01A1, r26
    3868:	b0 93 a2 01 	sts	0x01A2, r27
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    386c:	89 85       	ldd	r24, Y+9	; 0x09
    386e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3870:	ab 85       	ldd	r26, Y+11	; 0x0b
    3872:	bc 85       	ldd	r27, Y+12	; 0x0c
    3874:	05 80       	ldd	r0, Z+5	; 0x05
    3876:	04 c0       	rjmp	.+8      	; 0x3880 <__vector_13+0x18e>
    3878:	b6 95       	lsr	r27
    387a:	a7 95       	ror	r26
    387c:	97 95       	ror	r25
    387e:	87 95       	ror	r24
    3880:	0a 94       	dec	r0
    3882:	d2 f7       	brpl	.-12     	; 0x3878 <__vector_13+0x186>
    3884:	80 93 a3 01 	sts	0x01A3, r24
    3888:	90 93 a4 01 	sts	0x01A4, r25
    388c:	a0 93 a5 01 	sts	0x01A5, r26
    3890:	b0 93 a6 01 	sts	0x01A6, r27
    3894:	0b c0       	rjmp	.+22     	; 0x38ac <__vector_13+0x1ba>
      #endif
      
    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    3896:	0e 94 4b 1b 	call	0x3696	; 0x3696 <st_go_idle>
      bit_true_atomic(sys.rt_exec_state,EXEC_CYCLE_STOP); // Flag main program for cycle end
    389a:	8f b7       	in	r24, 0x3f	; 63
    389c:	f8 94       	cli
    389e:	ea e6       	ldi	r30, 0x6A	; 106
    38a0:	f7 e0       	ldi	r31, 0x07	; 7
    38a2:	90 81       	ld	r25, Z
    38a4:	94 60       	ori	r25, 0x04	; 4
    38a6:	90 83       	st	Z, r25
    38a8:	8f bf       	out	0x3f, r24	; 63
      return; // Nothing to do but exit.
    38aa:	26 c1       	rjmp	.+588    	; 0x3af8 <__vector_13+0x406>
    }  
  }
  
  
  // Check probing state.
  probe_state_monitor();
    38ac:	0e 94 28 34 	call	0x6850	; 0x6850 <probe_state_monitor>
   
  // Reset step out bits.
  st.step_outbits = 0; 
    38b0:	10 92 99 01 	sts	0x0199, r1

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    38b4:	eb e8       	ldi	r30, 0x8B	; 139
    38b6:	f1 e0       	ldi	r31, 0x01	; 1
    38b8:	40 91 9b 01 	lds	r20, 0x019B
    38bc:	50 91 9c 01 	lds	r21, 0x019C
    38c0:	60 91 9d 01 	lds	r22, 0x019D
    38c4:	70 91 9e 01 	lds	r23, 0x019E
    38c8:	80 81       	ld	r24, Z
    38ca:	91 81       	ldd	r25, Z+1	; 0x01
    38cc:	a2 81       	ldd	r26, Z+2	; 0x02
    38ce:	b3 81       	ldd	r27, Z+3	; 0x03
    38d0:	84 0f       	add	r24, r20
    38d2:	95 1f       	adc	r25, r21
    38d4:	a6 1f       	adc	r26, r22
    38d6:	b7 1f       	adc	r27, r23
    38d8:	80 83       	st	Z, r24
    38da:	91 83       	std	Z+1, r25	; 0x01
    38dc:	a2 83       	std	Z+2, r26	; 0x02
    38de:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif  
  if (st.counter_x > st.exec_block->step_event_count) {
    38e0:	e0 91 aa 01 	lds	r30, 0x01AA
    38e4:	f0 91 ab 01 	lds	r31, 0x01AB
    38e8:	45 85       	ldd	r20, Z+13	; 0x0d
    38ea:	56 85       	ldd	r21, Z+14	; 0x0e
    38ec:	67 85       	ldd	r22, Z+15	; 0x0f
    38ee:	70 89       	ldd	r23, Z+16	; 0x10
    38f0:	48 17       	cp	r20, r24
    38f2:	59 07       	cpc	r21, r25
    38f4:	6a 07       	cpc	r22, r26
    38f6:	7b 07       	cpc	r23, r27
    38f8:	88 f5       	brcc	.+98     	; 0x395c <__vector_13+0x26a>
    st.step_outbits |= (1<<X_STEP_BIT);
    38fa:	20 e4       	ldi	r18, 0x40	; 64
    38fc:	20 93 99 01 	sts	0x0199, r18
    st.counter_x -= st.exec_block->step_event_count;
    3900:	45 85       	ldd	r20, Z+13	; 0x0d
    3902:	56 85       	ldd	r21, Z+14	; 0x0e
    3904:	67 85       	ldd	r22, Z+15	; 0x0f
    3906:	70 89       	ldd	r23, Z+16	; 0x10
    3908:	84 1b       	sub	r24, r20
    390a:	95 0b       	sbc	r25, r21
    390c:	a6 0b       	sbc	r26, r22
    390e:	b7 0b       	sbc	r27, r23
    3910:	80 93 8b 01 	sts	0x018B, r24
    3914:	90 93 8c 01 	sts	0x018C, r25
    3918:	a0 93 8d 01 	sts	0x018D, r26
    391c:	b0 93 8e 01 	sts	0x018E, r27
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys.position[X_AXIS]--; }
    3920:	80 81       	ld	r24, Z
    3922:	88 23       	and	r24, r24
    3924:	74 f4       	brge	.+28     	; 0x3942 <__vector_13+0x250>
    3926:	cc e6       	ldi	r28, 0x6C	; 108
    3928:	d7 e0       	ldi	r29, 0x07	; 7
    392a:	88 81       	ld	r24, Y
    392c:	99 81       	ldd	r25, Y+1	; 0x01
    392e:	aa 81       	ldd	r26, Y+2	; 0x02
    3930:	bb 81       	ldd	r27, Y+3	; 0x03
    3932:	01 97       	sbiw	r24, 0x01	; 1
    3934:	a1 09       	sbc	r26, r1
    3936:	b1 09       	sbc	r27, r1
    3938:	88 83       	st	Y, r24
    393a:	99 83       	std	Y+1, r25	; 0x01
    393c:	aa 83       	std	Y+2, r26	; 0x02
    393e:	bb 83       	std	Y+3, r27	; 0x03
    3940:	0d c0       	rjmp	.+26     	; 0x395c <__vector_13+0x26a>
    else { sys.position[X_AXIS]++; }
    3942:	cc e6       	ldi	r28, 0x6C	; 108
    3944:	d7 e0       	ldi	r29, 0x07	; 7
    3946:	88 81       	ld	r24, Y
    3948:	99 81       	ldd	r25, Y+1	; 0x01
    394a:	aa 81       	ldd	r26, Y+2	; 0x02
    394c:	bb 81       	ldd	r27, Y+3	; 0x03
    394e:	01 96       	adiw	r24, 0x01	; 1
    3950:	a1 1d       	adc	r26, r1
    3952:	b1 1d       	adc	r27, r1
    3954:	88 83       	st	Y, r24
    3956:	99 83       	std	Y+1, r25	; 0x01
    3958:	aa 83       	std	Y+2, r26	; 0x02
    395a:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    395c:	cf e8       	ldi	r28, 0x8F	; 143
    395e:	d1 e0       	ldi	r29, 0x01	; 1
    3960:	40 91 9f 01 	lds	r20, 0x019F
    3964:	50 91 a0 01 	lds	r21, 0x01A0
    3968:	60 91 a1 01 	lds	r22, 0x01A1
    396c:	70 91 a2 01 	lds	r23, 0x01A2
    3970:	88 81       	ld	r24, Y
    3972:	99 81       	ldd	r25, Y+1	; 0x01
    3974:	aa 81       	ldd	r26, Y+2	; 0x02
    3976:	bb 81       	ldd	r27, Y+3	; 0x03
    3978:	84 0f       	add	r24, r20
    397a:	95 1f       	adc	r25, r21
    397c:	a6 1f       	adc	r26, r22
    397e:	b7 1f       	adc	r27, r23
    3980:	88 83       	st	Y, r24
    3982:	99 83       	std	Y+1, r25	; 0x01
    3984:	aa 83       	std	Y+2, r26	; 0x02
    3986:	bb 83       	std	Y+3, r27	; 0x03
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif    
  if (st.counter_y > st.exec_block->step_event_count) {
    3988:	45 85       	ldd	r20, Z+13	; 0x0d
    398a:	56 85       	ldd	r21, Z+14	; 0x0e
    398c:	67 85       	ldd	r22, Z+15	; 0x0f
    398e:	70 89       	ldd	r23, Z+16	; 0x10
    3990:	48 17       	cp	r20, r24
    3992:	59 07       	cpc	r21, r25
    3994:	6a 07       	cpc	r22, r26
    3996:	7b 07       	cpc	r23, r27
    3998:	98 f5       	brcc	.+102    	; 0x3a00 <__vector_13+0x30e>
    st.step_outbits |= (1<<Y_STEP_BIT);
    399a:	c9 e9       	ldi	r28, 0x99	; 153
    399c:	d1 e0       	ldi	r29, 0x01	; 1
    399e:	28 81       	ld	r18, Y
    39a0:	20 61       	ori	r18, 0x10	; 16
    39a2:	28 83       	st	Y, r18
    st.counter_y -= st.exec_block->step_event_count;
    39a4:	45 85       	ldd	r20, Z+13	; 0x0d
    39a6:	56 85       	ldd	r21, Z+14	; 0x0e
    39a8:	67 85       	ldd	r22, Z+15	; 0x0f
    39aa:	70 89       	ldd	r23, Z+16	; 0x10
    39ac:	84 1b       	sub	r24, r20
    39ae:	95 0b       	sbc	r25, r21
    39b0:	a6 0b       	sbc	r26, r22
    39b2:	b7 0b       	sbc	r27, r23
    39b4:	80 93 8f 01 	sts	0x018F, r24
    39b8:	90 93 90 01 	sts	0x0190, r25
    39bc:	a0 93 91 01 	sts	0x0191, r26
    39c0:	b0 93 92 01 	sts	0x0192, r27
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys.position[Y_AXIS]--; }
    39c4:	80 81       	ld	r24, Z
    39c6:	85 ff       	sbrs	r24, 5
    39c8:	0e c0       	rjmp	.+28     	; 0x39e6 <__vector_13+0x2f4>
    39ca:	c0 e7       	ldi	r28, 0x70	; 112
    39cc:	d7 e0       	ldi	r29, 0x07	; 7
    39ce:	88 81       	ld	r24, Y
    39d0:	99 81       	ldd	r25, Y+1	; 0x01
    39d2:	aa 81       	ldd	r26, Y+2	; 0x02
    39d4:	bb 81       	ldd	r27, Y+3	; 0x03
    39d6:	01 97       	sbiw	r24, 0x01	; 1
    39d8:	a1 09       	sbc	r26, r1
    39da:	b1 09       	sbc	r27, r1
    39dc:	88 83       	st	Y, r24
    39de:	99 83       	std	Y+1, r25	; 0x01
    39e0:	aa 83       	std	Y+2, r26	; 0x02
    39e2:	bb 83       	std	Y+3, r27	; 0x03
    39e4:	0d c0       	rjmp	.+26     	; 0x3a00 <__vector_13+0x30e>
    else { sys.position[Y_AXIS]++; }
    39e6:	c0 e7       	ldi	r28, 0x70	; 112
    39e8:	d7 e0       	ldi	r29, 0x07	; 7
    39ea:	88 81       	ld	r24, Y
    39ec:	99 81       	ldd	r25, Y+1	; 0x01
    39ee:	aa 81       	ldd	r26, Y+2	; 0x02
    39f0:	bb 81       	ldd	r27, Y+3	; 0x03
    39f2:	01 96       	adiw	r24, 0x01	; 1
    39f4:	a1 1d       	adc	r26, r1
    39f6:	b1 1d       	adc	r27, r1
    39f8:	88 83       	st	Y, r24
    39fa:	99 83       	std	Y+1, r25	; 0x01
    39fc:	aa 83       	std	Y+2, r26	; 0x02
    39fe:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    3a00:	c3 e9       	ldi	r28, 0x93	; 147
    3a02:	d1 e0       	ldi	r29, 0x01	; 1
    3a04:	40 91 a3 01 	lds	r20, 0x01A3
    3a08:	50 91 a4 01 	lds	r21, 0x01A4
    3a0c:	60 91 a5 01 	lds	r22, 0x01A5
    3a10:	70 91 a6 01 	lds	r23, 0x01A6
    3a14:	88 81       	ld	r24, Y
    3a16:	99 81       	ldd	r25, Y+1	; 0x01
    3a18:	aa 81       	ldd	r26, Y+2	; 0x02
    3a1a:	bb 81       	ldd	r27, Y+3	; 0x03
    3a1c:	84 0f       	add	r24, r20
    3a1e:	95 1f       	adc	r25, r21
    3a20:	a6 1f       	adc	r26, r22
    3a22:	b7 1f       	adc	r27, r23
    3a24:	88 83       	st	Y, r24
    3a26:	99 83       	std	Y+1, r25	; 0x01
    3a28:	aa 83       	std	Y+2, r26	; 0x02
    3a2a:	bb 83       	std	Y+3, r27	; 0x03
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif  
  if (st.counter_z > st.exec_block->step_event_count) {
    3a2c:	45 85       	ldd	r20, Z+13	; 0x0d
    3a2e:	56 85       	ldd	r21, Z+14	; 0x0e
    3a30:	67 85       	ldd	r22, Z+15	; 0x0f
    3a32:	70 89       	ldd	r23, Z+16	; 0x10
    3a34:	48 17       	cp	r20, r24
    3a36:	59 07       	cpc	r21, r25
    3a38:	6a 07       	cpc	r22, r26
    3a3a:	7b 07       	cpc	r23, r27
    3a3c:	98 f5       	brcc	.+102    	; 0x3aa4 <__vector_13+0x3b2>
    st.step_outbits |= (1<<Z_STEP_BIT);
    3a3e:	c9 e9       	ldi	r28, 0x99	; 153
    3a40:	d1 e0       	ldi	r29, 0x01	; 1
    3a42:	28 81       	ld	r18, Y
    3a44:	24 60       	ori	r18, 0x04	; 4
    3a46:	28 83       	st	Y, r18
    st.counter_z -= st.exec_block->step_event_count;
    3a48:	45 85       	ldd	r20, Z+13	; 0x0d
    3a4a:	56 85       	ldd	r21, Z+14	; 0x0e
    3a4c:	67 85       	ldd	r22, Z+15	; 0x0f
    3a4e:	70 89       	ldd	r23, Z+16	; 0x10
    3a50:	84 1b       	sub	r24, r20
    3a52:	95 0b       	sbc	r25, r21
    3a54:	a6 0b       	sbc	r26, r22
    3a56:	b7 0b       	sbc	r27, r23
    3a58:	80 93 93 01 	sts	0x0193, r24
    3a5c:	90 93 94 01 	sts	0x0194, r25
    3a60:	a0 93 95 01 	sts	0x0195, r26
    3a64:	b0 93 96 01 	sts	0x0196, r27
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys.position[Z_AXIS]--; }
    3a68:	80 81       	ld	r24, Z
    3a6a:	83 ff       	sbrs	r24, 3
    3a6c:	0e c0       	rjmp	.+28     	; 0x3a8a <__vector_13+0x398>
    3a6e:	e4 e7       	ldi	r30, 0x74	; 116
    3a70:	f7 e0       	ldi	r31, 0x07	; 7
    3a72:	80 81       	ld	r24, Z
    3a74:	91 81       	ldd	r25, Z+1	; 0x01
    3a76:	a2 81       	ldd	r26, Z+2	; 0x02
    3a78:	b3 81       	ldd	r27, Z+3	; 0x03
    3a7a:	01 97       	sbiw	r24, 0x01	; 1
    3a7c:	a1 09       	sbc	r26, r1
    3a7e:	b1 09       	sbc	r27, r1
    3a80:	80 83       	st	Z, r24
    3a82:	91 83       	std	Z+1, r25	; 0x01
    3a84:	a2 83       	std	Z+2, r26	; 0x02
    3a86:	b3 83       	std	Z+3, r27	; 0x03
    3a88:	0d c0       	rjmp	.+26     	; 0x3aa4 <__vector_13+0x3b2>
    else { sys.position[Z_AXIS]++; }
    3a8a:	e4 e7       	ldi	r30, 0x74	; 116
    3a8c:	f7 e0       	ldi	r31, 0x07	; 7
    3a8e:	80 81       	ld	r24, Z
    3a90:	91 81       	ldd	r25, Z+1	; 0x01
    3a92:	a2 81       	ldd	r26, Z+2	; 0x02
    3a94:	b3 81       	ldd	r27, Z+3	; 0x03
    3a96:	01 96       	adiw	r24, 0x01	; 1
    3a98:	a1 1d       	adc	r26, r1
    3a9a:	b1 1d       	adc	r27, r1
    3a9c:	80 83       	st	Z, r24
    3a9e:	91 83       	std	Z+1, r25	; 0x01
    3aa0:	a2 83       	std	Z+2, r26	; 0x02
    3aa2:	b3 83       	std	Z+3, r27	; 0x03
  }  

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }   
    3aa4:	80 91 68 07 	lds	r24, 0x0768
    3aa8:	84 30       	cpi	r24, 0x04	; 4
    3aaa:	39 f4       	brne	.+14     	; 0x3aba <__vector_13+0x3c8>
    3aac:	e9 e9       	ldi	r30, 0x99	; 153
    3aae:	f1 e0       	ldi	r31, 0x01	; 1
    3ab0:	90 91 78 07 	lds	r25, 0x0778
    3ab4:	80 81       	ld	r24, Z
    3ab6:	89 23       	and	r24, r25
    3ab8:	80 83       	st	Z, r24

  st.step_count--; // Decrement step events count 
    3aba:	e7 ea       	ldi	r30, 0xA7	; 167
    3abc:	f1 e0       	ldi	r31, 0x01	; 1
    3abe:	80 81       	ld	r24, Z
    3ac0:	91 81       	ldd	r25, Z+1	; 0x01
    3ac2:	01 97       	sbiw	r24, 0x01	; 1
    3ac4:	91 83       	std	Z+1, r25	; 0x01
    3ac6:	80 83       	st	Z, r24
  if (st.step_count == 0) {
    3ac8:	89 2b       	or	r24, r25
    3aca:	69 f4       	brne	.+26     	; 0x3ae6 <__vector_13+0x3f4>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    3acc:	10 92 ad 01 	sts	0x01AD, r1
    3ad0:	10 92 ac 01 	sts	0x01AC, r1
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    3ad4:	80 91 8a 01 	lds	r24, 0x018A
    3ad8:	8f 5f       	subi	r24, 0xFF	; 255
    3ada:	80 93 8a 01 	sts	0x018A, r24
    3ade:	86 30       	cpi	r24, 0x06	; 6
    3ae0:	11 f4       	brne	.+4      	; 0x3ae6 <__vector_13+0x3f4>
    3ae2:	10 92 8a 01 	sts	0x018A, r1
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask    
    3ae6:	e9 e9       	ldi	r30, 0x99	; 153
    3ae8:	f1 e0       	ldi	r31, 0x01	; 1
    3aea:	90 91 87 01 	lds	r25, 0x0187
    3aee:	80 81       	ld	r24, Z
    3af0:	89 27       	eor	r24, r25
    3af2:	80 83       	st	Z, r24
  busy = false;
    3af4:	10 92 85 01 	sts	0x0185, r1
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
}
    3af8:	ff 91       	pop	r31
    3afa:	ef 91       	pop	r30
    3afc:	df 91       	pop	r29
    3afe:	cf 91       	pop	r28
    3b00:	bf 91       	pop	r27
    3b02:	af 91       	pop	r26
    3b04:	9f 91       	pop	r25
    3b06:	8f 91       	pop	r24
    3b08:	7f 91       	pop	r23
    3b0a:	6f 91       	pop	r22
    3b0c:	5f 91       	pop	r21
    3b0e:	4f 91       	pop	r20
    3b10:	3f 91       	pop	r19
    3b12:	2f 91       	pop	r18
    3b14:	0f 90       	pop	r0
    3b16:	0f be       	out	0x3f, r0	; 63
    3b18:	0f 90       	pop	r0
    3b1a:	1f 90       	pop	r1
    3b1c:	18 95       	reti

00003b1e <__vector_18>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) 
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    3b1e:	1f 92       	push	r1
    3b20:	0f 92       	push	r0
    3b22:	0f b6       	in	r0, 0x3f	; 63
    3b24:	0f 92       	push	r0
    3b26:	11 24       	eor	r1, r1
    3b28:	8f 93       	push	r24
    3b2a:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK); 
    3b2c:	8b b1       	in	r24, 0x0b	; 11
    3b2e:	90 91 87 01 	lds	r25, 0x0187
    3b32:	94 75       	andi	r25, 0x54	; 84
    3b34:	8b 7a       	andi	r24, 0xAB	; 171
    3b36:	89 2b       	or	r24, r25
    3b38:	8b b9       	out	0x0b, r24	; 11
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed. 
    3b3a:	15 bc       	out	0x25, r1	; 37
}
    3b3c:	9f 91       	pop	r25
    3b3e:	8f 91       	pop	r24
    3b40:	0f 90       	pop	r0
    3b42:	0f be       	out	0x3f, r0	; 63
    3b44:	0f 90       	pop	r0
    3b46:	1f 90       	pop	r1
    3b48:	18 95       	reti

00003b4a <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{  
    3b4a:	cf 92       	push	r12
    3b4c:	df 92       	push	r13
    3b4e:	ef 92       	push	r14
    3b50:	ff 92       	push	r15
    3b52:	0f 93       	push	r16
    3b54:	1f 93       	push	r17
    3b56:	cf 93       	push	r28
    3b58:	df 93       	push	r29
  uint8_t idx;
  step_port_invert_mask = 0;
    3b5a:	10 92 87 01 	sts	0x0187, r1
  dir_port_invert_mask = 0;
    3b5e:	10 92 86 01 	sts	0x0186, r1
    3b62:	c0 e0       	ldi	r28, 0x00	; 0
    3b64:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    3b66:	0f 2e       	mov	r0, r31
    3b68:	f0 e3       	ldi	r31, 0x30	; 48
    3b6a:	ef 2e       	mov	r14, r31
    3b6c:	f9 e0       	ldi	r31, 0x09	; 9
    3b6e:	ff 2e       	mov	r15, r31
    3b70:	f0 2d       	mov	r31, r0
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3b72:	01 e3       	ldi	r16, 0x31	; 49
    3b74:	19 e0       	ldi	r17, 0x09	; 9
    3b76:	cc 2e       	mov	r12, r28
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    3b78:	dc 2e       	mov	r13, r28
    3b7a:	f7 01       	movw	r30, r14
    3b7c:	40 81       	ld	r20, Z
    3b7e:	50 e0       	ldi	r21, 0x00	; 0
    3b80:	0c 2e       	mov	r0, r28
    3b82:	02 c0       	rjmp	.+4      	; 0x3b88 <st_generate_step_dir_invert_masks+0x3e>
    3b84:	55 95       	asr	r21
    3b86:	47 95       	ror	r20
    3b88:	0a 94       	dec	r0
    3b8a:	e2 f7       	brpl	.-8      	; 0x3b84 <st_generate_step_dir_invert_masks+0x3a>
    3b8c:	40 ff       	sbrs	r20, 0
    3b8e:	08 c0       	rjmp	.+16     	; 0x3ba0 <st_generate_step_dir_invert_masks+0x56>
    3b90:	8c 2f       	mov	r24, r28
    3b92:	0e 94 e6 28 	call	0x51cc	; 0x51cc <get_step_pin_mask>
    3b96:	90 91 87 01 	lds	r25, 0x0187
    3b9a:	89 2b       	or	r24, r25
    3b9c:	80 93 87 01 	sts	0x0187, r24
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3ba0:	f8 01       	movw	r30, r16
    3ba2:	20 81       	ld	r18, Z
    3ba4:	30 e0       	ldi	r19, 0x00	; 0
    3ba6:	02 c0       	rjmp	.+4      	; 0x3bac <st_generate_step_dir_invert_masks+0x62>
    3ba8:	35 95       	asr	r19
    3baa:	27 95       	ror	r18
    3bac:	da 94       	dec	r13
    3bae:	e2 f7       	brpl	.-8      	; 0x3ba8 <st_generate_step_dir_invert_masks+0x5e>
    3bb0:	20 ff       	sbrs	r18, 0
    3bb2:	08 c0       	rjmp	.+16     	; 0x3bc4 <st_generate_step_dir_invert_masks+0x7a>
    3bb4:	8c 2d       	mov	r24, r12
    3bb6:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <get_direction_pin_mask>
    3bba:	90 91 86 01 	lds	r25, 0x0186
    3bbe:	89 2b       	or	r24, r25
    3bc0:	80 93 86 01 	sts	0x0186, r24
    3bc4:	21 96       	adiw	r28, 0x01	; 1
void st_generate_step_dir_invert_masks()
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    3bc6:	c3 30       	cpi	r28, 0x03	; 3
    3bc8:	d1 05       	cpc	r29, r1
    3bca:	a9 f6       	brne	.-86     	; 0x3b76 <st_generate_step_dir_invert_masks+0x2c>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
  }
}
    3bcc:	df 91       	pop	r29
    3bce:	cf 91       	pop	r28
    3bd0:	1f 91       	pop	r17
    3bd2:	0f 91       	pop	r16
    3bd4:	ff 90       	pop	r15
    3bd6:	ef 90       	pop	r14
    3bd8:	df 90       	pop	r13
    3bda:	cf 90       	pop	r12
    3bdc:	08 95       	ret

00003bde <st_reset>:

// Reset and clear stepper subsystem variables
void st_reset()
{
  // Initialize stepper driver idle state.
  st_go_idle();
    3bde:	0e 94 4b 1b 	call	0x3696	; 0x3696 <st_go_idle>
  
  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(prep));
    3be2:	8b e2       	ldi	r24, 0x2B	; 43
    3be4:	e6 e5       	ldi	r30, 0x56	; 86
    3be6:	f1 e0       	ldi	r31, 0x01	; 1
    3be8:	df 01       	movw	r26, r30
    3bea:	1d 92       	st	X+, r1
    3bec:	8a 95       	dec	r24
    3bee:	e9 f7       	brne	.-6      	; 0x3bea <st_reset+0xc>
  memset(&st, 0, sizeof(st));
    3bf0:	83 e2       	ldi	r24, 0x23	; 35
    3bf2:	eb e8       	ldi	r30, 0x8B	; 139
    3bf4:	f1 e0       	ldi	r31, 0x01	; 1
    3bf6:	df 01       	movw	r26, r30
    3bf8:	1d 92       	st	X+, r1
    3bfa:	8a 95       	dec	r24
    3bfc:	e9 f7       	brne	.-6      	; 0x3bf8 <st_reset+0x1a>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    3bfe:	10 92 84 01 	sts	0x0184, r1
    3c02:	10 92 83 01 	sts	0x0183, r1
  segment_buffer_tail = 0;
    3c06:	10 92 8a 01 	sts	0x018A, r1
  segment_buffer_head = 0; // empty = tail
    3c0a:	10 92 89 01 	sts	0x0189, r1
  segment_next_head = 1;
    3c0e:	81 e0       	ldi	r24, 0x01	; 1
    3c10:	80 93 88 01 	sts	0x0188, r24
  busy = false;
    3c14:	10 92 85 01 	sts	0x0185, r1
  
  st_generate_step_dir_invert_masks();
    3c18:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <st_generate_step_dir_invert_masks>
      
  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    3c1c:	8b b1       	in	r24, 0x0b	; 11
    3c1e:	8b 7a       	andi	r24, 0xAB	; 171
    3c20:	90 91 87 01 	lds	r25, 0x0187
    3c24:	89 2b       	or	r24, r25
    3c26:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    3c28:	8b b1       	in	r24, 0x0b	; 11
    3c2a:	87 75       	andi	r24, 0x57	; 87
    3c2c:	90 91 86 01 	lds	r25, 0x0186
    3c30:	89 2b       	or	r24, r25
    3c32:	8b b9       	out	0x0b, r24	; 11
    3c34:	08 95       	ret

00003c36 <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    3c36:	8a b1       	in	r24, 0x0a	; 10
    3c38:	84 65       	ori	r24, 0x54	; 84
    3c3a:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    3c3c:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    3c3e:	8a b1       	in	r24, 0x0a	; 10
    3c40:	88 6a       	ori	r24, 0xA8	; 168
    3c42:	8a b9       	out	0x0a, r24	; 10

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    3c44:	e1 e8       	ldi	r30, 0x81	; 129
    3c46:	f0 e0       	ldi	r31, 0x00	; 0
    3c48:	80 81       	ld	r24, Z
    3c4a:	8f 7e       	andi	r24, 0xEF	; 239
    3c4c:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    3c4e:	80 81       	ld	r24, Z
    3c50:	88 60       	ori	r24, 0x08	; 8
    3c52:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10)); 
    3c54:	e0 e8       	ldi	r30, 0x80	; 128
    3c56:	f0 e0       	ldi	r31, 0x00	; 0
    3c58:	80 81       	ld	r24, Z
    3c5a:	8c 7f       	andi	r24, 0xFC	; 252
    3c5c:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    3c5e:	80 81       	ld	r24, Z
    3c60:	8f 70       	andi	r24, 0x0F	; 15
    3c62:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().
  
  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    3c64:	ee e6       	ldi	r30, 0x6E	; 110
    3c66:	f0 e0       	ldi	r31, 0x00	; 0
    3c68:	80 81       	ld	r24, Z
    3c6a:	88 7f       	andi	r24, 0xF8	; 248
    3c6c:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    3c6e:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    3c70:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    3c72:	80 81       	ld	r24, Z
    3c74:	81 60       	ori	r24, 0x01	; 1
    3c76:	80 83       	st	Z, r24
    3c78:	08 95       	ret

00003c7a <st_update_plan_block_parameters>:
}
  

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{ 
    3c7a:	cf 93       	push	r28
    3c7c:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    3c7e:	c0 91 83 01 	lds	r28, 0x0183
    3c82:	d0 91 84 01 	lds	r29, 0x0184
    3c86:	20 97       	sbiw	r28, 0x00	; 0
    3c88:	b9 f0       	breq	.+46     	; 0x3cb8 <st_update_plan_block_parameters+0x3e>
    prep.flag_partial_block = true;
    3c8a:	81 e0       	ldi	r24, 0x01	; 1
    3c8c:	80 93 57 01 	sts	0x0157, r24
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    3c90:	60 91 6d 01 	lds	r22, 0x016D
    3c94:	70 91 6e 01 	lds	r23, 0x016E
    3c98:	80 91 6f 01 	lds	r24, 0x016F
    3c9c:	90 91 70 01 	lds	r25, 0x0170
    3ca0:	9b 01       	movw	r18, r22
    3ca2:	ac 01       	movw	r20, r24
    3ca4:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    3ca8:	69 8b       	std	Y+17, r22	; 0x11
    3caa:	7a 8b       	std	Y+18, r23	; 0x12
    3cac:	8b 8b       	std	Y+19, r24	; 0x13
    3cae:	9c 8b       	std	Y+20, r25	; 0x14
    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.
    3cb0:	10 92 84 01 	sts	0x0184, r1
    3cb4:	10 92 83 01 	sts	0x0183, r1
  }
}
    3cb8:	df 91       	pop	r29
    3cba:	cf 91       	pop	r28
    3cbc:	08 95       	ret

00003cbe <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it. 
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    3cbe:	2f 92       	push	r2
    3cc0:	3f 92       	push	r3
    3cc2:	4f 92       	push	r4
    3cc4:	5f 92       	push	r5
    3cc6:	6f 92       	push	r6
    3cc8:	7f 92       	push	r7
    3cca:	8f 92       	push	r8
    3ccc:	9f 92       	push	r9
    3cce:	af 92       	push	r10
    3cd0:	bf 92       	push	r11
    3cd2:	cf 92       	push	r12
    3cd4:	df 92       	push	r13
    3cd6:	ef 92       	push	r14
    3cd8:	ff 92       	push	r15
    3cda:	0f 93       	push	r16
    3cdc:	1f 93       	push	r17
    3cde:	cf 93       	push	r28
    3ce0:	df 93       	push	r29
    3ce2:	cd b7       	in	r28, 0x3d	; 61
    3ce4:	de b7       	in	r29, 0x3e	; 62
    3ce6:	e6 97       	sbiw	r28, 0x36	; 54
    3ce8:	0f b6       	in	r0, 0x3f	; 63
    3cea:	f8 94       	cli
    3cec:	de bf       	out	0x3e, r29	; 62
    3cee:	0f be       	out	0x3f, r0	; 63
    3cf0:	cd bf       	out	0x3d, r28	; 61

  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    3cf2:	80 91 68 07 	lds	r24, 0x0768
    3cf6:	80 77       	andi	r24, 0x70	; 112
    3cf8:	09 f4       	brne	.+2      	; 0x3cfc <st_prep_buffer+0x3e>
    3cfa:	6e c6       	rjmp	.+3292   	; 0x49d8 <st_prep_buffer+0xd1a>
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
    3cfc:	20 e0       	ldi	r18, 0x00	; 0
    3cfe:	30 e0       	ldi	r19, 0x00	; 0
    3d00:	a9 01       	movw	r20, r18
    3d02:	60 91 6d 01 	lds	r22, 0x016D
    3d06:	70 91 6e 01 	lds	r23, 0x016E
    3d0a:	80 91 6f 01 	lds	r24, 0x016F
    3d0e:	90 91 70 01 	lds	r25, 0x0170
    3d12:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    3d16:	81 11       	cpse	r24, r1
    3d18:	5f c6       	rjmp	.+3262   	; 0x49d8 <st_prep_buffer+0xd1a>
    3d1a:	64 c6       	rjmp	.+3272   	; 0x49e4 <st_prep_buffer+0xd26>
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block has been replanned. 
    if (pl_block == NULL) {
    3d1c:	80 91 83 01 	lds	r24, 0x0183
    3d20:	90 91 84 01 	lds	r25, 0x0184
    3d24:	89 2b       	or	r24, r25
    3d26:	09 f0       	breq	.+2      	; 0x3d2a <st_prep_buffer+0x6c>
    3d28:	6c c2       	rjmp	.+1240   	; 0x4202 <st_prep_buffer+0x544>
      pl_block = plan_get_current_block(); // Query planner for a queued block
    3d2a:	0e 94 59 2a 	call	0x54b2	; 0x54b2 <plan_get_current_block>
    3d2e:	8c 01       	movw	r16, r24
    3d30:	90 93 84 01 	sts	0x0184, r25
    3d34:	80 93 83 01 	sts	0x0183, r24
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    3d38:	00 97       	sbiw	r24, 0x00	; 0
    3d3a:	09 f4       	brne	.+2      	; 0x3d3e <st_prep_buffer+0x80>
    3d3c:	53 c6       	rjmp	.+3238   	; 0x49e4 <st_prep_buffer+0xd26>
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    3d3e:	a7 e5       	ldi	r26, 0x57	; 87
    3d40:	b1 e0       	ldi	r27, 0x01	; 1
    3d42:	8c 91       	ld	r24, X
    3d44:	88 23       	and	r24, r24
    3d46:	11 f0       	breq	.+4      	; 0x3d4c <st_prep_buffer+0x8e>
        prep.flag_partial_block = false; // Reset flag
    3d48:	1c 92       	st	X, r1
    3d4a:	dc c0       	rjmp	.+440    	; 0x3f04 <st_prep_buffer+0x246>
      } else {
        // Increment stepper common data index to store new planner block data. 
        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
    3d4c:	e6 e5       	ldi	r30, 0x56	; 86
    3d4e:	f1 e0       	ldi	r31, 0x01	; 1
    3d50:	80 81       	ld	r24, Z
    3d52:	8f 5f       	subi	r24, 0xFF	; 255
    3d54:	85 30       	cpi	r24, 0x05	; 5
    3d56:	11 f0       	breq	.+4      	; 0x3d5c <st_prep_buffer+0x9e>
    3d58:	80 83       	st	Z, r24
    3d5a:	03 c0       	rjmp	.+6      	; 0x3d62 <st_prep_buffer+0xa4>
    3d5c:	a6 e5       	ldi	r26, 0x56	; 86
    3d5e:	b1 e0       	ldi	r27, 0x01	; 1
    3d60:	1c 92       	st	X, r1
        
        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the 
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. 
        st_prep_block = &st_block_buffer[prep.st_block_index];
    3d62:	a6 e5       	ldi	r26, 0x56	; 86
    3d64:	b1 e0       	ldi	r27, 0x01	; 1
    3d66:	ec 91       	ld	r30, X
    3d68:	b1 e1       	ldi	r27, 0x11	; 17
    3d6a:	eb 9f       	mul	r30, r27
    3d6c:	f0 01       	movw	r30, r0
    3d6e:	11 24       	eor	r1, r1
    3d70:	ee 52       	subi	r30, 0x2E	; 46
    3d72:	fe 4f       	sbci	r31, 0xFE	; 254
    3d74:	f0 93 82 01 	sts	0x0182, r31
    3d78:	e0 93 81 01 	sts	0x0181, r30
        st_prep_block->direction_bits = pl_block->direction_bits;
    3d7c:	d8 01       	movw	r26, r16
    3d7e:	8c 91       	ld	r24, X
    3d80:	80 83       	st	Z, r24
          st_prep_block->step_event_count = pl_block->step_event_count;
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS 
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS] << MAX_AMASS_LEVEL;
    3d82:	11 96       	adiw	r26, 0x01	; 1
    3d84:	4d 91       	ld	r20, X+
    3d86:	5d 91       	ld	r21, X+
    3d88:	6d 91       	ld	r22, X+
    3d8a:	7c 91       	ld	r23, X
    3d8c:	14 97       	sbiw	r26, 0x04	; 4
    3d8e:	db 01       	movw	r26, r22
    3d90:	ca 01       	movw	r24, r20
    3d92:	88 0f       	add	r24, r24
    3d94:	99 1f       	adc	r25, r25
    3d96:	aa 1f       	adc	r26, r26
    3d98:	bb 1f       	adc	r27, r27
    3d9a:	88 0f       	add	r24, r24
    3d9c:	99 1f       	adc	r25, r25
    3d9e:	aa 1f       	adc	r26, r26
    3da0:	bb 1f       	adc	r27, r27
    3da2:	88 0f       	add	r24, r24
    3da4:	99 1f       	adc	r25, r25
    3da6:	aa 1f       	adc	r26, r26
    3da8:	bb 1f       	adc	r27, r27
    3daa:	81 83       	std	Z+1, r24	; 0x01
    3dac:	92 83       	std	Z+2, r25	; 0x02
    3dae:	a3 83       	std	Z+3, r26	; 0x03
    3db0:	b4 83       	std	Z+4, r27	; 0x04
          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS] << MAX_AMASS_LEVEL;
    3db2:	d8 01       	movw	r26, r16
    3db4:	15 96       	adiw	r26, 0x05	; 5
    3db6:	4d 91       	ld	r20, X+
    3db8:	5d 91       	ld	r21, X+
    3dba:	6d 91       	ld	r22, X+
    3dbc:	7c 91       	ld	r23, X
    3dbe:	18 97       	sbiw	r26, 0x08	; 8
    3dc0:	db 01       	movw	r26, r22
    3dc2:	ca 01       	movw	r24, r20
    3dc4:	88 0f       	add	r24, r24
    3dc6:	99 1f       	adc	r25, r25
    3dc8:	aa 1f       	adc	r26, r26
    3dca:	bb 1f       	adc	r27, r27
    3dcc:	88 0f       	add	r24, r24
    3dce:	99 1f       	adc	r25, r25
    3dd0:	aa 1f       	adc	r26, r26
    3dd2:	bb 1f       	adc	r27, r27
    3dd4:	88 0f       	add	r24, r24
    3dd6:	99 1f       	adc	r25, r25
    3dd8:	aa 1f       	adc	r26, r26
    3dda:	bb 1f       	adc	r27, r27
    3ddc:	85 83       	std	Z+5, r24	; 0x05
    3dde:	96 83       	std	Z+6, r25	; 0x06
    3de0:	a7 83       	std	Z+7, r26	; 0x07
    3de2:	b0 87       	std	Z+8, r27	; 0x08
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;
    3de4:	d8 01       	movw	r26, r16
    3de6:	19 96       	adiw	r26, 0x09	; 9
    3de8:	4d 91       	ld	r20, X+
    3dea:	5d 91       	ld	r21, X+
    3dec:	6d 91       	ld	r22, X+
    3dee:	7c 91       	ld	r23, X
    3df0:	1c 97       	sbiw	r26, 0x0c	; 12
    3df2:	db 01       	movw	r26, r22
    3df4:	ca 01       	movw	r24, r20
    3df6:	88 0f       	add	r24, r24
    3df8:	99 1f       	adc	r25, r25
    3dfa:	aa 1f       	adc	r26, r26
    3dfc:	bb 1f       	adc	r27, r27
    3dfe:	88 0f       	add	r24, r24
    3e00:	99 1f       	adc	r25, r25
    3e02:	aa 1f       	adc	r26, r26
    3e04:	bb 1f       	adc	r27, r27
    3e06:	88 0f       	add	r24, r24
    3e08:	99 1f       	adc	r25, r25
    3e0a:	aa 1f       	adc	r26, r26
    3e0c:	bb 1f       	adc	r27, r27
    3e0e:	81 87       	std	Z+9, r24	; 0x09
    3e10:	92 87       	std	Z+10, r25	; 0x0a
    3e12:	a3 87       	std	Z+11, r26	; 0x0b
    3e14:	b4 87       	std	Z+12, r27	; 0x0c
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    3e16:	d8 01       	movw	r26, r16
    3e18:	1d 96       	adiw	r26, 0x0d	; 13
    3e1a:	4d 91       	ld	r20, X+
    3e1c:	5d 91       	ld	r21, X+
    3e1e:	6d 91       	ld	r22, X+
    3e20:	7c 91       	ld	r23, X
    3e22:	50 97       	sbiw	r26, 0x10	; 16
    3e24:	44 0f       	add	r20, r20
    3e26:	55 1f       	adc	r21, r21
    3e28:	66 1f       	adc	r22, r22
    3e2a:	77 1f       	adc	r23, r23
    3e2c:	44 0f       	add	r20, r20
    3e2e:	55 1f       	adc	r21, r21
    3e30:	66 1f       	adc	r22, r22
    3e32:	77 1f       	adc	r23, r23
    3e34:	44 0f       	add	r20, r20
    3e36:	55 1f       	adc	r21, r21
    3e38:	66 1f       	adc	r22, r22
    3e3a:	77 1f       	adc	r23, r23
    3e3c:	45 87       	std	Z+13, r20	; 0x0d
    3e3e:	56 87       	std	Z+14, r21	; 0x0e
    3e40:	67 87       	std	Z+15, r22	; 0x0f
    3e42:	70 8b       	std	Z+16, r23	; 0x10
        #endif
        
        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = pl_block->step_event_count;
    3e44:	1d 96       	adiw	r26, 0x0d	; 13
    3e46:	6d 91       	ld	r22, X+
    3e48:	7d 91       	ld	r23, X+
    3e4a:	8d 91       	ld	r24, X+
    3e4c:	9c 91       	ld	r25, X
    3e4e:	50 97       	sbiw	r26, 0x10	; 16
    3e50:	0e 94 2c 3d 	call	0x7a58	; 0x7a58 <__floatunsisf>
    3e54:	e8 e5       	ldi	r30, 0x58	; 88
    3e56:	f1 e0       	ldi	r31, 0x01	; 1
    3e58:	60 83       	st	Z, r22
    3e5a:	71 83       	std	Z+1, r23	; 0x01
    3e5c:	82 83       	std	Z+2, r24	; 0x02
    3e5e:	93 83       	std	Z+3, r25	; 0x03
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    3e60:	d8 01       	movw	r26, r16
    3e62:	95 96       	adiw	r26, 0x25	; 37
    3e64:	2d 91       	ld	r18, X+
    3e66:	3d 91       	ld	r19, X+
    3e68:	4d 91       	ld	r20, X+
    3e6a:	5c 91       	ld	r21, X
    3e6c:	98 97       	sbiw	r26, 0x28	; 40
    3e6e:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    3e72:	9b 01       	movw	r18, r22
    3e74:	ac 01       	movw	r20, r24
    3e76:	ec e5       	ldi	r30, 0x5C	; 92
    3e78:	f1 e0       	ldi	r31, 0x01	; 1
    3e7a:	60 83       	st	Z, r22
    3e7c:	71 83       	std	Z+1, r23	; 0x01
    3e7e:	82 83       	std	Z+2, r24	; 0x02
    3e80:	93 83       	std	Z+3, r25	; 0x03
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    3e82:	60 e0       	ldi	r22, 0x00	; 0
    3e84:	70 e0       	ldi	r23, 0x00	; 0
    3e86:	80 ea       	ldi	r24, 0xA0	; 160
    3e88:	9f e3       	ldi	r25, 0x3F	; 63
    3e8a:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    3e8e:	60 93 60 01 	sts	0x0160, r22
    3e92:	70 93 61 01 	sts	0x0161, r23
    3e96:	80 93 62 01 	sts	0x0162, r24
    3e9a:	90 93 63 01 	sts	0x0163, r25
        
        prep.dt_remainder = 0.0; // Reset for new planner block
    3e9e:	10 92 64 01 	sts	0x0164, r1
    3ea2:	10 92 65 01 	sts	0x0165, r1
    3ea6:	10 92 66 01 	sts	0x0166, r1
    3eaa:	10 92 67 01 	sts	0x0167, r1

        if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    3eae:	a8 e6       	ldi	r26, 0x68	; 104
    3eb0:	b7 e0       	ldi	r27, 0x07	; 7
    3eb2:	8c 91       	ld	r24, X
    3eb4:	80 77       	andi	r24, 0x70	; 112
    3eb6:	b9 f0       	breq	.+46     	; 0x3ee6 <st_prep_buffer+0x228>
          // Override planner block entry speed and enforce deceleration during feed hold.
          prep.current_speed = prep.exit_speed; 
    3eb8:	e5 e7       	ldi	r30, 0x75	; 117
    3eba:	f1 e0       	ldi	r31, 0x01	; 1
    3ebc:	60 81       	ld	r22, Z
    3ebe:	71 81       	ldd	r23, Z+1	; 0x01
    3ec0:	82 81       	ldd	r24, Z+2	; 0x02
    3ec2:	93 81       	ldd	r25, Z+3	; 0x03
    3ec4:	ad e6       	ldi	r26, 0x6D	; 109
    3ec6:	b1 e0       	ldi	r27, 0x01	; 1
    3ec8:	6d 93       	st	X+, r22
    3eca:	7d 93       	st	X+, r23
    3ecc:	8d 93       	st	X+, r24
    3ece:	9c 93       	st	X, r25
    3ed0:	13 97       	sbiw	r26, 0x03	; 3
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; 
    3ed2:	9b 01       	movw	r18, r22
    3ed4:	ac 01       	movw	r20, r24
    3ed6:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    3eda:	f8 01       	movw	r30, r16
    3edc:	61 8b       	std	Z+17, r22	; 0x11
    3ede:	72 8b       	std	Z+18, r23	; 0x12
    3ee0:	83 8b       	std	Z+19, r24	; 0x13
    3ee2:	94 8b       	std	Z+20, r25	; 0x14
    3ee4:	0f c0       	rjmp	.+30     	; 0x3f04 <st_prep_buffer+0x246>
        }
        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }
    3ee6:	d8 01       	movw	r26, r16
    3ee8:	51 96       	adiw	r26, 0x11	; 17
    3eea:	6d 91       	ld	r22, X+
    3eec:	7d 91       	ld	r23, X+
    3eee:	8d 91       	ld	r24, X+
    3ef0:	9c 91       	ld	r25, X
    3ef2:	54 97       	sbiw	r26, 0x14	; 20
    3ef4:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    3ef8:	ed e6       	ldi	r30, 0x6D	; 109
    3efa:	f1 e0       	ldi	r31, 0x01	; 1
    3efc:	60 83       	st	Z, r22
    3efe:	71 83       	std	Z+1, r23	; 0x01
    3f00:	82 83       	std	Z+2, r24	; 0x02
    3f02:	93 83       	std	Z+3, r25	; 0x03
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
      */
      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    3f04:	a9 e6       	ldi	r26, 0x69	; 105
    3f06:	b1 e0       	ldi	r27, 0x01	; 1
    3f08:	1d 92       	st	X+, r1
    3f0a:	1d 92       	st	X+, r1
    3f0c:	1d 92       	st	X+, r1
    3f0e:	1c 92       	st	X, r1
    3f10:	13 97       	sbiw	r26, 0x03	; 3
      float inv_2_accel = 0.5/pl_block->acceleration;
    3f12:	00 91 83 01 	lds	r16, 0x0183
    3f16:	10 91 84 01 	lds	r17, 0x0184
    3f1a:	f8 01       	movw	r30, r16
    3f1c:	81 a0       	ldd	r8, Z+33	; 0x21
    3f1e:	92 a0       	ldd	r9, Z+34	; 0x22
    3f20:	a3 a0       	ldd	r10, Z+35	; 0x23
    3f22:	b4 a0       	ldd	r11, Z+36	; 0x24
    3f24:	a5 01       	movw	r20, r10
    3f26:	94 01       	movw	r18, r8
    3f28:	60 e0       	ldi	r22, 0x00	; 0
    3f2a:	70 e0       	ldi	r23, 0x00	; 0
    3f2c:	80 e0       	ldi	r24, 0x00	; 0
    3f2e:	9f e3       	ldi	r25, 0x3F	; 63
    3f30:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    3f34:	6b 01       	movw	r12, r22
    3f36:	7c 01       	movw	r14, r24
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { // [Forced Deceleration to Zero Velocity]
    3f38:	a8 e6       	ldi	r26, 0x68	; 104
    3f3a:	b7 e0       	ldi	r27, 0x07	; 7
    3f3c:	8c 91       	ld	r24, X
    3f3e:	80 77       	andi	r24, 0x70	; 112
    3f40:	09 f4       	brne	.+2      	; 0x3f44 <st_prep_buffer+0x286>
    3f42:	57 c0       	rjmp	.+174    	; 0x3ff2 <st_prep_buffer+0x334>
        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
        // the planner block profile, enforcing a deceleration to zero speed.
        prep.ramp_type = RAMP_DECEL;
    3f44:	82 e0       	ldi	r24, 0x02	; 2
    3f46:	e8 e6       	ldi	r30, 0x68	; 104
    3f48:	f1 e0       	ldi	r31, 0x01	; 1
    3f4a:	80 83       	st	Z, r24
        // Compute decelerate distance relative to end of block.
        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    3f4c:	d8 01       	movw	r26, r16
    3f4e:	95 96       	adiw	r26, 0x25	; 37
    3f50:	4d 90       	ld	r4, X+
    3f52:	5d 90       	ld	r5, X+
    3f54:	6d 90       	ld	r6, X+
    3f56:	7c 90       	ld	r7, X
    3f58:	98 97       	sbiw	r26, 0x28	; 40
    3f5a:	51 96       	adiw	r26, 0x11	; 17
    3f5c:	2d 91       	ld	r18, X+
    3f5e:	3d 91       	ld	r19, X+
    3f60:	4d 91       	ld	r20, X+
    3f62:	5c 91       	ld	r21, X
    3f64:	54 97       	sbiw	r26, 0x14	; 20
    3f66:	29 83       	std	Y+1, r18	; 0x01
    3f68:	3a 83       	std	Y+2, r19	; 0x02
    3f6a:	4b 83       	std	Y+3, r20	; 0x03
    3f6c:	5c 83       	std	Y+4, r21	; 0x04
    3f6e:	a7 01       	movw	r20, r14
    3f70:	96 01       	movw	r18, r12
    3f72:	69 81       	ldd	r22, Y+1	; 0x01
    3f74:	7a 81       	ldd	r23, Y+2	; 0x02
    3f76:	8b 81       	ldd	r24, Y+3	; 0x03
    3f78:	9c 81       	ldd	r25, Y+4	; 0x04
    3f7a:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    3f7e:	9b 01       	movw	r18, r22
    3f80:	ac 01       	movw	r20, r24
    3f82:	c3 01       	movw	r24, r6
    3f84:	b2 01       	movw	r22, r4
    3f86:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    3f8a:	6b 01       	movw	r12, r22
    3f8c:	7c 01       	movw	r14, r24
        if (decel_dist < 0.0) {
    3f8e:	20 e0       	ldi	r18, 0x00	; 0
    3f90:	30 e0       	ldi	r19, 0x00	; 0
    3f92:	a9 01       	movw	r20, r18
    3f94:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    3f98:	88 23       	and	r24, r24
    3f9a:	ec f4       	brge	.+58     	; 0x3fd6 <st_prep_buffer+0x318>
          // Deceleration through entire planner block. End of feed hold is not in this block.
          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3f9c:	a5 01       	movw	r20, r10
    3f9e:	94 01       	movw	r18, r8
    3fa0:	c5 01       	movw	r24, r10
    3fa2:	b4 01       	movw	r22, r8
    3fa4:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    3fa8:	9b 01       	movw	r18, r22
    3faa:	ac 01       	movw	r20, r24
    3fac:	c3 01       	movw	r24, r6
    3fae:	b2 01       	movw	r22, r4
    3fb0:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    3fb4:	9b 01       	movw	r18, r22
    3fb6:	ac 01       	movw	r20, r24
    3fb8:	69 81       	ldd	r22, Y+1	; 0x01
    3fba:	7a 81       	ldd	r23, Y+2	; 0x02
    3fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    3fbe:	9c 81       	ldd	r25, Y+4	; 0x04
    3fc0:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    3fc4:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    3fc8:	e5 e7       	ldi	r30, 0x75	; 117
    3fca:	f1 e0       	ldi	r31, 0x01	; 1
    3fcc:	60 83       	st	Z, r22
    3fce:	71 83       	std	Z+1, r23	; 0x01
    3fd0:	82 83       	std	Z+2, r24	; 0x02
    3fd2:	93 83       	std	Z+3, r25	; 0x03
    3fd4:	16 c1       	rjmp	.+556    	; 0x4202 <st_prep_buffer+0x544>
        } else {
          prep.mm_complete = decel_dist; // End of feed hold.
    3fd6:	a9 e6       	ldi	r26, 0x69	; 105
    3fd8:	b1 e0       	ldi	r27, 0x01	; 1
    3fda:	cd 92       	st	X+, r12
    3fdc:	dd 92       	st	X+, r13
    3fde:	ed 92       	st	X+, r14
    3fe0:	fc 92       	st	X, r15
    3fe2:	13 97       	sbiw	r26, 0x03	; 3
          prep.exit_speed = 0.0;
    3fe4:	e5 e7       	ldi	r30, 0x75	; 117
    3fe6:	f1 e0       	ldi	r31, 0x01	; 1
    3fe8:	10 82       	st	Z, r1
    3fea:	11 82       	std	Z+1, r1	; 0x01
    3fec:	12 82       	std	Z+2, r1	; 0x02
    3fee:	13 82       	std	Z+3, r1	; 0x03
    3ff0:	08 c1       	rjmp	.+528    	; 0x4202 <st_prep_buffer+0x544>
        }
      } else { // [Normal Operation]
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    3ff2:	a8 e6       	ldi	r26, 0x68	; 104
    3ff4:	b1 e0       	ldi	r27, 0x01	; 1
    3ff6:	1c 92       	st	X, r1
        prep.accelerate_until = pl_block->millimeters; 
    3ff8:	f8 01       	movw	r30, r16
    3ffa:	85 a1       	ldd	r24, Z+37	; 0x25
    3ffc:	96 a1       	ldd	r25, Z+38	; 0x26
    3ffe:	a7 a1       	ldd	r26, Z+39	; 0x27
    4000:	b0 a5       	ldd	r27, Z+40	; 0x28
    4002:	e9 e7       	ldi	r30, 0x79	; 121
    4004:	f1 e0       	ldi	r31, 0x01	; 1
    4006:	80 83       	st	Z, r24
    4008:	91 83       	std	Z+1, r25	; 0x01
    400a:	a2 83       	std	Z+2, r26	; 0x02
    400c:	b3 83       	std	Z+3, r27	; 0x03
        prep.exit_speed = plan_get_exec_block_exit_speed();   
    400e:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <plan_get_exec_block_exit_speed>
    4012:	2b 01       	movw	r4, r22
    4014:	3c 01       	movw	r6, r24
    4016:	a5 e7       	ldi	r26, 0x75	; 117
    4018:	b1 e0       	ldi	r27, 0x01	; 1
    401a:	6d 93       	st	X+, r22
    401c:	7d 93       	st	X+, r23
    401e:	8d 93       	st	X+, r24
    4020:	9c 93       	st	X, r25
    4022:	13 97       	sbiw	r26, 0x03	; 3
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
    4024:	9b 01       	movw	r18, r22
    4026:	ac 01       	movw	r20, r24
    4028:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    402c:	69 83       	std	Y+1, r22	; 0x01
    402e:	7a 83       	std	Y+2, r23	; 0x02
    4030:	8b 83       	std	Y+3, r24	; 0x03
    4032:	9c 83       	std	Y+4, r25	; 0x04
        float intersect_distance =
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    4034:	00 91 83 01 	lds	r16, 0x0183
    4038:	10 91 84 01 	lds	r17, 0x0184
    403c:	d8 01       	movw	r26, r16
    403e:	95 96       	adiw	r26, 0x25	; 37
    4040:	2d 91       	ld	r18, X+
    4042:	3d 91       	ld	r19, X+
    4044:	4d 91       	ld	r20, X+
    4046:	5c 91       	ld	r21, X
    4048:	98 97       	sbiw	r26, 0x28	; 40
    404a:	2d 83       	std	Y+5, r18	; 0x05
    404c:	3e 83       	std	Y+6, r19	; 0x06
    404e:	4f 83       	std	Y+7, r20	; 0x07
    4050:	58 87       	std	Y+8, r21	; 0x08
    4052:	9b 01       	movw	r18, r22
    4054:	ac 01       	movw	r20, r24
    4056:	51 96       	adiw	r26, 0x11	; 17
    4058:	6d 91       	ld	r22, X+
    405a:	7d 91       	ld	r23, X+
    405c:	8d 91       	ld	r24, X+
    405e:	9c 91       	ld	r25, X
    4060:	54 97       	sbiw	r26, 0x14	; 20
    4062:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    4066:	a7 01       	movw	r20, r14
    4068:	96 01       	movw	r18, r12
    406a:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    406e:	9b 01       	movw	r18, r22
    4070:	ac 01       	movw	r20, r24
    4072:	6d 81       	ldd	r22, Y+5	; 0x05
    4074:	7e 81       	ldd	r23, Y+6	; 0x06
    4076:	8f 81       	ldd	r24, Y+7	; 0x07
    4078:	98 85       	ldd	r25, Y+8	; 0x08
    407a:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
        prep.accelerate_until = pl_block->millimeters; 
        prep.exit_speed = plan_get_exec_block_exit_speed();   
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
        float intersect_distance =
    407e:	20 e0       	ldi	r18, 0x00	; 0
    4080:	30 e0       	ldi	r19, 0x00	; 0
    4082:	40 e0       	ldi	r20, 0x00	; 0
    4084:	5f e3       	ldi	r21, 0x3F	; 63
    4086:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    408a:	4b 01       	movw	r8, r22
    408c:	5c 01       	movw	r10, r24
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
        if (intersect_distance > 0.0) {
    408e:	20 e0       	ldi	r18, 0x00	; 0
    4090:	30 e0       	ldi	r19, 0x00	; 0
    4092:	a9 01       	movw	r20, r18
    4094:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    4098:	18 16       	cp	r1, r24
    409a:	0c f0       	brlt	.+2      	; 0x409e <st_prep_buffer+0x3e0>
    409c:	a5 c0       	rjmp	.+330    	; 0x41e8 <st_prep_buffer+0x52a>
          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    409e:	a5 01       	movw	r20, r10
    40a0:	94 01       	movw	r18, r8
    40a2:	6d 81       	ldd	r22, Y+5	; 0x05
    40a4:	7e 81       	ldd	r23, Y+6	; 0x06
    40a6:	8f 81       	ldd	r24, Y+7	; 0x07
    40a8:	98 85       	ldd	r25, Y+8	; 0x08
    40aa:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    40ae:	18 16       	cp	r1, r24
    40b0:	0c f0       	brlt	.+2      	; 0x40b4 <st_prep_buffer+0x3f6>
    40b2:	89 c0       	rjmp	.+274    	; 0x41c6 <st_prep_buffer+0x508>
            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);
    40b4:	29 81       	ldd	r18, Y+1	; 0x01
    40b6:	3a 81       	ldd	r19, Y+2	; 0x02
    40b8:	4b 81       	ldd	r20, Y+3	; 0x03
    40ba:	5c 81       	ldd	r21, Y+4	; 0x04
    40bc:	f8 01       	movw	r30, r16
    40be:	65 8d       	ldd	r22, Z+29	; 0x1d
    40c0:	76 8d       	ldd	r23, Z+30	; 0x1e
    40c2:	87 8d       	ldd	r24, Z+31	; 0x1f
    40c4:	90 a1       	ldd	r25, Z+32	; 0x20
    40c6:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    40ca:	a7 01       	movw	r20, r14
    40cc:	96 01       	movw	r18, r12
    40ce:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    40d2:	9b 01       	movw	r18, r22
    40d4:	ac 01       	movw	r20, r24
    40d6:	ad e7       	ldi	r26, 0x7D	; 125
    40d8:	b1 e0       	ldi	r27, 0x01	; 1
    40da:	6d 93       	st	X+, r22
    40dc:	7d 93       	st	X+, r23
    40de:	8d 93       	st	X+, r24
    40e0:	9c 93       	st	X, r25
    40e2:	13 97       	sbiw	r26, 0x03	; 3
            if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    40e4:	c5 01       	movw	r24, r10
    40e6:	b4 01       	movw	r22, r8
    40e8:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    40ec:	18 16       	cp	r1, r24
    40ee:	0c f0       	brlt	.+2      	; 0x40f2 <st_prep_buffer+0x434>
    40f0:	40 c0       	rjmp	.+128    	; 0x4172 <st_prep_buffer+0x4b4>
              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);
    40f2:	f8 01       	movw	r30, r16
    40f4:	65 8d       	ldd	r22, Z+29	; 0x1d
    40f6:	76 8d       	ldd	r23, Z+30	; 0x1e
    40f8:	87 8d       	ldd	r24, Z+31	; 0x1f
    40fa:	90 a1       	ldd	r25, Z+32	; 0x20
    40fc:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    4100:	a1 e7       	ldi	r26, 0x71	; 113
    4102:	b1 e0       	ldi	r27, 0x01	; 1
    4104:	6d 93       	st	X+, r22
    4106:	7d 93       	st	X+, r23
    4108:	8d 93       	st	X+, r24
    410a:	9c 93       	st	X, r25
    410c:	13 97       	sbiw	r26, 0x03	; 3
              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { 
    410e:	f8 01       	movw	r30, r16
    4110:	41 88       	ldd	r4, Z+17	; 0x11
    4112:	52 88       	ldd	r5, Z+18	; 0x12
    4114:	63 88       	ldd	r6, Z+19	; 0x13
    4116:	74 88       	ldd	r7, Z+20	; 0x14
    4118:	85 8c       	ldd	r8, Z+29	; 0x1d
    411a:	96 8c       	ldd	r9, Z+30	; 0x1e
    411c:	a7 8c       	ldd	r10, Z+31	; 0x1f
    411e:	b0 a0       	ldd	r11, Z+32	; 0x20
    4120:	a5 01       	movw	r20, r10
    4122:	94 01       	movw	r18, r8
    4124:	c3 01       	movw	r24, r6
    4126:	b2 01       	movw	r22, r4
    4128:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    412c:	81 11       	cpse	r24, r1
    412e:	05 c0       	rjmp	.+10     	; 0x413a <st_prep_buffer+0x47c>
                // Cruise-deceleration or cruise-only type.
                prep.ramp_type = RAMP_CRUISE;
    4130:	81 e0       	ldi	r24, 0x01	; 1
    4132:	a8 e6       	ldi	r26, 0x68	; 104
    4134:	b1 e0       	ldi	r27, 0x01	; 1
    4136:	8c 93       	st	X, r24
    4138:	64 c0       	rjmp	.+200    	; 0x4202 <st_prep_buffer+0x544>
              } else {
                // Full-trapezoid or acceleration-cruise types
                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); 
    413a:	a3 01       	movw	r20, r6
    413c:	92 01       	movw	r18, r4
    413e:	c5 01       	movw	r24, r10
    4140:	b4 01       	movw	r22, r8
    4142:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    4146:	a7 01       	movw	r20, r14
    4148:	96 01       	movw	r18, r12
    414a:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    414e:	9b 01       	movw	r18, r22
    4150:	ac 01       	movw	r20, r24
    4152:	e9 e7       	ldi	r30, 0x79	; 121
    4154:	f1 e0       	ldi	r31, 0x01	; 1
    4156:	60 81       	ld	r22, Z
    4158:	71 81       	ldd	r23, Z+1	; 0x01
    415a:	82 81       	ldd	r24, Z+2	; 0x02
    415c:	93 81       	ldd	r25, Z+3	; 0x03
    415e:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    4162:	a9 e7       	ldi	r26, 0x79	; 121
    4164:	b1 e0       	ldi	r27, 0x01	; 1
    4166:	6d 93       	st	X+, r22
    4168:	7d 93       	st	X+, r23
    416a:	8d 93       	st	X+, r24
    416c:	9c 93       	st	X, r25
    416e:	13 97       	sbiw	r26, 0x03	; 3
    4170:	48 c0       	rjmp	.+144    	; 0x4202 <st_prep_buffer+0x544>
              }
            } else { // Triangle type
              prep.accelerate_until = intersect_distance;
    4172:	e9 e7       	ldi	r30, 0x79	; 121
    4174:	f1 e0       	ldi	r31, 0x01	; 1
    4176:	80 82       	st	Z, r8
    4178:	91 82       	std	Z+1, r9	; 0x01
    417a:	a2 82       	std	Z+2, r10	; 0x02
    417c:	b3 82       	std	Z+3, r11	; 0x03
              prep.decelerate_after = intersect_distance;
    417e:	ad e7       	ldi	r26, 0x7D	; 125
    4180:	b1 e0       	ldi	r27, 0x01	; 1
    4182:	8d 92       	st	X+, r8
    4184:	9d 92       	st	X+, r9
    4186:	ad 92       	st	X+, r10
    4188:	bc 92       	st	X, r11
    418a:	13 97       	sbiw	r26, 0x03	; 3
              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    418c:	f8 01       	movw	r30, r16
    418e:	61 a1       	ldd	r22, Z+33	; 0x21
    4190:	72 a1       	ldd	r23, Z+34	; 0x22
    4192:	83 a1       	ldd	r24, Z+35	; 0x23
    4194:	94 a1       	ldd	r25, Z+36	; 0x24
    4196:	9b 01       	movw	r18, r22
    4198:	ac 01       	movw	r20, r24
    419a:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    419e:	a5 01       	movw	r20, r10
    41a0:	94 01       	movw	r18, r8
    41a2:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    41a6:	29 81       	ldd	r18, Y+1	; 0x01
    41a8:	3a 81       	ldd	r19, Y+2	; 0x02
    41aa:	4b 81       	ldd	r20, Y+3	; 0x03
    41ac:	5c 81       	ldd	r21, Y+4	; 0x04
    41ae:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    41b2:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    41b6:	a1 e7       	ldi	r26, 0x71	; 113
    41b8:	b1 e0       	ldi	r27, 0x01	; 1
    41ba:	6d 93       	st	X+, r22
    41bc:	7d 93       	st	X+, r23
    41be:	8d 93       	st	X+, r24
    41c0:	9c 93       	st	X, r25
    41c2:	13 97       	sbiw	r26, 0x03	; 3
    41c4:	1e c0       	rjmp	.+60     	; 0x4202 <st_prep_buffer+0x544>
            }          
          } else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    41c6:	82 e0       	ldi	r24, 0x02	; 2
    41c8:	e8 e6       	ldi	r30, 0x68	; 104
    41ca:	f1 e0       	ldi	r31, 0x01	; 1
    41cc:	80 83       	st	Z, r24
            // prep.decelerate_after = pl_block->millimeters;
            prep.maximum_speed = prep.current_speed;
    41ce:	ed e6       	ldi	r30, 0x6D	; 109
    41d0:	f1 e0       	ldi	r31, 0x01	; 1
    41d2:	80 81       	ld	r24, Z
    41d4:	91 81       	ldd	r25, Z+1	; 0x01
    41d6:	a2 81       	ldd	r26, Z+2	; 0x02
    41d8:	b3 81       	ldd	r27, Z+3	; 0x03
    41da:	e1 e7       	ldi	r30, 0x71	; 113
    41dc:	f1 e0       	ldi	r31, 0x01	; 1
    41de:	80 83       	st	Z, r24
    41e0:	91 83       	std	Z+1, r25	; 0x01
    41e2:	a2 83       	std	Z+2, r26	; 0x02
    41e4:	b3 83       	std	Z+3, r27	; 0x03
    41e6:	0d c0       	rjmp	.+26     	; 0x4202 <st_prep_buffer+0x544>
          }
        } else { // Acceleration-only type
          prep.accelerate_until = 0.0;
    41e8:	a9 e7       	ldi	r26, 0x79	; 121
    41ea:	b1 e0       	ldi	r27, 0x01	; 1
    41ec:	1d 92       	st	X+, r1
    41ee:	1d 92       	st	X+, r1
    41f0:	1d 92       	st	X+, r1
    41f2:	1c 92       	st	X, r1
    41f4:	13 97       	sbiw	r26, 0x03	; 3
          // prep.decelerate_after = 0.0;
          prep.maximum_speed = prep.exit_speed;
    41f6:	e1 e7       	ldi	r30, 0x71	; 113
    41f8:	f1 e0       	ldi	r31, 0x01	; 1
    41fa:	40 82       	st	Z, r4
    41fc:	51 82       	std	Z+1, r5	; 0x01
    41fe:	62 82       	std	Z+2, r6	; 0x02
    4200:	73 82       	std	Z+3, r7	; 0x03
        }
      }  
    }

    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    4202:	80 91 89 01 	lds	r24, 0x0189
    4206:	90 e0       	ldi	r25, 0x00	; 0
    4208:	9c 01       	movw	r18, r24
    420a:	22 0f       	add	r18, r18
    420c:	33 1f       	adc	r19, r19
    420e:	82 0f       	add	r24, r18
    4210:	93 1f       	adc	r25, r19
    4212:	88 0f       	add	r24, r24
    4214:	99 1f       	adc	r25, r25
    4216:	9c 01       	movw	r18, r24
    4218:	22 55       	subi	r18, 0x52	; 82
    421a:	3e 4f       	sbci	r19, 0xFE	; 254
    421c:	3c a7       	std	Y+44, r19	; 0x2c
    421e:	2b a7       	std	Y+43, r18	; 0x2b

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    4220:	a6 e5       	ldi	r26, 0x56	; 86
    4222:	b1 e0       	ldi	r27, 0x01	; 1
    4224:	8c 91       	ld	r24, X
    4226:	f9 01       	movw	r30, r18
    4228:	82 83       	std	Z+2, r24	; 0x02
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable   
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    422a:	20 91 83 01 	lds	r18, 0x0183
    422e:	30 91 84 01 	lds	r19, 0x0184
    4232:	3e 8b       	std	Y+22, r19	; 0x16
    4234:	2d 8b       	std	Y+21, r18	; 0x15
    4236:	d9 01       	movw	r26, r18
    4238:	95 96       	adiw	r26, 0x25	; 37
    423a:	bc 91       	ld	r27, X
    423c:	bd a7       	std	Y+45, r27	; 0x2d
    423e:	f9 01       	movw	r30, r18
    4240:	f6 a1       	ldd	r31, Z+38	; 0x26
    4242:	fe a7       	std	Y+46, r31	; 0x2e
    4244:	d9 01       	movw	r26, r18
    4246:	97 96       	adiw	r26, 0x27	; 39
    4248:	bc 91       	ld	r27, X
    424a:	bf a7       	std	Y+47, r27	; 0x2f
    424c:	f9 01       	movw	r30, r18
    424e:	f0 a5       	ldd	r31, Z+40	; 0x28
    4250:	f8 ab       	std	Y+48, r31	; 0x30
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    4252:	20 91 60 01 	lds	r18, 0x0160
    4256:	30 91 61 01 	lds	r19, 0x0161
    425a:	40 91 62 01 	lds	r20, 0x0162
    425e:	50 91 63 01 	lds	r21, 0x0163
    4262:	6d a5       	ldd	r22, Y+45	; 0x2d
    4264:	7e a5       	ldd	r23, Y+46	; 0x2e
    4266:	8b 2f       	mov	r24, r27
    4268:	9f 2f       	mov	r25, r31
    426a:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    426e:	6b a3       	std	Y+35, r22	; 0x23
    4270:	7c a3       	std	Y+36, r23	; 0x24
    4272:	8d a3       	std	Y+37, r24	; 0x25
    4274:	9e a3       	std	Y+38, r25	; 0x26
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    4276:	20 e0       	ldi	r18, 0x00	; 0
    4278:	30 e0       	ldi	r19, 0x00	; 0
    427a:	a9 01       	movw	r20, r18
    427c:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    4280:	88 23       	and	r24, r24
    4282:	24 f4       	brge	.+8      	; 0x428c <st_prep_buffer+0x5ce>
    4284:	1b a2       	std	Y+35, r1	; 0x23
    4286:	1c a2       	std	Y+36, r1	; 0x24
    4288:	1d a2       	std	Y+37, r1	; 0x25
    428a:	1e a2       	std	Y+38, r1	; 0x26
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    428c:	a9 e7       	ldi	r26, 0x79	; 121
    428e:	b1 e0       	ldi	r27, 0x01	; 1
    4290:	bc 91       	ld	r27, X
    4292:	bf 8b       	std	Y+23, r27	; 0x17
    4294:	e0 91 7a 01 	lds	r30, 0x017A
    4298:	e8 8f       	std	Y+24, r30	; 0x18
    429a:	f0 91 7b 01 	lds	r31, 0x017B
    429e:	f9 8f       	std	Y+25, r31	; 0x19
    42a0:	20 91 7c 01 	lds	r18, 0x017C
    42a4:	2a 8f       	std	Y+26, r18	; 0x1a
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    42a6:	a1 e7       	ldi	r26, 0x71	; 113
    42a8:	b1 e0       	ldi	r27, 0x01	; 1
    42aa:	bc 91       	ld	r27, X
    42ac:	bb 8f       	std	Y+27, r27	; 0x1b
    42ae:	e0 91 72 01 	lds	r30, 0x0172
    42b2:	ec 8f       	std	Y+28, r30	; 0x1c
    42b4:	f0 91 73 01 	lds	r31, 0x0173
    42b8:	fd 8f       	std	Y+29, r31	; 0x1d
    42ba:	20 91 74 01 	lds	r18, 0x0174
    42be:	2e 8f       	std	Y+30, r18	; 0x1e
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    42c0:	ad e7       	ldi	r26, 0x7D	; 125
    42c2:	b1 e0       	ldi	r27, 0x01	; 1
    42c4:	bc 91       	ld	r27, X
    42c6:	bf 8f       	std	Y+31, r27	; 0x1f
    42c8:	e0 91 7e 01 	lds	r30, 0x017E
    42cc:	e8 a3       	std	Y+32, r30	; 0x20
    42ce:	f0 91 7f 01 	lds	r31, 0x017F
    42d2:	f9 a3       	std	Y+33, r31	; 0x21
    42d4:	20 91 80 01 	lds	r18, 0x0180
    42d8:	2a a3       	std	Y+34, r18	; 0x22
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
    42da:	a9 e6       	ldi	r26, 0x69	; 105
    42dc:	b1 e0       	ldi	r27, 0x01	; 1
    42de:	bc 91       	ld	r27, X
    42e0:	b9 8b       	std	Y+17, r27	; 0x11
    42e2:	e0 91 6a 01 	lds	r30, 0x016A
    42e6:	ea 8b       	std	Y+18, r30	; 0x12
    42e8:	f0 91 6b 01 	lds	r31, 0x016B
    42ec:	fb 8b       	std	Y+19, r31	; 0x13
    42ee:	20 91 6c 01 	lds	r18, 0x016C
    42f2:	2c 8b       	std	Y+20, r18	; 0x14
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    42f4:	a5 e7       	ldi	r26, 0x75	; 117
    42f6:	b1 e0       	ldi	r27, 0x01	; 1
    42f8:	8d 91       	ld	r24, X+
    42fa:	9d 91       	ld	r25, X+
    42fc:	0d 90       	ld	r0, X+
    42fe:	bc 91       	ld	r27, X
    4300:	a0 2d       	mov	r26, r0
    4302:	89 ab       	std	Y+49, r24	; 0x31
    4304:	9a ab       	std	Y+50, r25	; 0x32
    4306:	ab ab       	std	Y+51, r26	; 0x33
    4308:	bc ab       	std	Y+52, r27	; 0x34
    430a:	ed e6       	ldi	r30, 0x6D	; 109
    430c:	f1 e0       	ldi	r31, 0x01	; 1
    430e:	f0 81       	ld	r31, Z
    4310:	fd 87       	std	Y+13, r31	; 0x0d
    4312:	20 91 6e 01 	lds	r18, 0x016E
    4316:	2e 87       	std	Y+14, r18	; 0x0e
    4318:	30 91 6f 01 	lds	r19, 0x016F
    431c:	3f 87       	std	Y+15, r19	; 0x0f
    431e:	40 91 70 01 	lds	r20, 0x0170
    4322:	48 8b       	std	Y+16, r20	; 0x10
    4324:	a8 e6       	ldi	r26, 0x68	; 104
    4326:	b1 e0       	ldi	r27, 0x01	; 1
    4328:	bc 91       	ld	r27, X
    432a:	b9 87       	std	Y+9, r27	; 0x09
    432c:	ed a5       	ldd	r30, Y+45	; 0x2d
    432e:	fe a5       	ldd	r31, Y+46	; 0x2e
    4330:	ff a3       	std	Y+39, r31	; 0x27
    4332:	0f a5       	ldd	r16, Y+47	; 0x2f
    4334:	18 a9       	ldd	r17, Y+48	; 0x30
    4336:	0f 2e       	mov	r0, r31
    4338:	fe e3       	ldi	r31, 0x3E	; 62
    433a:	2f 2e       	mov	r2, r31
    433c:	f0 2d       	mov	r31, r0
    433e:	0f 2e       	mov	r0, r31
    4340:	f3 ec       	ldi	r31, 0xC3	; 195
    4342:	6f 2e       	mov	r6, r31
    4344:	f0 2d       	mov	r31, r0
    4346:	0f 2e       	mov	r0, r31
    4348:	fe ea       	ldi	r31, 0xAE	; 174
    434a:	7f 2e       	mov	r7, r31
    434c:	f0 2d       	mov	r31, r0
    434e:	0f 2e       	mov	r0, r31
    4350:	f9 e3       	ldi	r31, 0x39	; 57
    4352:	3f 2e       	mov	r3, r31
    4354:	f0 2d       	mov	r31, r0
    4356:	c1 2c       	mov	r12, r1
    4358:	d1 2c       	mov	r13, r1
    435a:	76 01       	movw	r14, r12
    435c:	0f 2e       	mov	r0, r31
    435e:	fe e3       	ldi	r31, 0x3E	; 62
    4360:	4f 2e       	mov	r4, r31
    4362:	f0 2d       	mov	r31, r0
    4364:	0f 2e       	mov	r0, r31
    4366:	f3 ec       	ldi	r31, 0xC3	; 195
    4368:	5f 2e       	mov	r5, r31
    436a:	f0 2d       	mov	r31, r0
    436c:	2e ea       	ldi	r18, 0xAE	; 174
    436e:	29 83       	std	Y+1, r18	; 0x01
    4370:	39 e3       	ldi	r19, 0x39	; 57
    4372:	3d 83       	std	Y+5, r19	; 0x05
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
    4374:	ed ab       	std	Y+53, r30	; 0x35
    4376:	fe ab       	std	Y+54, r31	; 0x36
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    4378:	49 85       	ldd	r20, Y+9	; 0x09
    437a:	44 23       	and	r20, r20
    437c:	21 f0       	breq	.+8      	; 0x4386 <st_prep_buffer+0x6c8>
    437e:	41 30       	cpi	r20, 0x01	; 1
    4380:	09 f4       	brne	.+2      	; 0x4384 <st_prep_buffer+0x6c6>
    4382:	8a c0       	rjmp	.+276    	; 0x4498 <st_prep_buffer+0x7da>
    4384:	c9 c0       	rjmp	.+402    	; 0x4518 <st_prep_buffer+0x85a>
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    4386:	ad 89       	ldd	r26, Y+21	; 0x15
    4388:	be 89       	ldd	r27, Y+22	; 0x16
    438a:	91 96       	adiw	r26, 0x21	; 33
    438c:	2d 91       	ld	r18, X+
    438e:	3d 91       	ld	r19, X+
    4390:	4d 91       	ld	r20, X+
    4392:	5c 91       	ld	r21, X
    4394:	94 97       	sbiw	r26, 0x24	; 36
    4396:	62 2d       	mov	r22, r2
    4398:	76 2d       	mov	r23, r6
    439a:	87 2d       	mov	r24, r7
    439c:	93 2d       	mov	r25, r3
    439e:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    43a2:	4b 01       	movw	r8, r22
    43a4:	5c 01       	movw	r10, r24
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    43a6:	20 e0       	ldi	r18, 0x00	; 0
    43a8:	30 e0       	ldi	r19, 0x00	; 0
    43aa:	40 e0       	ldi	r20, 0x00	; 0
    43ac:	5f e3       	ldi	r21, 0x3F	; 63
    43ae:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    43b2:	2d 85       	ldd	r18, Y+13	; 0x0d
    43b4:	3e 85       	ldd	r19, Y+14	; 0x0e
    43b6:	4f 85       	ldd	r20, Y+15	; 0x0f
    43b8:	58 89       	ldd	r21, Y+16	; 0x10
    43ba:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    43be:	22 2d       	mov	r18, r2
    43c0:	36 2d       	mov	r19, r6
    43c2:	47 2d       	mov	r20, r7
    43c4:	53 2d       	mov	r21, r3
    43c6:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    43ca:	9b 01       	movw	r18, r22
    43cc:	ac 01       	movw	r20, r24
    43ce:	6d a9       	ldd	r22, Y+53	; 0x35
    43d0:	7e a9       	ldd	r23, Y+54	; 0x36
    43d2:	80 2f       	mov	r24, r16
    43d4:	91 2f       	mov	r25, r17
    43d6:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    43da:	6d ab       	std	Y+53, r22	; 0x35
    43dc:	7e ab       	std	Y+54, r23	; 0x36
    43de:	08 2f       	mov	r16, r24
    43e0:	19 2f       	mov	r17, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    43e2:	2f 89       	ldd	r18, Y+23	; 0x17
    43e4:	38 8d       	ldd	r19, Y+24	; 0x18
    43e6:	49 8d       	ldd	r20, Y+25	; 0x19
    43e8:	5a 8d       	ldd	r21, Y+26	; 0x1a
    43ea:	91 2f       	mov	r25, r17
    43ec:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    43f0:	88 23       	and	r24, r24
    43f2:	0c f0       	brlt	.+2      	; 0x43f6 <st_prep_buffer+0x738>
    43f4:	44 c0       	rjmp	.+136    	; 0x447e <st_prep_buffer+0x7c0>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    43f6:	2f 89       	ldd	r18, Y+23	; 0x17
    43f8:	38 8d       	ldd	r19, Y+24	; 0x18
    43fa:	49 8d       	ldd	r20, Y+25	; 0x19
    43fc:	5a 8d       	ldd	r21, Y+26	; 0x1a
    43fe:	6d a5       	ldd	r22, Y+45	; 0x2d
    4400:	7e a5       	ldd	r23, Y+46	; 0x2e
    4402:	8f a5       	ldd	r24, Y+47	; 0x2f
    4404:	98 a9       	ldd	r25, Y+48	; 0x30
    4406:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    440a:	9b 01       	movw	r18, r22
    440c:	ac 01       	movw	r20, r24
    440e:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    4412:	4b 01       	movw	r8, r22
    4414:	5c 01       	movw	r10, r24
    4416:	2d 85       	ldd	r18, Y+13	; 0x0d
    4418:	3e 85       	ldd	r19, Y+14	; 0x0e
    441a:	4f 85       	ldd	r20, Y+15	; 0x0f
    441c:	58 89       	ldd	r21, Y+16	; 0x10
    441e:	6b 8d       	ldd	r22, Y+27	; 0x1b
    4420:	7c 8d       	ldd	r23, Y+28	; 0x1c
    4422:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4424:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4426:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    442a:	9b 01       	movw	r18, r22
    442c:	ac 01       	movw	r20, r24
    442e:	c5 01       	movw	r24, r10
    4430:	b4 01       	movw	r22, r8
    4432:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    4436:	26 2e       	mov	r2, r22
    4438:	67 2e       	mov	r6, r23
    443a:	78 2e       	mov	r7, r24
    443c:	39 2e       	mov	r3, r25
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    443e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    4440:	38 a1       	ldd	r19, Y+32	; 0x20
    4442:	49 a1       	ldd	r20, Y+33	; 0x21
    4444:	5a a1       	ldd	r21, Y+34	; 0x22
    4446:	6f 89       	ldd	r22, Y+23	; 0x17
    4448:	78 8d       	ldd	r23, Y+24	; 0x18
    444a:	89 8d       	ldd	r24, Y+25	; 0x19
    444c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    444e:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    4452:	88 23       	and	r24, r24
    4454:	19 f0       	breq	.+6      	; 0x445c <st_prep_buffer+0x79e>
            else { prep.ramp_type = RAMP_CRUISE; }
    4456:	b1 e0       	ldi	r27, 0x01	; 1
    4458:	b9 87       	std	Y+9, r27	; 0x09
    445a:	02 c0       	rjmp	.+4      	; 0x4460 <st_prep_buffer+0x7a2>
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    445c:	e2 e0       	ldi	r30, 0x02	; 2
    445e:	e9 87       	std	Y+9, r30	; 0x09
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    4460:	fb 8d       	ldd	r31, Y+27	; 0x1b
    4462:	fd 87       	std	Y+13, r31	; 0x0d
    4464:	2c 8d       	ldd	r18, Y+28	; 0x1c
    4466:	2e 87       	std	Y+14, r18	; 0x0e
    4468:	3d 8d       	ldd	r19, Y+29	; 0x1d
    446a:	3f 87       	std	Y+15, r19	; 0x0f
    446c:	4e 8d       	ldd	r20, Y+30	; 0x1e
    446e:	48 8b       	std	Y+16, r20	; 0x10
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    4470:	5f 89       	ldd	r21, Y+23	; 0x17
    4472:	5d ab       	std	Y+53, r21	; 0x35
    4474:	88 8d       	ldd	r24, Y+24	; 0x18
    4476:	8e ab       	std	Y+54, r24	; 0x36
    4478:	09 8d       	ldd	r16, Y+25	; 0x19
    447a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    447c:	d1 c0       	rjmp	.+418    	; 0x4620 <st_prep_buffer+0x962>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only. 
            prep.current_speed += speed_var;
    447e:	2d 85       	ldd	r18, Y+13	; 0x0d
    4480:	3e 85       	ldd	r19, Y+14	; 0x0e
    4482:	4f 85       	ldd	r20, Y+15	; 0x0f
    4484:	58 89       	ldd	r21, Y+16	; 0x10
    4486:	c5 01       	movw	r24, r10
    4488:	b4 01       	movw	r22, r8
    448a:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    448e:	6d 87       	std	Y+13, r22	; 0x0d
    4490:	7e 87       	std	Y+14, r23	; 0x0e
    4492:	8f 87       	std	Y+15, r24	; 0x0f
    4494:	98 8b       	std	Y+16, r25	; 0x10
    4496:	c4 c0       	rjmp	.+392    	; 0x4620 <st_prep_buffer+0x962>
          break;
        case RAMP_CRUISE: 
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To 
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    4498:	2b 8d       	ldd	r18, Y+27	; 0x1b
    449a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    449c:	4d 8d       	ldd	r20, Y+29	; 0x1d
    449e:	5e 8d       	ldd	r21, Y+30	; 0x1e
    44a0:	62 2d       	mov	r22, r2
    44a2:	76 2d       	mov	r23, r6
    44a4:	87 2d       	mov	r24, r7
    44a6:	93 2d       	mov	r25, r3
    44a8:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    44ac:	9b 01       	movw	r18, r22
    44ae:	ac 01       	movw	r20, r24
    44b0:	6d a9       	ldd	r22, Y+53	; 0x35
    44b2:	7e a9       	ldd	r23, Y+54	; 0x36
    44b4:	80 2f       	mov	r24, r16
    44b6:	91 2f       	mov	r25, r17
    44b8:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    44bc:	a6 2e       	mov	r10, r22
    44be:	b7 2e       	mov	r11, r23
    44c0:	88 2e       	mov	r8, r24
    44c2:	99 2e       	mov	r9, r25
          if (mm_var < prep.decelerate_after) { // End of cruise. 
    44c4:	26 2f       	mov	r18, r22
    44c6:	37 2f       	mov	r19, r23
    44c8:	48 2f       	mov	r20, r24
    44ca:	59 2f       	mov	r21, r25
    44cc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    44ce:	78 a1       	ldd	r23, Y+32	; 0x20
    44d0:	89 a1       	ldd	r24, Y+33	; 0x21
    44d2:	9a a1       	ldd	r25, Y+34	; 0x22
    44d4:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    44d8:	18 16       	cp	r1, r24
    44da:	0c f0       	brlt	.+2      	; 0x44de <st_prep_buffer+0x820>
    44dc:	9d c0       	rjmp	.+314    	; 0x4618 <st_prep_buffer+0x95a>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    44de:	2f 8d       	ldd	r18, Y+31	; 0x1f
    44e0:	38 a1       	ldd	r19, Y+32	; 0x20
    44e2:	49 a1       	ldd	r20, Y+33	; 0x21
    44e4:	5a a1       	ldd	r21, Y+34	; 0x22
    44e6:	6d a9       	ldd	r22, Y+53	; 0x35
    44e8:	7e a9       	ldd	r23, Y+54	; 0x36
    44ea:	80 2f       	mov	r24, r16
    44ec:	91 2f       	mov	r25, r17
    44ee:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    44f2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    44f4:	3c 8d       	ldd	r19, Y+28	; 0x1c
    44f6:	4d 8d       	ldd	r20, Y+29	; 0x1d
    44f8:	5e 8d       	ldd	r21, Y+30	; 0x1e
    44fa:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    44fe:	26 2e       	mov	r2, r22
    4500:	67 2e       	mov	r6, r23
    4502:	78 2e       	mov	r7, r24
    4504:	39 2e       	mov	r3, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    4506:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4508:	9d ab       	std	Y+53, r25	; 0x35
    450a:	a8 a1       	ldd	r26, Y+32	; 0x20
    450c:	ae ab       	std	Y+54, r26	; 0x36
    450e:	09 a1       	ldd	r16, Y+33	; 0x21
    4510:	1a a1       	ldd	r17, Y+34	; 0x22
            prep.ramp_type = RAMP_DECEL;
    4512:	b2 e0       	ldi	r27, 0x02	; 2
    4514:	b9 87       	std	Y+9, r27	; 0x09
    4516:	84 c0       	rjmp	.+264    	; 0x4620 <st_prep_buffer+0x962>
            mm_remaining = mm_var; 
          } 
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    4518:	ed 89       	ldd	r30, Y+21	; 0x15
    451a:	fe 89       	ldd	r31, Y+22	; 0x16
    451c:	21 a1       	ldd	r18, Z+33	; 0x21
    451e:	32 a1       	ldd	r19, Z+34	; 0x22
    4520:	43 a1       	ldd	r20, Z+35	; 0x23
    4522:	54 a1       	ldd	r21, Z+36	; 0x24
    4524:	62 2d       	mov	r22, r2
    4526:	76 2d       	mov	r23, r6
    4528:	87 2d       	mov	r24, r7
    452a:	93 2d       	mov	r25, r3
    452c:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    4530:	4b 01       	movw	r8, r22
    4532:	5c 01       	movw	r10, r24
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    4534:	9b 01       	movw	r18, r22
    4536:	ac 01       	movw	r20, r24
    4538:	6d 85       	ldd	r22, Y+13	; 0x0d
    453a:	7e 85       	ldd	r23, Y+14	; 0x0e
    453c:	8f 85       	ldd	r24, Y+15	; 0x0f
    453e:	98 89       	ldd	r25, Y+16	; 0x10
    4540:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    4544:	18 16       	cp	r1, r24
    4546:	ec f5       	brge	.+122    	; 0x45c2 <st_prep_buffer+0x904>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    4548:	20 e0       	ldi	r18, 0x00	; 0
    454a:	30 e0       	ldi	r19, 0x00	; 0
    454c:	40 e0       	ldi	r20, 0x00	; 0
    454e:	5f e3       	ldi	r21, 0x3F	; 63
    4550:	c5 01       	movw	r24, r10
    4552:	b4 01       	movw	r22, r8
    4554:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    4558:	9b 01       	movw	r18, r22
    455a:	ac 01       	movw	r20, r24
    455c:	6d 85       	ldd	r22, Y+13	; 0x0d
    455e:	7e 85       	ldd	r23, Y+14	; 0x0e
    4560:	8f 85       	ldd	r24, Y+15	; 0x0f
    4562:	98 89       	ldd	r25, Y+16	; 0x10
    4564:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    4568:	22 2d       	mov	r18, r2
    456a:	36 2d       	mov	r19, r6
    456c:	47 2d       	mov	r20, r7
    456e:	53 2d       	mov	r21, r3
    4570:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    4574:	9b 01       	movw	r18, r22
    4576:	ac 01       	movw	r20, r24
    4578:	6d a9       	ldd	r22, Y+53	; 0x35
    457a:	7e a9       	ldd	r23, Y+54	; 0x36
    457c:	80 2f       	mov	r24, r16
    457e:	91 2f       	mov	r25, r17
    4580:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    4584:	6f a3       	std	Y+39, r22	; 0x27
    4586:	78 a7       	std	Y+40, r23	; 0x28
    4588:	89 a7       	std	Y+41, r24	; 0x29
    458a:	9a a7       	std	Y+42, r25	; 0x2a
            if (mm_var > prep.mm_complete) { // Deceleration only.
    458c:	29 89       	ldd	r18, Y+17	; 0x11
    458e:	3a 89       	ldd	r19, Y+18	; 0x12
    4590:	4b 89       	ldd	r20, Y+19	; 0x13
    4592:	5c 89       	ldd	r21, Y+20	; 0x14
    4594:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    4598:	18 16       	cp	r1, r24
    459a:	9c f4       	brge	.+38     	; 0x45c2 <st_prep_buffer+0x904>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    459c:	a5 01       	movw	r20, r10
    459e:	94 01       	movw	r18, r8
    45a0:	6d 85       	ldd	r22, Y+13	; 0x0d
    45a2:	7e 85       	ldd	r23, Y+14	; 0x0e
    45a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    45a6:	98 89       	ldd	r25, Y+16	; 0x10
    45a8:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    45ac:	6d 87       	std	Y+13, r22	; 0x0d
    45ae:	7e 87       	std	Y+14, r23	; 0x0e
    45b0:	8f 87       	std	Y+15, r24	; 0x0f
    45b2:	98 8b       	std	Y+16, r25	; 0x10
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
              mm_remaining = mm_var;
    45b4:	ff a1       	ldd	r31, Y+39	; 0x27
    45b6:	fd ab       	std	Y+53, r31	; 0x35
    45b8:	28 a5       	ldd	r18, Y+40	; 0x28
    45ba:	2e ab       	std	Y+54, r18	; 0x36
    45bc:	09 a5       	ldd	r16, Y+41	; 0x29
    45be:	1a a5       	ldd	r17, Y+42	; 0x2a
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    45c0:	2f c0       	rjmp	.+94     	; 0x4620 <st_prep_buffer+0x962>
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    45c2:	29 89       	ldd	r18, Y+17	; 0x11
    45c4:	3a 89       	ldd	r19, Y+18	; 0x12
    45c6:	4b 89       	ldd	r20, Y+19	; 0x13
    45c8:	5c 89       	ldd	r21, Y+20	; 0x14
    45ca:	6d a9       	ldd	r22, Y+53	; 0x35
    45cc:	7e a9       	ldd	r23, Y+54	; 0x36
    45ce:	80 2f       	mov	r24, r16
    45d0:	91 2f       	mov	r25, r17
    45d2:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    45d6:	9b 01       	movw	r18, r22
    45d8:	ac 01       	movw	r20, r24
    45da:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    45de:	4b 01       	movw	r8, r22
    45e0:	5c 01       	movw	r10, r24
    45e2:	29 a9       	ldd	r18, Y+49	; 0x31
    45e4:	3a a9       	ldd	r19, Y+50	; 0x32
    45e6:	4b a9       	ldd	r20, Y+51	; 0x33
    45e8:	5c a9       	ldd	r21, Y+52	; 0x34
    45ea:	6d 85       	ldd	r22, Y+13	; 0x0d
    45ec:	7e 85       	ldd	r23, Y+14	; 0x0e
    45ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    45f0:	98 89       	ldd	r25, Y+16	; 0x10
    45f2:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    45f6:	9b 01       	movw	r18, r22
    45f8:	ac 01       	movw	r20, r24
    45fa:	c5 01       	movw	r24, r10
    45fc:	b4 01       	movw	r22, r8
    45fe:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    4602:	26 2e       	mov	r2, r22
    4604:	67 2e       	mov	r6, r23
    4606:	78 2e       	mov	r7, r24
    4608:	39 2e       	mov	r3, r25
          mm_remaining = prep.mm_complete; 
    460a:	39 89       	ldd	r19, Y+17	; 0x11
    460c:	3d ab       	std	Y+53, r19	; 0x35
    460e:	4a 89       	ldd	r20, Y+18	; 0x12
    4610:	4e ab       	std	Y+54, r20	; 0x36
    4612:	0b 89       	ldd	r16, Y+19	; 0x13
    4614:	1c 89       	ldd	r17, Y+20	; 0x14
    4616:	04 c0       	rjmp	.+8      	; 0x4620 <st_prep_buffer+0x962>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.         
            mm_remaining = mm_var; 
    4618:	ad aa       	std	Y+53, r10	; 0x35
    461a:	be aa       	std	Y+54, r11	; 0x36
    461c:	08 2d       	mov	r16, r8
    461e:	19 2d       	mov	r17, r9
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete; 
      }
      dt += time_var; // Add computed ramp time to total segment time.
    4620:	22 2d       	mov	r18, r2
    4622:	36 2d       	mov	r19, r6
    4624:	47 2d       	mov	r20, r7
    4626:	53 2d       	mov	r21, r3
    4628:	c7 01       	movw	r24, r14
    462a:	b6 01       	movw	r22, r12
    462c:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    4630:	6b 01       	movw	r12, r22
    4632:	7c 01       	movw	r14, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    4634:	9b 01       	movw	r18, r22
    4636:	ac 01       	movw	r20, r24
    4638:	64 2d       	mov	r22, r4
    463a:	75 2d       	mov	r23, r5
    463c:	89 81       	ldd	r24, Y+1	; 0x01
    463e:	9d 81       	ldd	r25, Y+5	; 0x05
    4640:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    4644:	18 16       	cp	r1, r24
    4646:	6c f4       	brge	.+26     	; 0x4662 <st_prep_buffer+0x9a4>
    4648:	a7 01       	movw	r20, r14
    464a:	96 01       	movw	r18, r12
    464c:	64 2d       	mov	r22, r4
    464e:	75 2d       	mov	r23, r5
    4650:	89 81       	ldd	r24, Y+1	; 0x01
    4652:	9d 81       	ldd	r25, Y+5	; 0x05
    4654:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    4658:	26 2e       	mov	r2, r22
    465a:	67 2e       	mov	r6, r23
    465c:	78 2e       	mov	r7, r24
    465e:	39 2e       	mov	r3, r25
    4660:	33 c0       	rjmp	.+102    	; 0x46c8 <st_prep_buffer+0xa0a>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    4662:	2b a1       	ldd	r18, Y+35	; 0x23
    4664:	3c a1       	ldd	r19, Y+36	; 0x24
    4666:	4d a1       	ldd	r20, Y+37	; 0x25
    4668:	5e a1       	ldd	r21, Y+38	; 0x26
    466a:	6d a9       	ldd	r22, Y+53	; 0x35
    466c:	7e a9       	ldd	r23, Y+54	; 0x36
    466e:	80 2f       	mov	r24, r16
    4670:	91 2f       	mov	r25, r17
    4672:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    4676:	18 16       	cp	r1, r24
    4678:	8c f0       	brlt	.+34     	; 0x469c <st_prep_buffer+0x9de>
    467a:	8e a9       	ldd	r24, Y+54	; 0x36
    467c:	8f a3       	std	Y+39, r24	; 0x27
    467e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4680:	9e 85       	ldd	r25, Y+14	; 0x0e
    4682:	af 85       	ldd	r26, Y+15	; 0x0f
    4684:	b8 89       	ldd	r27, Y+16	; 0x10
    4686:	ed e6       	ldi	r30, 0x6D	; 109
    4688:	f1 e0       	ldi	r31, 0x01	; 1
    468a:	80 83       	st	Z, r24
    468c:	91 83       	std	Z+1, r25	; 0x01
    468e:	a2 83       	std	Z+2, r26	; 0x02
    4690:	b3 83       	std	Z+3, r27	; 0x03
    4692:	e9 85       	ldd	r30, Y+9	; 0x09
    4694:	a8 e6       	ldi	r26, 0x68	; 104
    4696:	b1 e0       	ldi	r27, 0x01	; 1
    4698:	ec 93       	st	X, r30
    469a:	33 c0       	rjmp	.+102    	; 0x4702 <st_prep_buffer+0xa44>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    469c:	2e e3       	ldi	r18, 0x3E	; 62
    469e:	33 ec       	ldi	r19, 0xC3	; 195
    46a0:	4e ea       	ldi	r20, 0xAE	; 174
    46a2:	59 e3       	ldi	r21, 0x39	; 57
    46a4:	64 2d       	mov	r22, r4
    46a6:	75 2d       	mov	r23, r5
    46a8:	89 81       	ldd	r24, Y+1	; 0x01
    46aa:	9d 81       	ldd	r25, Y+5	; 0x05
    46ac:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    46b0:	46 2e       	mov	r4, r22
    46b2:	57 2e       	mov	r5, r23
    46b4:	89 83       	std	Y+1, r24	; 0x01
    46b6:	9d 83       	std	Y+5, r25	; 0x05
          time_var = dt_max - dt;
    46b8:	a7 01       	movw	r20, r14
    46ba:	96 01       	movw	r18, r12
    46bc:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    46c0:	26 2e       	mov	r2, r22
    46c2:	67 2e       	mov	r6, r23
    46c4:	78 2e       	mov	r7, r24
    46c6:	39 2e       	mov	r3, r25
        } else { 
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    46c8:	29 89       	ldd	r18, Y+17	; 0x11
    46ca:	3a 89       	ldd	r19, Y+18	; 0x12
    46cc:	4b 89       	ldd	r20, Y+19	; 0x13
    46ce:	5c 89       	ldd	r21, Y+20	; 0x14
    46d0:	6d a9       	ldd	r22, Y+53	; 0x35
    46d2:	7e a9       	ldd	r23, Y+54	; 0x36
    46d4:	80 2f       	mov	r24, r16
    46d6:	91 2f       	mov	r25, r17
    46d8:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    46dc:	18 16       	cp	r1, r24
    46de:	0c f4       	brge	.+2      	; 0x46e2 <st_prep_buffer+0xa24>
    46e0:	4b ce       	rjmp	.-874    	; 0x4378 <st_prep_buffer+0x6ba>
    46e2:	8e a9       	ldd	r24, Y+54	; 0x36
    46e4:	8f a3       	std	Y+39, r24	; 0x27
    46e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    46e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    46ea:	af 85       	ldd	r26, Y+15	; 0x0f
    46ec:	b8 89       	ldd	r27, Y+16	; 0x10
    46ee:	ed e6       	ldi	r30, 0x6D	; 109
    46f0:	f1 e0       	ldi	r31, 0x01	; 1
    46f2:	80 83       	st	Z, r24
    46f4:	91 83       	std	Z+1, r25	; 0x01
    46f6:	a2 83       	std	Z+2, r26	; 0x02
    46f8:	b3 83       	std	Z+3, r27	; 0x03
    46fa:	e9 85       	ldd	r30, Y+9	; 0x09
    46fc:	a8 e6       	ldi	r26, 0x68	; 104
    46fe:	b1 e0       	ldi	r27, 0x01	; 1
    4700:	ec 93       	st	X, r30
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    4702:	ac e5       	ldi	r26, 0x5C	; 92
    4704:	b1 e0       	ldi	r27, 0x01	; 1
    4706:	2d 91       	ld	r18, X+
    4708:	3d 91       	ld	r19, X+
    470a:	4d 91       	ld	r20, X+
    470c:	5c 91       	ld	r21, X
    470e:	29 87       	std	Y+9, r18	; 0x09
    4710:	3a 87       	std	Y+10, r19	; 0x0a
    4712:	4b 87       	std	Y+11, r20	; 0x0b
    4714:	5c 87       	std	Y+12, r21	; 0x0c
    4716:	2d a9       	ldd	r18, Y+53	; 0x35
    4718:	3f a1       	ldd	r19, Y+39	; 0x27
    471a:	40 2f       	mov	r20, r16
    471c:	51 2f       	mov	r21, r17
    471e:	69 85       	ldd	r22, Y+9	; 0x09
    4720:	7a 85       	ldd	r23, Y+10	; 0x0a
    4722:	8b 85       	ldd	r24, Y+11	; 0x0b
    4724:	9c 85       	ldd	r25, Y+12	; 0x0c
    4726:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    472a:	2b 01       	movw	r4, r22
    472c:	3c 01       	movw	r6, r24
    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining
    472e:	0e 94 79 3c 	call	0x78f2	; 0x78f2 <ceil>
    4732:	6d 83       	std	Y+5, r22	; 0x05
    4734:	7e 83       	std	Y+6, r23	; 0x06
    4736:	8f 83       	std	Y+7, r24	; 0x07
    4738:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    473a:	e8 e5       	ldi	r30, 0x58	; 88
    473c:	f1 e0       	ldi	r31, 0x01	; 1
    473e:	60 81       	ld	r22, Z
    4740:	71 81       	ldd	r23, Z+1	; 0x01
    4742:	82 81       	ldd	r24, Z+2	; 0x02
    4744:	93 81       	ldd	r25, Z+3	; 0x03
    4746:	0e 94 79 3c 	call	0x78f2	; 0x78f2 <ceil>
    474a:	4b 01       	movw	r8, r22
    474c:	5c 01       	movw	r10, r24
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    474e:	2d 81       	ldd	r18, Y+5	; 0x05
    4750:	3e 81       	ldd	r19, Y+6	; 0x06
    4752:	4f 81       	ldd	r20, Y+7	; 0x07
    4754:	58 85       	ldd	r21, Y+8	; 0x08
    4756:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    475a:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
    475e:	69 83       	std	Y+1, r22	; 0x01
    4760:	7a 83       	std	Y+2, r23	; 0x02
    4762:	8b 83       	std	Y+3, r24	; 0x03
    4764:	9c 83       	std	Y+4, r25	; 0x04
    4766:	e9 81       	ldd	r30, Y+1	; 0x01
    4768:	fa 81       	ldd	r31, Y+2	; 0x02
    476a:	ab a5       	ldd	r26, Y+43	; 0x2b
    476c:	bc a5       	ldd	r27, Y+44	; 0x2c
    476e:	ed 93       	st	X+, r30
    4770:	fc 93       	st	X, r31
    
    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    4772:	30 97       	sbiw	r30, 0x00	; 0
    4774:	91 f5       	brne	.+100    	; 0x47da <st_prep_buffer+0xb1c>
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    4776:	a8 e6       	ldi	r26, 0x68	; 104
    4778:	b7 e0       	ldi	r27, 0x07	; 7
    477a:	8c 91       	ld	r24, X
    477c:	80 77       	andi	r24, 0x70	; 112
    477e:	69 f1       	breq	.+90     	; 0x47da <st_prep_buffer+0xb1c>
    4780:	4d 80       	ldd	r4, Y+5	; 0x05
    4782:	5e 80       	ldd	r5, Y+6	; 0x06
    4784:	6f 80       	ldd	r6, Y+7	; 0x07
    4786:	78 84       	ldd	r7, Y+8	; 0x08
        // Less than one step to decelerate to zero speed, but already very close. AMASS 
        // requires full steps to execute. So, just bail.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    4788:	10 92 6d 01 	sts	0x016D, r1
    478c:	10 92 6e 01 	sts	0x016E, r1
    4790:	10 92 6f 01 	sts	0x016F, r1
    4794:	10 92 70 01 	sts	0x0170, r1
        prep.dt_remainder = 0.0;
    4798:	10 92 64 01 	sts	0x0164, r1
    479c:	10 92 65 01 	sts	0x0165, r1
    47a0:	10 92 66 01 	sts	0x0166, r1
    47a4:	10 92 67 01 	sts	0x0167, r1
        prep.steps_remaining = n_steps_remaining;
    47a8:	40 92 58 01 	sts	0x0158, r4
    47ac:	50 92 59 01 	sts	0x0159, r5
    47b0:	60 92 5a 01 	sts	0x015A, r6
    47b4:	70 92 5b 01 	sts	0x015B, r7
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    47b8:	29 85       	ldd	r18, Y+9	; 0x09
    47ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    47bc:	4b 85       	ldd	r20, Y+11	; 0x0b
    47be:	5c 85       	ldd	r21, Y+12	; 0x0c
    47c0:	c3 01       	movw	r24, r6
    47c2:	b2 01       	movw	r22, r4
    47c4:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    47c8:	ed 89       	ldd	r30, Y+21	; 0x15
    47ca:	fe 89       	ldd	r31, Y+22	; 0x16
    47cc:	65 a3       	std	Z+37, r22	; 0x25
    47ce:	76 a3       	std	Z+38, r23	; 0x26
    47d0:	87 a3       	std	Z+39, r24	; 0x27
    47d2:	90 a7       	std	Z+40, r25	; 0x28
        plan_cycle_reinitialize();         
    47d4:	0e 94 e2 2d 	call	0x5bc4	; 0x5bc4 <plan_cycle_reinitialize>
        return; // Segment not generated, but current step data still retained.
    47d8:	05 c1       	rjmp	.+522    	; 0x49e4 <st_prep_buffer+0xd26>
    // compensate, we track the time to execute the previous segment's partial step and simply
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are 
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    47da:	0f 2e       	mov	r0, r31
    47dc:	f4 e6       	ldi	r31, 0x64	; 100
    47de:	2f 2e       	mov	r2, r31
    47e0:	f1 e0       	ldi	r31, 0x01	; 1
    47e2:	3f 2e       	mov	r3, r31
    47e4:	f0 2d       	mov	r31, r0
    47e6:	d1 01       	movw	r26, r2
    47e8:	2d 91       	ld	r18, X+
    47ea:	3d 91       	ld	r19, X+
    47ec:	4d 91       	ld	r20, X+
    47ee:	5c 91       	ld	r21, X
    47f0:	c7 01       	movw	r24, r14
    47f2:	b6 01       	movw	r22, r12
    47f4:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    47f8:	6b 01       	movw	r12, r22
    47fa:	7c 01       	movw	r14, r24
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
    47fc:	a3 01       	movw	r20, r6
    47fe:	92 01       	movw	r18, r4
    4800:	c5 01       	movw	r24, r10
    4802:	b4 01       	movw	r22, r8
    4804:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    4808:	9b 01       	movw	r18, r22
    480a:	ac 01       	movw	r20, r24
    480c:	c7 01       	movw	r24, r14
    480e:	b6 01       	movw	r22, r12
    4810:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    4814:	6b 01       	movw	r12, r22
    4816:	7c 01       	movw	r14, r24
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time
    4818:	a3 01       	movw	r20, r6
    481a:	92 01       	movw	r18, r4
    481c:	6d 81       	ldd	r22, Y+5	; 0x05
    481e:	7e 81       	ldd	r23, Y+6	; 0x06
    4820:	8f 81       	ldd	r24, Y+7	; 0x07
    4822:	98 85       	ldd	r25, Y+8	; 0x08
    4824:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    4828:	a7 01       	movw	r20, r14
    482a:	96 01       	movw	r18, r12
    482c:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    4830:	f1 01       	movw	r30, r2
    4832:	60 83       	st	Z, r22
    4834:	71 83       	std	Z+1, r23	; 0x01
    4836:	82 83       	std	Z+2, r24	; 0x02
    4838:	93 83       	std	Z+3, r25	; 0x03

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)    
    483a:	2c ef       	ldi	r18, 0xFC	; 252
    483c:	3e eb       	ldi	r19, 0xBE	; 190
    483e:	40 e8       	ldi	r20, 0x80	; 128
    4840:	5e e4       	ldi	r21, 0x4E	; 78
    4842:	c7 01       	movw	r24, r14
    4844:	b6 01       	movw	r22, r12
    4846:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    484a:	0e 94 79 3c 	call	0x78f2	; 0x78f2 <ceil>
    484e:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    4852:	61 15       	cp	r22, r1
    4854:	f9 e0       	ldi	r31, 0x09	; 9
    4856:	7f 07       	cpc	r23, r31
    4858:	81 05       	cpc	r24, r1
    485a:	91 05       	cpc	r25, r1
    485c:	28 f4       	brcc	.+10     	; 0x4868 <st_prep_buffer+0xbaa>
    485e:	ab a5       	ldd	r26, Y+43	; 0x2b
    4860:	bc a5       	ldd	r27, Y+44	; 0x2c
    4862:	15 96       	adiw	r26, 0x05	; 5
    4864:	1c 92       	st	X, r1
    4866:	31 c0       	rjmp	.+98     	; 0x48ca <st_prep_buffer+0xc0c>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    4868:	61 15       	cp	r22, r1
    486a:	b2 e1       	ldi	r27, 0x12	; 18
    486c:	7b 07       	cpc	r23, r27
    486e:	81 05       	cpc	r24, r1
    4870:	91 05       	cpc	r25, r1
    4872:	28 f4       	brcc	.+10     	; 0x487e <st_prep_buffer+0xbc0>
    4874:	21 e0       	ldi	r18, 0x01	; 1
    4876:	eb a5       	ldd	r30, Y+43	; 0x2b
    4878:	fc a5       	ldd	r31, Y+44	; 0x2c
    487a:	25 83       	std	Z+5, r18	; 0x05
    487c:	10 c0       	rjmp	.+32     	; 0x489e <st_prep_buffer+0xbe0>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    487e:	61 15       	cp	r22, r1
    4880:	f4 e2       	ldi	r31, 0x24	; 36
    4882:	7f 07       	cpc	r23, r31
    4884:	81 05       	cpc	r24, r1
    4886:	91 05       	cpc	r25, r1
    4888:	30 f4       	brcc	.+12     	; 0x4896 <st_prep_buffer+0xbd8>
    488a:	22 e0       	ldi	r18, 0x02	; 2
    488c:	ab a5       	ldd	r26, Y+43	; 0x2b
    488e:	bc a5       	ldd	r27, Y+44	; 0x2c
    4890:	15 96       	adiw	r26, 0x05	; 5
    4892:	2c 93       	st	X, r18
    4894:	04 c0       	rjmp	.+8      	; 0x489e <st_prep_buffer+0xbe0>
        else { prep_segment->amass_level = 3; }    
    4896:	23 e0       	ldi	r18, 0x03	; 3
    4898:	eb a5       	ldd	r30, Y+43	; 0x2b
    489a:	fc a5       	ldd	r31, Y+44	; 0x2c
    489c:	25 83       	std	Z+5, r18	; 0x05
        cycles >>= prep_segment->amass_level; 
    489e:	ab a5       	ldd	r26, Y+43	; 0x2b
    48a0:	bc a5       	ldd	r27, Y+44	; 0x2c
    48a2:	15 96       	adiw	r26, 0x05	; 5
    48a4:	2c 91       	ld	r18, X
    48a6:	15 97       	sbiw	r26, 0x05	; 5
    48a8:	02 2e       	mov	r0, r18
    48aa:	04 c0       	rjmp	.+8      	; 0x48b4 <st_prep_buffer+0xbf6>
    48ac:	96 95       	lsr	r25
    48ae:	87 95       	ror	r24
    48b0:	77 95       	ror	r23
    48b2:	67 95       	ror	r22
    48b4:	0a 94       	dec	r0
    48b6:	d2 f7       	brpl	.-12     	; 0x48ac <st_prep_buffer+0xbee>
        prep_segment->n_step <<= prep_segment->amass_level;
    48b8:	e9 81       	ldd	r30, Y+1	; 0x01
    48ba:	fa 81       	ldd	r31, Y+2	; 0x02
    48bc:	02 c0       	rjmp	.+4      	; 0x48c2 <st_prep_buffer+0xc04>
    48be:	ee 0f       	add	r30, r30
    48c0:	ff 1f       	adc	r31, r31
    48c2:	2a 95       	dec	r18
    48c4:	e2 f7       	brpl	.-8      	; 0x48be <st_prep_buffer+0xc00>
    48c6:	ed 93       	st	X+, r30
    48c8:	fc 93       	st	X, r31
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    48ca:	61 15       	cp	r22, r1
    48cc:	71 05       	cpc	r23, r1
    48ce:	f1 e0       	ldi	r31, 0x01	; 1
    48d0:	8f 07       	cpc	r24, r31
    48d2:	91 05       	cpc	r25, r1
    48d4:	38 f4       	brcc	.+14     	; 0x48e4 <st_prep_buffer+0xc26>
    48d6:	ab a5       	ldd	r26, Y+43	; 0x2b
    48d8:	bc a5       	ldd	r27, Y+44	; 0x2c
    48da:	14 96       	adiw	r26, 0x04	; 4
    48dc:	7c 93       	st	X, r23
    48de:	6e 93       	st	-X, r22
    48e0:	13 97       	sbiw	r26, 0x03	; 3
    48e2:	06 c0       	rjmp	.+12     	; 0x48f0 <st_prep_buffer+0xc32>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    48e4:	8f ef       	ldi	r24, 0xFF	; 255
    48e6:	9f ef       	ldi	r25, 0xFF	; 255
    48e8:	eb a5       	ldd	r30, Y+43	; 0x2b
    48ea:	fc a5       	ldd	r31, Y+44	; 0x2c
    48ec:	94 83       	std	Z+4, r25	; 0x04
    48ee:	83 83       	std	Z+3, r24	; 0x03
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices.
    segment_buffer_head = segment_next_head;
    48f0:	80 91 88 01 	lds	r24, 0x0188
    48f4:	80 93 89 01 	sts	0x0189, r24
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    48f8:	8f 5f       	subi	r24, 0xFF	; 255
    48fa:	86 30       	cpi	r24, 0x06	; 6
    48fc:	19 f0       	breq	.+6      	; 0x4904 <st_prep_buffer+0xc46>
    48fe:	80 93 88 01 	sts	0x0188, r24
    4902:	02 c0       	rjmp	.+4      	; 0x4908 <st_prep_buffer+0xc4a>
    4904:	10 92 88 01 	sts	0x0188, r1

    // Setup initial conditions for next segment.
    if (mm_remaining > prep.mm_complete) { 
    4908:	2d a9       	ldd	r18, Y+53	; 0x35
    490a:	3f a1       	ldd	r19, Y+39	; 0x27
    490c:	40 2f       	mov	r20, r16
    490e:	51 2f       	mov	r21, r17
    4910:	a9 e6       	ldi	r26, 0x69	; 105
    4912:	b1 e0       	ldi	r27, 0x01	; 1
    4914:	6d 91       	ld	r22, X+
    4916:	7d 91       	ld	r23, X+
    4918:	8d 91       	ld	r24, X+
    491a:	9c 91       	ld	r25, X
    491c:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    4920:	88 23       	and	r24, r24
    4922:	9c f4       	brge	.+38     	; 0x494a <st_prep_buffer+0xc8c>
      // Normal operation. Block incomplete. Distance remaining in block to be executed.
      pl_block->millimeters = mm_remaining;      
    4924:	e0 91 83 01 	lds	r30, 0x0183
    4928:	f0 91 84 01 	lds	r31, 0x0184
    492c:	8d a9       	ldd	r24, Y+53	; 0x35
    492e:	9f a1       	ldd	r25, Y+39	; 0x27
    4930:	a0 2f       	mov	r26, r16
    4932:	b1 2f       	mov	r27, r17
    4934:	85 a3       	std	Z+37, r24	; 0x25
    4936:	96 a3       	std	Z+38, r25	; 0x26
    4938:	a7 a3       	std	Z+39, r26	; 0x27
    493a:	b0 a7       	std	Z+40, r27	; 0x28
      prep.steps_remaining = steps_remaining;  
    493c:	e8 e5       	ldi	r30, 0x58	; 88
    493e:	f1 e0       	ldi	r31, 0x01	; 1
    4940:	40 82       	st	Z, r4
    4942:	51 82       	std	Z+1, r5	; 0x01
    4944:	62 82       	std	Z+2, r6	; 0x02
    4946:	73 82       	std	Z+3, r7	; 0x03
    4948:	47 c0       	rjmp	.+142    	; 0x49d8 <st_prep_buffer+0xd1a>
    } else { 
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    494a:	20 e0       	ldi	r18, 0x00	; 0
    494c:	30 e0       	ldi	r19, 0x00	; 0
    494e:	a9 01       	movw	r20, r18
    4950:	6d a9       	ldd	r22, Y+53	; 0x35
    4952:	7f a1       	ldd	r23, Y+39	; 0x27
    4954:	80 2f       	mov	r24, r16
    4956:	91 2f       	mov	r25, r17
    4958:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    495c:	18 16       	cp	r1, r24
    495e:	b4 f5       	brge	.+108    	; 0x49cc <st_prep_buffer+0xd0e>
    4960:	4d 80       	ldd	r4, Y+5	; 0x05
    4962:	5e 80       	ldd	r5, Y+6	; 0x06
    4964:	6f 80       	ldd	r6, Y+7	; 0x07
    4966:	78 84       	ldd	r7, Y+8	; 0x08
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the 
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    4968:	10 92 6d 01 	sts	0x016D, r1
    496c:	10 92 6e 01 	sts	0x016E, r1
    4970:	10 92 6f 01 	sts	0x016F, r1
    4974:	10 92 70 01 	sts	0x0170, r1
        prep.dt_remainder = 0.0;
    4978:	10 92 64 01 	sts	0x0164, r1
    497c:	10 92 65 01 	sts	0x0165, r1
    4980:	10 92 66 01 	sts	0x0166, r1
    4984:	10 92 67 01 	sts	0x0167, r1
        prep.steps_remaining = ceil(steps_remaining);
    4988:	40 92 58 01 	sts	0x0158, r4
    498c:	50 92 59 01 	sts	0x0159, r5
    4990:	60 92 5a 01 	sts	0x015A, r6
    4994:	70 92 5b 01 	sts	0x015B, r7
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    4998:	00 91 83 01 	lds	r16, 0x0183
    499c:	10 91 84 01 	lds	r17, 0x0184
    49a0:	20 91 5c 01 	lds	r18, 0x015C
    49a4:	30 91 5d 01 	lds	r19, 0x015D
    49a8:	40 91 5e 01 	lds	r20, 0x015E
    49ac:	50 91 5f 01 	lds	r21, 0x015F
    49b0:	c3 01       	movw	r24, r6
    49b2:	b2 01       	movw	r22, r4
    49b4:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    49b8:	d8 01       	movw	r26, r16
    49ba:	95 96       	adiw	r26, 0x25	; 37
    49bc:	6d 93       	st	X+, r22
    49be:	7d 93       	st	X+, r23
    49c0:	8d 93       	st	X+, r24
    49c2:	9c 93       	st	X, r25
    49c4:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize(); 
    49c6:	0e 94 e2 2d 	call	0x5bc4	; 0x5bc4 <plan_cycle_reinitialize>
        return; // Bail!
    49ca:	0c c0       	rjmp	.+24     	; 0x49e4 <st_prep_buffer+0xd26>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    49cc:	10 92 84 01 	sts	0x0184, r1
    49d0:	10 92 83 01 	sts	0x0183, r1
        plan_discard_current_block();
    49d4:	0e 94 45 2a 	call	0x548a	; 0x548a <plan_discard_current_block>
  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    49d8:	90 91 8a 01 	lds	r25, 0x018A
    49dc:	80 91 88 01 	lds	r24, 0x0188
    49e0:	98 13       	cpse	r25, r24
    49e2:	9c c9       	rjmp	.-3272   	; 0x3d1c <st_prep_buffer+0x5e>
        plan_discard_current_block();
      }
    }

  } 
}      
    49e4:	e6 96       	adiw	r28, 0x36	; 54
    49e6:	0f b6       	in	r0, 0x3f	; 63
    49e8:	f8 94       	cli
    49ea:	de bf       	out	0x3e, r29	; 62
    49ec:	0f be       	out	0x3f, r0	; 63
    49ee:	cd bf       	out	0x3d, r28	; 61
    49f0:	df 91       	pop	r29
    49f2:	cf 91       	pop	r28
    49f4:	1f 91       	pop	r17
    49f6:	0f 91       	pop	r16
    49f8:	ff 90       	pop	r15
    49fa:	ef 90       	pop	r14
    49fc:	df 90       	pop	r13
    49fe:	cf 90       	pop	r12
    4a00:	bf 90       	pop	r11
    4a02:	af 90       	pop	r10
    4a04:	9f 90       	pop	r9
    4a06:	8f 90       	pop	r8
    4a08:	7f 90       	pop	r7
    4a0a:	6f 90       	pop	r6
    4a0c:	5f 90       	pop	r5
    4a0e:	4f 90       	pop	r4
    4a10:	3f 90       	pop	r3
    4a12:	2f 90       	pop	r2
    4a14:	08 95       	ret

00004a16 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4a16:	f9 99       	sbic	0x1f, 1	; 31
    4a18:	fe cf       	rjmp	.-4      	; 0x4a16 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    4a1a:	92 bd       	out	0x22, r25	; 34
    4a1c:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4a1e:	81 e0       	ldi	r24, 0x01	; 1
    4a20:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    4a22:	80 b5       	in	r24, 0x20	; 32
}
    4a24:	08 95       	ret

00004a26 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    4a26:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4a28:	f9 99       	sbic	0x1f, 1	; 31
    4a2a:	fe cf       	rjmp	.-4      	; 0x4a28 <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    4a2c:	92 bd       	out	0x22, r25	; 34
    4a2e:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4a30:	81 e0       	ldi	r24, 0x01	; 1
    4a32:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    4a34:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    4a36:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    4a38:	98 2f       	mov	r25, r24
    4a3a:	96 23       	and	r25, r22
    4a3c:	59 f0       	breq	.+22     	; 0x4a54 <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    4a3e:	6f 3f       	cpi	r22, 0xFF	; 255
    4a40:	29 f0       	breq	.+10     	; 0x4a4c <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    4a42:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a44:	84 e0       	ldi	r24, 0x04	; 4
    4a46:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    4a48:	f9 9a       	sbi	0x1f, 1	; 31
    4a4a:	0a c0       	rjmp	.+20     	; 0x4a60 <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a4c:	84 e1       	ldi	r24, 0x14	; 20
    4a4e:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    4a50:	f9 9a       	sbi	0x1f, 1	; 31
    4a52:	06 c0       	rjmp	.+12     	; 0x4a60 <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    4a54:	88 23       	and	r24, r24
    4a56:	21 f0       	breq	.+8      	; 0x4a60 <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    4a58:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a5a:	84 e2       	ldi	r24, 0x24	; 36
    4a5c:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4a5e:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    4a60:	78 94       	sei
    4a62:	08 95       	ret

00004a64 <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    4a64:	8f 92       	push	r8
    4a66:	9f 92       	push	r9
    4a68:	af 92       	push	r10
    4a6a:	bf 92       	push	r11
    4a6c:	cf 92       	push	r12
    4a6e:	df 92       	push	r13
    4a70:	ef 92       	push	r14
    4a72:	ff 92       	push	r15
    4a74:	0f 93       	push	r16
    4a76:	1f 93       	push	r17
    4a78:	cf 93       	push	r28
    4a7a:	df 93       	push	r29
    4a7c:	6c 01       	movw	r12, r24
    4a7e:	8b 01       	movw	r16, r22
    4a80:	5a 01       	movw	r10, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4a82:	41 15       	cp	r20, r1
    4a84:	51 05       	cpc	r21, r1
    4a86:	11 f1       	breq	.+68     	; 0x4acc <memcpy_to_eeprom_with_checksum+0x68>
    4a88:	ea 01       	movw	r28, r20

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4a8a:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    4a8c:	88 24       	eor	r8, r8
    4a8e:	83 94       	inc	r8
    4a90:	91 10       	cpse	r9, r1
    4a92:	09 c0       	rjmp	.+18     	; 0x4aa6 <memcpy_to_eeprom_with_checksum+0x42>
    4a94:	69 2d       	mov	r22, r9
    4a96:	77 27       	eor	r23, r23
    4a98:	67 fd       	sbrc	r22, 7
    4a9a:	70 95       	com	r23
    4a9c:	97 2e       	mov	r9, r23
    4a9e:	99 1c       	adc	r9, r9
    4aa0:	99 24       	eor	r9, r9
    4aa2:	99 1c       	adc	r9, r9
    4aa4:	01 c0       	rjmp	.+2      	; 0x4aa8 <memcpy_to_eeprom_with_checksum+0x44>
    4aa6:	98 2c       	mov	r9, r8
    checksum += *source;
    4aa8:	f8 01       	movw	r30, r16
    4aaa:	61 91       	ld	r22, Z+
    4aac:	8f 01       	movw	r16, r30
    4aae:	96 0e       	add	r9, r22
    eeprom_put_char(destination++, *(source++)); 
    4ab0:	7c 01       	movw	r14, r24
    4ab2:	ff ef       	ldi	r31, 0xFF	; 255
    4ab4:	ef 1a       	sub	r14, r31
    4ab6:	ff 0a       	sbc	r15, r31
    4ab8:	0e 94 13 25 	call	0x4a26	; 0x4a26 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4abc:	21 97       	sbiw	r28, 0x01	; 1
    4abe:	20 97       	sbiw	r28, 0x00	; 0
    4ac0:	11 f0       	breq	.+4      	; 0x4ac6 <memcpy_to_eeprom_with_checksum+0x62>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    4ac2:	c7 01       	movw	r24, r14
    4ac4:	e5 cf       	rjmp	.-54     	; 0x4a90 <memcpy_to_eeprom_with_checksum+0x2c>
    4ac6:	ca 0c       	add	r12, r10
    4ac8:	db 1c       	adc	r13, r11
    4aca:	01 c0       	rjmp	.+2      	; 0x4ace <memcpy_to_eeprom_with_checksum+0x6a>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4acc:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    4ace:	69 2d       	mov	r22, r9
    4ad0:	c6 01       	movw	r24, r12
    4ad2:	0e 94 13 25 	call	0x4a26	; 0x4a26 <eeprom_put_char>
}
    4ad6:	df 91       	pop	r29
    4ad8:	cf 91       	pop	r28
    4ada:	1f 91       	pop	r17
    4adc:	0f 91       	pop	r16
    4ade:	ff 90       	pop	r15
    4ae0:	ef 90       	pop	r14
    4ae2:	df 90       	pop	r13
    4ae4:	cf 90       	pop	r12
    4ae6:	bf 90       	pop	r11
    4ae8:	af 90       	pop	r10
    4aea:	9f 90       	pop	r9
    4aec:	8f 90       	pop	r8
    4aee:	08 95       	ret

00004af0 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    4af0:	8f 92       	push	r8
    4af2:	9f 92       	push	r9
    4af4:	af 92       	push	r10
    4af6:	bf 92       	push	r11
    4af8:	cf 92       	push	r12
    4afa:	df 92       	push	r13
    4afc:	ef 92       	push	r14
    4afe:	ff 92       	push	r15
    4b00:	0f 93       	push	r16
    4b02:	1f 93       	push	r17
    4b04:	cf 93       	push	r28
    4b06:	df 93       	push	r29
    4b08:	6b 01       	movw	r12, r22
    4b0a:	5a 01       	movw	r10, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4b0c:	41 15       	cp	r20, r1
    4b0e:	51 05       	cpc	r21, r1
    4b10:	29 f1       	breq	.+74     	; 0x4b5c <memcpy_from_eeprom_with_checksum+0x6c>
    4b12:	08 2f       	mov	r16, r24
    4b14:	19 2f       	mov	r17, r25
    4b16:	ea 01       	movw	r28, r20
    4b18:	cb 01       	movw	r24, r22
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4b1a:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    4b1c:	88 24       	eor	r8, r8
    4b1e:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    4b20:	7c 01       	movw	r14, r24
    4b22:	2f ef       	ldi	r18, 0xFF	; 255
    4b24:	e2 1a       	sub	r14, r18
    4b26:	f2 0a       	sbc	r15, r18
    4b28:	0e 94 0b 25 	call	0x4a16	; 0x4a16 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    4b2c:	91 10       	cpse	r9, r1
    4b2e:	09 c0       	rjmp	.+18     	; 0x4b42 <memcpy_from_eeprom_with_checksum+0x52>
    4b30:	29 2d       	mov	r18, r9
    4b32:	33 27       	eor	r19, r19
    4b34:	27 fd       	sbrc	r18, 7
    4b36:	30 95       	com	r19
    4b38:	93 2e       	mov	r9, r19
    4b3a:	99 1c       	adc	r9, r9
    4b3c:	99 24       	eor	r9, r9
    4b3e:	99 1c       	adc	r9, r9
    4b40:	01 c0       	rjmp	.+2      	; 0x4b44 <memcpy_from_eeprom_with_checksum+0x54>
    4b42:	98 2c       	mov	r9, r8
    checksum += data;    
    4b44:	98 0e       	add	r9, r24
    *(destination++) = data; 
    4b46:	f8 01       	movw	r30, r16
    4b48:	81 93       	st	Z+, r24
    4b4a:	8f 01       	movw	r16, r30
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4b4c:	21 97       	sbiw	r28, 0x01	; 1
    4b4e:	20 97       	sbiw	r28, 0x00	; 0
    4b50:	11 f0       	breq	.+4      	; 0x4b56 <memcpy_from_eeprom_with_checksum+0x66>
    data = eeprom_get_char(source++);
    4b52:	c7 01       	movw	r24, r14
    4b54:	e5 cf       	rjmp	.-54     	; 0x4b20 <memcpy_from_eeprom_with_checksum+0x30>
    4b56:	ca 0c       	add	r12, r10
    4b58:	db 1c       	adc	r13, r11
    4b5a:	01 c0       	rjmp	.+2      	; 0x4b5e <memcpy_from_eeprom_with_checksum+0x6e>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4b5c:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4b5e:	c6 01       	movw	r24, r12
    4b60:	0e 94 0b 25 	call	0x4a16	; 0x4a16 <eeprom_get_char>
    4b64:	41 e0       	ldi	r20, 0x01	; 1
    4b66:	50 e0       	ldi	r21, 0x00	; 0
    4b68:	89 15       	cp	r24, r9
    4b6a:	11 f0       	breq	.+4      	; 0x4b70 <memcpy_from_eeprom_with_checksum+0x80>
    4b6c:	40 e0       	ldi	r20, 0x00	; 0
    4b6e:	50 e0       	ldi	r21, 0x00	; 0
}
    4b70:	ca 01       	movw	r24, r20
    4b72:	df 91       	pop	r29
    4b74:	cf 91       	pop	r28
    4b76:	1f 91       	pop	r17
    4b78:	0f 91       	pop	r16
    4b7a:	ff 90       	pop	r15
    4b7c:	ef 90       	pop	r14
    4b7e:	df 90       	pop	r13
    4b80:	cf 90       	pop	r12
    4b82:	bf 90       	pop	r11
    4b84:	af 90       	pop	r10
    4b86:	9f 90       	pop	r9
    4b88:	8f 90       	pop	r8
    4b8a:	08 95       	ret

00004b8c <settings_store_startup_line>:


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    4b8c:	21 e5       	ldi	r18, 0x51	; 81
    4b8e:	82 9f       	mul	r24, r18
    4b90:	c0 01       	movw	r24, r0
    4b92:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    4b94:	40 e5       	ldi	r20, 0x50	; 80
    4b96:	50 e0       	ldi	r21, 0x00	; 0
    4b98:	9d 5f       	subi	r25, 0xFD	; 253
    4b9a:	0e 94 32 25 	call	0x4a64	; 0x4a64 <memcpy_to_eeprom_with_checksum>
    4b9e:	08 95       	ret

00004ba0 <settings_store_build_info>:


// Method to store build info into EEPROM
void settings_store_build_info(char *line)
{
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    4ba0:	40 e5       	ldi	r20, 0x50	; 80
    4ba2:	50 e0       	ldi	r21, 0x00	; 0
    4ba4:	bc 01       	movw	r22, r24
    4ba6:	8e ea       	ldi	r24, 0xAE	; 174
    4ba8:	93 e0       	ldi	r25, 0x03	; 3
    4baa:	0e 94 32 25 	call	0x4a64	; 0x4a64 <memcpy_to_eeprom_with_checksum>
    4bae:	08 95       	ret

00004bb0 <settings_write_coord_data>:


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{  
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    4bb0:	2d e0       	ldi	r18, 0x0D	; 13
    4bb2:	82 9f       	mul	r24, r18
    4bb4:	c0 01       	movw	r24, r0
    4bb6:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    4bb8:	4c e0       	ldi	r20, 0x0C	; 12
    4bba:	50 e0       	ldi	r21, 0x00	; 0
    4bbc:	9e 5f       	subi	r25, 0xFE	; 254
    4bbe:	0e 94 32 25 	call	0x4a64	; 0x4a64 <memcpy_to_eeprom_with_checksum>
    4bc2:	08 95       	ret

00004bc4 <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
void write_global_settings() 
{
  eeprom_put_char(0, SETTINGS_VERSION);
    4bc4:	69 e0       	ldi	r22, 0x09	; 9
    4bc6:	80 e0       	ldi	r24, 0x00	; 0
    4bc8:	90 e0       	ldi	r25, 0x00	; 0
    4bca:	0e 94 13 25 	call	0x4a26	; 0x4a26 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    4bce:	45 e5       	ldi	r20, 0x55	; 85
    4bd0:	50 e0       	ldi	r21, 0x00	; 0
    4bd2:	6f ef       	ldi	r22, 0xFF	; 255
    4bd4:	78 e0       	ldi	r23, 0x08	; 8
    4bd6:	81 e0       	ldi	r24, 0x01	; 1
    4bd8:	90 e0       	ldi	r25, 0x00	; 0
    4bda:	0e 94 32 25 	call	0x4a64	; 0x4a64 <memcpy_to_eeprom_with_checksum>
    4bde:	08 95       	ret

00004be0 <settings_restore_global_settings>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults. 
void settings_restore_global_settings() {  
  settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
    4be0:	8a e0       	ldi	r24, 0x0A	; 10
    4be2:	80 93 2f 09 	sts	0x092F, r24
  settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
    4be6:	89 e1       	ldi	r24, 0x19	; 25
    4be8:	80 93 32 09 	sts	0x0932, r24
  settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
    4bec:	10 92 30 09 	sts	0x0930, r1
  settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
    4bf0:	10 92 31 09 	sts	0x0931, r1
  settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
    4bf4:	83 e0       	ldi	r24, 0x03	; 3
    4bf6:	80 93 33 09 	sts	0x0933, r24
  settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
    4bfa:	8d ec       	ldi	r24, 0xCD	; 205
    4bfc:	9c ec       	ldi	r25, 0xCC	; 204
    4bfe:	ac ec       	ldi	r26, 0xCC	; 204
    4c00:	bd e3       	ldi	r27, 0x3D	; 61
    4c02:	80 93 34 09 	sts	0x0934, r24
    4c06:	90 93 35 09 	sts	0x0935, r25
    4c0a:	a0 93 36 09 	sts	0x0936, r26
    4c0e:	b0 93 37 09 	sts	0x0937, r27
  settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
    4c12:	8a e0       	ldi	r24, 0x0A	; 10
    4c14:	97 ed       	ldi	r25, 0xD7	; 215
    4c16:	a3 ea       	ldi	r26, 0xA3	; 163
    4c18:	bc e3       	ldi	r27, 0x3C	; 60
    4c1a:	80 93 38 09 	sts	0x0938, r24
    4c1e:	90 93 39 09 	sts	0x0939, r25
    4c22:	a0 93 3a 09 	sts	0x093A, r26
    4c26:	b0 93 3b 09 	sts	0x093B, r27
  settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
    4c2a:	10 92 3d 09 	sts	0x093D, r1
  settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
    4c2e:	80 e0       	ldi	r24, 0x00	; 0
    4c30:	90 e0       	ldi	r25, 0x00	; 0
    4c32:	a8 e4       	ldi	r26, 0x48	; 72
    4c34:	b3 e4       	ldi	r27, 0x43	; 67
    4c36:	80 93 3e 09 	sts	0x093E, r24
    4c3a:	90 93 3f 09 	sts	0x093F, r25
    4c3e:	a0 93 40 09 	sts	0x0940, r26
    4c42:	b0 93 41 09 	sts	0x0941, r27
  settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
    4c46:	80 e0       	ldi	r24, 0x00	; 0
    4c48:	90 e8       	ldi	r25, 0x80	; 128
    4c4a:	ab eb       	ldi	r26, 0xBB	; 187
    4c4c:	b4 e4       	ldi	r27, 0x44	; 68
    4c4e:	80 93 42 09 	sts	0x0942, r24
    4c52:	90 93 43 09 	sts	0x0943, r25
    4c56:	a0 93 44 09 	sts	0x0944, r26
    4c5a:	b0 93 45 09 	sts	0x0945, r27
  settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
    4c5e:	84 e6       	ldi	r24, 0x64	; 100
    4c60:	90 e0       	ldi	r25, 0x00	; 0
    4c62:	90 93 47 09 	sts	0x0947, r25
    4c66:	80 93 46 09 	sts	0x0946, r24
  settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
    4c6a:	80 e0       	ldi	r24, 0x00	; 0
    4c6c:	90 e0       	ldi	r25, 0x00	; 0
    4c6e:	a0 ea       	ldi	r26, 0xA0	; 160
    4c70:	b0 e4       	ldi	r27, 0x40	; 64
    4c72:	80 93 48 09 	sts	0x0948, r24
    4c76:	90 93 49 09 	sts	0x0949, r25
    4c7a:	a0 93 4a 09 	sts	0x094A, r26
    4c7e:	b0 93 4b 09 	sts	0x094B, r27
  settings.z_zero_gauge = DEFAULT_Z_GAUGE;
    4c82:	80 e0       	ldi	r24, 0x00	; 0
    4c84:	90 e0       	ldi	r25, 0x00	; 0
    4c86:	a0 e2       	ldi	r26, 0x20	; 32
    4c88:	b1 e4       	ldi	r27, 0x41	; 65
    4c8a:	80 93 50 09 	sts	0x0950, r24
    4c8e:	90 93 51 09 	sts	0x0951, r25
    4c92:	a0 93 52 09 	sts	0x0952, r26
    4c96:	b0 93 53 09 	sts	0x0953, r27
  settings.z_zero_pulloff = DEFAULT_Z_PULLOFF;
    4c9a:	10 92 4c 09 	sts	0x094C, r1
    4c9e:	10 92 4d 09 	sts	0x094D, r1
    4ca2:	10 92 4e 09 	sts	0x094E, r1
    4ca6:	10 92 4f 09 	sts	0x094F, r1
  if (DEFAULT_REPORT_INCHES) { settings.flags |= BITFLAG_REPORT_INCHES; }
  if (DEFAULT_INVERT_ST_ENABLE) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
  if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
  if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
  if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
  if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    4caa:	88 e1       	ldi	r24, 0x18	; 24
    4cac:	80 93 3c 09 	sts	0x093C, r24
  
  settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
    4cb0:	80 e0       	ldi	r24, 0x00	; 0
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
    4cb4:	a0 ea       	ldi	r26, 0xA0	; 160
    4cb6:	b2 e4       	ldi	r27, 0x42	; 66
    4cb8:	80 93 ff 08 	sts	0x08FF, r24
    4cbc:	90 93 00 09 	sts	0x0900, r25
    4cc0:	a0 93 01 09 	sts	0x0901, r26
    4cc4:	b0 93 02 09 	sts	0x0902, r27
  settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
    4cc8:	80 93 03 09 	sts	0x0903, r24
    4ccc:	90 93 04 09 	sts	0x0904, r25
    4cd0:	a0 93 05 09 	sts	0x0905, r26
    4cd4:	b0 93 06 09 	sts	0x0906, r27
  settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
    4cd8:	80 e0       	ldi	r24, 0x00	; 0
    4cda:	90 e0       	ldi	r25, 0x00	; 0
    4cdc:	a8 ec       	ldi	r26, 0xC8	; 200
    4cde:	b2 e4       	ldi	r27, 0x42	; 66
    4ce0:	80 93 07 09 	sts	0x0907, r24
    4ce4:	90 93 08 09 	sts	0x0908, r25
    4ce8:	a0 93 09 09 	sts	0x0909, r26
    4cec:	b0 93 0a 09 	sts	0x090A, r27
  settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
    4cf0:	40 e0       	ldi	r20, 0x00	; 0
    4cf2:	50 e0       	ldi	r21, 0x00	; 0
    4cf4:	68 ec       	ldi	r22, 0xC8	; 200
    4cf6:	73 e4       	ldi	r23, 0x43	; 67
    4cf8:	40 93 0b 09 	sts	0x090B, r20
    4cfc:	50 93 0c 09 	sts	0x090C, r21
    4d00:	60 93 0d 09 	sts	0x090D, r22
    4d04:	70 93 0e 09 	sts	0x090E, r23
  settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
    4d08:	40 93 0f 09 	sts	0x090F, r20
    4d0c:	50 93 10 09 	sts	0x0910, r21
    4d10:	60 93 11 09 	sts	0x0911, r22
    4d14:	70 93 12 09 	sts	0x0912, r23
  settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
    4d18:	80 93 13 09 	sts	0x0913, r24
    4d1c:	90 93 14 09 	sts	0x0914, r25
    4d20:	a0 93 15 09 	sts	0x0915, r26
    4d24:	b0 93 16 09 	sts	0x0916, r27
  settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
    4d28:	80 e0       	ldi	r24, 0x00	; 0
    4d2a:	98 ec       	ldi	r25, 0xC8	; 200
    4d2c:	af e2       	ldi	r26, 0x2F	; 47
    4d2e:	b9 e4       	ldi	r27, 0x49	; 73
    4d30:	80 93 17 09 	sts	0x0917, r24
    4d34:	90 93 18 09 	sts	0x0918, r25
    4d38:	a0 93 19 09 	sts	0x0919, r26
    4d3c:	b0 93 1a 09 	sts	0x091A, r27
  settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
    4d40:	80 93 1b 09 	sts	0x091B, r24
    4d44:	90 93 1c 09 	sts	0x091C, r25
    4d48:	a0 93 1d 09 	sts	0x091D, r26
    4d4c:	b0 93 1e 09 	sts	0x091E, r27
  settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
    4d50:	80 93 1f 09 	sts	0x091F, r24
    4d54:	90 93 20 09 	sts	0x0920, r25
    4d58:	a0 93 21 09 	sts	0x0921, r26
    4d5c:	b0 93 22 09 	sts	0x0922, r27
  settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
    4d60:	80 e0       	ldi	r24, 0x00	; 0
    4d62:	90 e0       	ldi	r25, 0x00	; 0
    4d64:	a8 e4       	ldi	r26, 0x48	; 72
    4d66:	b4 ec       	ldi	r27, 0xC4	; 196
    4d68:	80 93 23 09 	sts	0x0923, r24
    4d6c:	90 93 24 09 	sts	0x0924, r25
    4d70:	a0 93 25 09 	sts	0x0925, r26
    4d74:	b0 93 26 09 	sts	0x0926, r27
  settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
    4d78:	80 e0       	ldi	r24, 0x00	; 0
    4d7a:	90 e0       	ldi	r25, 0x00	; 0
    4d7c:	aa ef       	ldi	r26, 0xFA	; 250
    4d7e:	b3 ec       	ldi	r27, 0xC3	; 195
    4d80:	80 93 27 09 	sts	0x0927, r24
    4d84:	90 93 28 09 	sts	0x0928, r25
    4d88:	a0 93 29 09 	sts	0x0929, r26
    4d8c:	b0 93 2a 09 	sts	0x092A, r27
  settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    
    4d90:	80 e0       	ldi	r24, 0x00	; 0
    4d92:	90 e0       	ldi	r25, 0x00	; 0
    4d94:	a0 ef       	ldi	r26, 0xF0	; 240
    4d96:	b2 ec       	ldi	r27, 0xC2	; 194
    4d98:	80 93 2b 09 	sts	0x092B, r24
    4d9c:	90 93 2c 09 	sts	0x092C, r25
    4da0:	a0 93 2d 09 	sts	0x092D, r26
    4da4:	b0 93 2e 09 	sts	0x092E, r27

  write_global_settings();
    4da8:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <write_global_settings>
    4dac:	08 95       	ret

00004dae <settings_clear_startup_lines>:


// Helper function to clear the EEPROM space containing the startup lines.
void settings_clear_startup_lines() {
  #if N_STARTUP_LINE > 0
  eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    4dae:	60 e0       	ldi	r22, 0x00	; 0
    4db0:	80 e0       	ldi	r24, 0x00	; 0
    4db2:	93 e0       	ldi	r25, 0x03	; 3
    4db4:	0e 94 13 25 	call	0x4a26	; 0x4a26 <eeprom_put_char>
  #endif
  #if N_STARTUP_LINE > 1
  eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    4db8:	60 e0       	ldi	r22, 0x00	; 0
    4dba:	81 e5       	ldi	r24, 0x51	; 81
    4dbc:	93 e0       	ldi	r25, 0x03	; 3
    4dbe:	0e 94 13 25 	call	0x4a26	; 0x4a26 <eeprom_put_char>
    4dc2:	08 95       	ret

00004dc4 <settings_clear_build_info>:
  #endif
}


// Helper function to clear the EEPROM space containing the user build info string.
void settings_clear_build_info() { eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0); }
    4dc4:	60 e0       	ldi	r22, 0x00	; 0
    4dc6:	8e ea       	ldi	r24, 0xAE	; 174
    4dc8:	93 e0       	ldi	r25, 0x03	; 3
    4dca:	0e 94 13 25 	call	0x4a26	; 0x4a26 <eeprom_put_char>
    4dce:	08 95       	ret

00004dd0 <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    4dd0:	1f 93       	push	r17
    4dd2:	cf 93       	push	r28
    4dd4:	df 93       	push	r29
    4dd6:	18 2f       	mov	r17, r24
    4dd8:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    4dda:	81 e5       	ldi	r24, 0x51	; 81
    4ddc:	18 9f       	mul	r17, r24
    4dde:	b0 01       	movw	r22, r0
    4de0:	11 24       	eor	r1, r1
    4de2:	7d 5f       	subi	r23, 0xFD	; 253
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    4de4:	40 e5       	ldi	r20, 0x50	; 80
    4de6:	50 e0       	ldi	r21, 0x00	; 0
    4de8:	ce 01       	movw	r24, r28
    4dea:	0e 94 78 25 	call	0x4af0	; 0x4af0 <memcpy_from_eeprom_with_checksum>
    4dee:	89 2b       	or	r24, r25
    4df0:	39 f4       	brne	.+14     	; 0x4e00 <settings_read_startup_line+0x30>
    // Reset line with default value
    line[0] = 0; // Empty line
    4df2:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    4df4:	be 01       	movw	r22, r28
    4df6:	81 2f       	mov	r24, r17
    4df8:	0e 94 c6 25 	call	0x4b8c	; 0x4b8c <settings_store_startup_line>
    return(false);
    4dfc:	80 e0       	ldi	r24, 0x00	; 0
    4dfe:	01 c0       	rjmp	.+2      	; 0x4e02 <settings_read_startup_line+0x32>
  }
  return(true);
    4e00:	81 e0       	ldi	r24, 0x01	; 1
}
    4e02:	df 91       	pop	r29
    4e04:	cf 91       	pop	r28
    4e06:	1f 91       	pop	r17
    4e08:	08 95       	ret

00004e0a <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    4e0a:	cf 93       	push	r28
    4e0c:	df 93       	push	r29
    4e0e:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    4e10:	40 e5       	ldi	r20, 0x50	; 80
    4e12:	50 e0       	ldi	r21, 0x00	; 0
    4e14:	6e ea       	ldi	r22, 0xAE	; 174
    4e16:	73 e0       	ldi	r23, 0x03	; 3
    4e18:	0e 94 78 25 	call	0x4af0	; 0x4af0 <memcpy_from_eeprom_with_checksum>
    4e1c:	89 2b       	or	r24, r25
    4e1e:	31 f4       	brne	.+12     	; 0x4e2c <settings_read_build_info+0x22>
    // Reset line with default value
    line[0] = 0; // Empty line
    4e20:	18 82       	st	Y, r1
    settings_store_build_info(line);
    4e22:	ce 01       	movw	r24, r28
    4e24:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <settings_store_build_info>
    return(false);
    4e28:	80 e0       	ldi	r24, 0x00	; 0
    4e2a:	01 c0       	rjmp	.+2      	; 0x4e2e <settings_read_build_info+0x24>
  }
  return(true);
    4e2c:	81 e0       	ldi	r24, 0x01	; 1
}
    4e2e:	df 91       	pop	r29
    4e30:	cf 91       	pop	r28
    4e32:	08 95       	ret

00004e34 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    4e34:	1f 93       	push	r17
    4e36:	cf 93       	push	r28
    4e38:	df 93       	push	r29
    4e3a:	18 2f       	mov	r17, r24
    4e3c:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    4e3e:	8d e0       	ldi	r24, 0x0D	; 13
    4e40:	18 9f       	mul	r17, r24
    4e42:	b0 01       	movw	r22, r0
    4e44:	11 24       	eor	r1, r1
    4e46:	7e 5f       	subi	r23, 0xFE	; 254
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    4e48:	4c e0       	ldi	r20, 0x0C	; 12
    4e4a:	50 e0       	ldi	r21, 0x00	; 0
    4e4c:	ce 01       	movw	r24, r28
    4e4e:	0e 94 78 25 	call	0x4af0	; 0x4af0 <memcpy_from_eeprom_with_checksum>
    4e52:	89 2b       	or	r24, r25
    4e54:	59 f4       	brne	.+22     	; 0x4e6c <settings_read_coord_data+0x38>
    // Reset with default zero vector
    clear_vector_float(coord_data); 
    4e56:	8c e0       	ldi	r24, 0x0C	; 12
    4e58:	fe 01       	movw	r30, r28
    4e5a:	11 92       	st	Z+, r1
    4e5c:	8a 95       	dec	r24
    4e5e:	e9 f7       	brne	.-6      	; 0x4e5a <settings_read_coord_data+0x26>
    settings_write_coord_data(coord_select,coord_data);
    4e60:	be 01       	movw	r22, r28
    4e62:	81 2f       	mov	r24, r17
    4e64:	0e 94 d8 25 	call	0x4bb0	; 0x4bb0 <settings_write_coord_data>
    return(false);
    4e68:	80 e0       	ldi	r24, 0x00	; 0
    4e6a:	01 c0       	rjmp	.+2      	; 0x4e6e <settings_read_coord_data+0x3a>
  }
  return(true);
    4e6c:	81 e0       	ldi	r24, 0x01	; 1
}  
    4e6e:	df 91       	pop	r29
    4e70:	cf 91       	pop	r28
    4e72:	1f 91       	pop	r17
    4e74:	08 95       	ret

00004e76 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    4e76:	80 e0       	ldi	r24, 0x00	; 0
    4e78:	90 e0       	ldi	r25, 0x00	; 0
    4e7a:	0e 94 0b 25 	call	0x4a16	; 0x4a16 <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4e7e:	89 30       	cpi	r24, 0x09	; 9
    4e80:	69 f4       	brne	.+26     	; 0x4e9c <read_global_settings+0x26>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4e82:	45 e5       	ldi	r20, 0x55	; 85
    4e84:	50 e0       	ldi	r21, 0x00	; 0
    4e86:	61 e0       	ldi	r22, 0x01	; 1
    4e88:	70 e0       	ldi	r23, 0x00	; 0
    4e8a:	8f ef       	ldi	r24, 0xFF	; 255
    4e8c:	98 e0       	ldi	r25, 0x08	; 8
    4e8e:	0e 94 78 25 	call	0x4af0	; 0x4af0 <memcpy_from_eeprom_with_checksum>
    4e92:	21 e0       	ldi	r18, 0x01	; 1
    4e94:	89 2b       	or	r24, r25
    4e96:	19 f4       	brne	.+6      	; 0x4e9e <read_global_settings+0x28>
    4e98:	20 e0       	ldi	r18, 0x00	; 0
    4e9a:	01 c0       	rjmp	.+2      	; 0x4e9e <read_global_settings+0x28>
      return(false);
    }
  } else {
    return(false); 
    4e9c:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    4e9e:	82 2f       	mov	r24, r18
    4ea0:	08 95       	ret

00004ea2 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4ea2:	cf 92       	push	r12
    4ea4:	df 92       	push	r13
    4ea6:	ef 92       	push	r14
    4ea8:	ff 92       	push	r15
    4eaa:	cf 93       	push	r28
    4eac:	df 93       	push	r29
    4eae:	d8 2f       	mov	r29, r24
    4eb0:	6a 01       	movw	r12, r20
    4eb2:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    4eb4:	20 e0       	ldi	r18, 0x00	; 0
    4eb6:	30 e0       	ldi	r19, 0x00	; 0
    4eb8:	a9 01       	movw	r20, r18
    4eba:	c7 01       	movw	r24, r14
    4ebc:	b6 01       	movw	r22, r12
    4ebe:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    4ec2:	88 23       	and	r24, r24
    4ec4:	0c f4       	brge	.+2      	; 0x4ec8 <settings_store_global_setting+0x26>
    4ec6:	ef c0       	rjmp	.+478    	; 0x50a6 <settings_store_global_setting+0x204>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    4ec8:	d4 36       	cpi	r29, 0x64	; 100
    4eca:	a0 f0       	brcs	.+40     	; 0x4ef4 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    4ecc:	ec e9       	ldi	r30, 0x9C	; 156
    4ece:	ed 0f       	add	r30, r29
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4ed0:	e3 30       	cpi	r30, 0x03	; 3
    4ed2:	20 f0       	brcs	.+8      	; 0x4edc <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ed4:	ea 30       	cpi	r30, 0x0A	; 10
    4ed6:	08 f0       	brcs	.+2      	; 0x4eda <settings_store_global_setting+0x38>
    4ed8:	f4 c0       	rjmp	.+488    	; 0x50c2 <settings_store_global_setting+0x220>
    4eda:	e7 c0       	rjmp	.+462    	; 0x50aa <settings_store_global_setting+0x208>
      if (parameter < N_AXIS) {
        // Valid axis setting found.
        switch (set_idx) {
          case 0:
            // if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.steps_per_mm[parameter] = value;
    4edc:	f0 e0       	ldi	r31, 0x00	; 0
    4ede:	ee 0f       	add	r30, r30
    4ee0:	ff 1f       	adc	r31, r31
    4ee2:	ee 0f       	add	r30, r30
    4ee4:	ff 1f       	adc	r31, r31
    4ee6:	e1 50       	subi	r30, 0x01	; 1
    4ee8:	f7 4f       	sbci	r31, 0xF7	; 247
    4eea:	c0 82       	st	Z, r12
    4eec:	d1 82       	std	Z+1, r13	; 0x01
    4eee:	e2 82       	std	Z+2, r14	; 0x02
    4ef0:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4ef2:	d5 c0       	rjmp	.+426    	; 0x509e <settings_store_global_setting+0x1fc>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    4ef4:	c7 01       	movw	r24, r14
    4ef6:	b6 01       	movw	r22, r12
    4ef8:	0e 94 98 3f 	call	0x7f30	; 0x7f30 <trunc>
    4efc:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
    switch(parameter) {
    4f00:	8d 2f       	mov	r24, r29
    4f02:	90 e0       	ldi	r25, 0x00	; 0
    4f04:	80 32       	cpi	r24, 0x20	; 32
    4f06:	91 05       	cpc	r25, r1
    4f08:	08 f0       	brcs	.+2      	; 0x4f0c <settings_store_global_setting+0x6a>
    4f0a:	d1 c0       	rjmp	.+418    	; 0x50ae <settings_store_global_setting+0x20c>
    4f0c:	fc 01       	movw	r30, r24
    4f0e:	e5 52       	subi	r30, 0x25	; 37
    4f10:	ff 4f       	sbci	r31, 0xFF	; 255
    4f12:	0c 94 d9 3f 	jmp	0x7fb2	; 0x7fb2 <__tablejump2__>
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4f16:	63 30       	cpi	r22, 0x03	; 3
    4f18:	08 f4       	brcc	.+2      	; 0x4f1c <settings_store_global_setting+0x7a>
    4f1a:	cb c0       	rjmp	.+406    	; 0x50b2 <settings_store_global_setting+0x210>
        settings.pulse_microseconds = int_value; break;
    4f1c:	60 93 2f 09 	sts	0x092F, r22
    4f20:	be c0       	rjmp	.+380    	; 0x509e <settings_store_global_setting+0x1fc>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4f22:	60 93 32 09 	sts	0x0932, r22
    4f26:	bb c0       	rjmp	.+374    	; 0x509e <settings_store_global_setting+0x1fc>
      case 2: 
        settings.step_invert_mask = int_value; 
    4f28:	60 93 30 09 	sts	0x0930, r22
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4f2c:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <st_generate_step_dir_invert_masks>
        break;
    4f30:	b6 c0       	rjmp	.+364    	; 0x509e <settings_store_global_setting+0x1fc>
      case 3: 
        settings.dir_invert_mask = int_value; 
    4f32:	60 93 31 09 	sts	0x0931, r22
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4f36:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <st_generate_step_dir_invert_masks>
        break;
    4f3a:	b1 c0       	rjmp	.+354    	; 0x509e <settings_store_global_setting+0x1fc>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4f3c:	66 23       	and	r22, r22
    4f3e:	31 f0       	breq	.+12     	; 0x4f4c <settings_store_global_setting+0xaa>
    4f40:	ec e3       	ldi	r30, 0x3C	; 60
    4f42:	f9 e0       	ldi	r31, 0x09	; 9
    4f44:	80 81       	ld	r24, Z
    4f46:	84 60       	ori	r24, 0x04	; 4
    4f48:	80 83       	st	Z, r24
    4f4a:	a9 c0       	rjmp	.+338    	; 0x509e <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4f4c:	ec e3       	ldi	r30, 0x3C	; 60
    4f4e:	f9 e0       	ldi	r31, 0x09	; 9
    4f50:	80 81       	ld	r24, Z
    4f52:	8b 7f       	andi	r24, 0xFB	; 251
    4f54:	80 83       	st	Z, r24
    4f56:	a3 c0       	rjmp	.+326    	; 0x509e <settings_store_global_setting+0x1fc>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4f58:	66 23       	and	r22, r22
    4f5a:	31 f0       	breq	.+12     	; 0x4f68 <settings_store_global_setting+0xc6>
    4f5c:	ec e3       	ldi	r30, 0x3C	; 60
    4f5e:	f9 e0       	ldi	r31, 0x09	; 9
    4f60:	80 81       	ld	r24, Z
    4f62:	80 64       	ori	r24, 0x40	; 64
    4f64:	80 83       	st	Z, r24
    4f66:	9b c0       	rjmp	.+310    	; 0x509e <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4f68:	ec e3       	ldi	r30, 0x3C	; 60
    4f6a:	f9 e0       	ldi	r31, 0x09	; 9
    4f6c:	80 81       	ld	r24, Z
    4f6e:	8f 7b       	andi	r24, 0xBF	; 191
    4f70:	80 83       	st	Z, r24
    4f72:	95 c0       	rjmp	.+298    	; 0x509e <settings_store_global_setting+0x1fc>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4f74:	66 23       	and	r22, r22
    4f76:	31 f0       	breq	.+12     	; 0x4f84 <settings_store_global_setting+0xe2>
    4f78:	ec e3       	ldi	r30, 0x3C	; 60
    4f7a:	f9 e0       	ldi	r31, 0x09	; 9
    4f7c:	80 81       	ld	r24, Z
    4f7e:	80 68       	ori	r24, 0x80	; 128
    4f80:	80 83       	st	Z, r24
    4f82:	8d c0       	rjmp	.+282    	; 0x509e <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4f84:	ec e3       	ldi	r30, 0x3C	; 60
    4f86:	f9 e0       	ldi	r31, 0x09	; 9
    4f88:	80 81       	ld	r24, Z
    4f8a:	8f 77       	andi	r24, 0x7F	; 127
    4f8c:	80 83       	st	Z, r24
    4f8e:	87 c0       	rjmp	.+270    	; 0x509e <settings_store_global_setting+0x1fc>
        break;
      case 10: settings.status_report_mask = int_value; break;
    4f90:	60 93 33 09 	sts	0x0933, r22
    4f94:	84 c0       	rjmp	.+264    	; 0x509e <settings_store_global_setting+0x1fc>
      case 11: settings.junction_deviation = value; break;
    4f96:	c0 92 34 09 	sts	0x0934, r12
    4f9a:	d0 92 35 09 	sts	0x0935, r13
    4f9e:	e0 92 36 09 	sts	0x0936, r14
    4fa2:	f0 92 37 09 	sts	0x0937, r15
    4fa6:	7b c0       	rjmp	.+246    	; 0x509e <settings_store_global_setting+0x1fc>
      case 12: settings.arc_tolerance = value; break;
    4fa8:	c0 92 38 09 	sts	0x0938, r12
    4fac:	d0 92 39 09 	sts	0x0939, r13
    4fb0:	e0 92 3a 09 	sts	0x093A, r14
    4fb4:	f0 92 3b 09 	sts	0x093B, r15
    4fb8:	72 c0       	rjmp	.+228    	; 0x509e <settings_store_global_setting+0x1fc>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4fba:	66 23       	and	r22, r22
    4fbc:	31 f0       	breq	.+12     	; 0x4fca <settings_store_global_setting+0x128>
    4fbe:	ec e3       	ldi	r30, 0x3C	; 60
    4fc0:	f9 e0       	ldi	r31, 0x09	; 9
    4fc2:	80 81       	ld	r24, Z
    4fc4:	81 60       	ori	r24, 0x01	; 1
    4fc6:	80 83       	st	Z, r24
    4fc8:	6a c0       	rjmp	.+212    	; 0x509e <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    4fca:	ec e3       	ldi	r30, 0x3C	; 60
    4fcc:	f9 e0       	ldi	r31, 0x09	; 9
    4fce:	80 81       	ld	r24, Z
    4fd0:	8e 7f       	andi	r24, 0xFE	; 254
    4fd2:	80 83       	st	Z, r24
    4fd4:	64 c0       	rjmp	.+200    	; 0x509e <settings_store_global_setting+0x1fc>
        break;
      case 20:
        if (int_value) { 
    4fd6:	66 23       	and	r22, r22
    4fd8:	41 f0       	breq	.+16     	; 0x4fea <settings_store_global_setting+0x148>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4fda:	80 91 3c 09 	lds	r24, 0x093C
    4fde:	84 ff       	sbrs	r24, 4
    4fe0:	6a c0       	rjmp	.+212    	; 0x50b6 <settings_store_global_setting+0x214>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; 
    4fe2:	80 62       	ori	r24, 0x20	; 32
    4fe4:	80 93 3c 09 	sts	0x093C, r24
    4fe8:	5a c0       	rjmp	.+180    	; 0x509e <settings_store_global_setting+0x1fc>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    4fea:	ec e3       	ldi	r30, 0x3C	; 60
    4fec:	f9 e0       	ldi	r31, 0x09	; 9
    4fee:	80 81       	ld	r24, Z
    4ff0:	8f 7d       	andi	r24, 0xDF	; 223
    4ff2:	80 83       	st	Z, r24
    4ff4:	54 c0       	rjmp	.+168    	; 0x509e <settings_store_global_setting+0x1fc>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    4ff6:	66 23       	and	r22, r22
    4ff8:	31 f0       	breq	.+12     	; 0x5006 <settings_store_global_setting+0x164>
    4ffa:	ec e3       	ldi	r30, 0x3C	; 60
    4ffc:	f9 e0       	ldi	r31, 0x09	; 9
    4ffe:	80 81       	ld	r24, Z
    5000:	88 60       	ori	r24, 0x08	; 8
    5002:	80 83       	st	Z, r24
    5004:	05 c0       	rjmp	.+10     	; 0x5010 <settings_store_global_setting+0x16e>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    5006:	ec e3       	ldi	r30, 0x3C	; 60
    5008:	f9 e0       	ldi	r31, 0x09	; 9
    500a:	80 81       	ld	r24, Z
    500c:	87 7f       	andi	r24, 0xF7	; 247
    500e:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    5010:	0e 94 37 2f 	call	0x5e6e	; 0x5e6e <limits_init>
        break;
    5014:	44 c0       	rjmp	.+136    	; 0x509e <settings_store_global_setting+0x1fc>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    5016:	66 23       	and	r22, r22
    5018:	31 f0       	breq	.+12     	; 0x5026 <settings_store_global_setting+0x184>
    501a:	ec e3       	ldi	r30, 0x3C	; 60
    501c:	f9 e0       	ldi	r31, 0x09	; 9
    501e:	80 81       	ld	r24, Z
    5020:	80 61       	ori	r24, 0x10	; 16
    5022:	80 83       	st	Z, r24
    5024:	3c c0       	rjmp	.+120    	; 0x509e <settings_store_global_setting+0x1fc>
        else { 
          settings.flags &= ~BITFLAG_HOMING_ENABLE; 
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    5026:	ec e3       	ldi	r30, 0x3C	; 60
    5028:	f9 e0       	ldi	r31, 0x09	; 9
    502a:	80 81       	ld	r24, Z
    502c:	8f 7c       	andi	r24, 0xCF	; 207
    502e:	80 83       	st	Z, r24
    5030:	36 c0       	rjmp	.+108    	; 0x509e <settings_store_global_setting+0x1fc>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    5032:	60 93 3d 09 	sts	0x093D, r22
    5036:	33 c0       	rjmp	.+102    	; 0x509e <settings_store_global_setting+0x1fc>
      case 24: settings.homing_feed_rate = value; break;
    5038:	c0 92 3e 09 	sts	0x093E, r12
    503c:	d0 92 3f 09 	sts	0x093F, r13
    5040:	e0 92 40 09 	sts	0x0940, r14
    5044:	f0 92 41 09 	sts	0x0941, r15
    5048:	2a c0       	rjmp	.+84     	; 0x509e <settings_store_global_setting+0x1fc>
      case 25: settings.homing_seek_rate = value; break;
    504a:	c0 92 42 09 	sts	0x0942, r12
    504e:	d0 92 43 09 	sts	0x0943, r13
    5052:	e0 92 44 09 	sts	0x0944, r14
    5056:	f0 92 45 09 	sts	0x0945, r15
    505a:	21 c0       	rjmp	.+66     	; 0x509e <settings_store_global_setting+0x1fc>
      case 26: settings.homing_debounce_delay = int_value; break;
    505c:	86 2f       	mov	r24, r22
    505e:	90 e0       	ldi	r25, 0x00	; 0
    5060:	90 93 47 09 	sts	0x0947, r25
    5064:	80 93 46 09 	sts	0x0946, r24
    5068:	1a c0       	rjmp	.+52     	; 0x509e <settings_store_global_setting+0x1fc>
      case 27: settings.homing_pulloff = value; break;
    506a:	c0 92 48 09 	sts	0x0948, r12
    506e:	d0 92 49 09 	sts	0x0949, r13
    5072:	e0 92 4a 09 	sts	0x094A, r14
    5076:	f0 92 4b 09 	sts	0x094B, r15
    507a:	11 c0       	rjmp	.+34     	; 0x509e <settings_store_global_setting+0x1fc>
	  case 30: settings.z_zero_gauge = value; break;
    507c:	c0 92 50 09 	sts	0x0950, r12
    5080:	d0 92 51 09 	sts	0x0951, r13
    5084:	e0 92 52 09 	sts	0x0952, r14
    5088:	f0 92 53 09 	sts	0x0953, r15
    508c:	08 c0       	rjmp	.+16     	; 0x509e <settings_store_global_setting+0x1fc>
	  case 31: settings.z_zero_pulloff = value; break;
    508e:	c0 92 4c 09 	sts	0x094C, r12
    5092:	d0 92 4d 09 	sts	0x094D, r13
    5096:	e0 92 4e 09 	sts	0x094E, r14
    509a:	f0 92 4f 09 	sts	0x094F, r15
      default: 
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    509e:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <write_global_settings>
  return(STATUS_OK);
    50a2:	80 e0       	ldi	r24, 0x00	; 0
    50a4:	56 c0       	rjmp	.+172    	; 0x5152 <settings_store_global_setting+0x2b0>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    50a6:	84 e0       	ldi	r24, 0x04	; 4
    50a8:	54 c0       	rjmp	.+168    	; 0x5152 <settings_store_global_setting+0x2b0>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50aa:	83 e0       	ldi	r24, 0x03	; 3
    50ac:	52 c0       	rjmp	.+164    	; 0x5152 <settings_store_global_setting+0x2b0>
      case 26: settings.homing_debounce_delay = int_value; break;
      case 27: settings.homing_pulloff = value; break;
	  case 30: settings.z_zero_gauge = value; break;
	  case 31: settings.z_zero_pulloff = value; break;
      default: 
        return(STATUS_INVALID_STATEMENT);
    50ae:	83 e0       	ldi	r24, 0x03	; 3
    50b0:	50 c0       	rjmp	.+160    	; 0x5152 <settings_store_global_setting+0x2b0>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    50b2:	86 e0       	ldi	r24, 0x06	; 6
    50b4:	4e c0       	rjmp	.+156    	; 0x5152 <settings_store_global_setting+0x2b0>
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        break;
      case 20:
        if (int_value) { 
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    50b6:	8a e0       	ldi	r24, 0x0A	; 10
    50b8:	4c c0       	rjmp	.+152    	; 0x5152 <settings_store_global_setting+0x2b0>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50ba:	83 e0       	ldi	r24, 0x03	; 3
    50bc:	4a c0       	rjmp	.+148    	; 0x5152 <settings_store_global_setting+0x2b0>
    50be:	83 e0       	ldi	r24, 0x03	; 3
    50c0:	48 c0       	rjmp	.+144    	; 0x5152 <settings_store_global_setting+0x2b0>
        parameter -= AXIS_SETTINGS_INCREMENT;
    50c2:	e2 e9       	ldi	r30, 0x92	; 146
    50c4:	ed 0f       	add	r30, r29
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    50c6:	e3 30       	cpi	r30, 0x03	; 3
    50c8:	68 f0       	brcs	.+26     	; 0x50e4 <settings_store_global_setting+0x242>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50ca:	ea 30       	cpi	r30, 0x0A	; 10
    50cc:	b0 f3       	brcs	.-20     	; 0x50ba <settings_store_global_setting+0x218>
        parameter -= AXIS_SETTINGS_INCREMENT;
    50ce:	c8 e8       	ldi	r28, 0x88	; 136
    50d0:	cd 0f       	add	r28, r29
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    50d2:	c3 30       	cpi	r28, 0x03	; 3
    50d4:	98 f0       	brcs	.+38     	; 0x50fc <settings_store_global_setting+0x25a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50d6:	ca 30       	cpi	r28, 0x0A	; 10
    50d8:	90 f3       	brcs	.-28     	; 0x50be <settings_store_global_setting+0x21c>
        parameter -= AXIS_SETTINGS_INCREMENT;
    50da:	d2 58       	subi	r29, 0x82	; 130
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    50dc:	d3 30       	cpi	r29, 0x03	; 3
    50de:	40 f1       	brcs	.+80     	; 0x5130 <settings_store_global_setting+0x28e>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50e0:	83 e0       	ldi	r24, 0x03	; 3
    50e2:	37 c0       	rjmp	.+110    	; 0x5152 <settings_store_global_setting+0x2b0>
            // if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.steps_per_mm[parameter] = value;
            break;
          case 1:
            // if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.max_rate[parameter] = value;
    50e4:	f0 e0       	ldi	r31, 0x00	; 0
    50e6:	ee 0f       	add	r30, r30
    50e8:	ff 1f       	adc	r31, r31
    50ea:	ee 0f       	add	r30, r30
    50ec:	ff 1f       	adc	r31, r31
    50ee:	e5 5f       	subi	r30, 0xF5	; 245
    50f0:	f6 4f       	sbci	r31, 0xF6	; 246
    50f2:	c0 82       	st	Z, r12
    50f4:	d1 82       	std	Z+1, r13	; 0x01
    50f6:	e2 82       	std	Z+2, r14	; 0x02
    50f8:	f3 82       	std	Z+3, r15	; 0x03
            break;
    50fa:	d1 cf       	rjmp	.-94     	; 0x509e <settings_store_global_setting+0x1fc>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    50fc:	d0 e0       	ldi	r29, 0x00	; 0
    50fe:	cc 0f       	add	r28, r28
    5100:	dd 1f       	adc	r29, r29
    5102:	cc 0f       	add	r28, r28
    5104:	dd 1f       	adc	r29, r29
    5106:	c9 5e       	subi	r28, 0xE9	; 233
    5108:	d6 4f       	sbci	r29, 0xF6	; 246
    510a:	20 e0       	ldi	r18, 0x00	; 0
    510c:	30 e0       	ldi	r19, 0x00	; 0
    510e:	40 e7       	ldi	r20, 0x70	; 112
    5110:	52 e4       	ldi	r21, 0x42	; 66
    5112:	c7 01       	movw	r24, r14
    5114:	b6 01       	movw	r22, r12
    5116:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    511a:	20 e0       	ldi	r18, 0x00	; 0
    511c:	30 e0       	ldi	r19, 0x00	; 0
    511e:	40 e7       	ldi	r20, 0x70	; 112
    5120:	52 e4       	ldi	r21, 0x42	; 66
    5122:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5126:	68 83       	st	Y, r22
    5128:	79 83       	std	Y+1, r23	; 0x01
    512a:	8a 83       	std	Y+2, r24	; 0x02
    512c:	9b 83       	std	Y+3, r25	; 0x03
    512e:	b7 cf       	rjmp	.-146    	; 0x509e <settings_store_global_setting+0x1fc>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    5130:	ed 2f       	mov	r30, r29
    5132:	f0 e0       	ldi	r31, 0x00	; 0
    5134:	ee 0f       	add	r30, r30
    5136:	ff 1f       	adc	r31, r31
    5138:	ee 0f       	add	r30, r30
    513a:	ff 1f       	adc	r31, r31
    513c:	ed 5d       	subi	r30, 0xDD	; 221
    513e:	f6 4f       	sbci	r31, 0xF6	; 246
    5140:	f7 fa       	bst	r15, 7
    5142:	f0 94       	com	r15
    5144:	f7 f8       	bld	r15, 7
    5146:	f0 94       	com	r15
    5148:	c0 82       	st	Z, r12
    514a:	d1 82       	std	Z+1, r13	; 0x01
    514c:	e2 82       	std	Z+2, r14	; 0x02
    514e:	f3 82       	std	Z+3, r15	; 0x03
    5150:	a6 cf       	rjmp	.-180    	; 0x509e <settings_store_global_setting+0x1fc>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    5152:	df 91       	pop	r29
    5154:	cf 91       	pop	r28
    5156:	ff 90       	pop	r15
    5158:	ef 90       	pop	r14
    515a:	df 90       	pop	r13
    515c:	cf 90       	pop	r12
    515e:	08 95       	ret

00005160 <settings_init>:


// Initialize the config subsystem
void settings_init() {
    5160:	1f 93       	push	r17
    5162:	cf 93       	push	r28
    5164:	df 93       	push	r29
    5166:	cd b7       	in	r28, 0x3d	; 61
    5168:	de b7       	in	r29, 0x3e	; 62
    516a:	2c 97       	sbiw	r28, 0x0c	; 12
    516c:	0f b6       	in	r0, 0x3f	; 63
    516e:	f8 94       	cli
    5170:	de bf       	out	0x3e, r29	; 62
    5172:	0f be       	out	0x3f, r0	; 63
    5174:	cd bf       	out	0x3d, r28	; 61
  if(!read_global_settings()) {
    5176:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <read_global_settings>
    517a:	81 11       	cpse	r24, r1
    517c:	1b c0       	rjmp	.+54     	; 0x51b4 <settings_init+0x54>
    report_status_message(STATUS_SETTING_READ_FAIL);
    517e:	87 e0       	ldi	r24, 0x07	; 7
    5180:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>

    settings_restore_global_settings();
    5184:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <settings_restore_global_settings>
    
    // Force clear startup lines and build info user data. Parameters should be ok.
    // TODO: For next version, remove these clears. Only here because line buffer increased.
    settings_clear_startup_lines();
    5188:	0e 94 d7 26 	call	0x4dae	; 0x4dae <settings_clear_startup_lines>
    settings_clear_build_info();
    518c:	0e 94 e2 26 	call	0x4dc4	; 0x4dc4 <settings_clear_build_info>
    
    report_grbl_settings();
    5190:	0e 94 20 35 	call	0x6a40	; 0x6a40 <report_grbl_settings>
    5194:	0f c0       	rjmp	.+30     	; 0x51b4 <settings_init+0x54>

  // Check all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.
  float coord_data[N_AXIS];
  uint8_t i;
  for (i=0; i<=SETTING_INDEX_NCOORD; i++) {
    if (!settings_read_coord_data(i, coord_data)) {
    5196:	be 01       	movw	r22, r28
    5198:	6f 5f       	subi	r22, 0xFF	; 255
    519a:	7f 4f       	sbci	r23, 0xFF	; 255
    519c:	81 2f       	mov	r24, r17
    519e:	0e 94 1a 27 	call	0x4e34	; 0x4e34 <settings_read_coord_data>
    51a2:	81 11       	cpse	r24, r1
    51a4:	03 c0       	rjmp	.+6      	; 0x51ac <settings_init+0x4c>
      report_status_message(STATUS_SETTING_READ_FAIL);
    51a6:	87 e0       	ldi	r24, 0x07	; 7
    51a8:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
  }

  // Check all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.
  float coord_data[N_AXIS];
  uint8_t i;
  for (i=0; i<=SETTING_INDEX_NCOORD; i++) {
    51ac:	1f 5f       	subi	r17, 0xFF	; 255
    51ae:	18 30       	cpi	r17, 0x08	; 8
    51b0:	91 f7       	brne	.-28     	; 0x5196 <settings_init+0x36>
    51b2:	02 c0       	rjmp	.+4      	; 0x51b8 <settings_init+0x58>
  return(STATUS_OK);
}


// Initialize the config subsystem
void settings_init() {
    51b4:	10 e0       	ldi	r17, 0x00	; 0
    51b6:	ef cf       	rjmp	.-34     	; 0x5196 <settings_init+0x36>
      report_status_message(STATUS_SETTING_READ_FAIL);
    }
  }
  // NOTE: Startup lines are checked and executed by protocol_main_loop at the end of initialization.
  // TODO: Build info should be checked here, but will wait until v1.0 to address this. Ok for now.
}
    51b8:	2c 96       	adiw	r28, 0x0c	; 12
    51ba:	0f b6       	in	r0, 0x3f	; 63
    51bc:	f8 94       	cli
    51be:	de bf       	out	0x3e, r29	; 62
    51c0:	0f be       	out	0x3f, r0	; 63
    51c2:	cd bf       	out	0x3d, r28	; 61
    51c4:	df 91       	pop	r29
    51c6:	cf 91       	pop	r28
    51c8:	1f 91       	pop	r17
    51ca:	08 95       	ret

000051cc <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    51cc:	88 23       	and	r24, r24
    51ce:	21 f0       	breq	.+8      	; 0x51d8 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    51d0:	81 30       	cpi	r24, 0x01	; 1
    51d2:	21 f4       	brne	.+8      	; 0x51dc <get_step_pin_mask+0x10>
    51d4:	80 e1       	ldi	r24, 0x10	; 16
    51d6:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    51d8:	80 e4       	ldi	r24, 0x40	; 64
    51da:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
  return((1<<Z_STEP_BIT));
    51dc:	84 e0       	ldi	r24, 0x04	; 4
}
    51de:	08 95       	ret

000051e0 <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    51e0:	88 23       	and	r24, r24
    51e2:	21 f0       	breq	.+8      	; 0x51ec <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    51e4:	81 30       	cpi	r24, 0x01	; 1
    51e6:	21 f4       	brne	.+8      	; 0x51f0 <get_direction_pin_mask+0x10>
    51e8:	80 e2       	ldi	r24, 0x20	; 32
    51ea:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    51ec:	80 e8       	ldi	r24, 0x80	; 128
    51ee:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
  return((1<<Z_DIRECTION_BIT));
    51f0:	88 e0       	ldi	r24, 0x08	; 8
}
    51f2:	08 95       	ret

000051f4 <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    51f4:	88 23       	and	r24, r24
    51f6:	21 f0       	breq	.+8      	; 0x5200 <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    51f8:	81 30       	cpi	r24, 0x01	; 1
    51fa:	21 f4       	brne	.+8      	; 0x5204 <get_limit_pin_mask+0x10>
    51fc:	84 e0       	ldi	r24, 0x04	; 4
    51fe:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    5200:	82 e0       	ldi	r24, 0x02	; 2
    5202:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
  return((1<<Z_LIMIT_BIT));
    5204:	88 e0       	ldi	r24, 0x08	; 8
}
    5206:	08 95       	ret

00005208 <planner_recalculate>:
  to compute an optimal plan, so select carefully. The Arduino 328p memory is already maxed out, but future
  ARM versions should have enough memory and speed for look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate() 
{   
    5208:	3f 92       	push	r3
    520a:	4f 92       	push	r4
    520c:	5f 92       	push	r5
    520e:	6f 92       	push	r6
    5210:	7f 92       	push	r7
    5212:	8f 92       	push	r8
    5214:	9f 92       	push	r9
    5216:	af 92       	push	r10
    5218:	bf 92       	push	r11
    521a:	cf 92       	push	r12
    521c:	df 92       	push	r13
    521e:	ef 92       	push	r14
    5220:	ff 92       	push	r15
    5222:	0f 93       	push	r16
    5224:	1f 93       	push	r17
    5226:	cf 93       	push	r28
    5228:	df 93       	push	r29
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
    522a:	80 91 45 02 	lds	r24, 0x0245


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    522e:	81 11       	cpse	r24, r1
    5230:	01 c0       	rjmp	.+2      	; 0x5234 <planner_recalculate+0x2c>
    5232:	80 e2       	ldi	r24, 0x20	; 32
  block_index--;
    5234:	77 24       	eor	r7, r7
    5236:	7a 94       	dec	r7
    5238:	78 0e       	add	r7, r24
{   
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
        
  // Bail. Can't do anything with one only one plan-able block.
  if (block_index == block_buffer_planned) { return; }
    523a:	c0 91 43 02 	lds	r28, 0x0243
    523e:	c7 15       	cp	r28, r7
    5240:	09 f4       	brne	.+2      	; 0x5244 <planner_recalculate+0x3c>
    5242:	00 c1       	rjmp	.+512    	; 0x5444 <planner_recalculate+0x23c>
  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
  float entry_speed_sqr;
  plan_block_t *next;
  plan_block_t *current = &block_buffer[block_index];
    5244:	89 e2       	ldi	r24, 0x29	; 41
    5246:	78 9e       	mul	r7, r24
    5248:	80 01       	movw	r16, r0
    524a:	11 24       	eor	r1, r1
    524c:	09 5b       	subi	r16, 0xB9	; 185
    524e:	1d 4f       	sbci	r17, 0xFD	; 253

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
    5250:	f8 01       	movw	r30, r16
    5252:	95 88       	ldd	r9, Z+21	; 0x15
    5254:	a6 88       	ldd	r10, Z+22	; 0x16
    5256:	b7 88       	ldd	r11, Z+23	; 0x17
    5258:	c0 8c       	ldd	r12, Z+24	; 0x18
    525a:	61 a1       	ldd	r22, Z+33	; 0x21
    525c:	72 a1       	ldd	r23, Z+34	; 0x22
    525e:	83 a1       	ldd	r24, Z+35	; 0x23
    5260:	94 a1       	ldd	r25, Z+36	; 0x24
    5262:	9b 01       	movw	r18, r22
    5264:	ac 01       	movw	r20, r24
    5266:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    526a:	f8 01       	movw	r30, r16
    526c:	25 a1       	ldd	r18, Z+37	; 0x25
    526e:	36 a1       	ldd	r19, Z+38	; 0x26
    5270:	47 a1       	ldd	r20, Z+39	; 0x27
    5272:	50 a5       	ldd	r21, Z+40	; 0x28
    5274:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5278:	d6 2e       	mov	r13, r22
    527a:	e7 2e       	mov	r14, r23
    527c:	f8 2e       	mov	r15, r24
    527e:	d9 2f       	mov	r29, r25
    5280:	26 2f       	mov	r18, r22
    5282:	37 2f       	mov	r19, r23
    5284:	48 2f       	mov	r20, r24
    5286:	59 2f       	mov	r21, r25
    5288:	69 2d       	mov	r22, r9
    528a:	7a 2d       	mov	r23, r10
    528c:	8b 2d       	mov	r24, r11
    528e:	9c 2d       	mov	r25, r12
    5290:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5294:	88 23       	and	r24, r24
    5296:	24 f4       	brge	.+8      	; 0x52a0 <planner_recalculate+0x98>
    5298:	d9 2c       	mov	r13, r9
    529a:	ea 2c       	mov	r14, r10
    529c:	fb 2c       	mov	r15, r11
    529e:	dc 2d       	mov	r29, r12
    52a0:	4d 2d       	mov	r20, r13
    52a2:	5e 2d       	mov	r21, r14
    52a4:	6f 2d       	mov	r22, r15
    52a6:	7d 2f       	mov	r23, r29
    52a8:	f8 01       	movw	r30, r16
    52aa:	41 8b       	std	Z+17, r20	; 0x11
    52ac:	52 8b       	std	Z+18, r21	; 0x12
    52ae:	63 8b       	std	Z+19, r22	; 0x13
    52b0:	74 8b       	std	Z+20, r23	; 0x14


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    52b2:	71 10       	cpse	r7, r1
    52b4:	03 c0       	rjmp	.+6      	; 0x52bc <planner_recalculate+0xb4>
    52b6:	68 94       	set
    52b8:	77 24       	eor	r7, r7
    52ba:	75 f8       	bld	r7, 5
  block_index--;
    52bc:	7a 94       	dec	r7

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    52be:	c7 15       	cp	r28, r7
    52c0:	29 f0       	breq	.+10     	; 0x52cc <planner_recalculate+0xc4>
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
    52c2:	0f 2e       	mov	r0, r31
    52c4:	f9 e2       	ldi	r31, 0x29	; 41
    52c6:	6f 2e       	mov	r6, r31
    52c8:	f0 2d       	mov	r31, r0
    52ca:	4f c0       	rjmp	.+158    	; 0x536a <planner_recalculate+0x162>
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
    52cc:	80 91 46 02 	lds	r24, 0x0246
    52d0:	c8 13       	cpse	r28, r24
    52d2:	4f c0       	rjmp	.+158    	; 0x5372 <planner_recalculate+0x16a>
    52d4:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <st_update_plan_block_parameters>
    52d8:	4c c0       	rjmp	.+152    	; 0x5372 <planner_recalculate+0x16a>
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
    52da:	67 9c       	mul	r6, r7
    52dc:	e0 01       	movw	r28, r0
    52de:	11 24       	eor	r1, r1
    52e0:	c9 5b       	subi	r28, 0xB9	; 185
    52e2:	dd 4f       	sbci	r29, 0xFD	; 253


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    52e4:	71 10       	cpse	r7, r1
    52e6:	03 c0       	rjmp	.+6      	; 0x52ee <planner_recalculate+0xe6>
    52e8:	68 94       	set
    52ea:	77 24       	eor	r7, r7
    52ec:	75 f8       	bld	r7, 5
  block_index--;
    52ee:	7a 94       	dec	r7
      next = current;
      current = &block_buffer[block_index];
      block_index = plan_prev_block_index(block_index);

      // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
      if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); } 
    52f0:	80 91 46 02 	lds	r24, 0x0246
    52f4:	87 11       	cpse	r24, r7
    52f6:	02 c0       	rjmp	.+4      	; 0x52fc <planner_recalculate+0xf4>
    52f8:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <st_update_plan_block_parameters>

      // Compute maximum entry speed decelerating over the current block from its exit speed.
      if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
    52fc:	cd 88       	ldd	r12, Y+21	; 0x15
    52fe:	de 88       	ldd	r13, Y+22	; 0x16
    5300:	ef 88       	ldd	r14, Y+23	; 0x17
    5302:	f8 8c       	ldd	r15, Y+24	; 0x18
    5304:	a7 01       	movw	r20, r14
    5306:	96 01       	movw	r18, r12
    5308:	69 89       	ldd	r22, Y+17	; 0x11
    530a:	7a 89       	ldd	r23, Y+18	; 0x12
    530c:	8b 89       	ldd	r24, Y+19	; 0x13
    530e:	9c 89       	ldd	r25, Y+20	; 0x14
    5310:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5314:	88 23       	and	r24, r24
    5316:	41 f1       	breq	.+80     	; 0x5368 <planner_recalculate+0x160>
        entry_speed_sqr = next->entry_speed_sqr + 2*current->acceleration*current->millimeters;
    5318:	69 a1       	ldd	r22, Y+33	; 0x21
    531a:	7a a1       	ldd	r23, Y+34	; 0x22
    531c:	8b a1       	ldd	r24, Y+35	; 0x23
    531e:	9c a1       	ldd	r25, Y+36	; 0x24
    5320:	9b 01       	movw	r18, r22
    5322:	ac 01       	movw	r20, r24
    5324:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    5328:	2d a1       	ldd	r18, Y+37	; 0x25
    532a:	3e a1       	ldd	r19, Y+38	; 0x26
    532c:	4f a1       	ldd	r20, Y+39	; 0x27
    532e:	58 a5       	ldd	r21, Y+40	; 0x28
    5330:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5334:	f8 01       	movw	r30, r16
    5336:	21 89       	ldd	r18, Z+17	; 0x11
    5338:	32 89       	ldd	r19, Z+18	; 0x12
    533a:	43 89       	ldd	r20, Z+19	; 0x13
    533c:	54 89       	ldd	r21, Z+20	; 0x14
    533e:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    5342:	4b 01       	movw	r8, r22
    5344:	5c 01       	movw	r10, r24
        if (entry_speed_sqr < current->max_entry_speed_sqr) {
    5346:	9b 01       	movw	r18, r22
    5348:	ac 01       	movw	r20, r24
    534a:	c7 01       	movw	r24, r14
    534c:	b6 01       	movw	r22, r12
    534e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    5352:	18 16       	cp	r1, r24
    5354:	2c f4       	brge	.+10     	; 0x5360 <planner_recalculate+0x158>
          current->entry_speed_sqr = entry_speed_sqr;
    5356:	89 8a       	std	Y+17, r8	; 0x11
    5358:	9a 8a       	std	Y+18, r9	; 0x12
    535a:	ab 8a       	std	Y+19, r10	; 0x13
    535c:	bc 8a       	std	Y+20, r11	; 0x14
    535e:	04 c0       	rjmp	.+8      	; 0x5368 <planner_recalculate+0x160>
        } else {
          current->entry_speed_sqr = current->max_entry_speed_sqr;
    5360:	c9 8a       	std	Y+17, r12	; 0x11
    5362:	da 8a       	std	Y+18, r13	; 0x12
    5364:	eb 8a       	std	Y+19, r14	; 0x13
    5366:	fc 8a       	std	Y+20, r15	; 0x14


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    5368:	8e 01       	movw	r16, r28
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
    536a:	80 91 43 02 	lds	r24, 0x0243
    536e:	78 12       	cpse	r7, r24
    5370:	b4 cf       	rjmp	.-152    	; 0x52da <planner_recalculate+0xd2>
    }
  }    

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
    5372:	40 90 43 02 	lds	r4, 0x0243
    5376:	f9 e2       	ldi	r31, 0x29	; 41
    5378:	4f 9e       	mul	r4, r31
    537a:	80 01       	movw	r16, r0
    537c:	11 24       	eor	r1, r1
    537e:	09 5b       	subi	r16, 0xB9	; 185
    5380:	1d 4f       	sbci	r17, 0xFD	; 253


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    5382:	77 24       	eor	r7, r7
    5384:	73 94       	inc	r7
    5386:	74 0c       	add	r7, r4
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    5388:	80 e2       	ldi	r24, 0x20	; 32
    538a:	78 12       	cpse	r7, r24
    538c:	01 c0       	rjmp	.+2      	; 0x5390 <planner_recalculate+0x188>
    538e:	71 2c       	mov	r7, r1

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    5390:	60 90 45 02 	lds	r6, 0x0245
    current = next;
    next = &block_buffer[block_index];
    5394:	0f 2e       	mov	r0, r31
    5396:	f9 e2       	ldi	r31, 0x29	; 41
    5398:	5f 2e       	mov	r5, r31
    539a:	f0 2d       	mov	r31, r0

// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    539c:	31 2c       	mov	r3, r1

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    539e:	4e c0       	rjmp	.+156    	; 0x543c <planner_recalculate+0x234>
    current = next;
    next = &block_buffer[block_index];
    53a0:	57 9c       	mul	r5, r7
    53a2:	e0 01       	movw	r28, r0
    53a4:	11 24       	eor	r1, r1
    53a6:	c9 5b       	subi	r28, 0xB9	; 185
    53a8:	dd 4f       	sbci	r29, 0xFD	; 253
    
    // Any acceleration detected in the forward pass automatically moves the optimal planned
    // pointer forward, since everything before this is all optimal. In other words, nothing
    // can improve the plan from the buffer tail to the planned pointer by logic.
    if (current->entry_speed_sqr < next->entry_speed_sqr) {
    53aa:	f8 01       	movw	r30, r16
    53ac:	81 88       	ldd	r8, Z+17	; 0x11
    53ae:	92 88       	ldd	r9, Z+18	; 0x12
    53b0:	a3 88       	ldd	r10, Z+19	; 0x13
    53b2:	b4 88       	ldd	r11, Z+20	; 0x14
    53b4:	c9 88       	ldd	r12, Y+17	; 0x11
    53b6:	da 88       	ldd	r13, Y+18	; 0x12
    53b8:	eb 88       	ldd	r14, Y+19	; 0x13
    53ba:	fc 88       	ldd	r15, Y+20	; 0x14
    53bc:	a7 01       	movw	r20, r14
    53be:	96 01       	movw	r18, r12
    53c0:	c5 01       	movw	r24, r10
    53c2:	b4 01       	movw	r22, r8
    53c4:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    53c8:	88 23       	and	r24, r24
    53ca:	2c f5       	brge	.+74     	; 0x5416 <planner_recalculate+0x20e>
      entry_speed_sqr = current->entry_speed_sqr + 2*current->acceleration*current->millimeters;
    53cc:	f8 01       	movw	r30, r16
    53ce:	61 a1       	ldd	r22, Z+33	; 0x21
    53d0:	72 a1       	ldd	r23, Z+34	; 0x22
    53d2:	83 a1       	ldd	r24, Z+35	; 0x23
    53d4:	94 a1       	ldd	r25, Z+36	; 0x24
    53d6:	9b 01       	movw	r18, r22
    53d8:	ac 01       	movw	r20, r24
    53da:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    53de:	f8 01       	movw	r30, r16
    53e0:	25 a1       	ldd	r18, Z+37	; 0x25
    53e2:	36 a1       	ldd	r19, Z+38	; 0x26
    53e4:	47 a1       	ldd	r20, Z+39	; 0x27
    53e6:	50 a5       	ldd	r21, Z+40	; 0x28
    53e8:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    53ec:	9b 01       	movw	r18, r22
    53ee:	ac 01       	movw	r20, r24
    53f0:	c5 01       	movw	r24, r10
    53f2:	b4 01       	movw	r22, r8
    53f4:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    53f8:	4b 01       	movw	r8, r22
    53fa:	5c 01       	movw	r10, r24
      // If true, current block is full-acceleration and we can move the planned pointer forward.
      if (entry_speed_sqr < next->entry_speed_sqr) {
    53fc:	9b 01       	movw	r18, r22
    53fe:	ac 01       	movw	r20, r24
    5400:	c7 01       	movw	r24, r14
    5402:	b6 01       	movw	r22, r12
    5404:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    5408:	18 16       	cp	r1, r24
    540a:	2c f4       	brge	.+10     	; 0x5416 <planner_recalculate+0x20e>
        next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
    540c:	89 8a       	std	Y+17, r8	; 0x11
    540e:	9a 8a       	std	Y+18, r9	; 0x12
    5410:	ab 8a       	std	Y+19, r10	; 0x13
    5412:	bc 8a       	std	Y+20, r11	; 0x14
        block_buffer_planned = block_index; // Set optimal plan pointer.
    5414:	47 2c       	mov	r4, r7
    
    // Any block set at its maximum entry speed also creates an optimal plan up to this
    // point in the buffer. When the plan is bracketed by either the beginning of the
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    5416:	2d 89       	ldd	r18, Y+21	; 0x15
    5418:	3e 89       	ldd	r19, Y+22	; 0x16
    541a:	4f 89       	ldd	r20, Y+23	; 0x17
    541c:	58 8d       	ldd	r21, Y+24	; 0x18
    541e:	69 89       	ldd	r22, Y+17	; 0x11
    5420:	7a 89       	ldd	r23, Y+18	; 0x12
    5422:	8b 89       	ldd	r24, Y+19	; 0x13
    5424:	9c 89       	ldd	r25, Y+20	; 0x14
    5426:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    542a:	81 11       	cpse	r24, r1
    542c:	01 c0       	rjmp	.+2      	; 0x5430 <planner_recalculate+0x228>
    542e:	47 2c       	mov	r4, r7


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    5430:	73 94       	inc	r7
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    5432:	f0 e2       	ldi	r31, 0x20	; 32
    5434:	7f 12       	cpse	r7, r31
    5436:	01 c0       	rjmp	.+2      	; 0x543a <planner_recalculate+0x232>
    5438:	73 2c       	mov	r7, r3
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    current = next;
    next = &block_buffer[block_index];
    543a:	8e 01       	movw	r16, r28

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    543c:	76 10       	cpse	r7, r6
    543e:	b0 cf       	rjmp	.-160    	; 0x53a0 <planner_recalculate+0x198>
    5440:	40 92 43 02 	sts	0x0243, r4
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    block_index = plan_next_block_index( block_index );
  } 
}
    5444:	df 91       	pop	r29
    5446:	cf 91       	pop	r28
    5448:	1f 91       	pop	r17
    544a:	0f 91       	pop	r16
    544c:	ff 90       	pop	r15
    544e:	ef 90       	pop	r14
    5450:	df 90       	pop	r13
    5452:	cf 90       	pop	r12
    5454:	bf 90       	pop	r11
    5456:	af 90       	pop	r10
    5458:	9f 90       	pop	r9
    545a:	8f 90       	pop	r8
    545c:	7f 90       	pop	r7
    545e:	6f 90       	pop	r6
    5460:	5f 90       	pop	r5
    5462:	4f 90       	pop	r4
    5464:	3f 90       	pop	r3
    5466:	08 95       	ret

00005468 <plan_reset>:


void plan_reset() 
{
  memset(&pl, 0, sizeof(pl)); // Clear planner struct
    5468:	8c e1       	ldi	r24, 0x1C	; 28
    546a:	e7 e2       	ldi	r30, 0x27	; 39
    546c:	f2 e0       	ldi	r31, 0x02	; 2
    546e:	df 01       	movw	r26, r30
    5470:	1d 92       	st	X+, r1
    5472:	8a 95       	dec	r24
    5474:	e9 f7       	brne	.-6      	; 0x5470 <plan_reset+0x8>
  block_buffer_tail = 0;
    5476:	10 92 46 02 	sts	0x0246, r1
  block_buffer_head = 0; // Empty = tail
    547a:	10 92 45 02 	sts	0x0245, r1
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
    547e:	81 e0       	ldi	r24, 0x01	; 1
    5480:	80 93 44 02 	sts	0x0244, r24
  block_buffer_planned = 0; // = block_buffer_tail;
    5484:	10 92 43 02 	sts	0x0243, r1
    5488:	08 95       	ret

0000548a <plan_discard_current_block>:
}


void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    548a:	80 91 46 02 	lds	r24, 0x0246
    548e:	90 91 45 02 	lds	r25, 0x0245
    5492:	98 17       	cp	r25, r24
    5494:	69 f0       	breq	.+26     	; 0x54b0 <plan_discard_current_block+0x26>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    5496:	91 e0       	ldi	r25, 0x01	; 1
    5498:	98 0f       	add	r25, r24
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    549a:	90 32       	cpi	r25, 0x20	; 32
    549c:	09 f4       	brne	.+2      	; 0x54a0 <plan_discard_current_block+0x16>
    549e:	90 e0       	ldi	r25, 0x00	; 0
void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
    54a0:	20 91 43 02 	lds	r18, 0x0243
    54a4:	82 13       	cpse	r24, r18
    54a6:	02 c0       	rjmp	.+4      	; 0x54ac <plan_discard_current_block+0x22>
    54a8:	90 93 43 02 	sts	0x0243, r25
    block_buffer_tail = block_index;
    54ac:	90 93 46 02 	sts	0x0246, r25
    54b0:	08 95       	ret

000054b2 <plan_get_current_block>:
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    54b2:	80 91 46 02 	lds	r24, 0x0246
    54b6:	90 91 45 02 	lds	r25, 0x0245
    54ba:	98 17       	cp	r25, r24
    54bc:	39 f0       	breq	.+14     	; 0x54cc <plan_get_current_block+0x1a>
  return(&block_buffer[block_buffer_tail]);
    54be:	29 e2       	ldi	r18, 0x29	; 41
    54c0:	82 9f       	mul	r24, r18
    54c2:	c0 01       	movw	r24, r0
    54c4:	11 24       	eor	r1, r1
    54c6:	89 5b       	subi	r24, 0xB9	; 185
    54c8:	9d 4f       	sbci	r25, 0xFD	; 253
    54ca:	08 95       	ret
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    54cc:	80 e0       	ldi	r24, 0x00	; 0
    54ce:	90 e0       	ldi	r25, 0x00	; 0
  return(&block_buffer[block_buffer_tail]);
}
    54d0:	08 95       	ret

000054d2 <plan_get_exec_block_exit_speed>:


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    54d2:	e0 91 46 02 	lds	r30, 0x0246
    54d6:	ef 5f       	subi	r30, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    54d8:	e0 32       	cpi	r30, 0x20	; 32
    54da:	09 f4       	brne	.+2      	; 0x54de <plan_get_exec_block_exit_speed+0xc>
    54dc:	e0 e0       	ldi	r30, 0x00	; 0


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    54de:	80 91 45 02 	lds	r24, 0x0245
    54e2:	8e 17       	cp	r24, r30
    54e4:	69 f0       	breq	.+26     	; 0x5500 <plan_get_exec_block_exit_speed+0x2e>
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
    54e6:	89 e2       	ldi	r24, 0x29	; 41
    54e8:	e8 9f       	mul	r30, r24
    54ea:	f0 01       	movw	r30, r0
    54ec:	11 24       	eor	r1, r1
    54ee:	e9 5b       	subi	r30, 0xB9	; 185
    54f0:	fd 4f       	sbci	r31, 0xFD	; 253
    54f2:	61 89       	ldd	r22, Z+17	; 0x11
    54f4:	72 89       	ldd	r23, Z+18	; 0x12
    54f6:	83 89       	ldd	r24, Z+19	; 0x13
    54f8:	94 89       	ldd	r25, Z+20	; 0x14
    54fa:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    54fe:	08 95       	ret


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    5500:	60 e0       	ldi	r22, 0x00	; 0
    5502:	70 e0       	ldi	r23, 0x00	; 0
    5504:	cb 01       	movw	r24, r22
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
}
    5506:	08 95       	ret

00005508 <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
  if (block_buffer_tail == next_buffer_head) { return(true); }
    5508:	81 e0       	ldi	r24, 0x01	; 1
    550a:	20 91 46 02 	lds	r18, 0x0246
    550e:	90 91 44 02 	lds	r25, 0x0244
    5512:	29 13       	cpse	r18, r25
    5514:	80 e0       	ldi	r24, 0x00	; 0
  return(false);
}
    5516:	08 95       	ret

00005518 <plan_buffer_line>:
#ifdef USE_LINE_NUMBERS   
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number) 
#else
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate) 
#endif
{
    5518:	2f 92       	push	r2
    551a:	3f 92       	push	r3
    551c:	4f 92       	push	r4
    551e:	5f 92       	push	r5
    5520:	6f 92       	push	r6
    5522:	7f 92       	push	r7
    5524:	8f 92       	push	r8
    5526:	9f 92       	push	r9
    5528:	af 92       	push	r10
    552a:	bf 92       	push	r11
    552c:	cf 92       	push	r12
    552e:	df 92       	push	r13
    5530:	ef 92       	push	r14
    5532:	ff 92       	push	r15
    5534:	0f 93       	push	r16
    5536:	1f 93       	push	r17
    5538:	cf 93       	push	r28
    553a:	df 93       	push	r29
    553c:	cd b7       	in	r28, 0x3d	; 61
    553e:	de b7       	in	r29, 0x3e	; 62
    5540:	ad 97       	sbiw	r28, 0x2d	; 45
    5542:	0f b6       	in	r0, 0x3f	; 63
    5544:	f8 94       	cli
    5546:	de bf       	out	0x3e, r29	; 62
    5548:	0f be       	out	0x3f, r0	; 63
    554a:	cd bf       	out	0x3d, r28	; 61
    554c:	49 a3       	std	Y+33, r20	; 0x21
    554e:	5a a3       	std	Y+34, r21	; 0x22
    5550:	6b a3       	std	Y+35, r22	; 0x23
    5552:	7c a3       	std	Y+36, r23	; 0x24
    5554:	2d a3       	std	Y+37, r18	; 0x25
  // Prepare and initialize new block
  plan_block_t *block = &block_buffer[block_buffer_head];
    5556:	20 91 45 02 	lds	r18, 0x0245
    555a:	49 e2       	ldi	r20, 0x29	; 41
    555c:	24 9f       	mul	r18, r20
    555e:	90 01       	movw	r18, r0
    5560:	11 24       	eor	r1, r1
    5562:	f9 01       	movw	r30, r18
    5564:	e9 5b       	subi	r30, 0xB9	; 185
    5566:	fd 4f       	sbci	r31, 0xFD	; 253
    5568:	1f 01       	movw	r2, r30
  block->step_event_count = 0;
    556a:	15 86       	std	Z+13, r1	; 0x0d
    556c:	16 86       	std	Z+14, r1	; 0x0e
    556e:	17 86       	std	Z+15, r1	; 0x0f
    5570:	10 8a       	std	Z+16, r1	; 0x10
  block->millimeters = 0;
    5572:	15 a2       	std	Z+37, r1	; 0x25
    5574:	16 a2       	std	Z+38, r1	; 0x26
    5576:	17 a2       	std	Z+39, r1	; 0x27
    5578:	10 a6       	std	Z+40, r1	; 0x28
  block->direction_bits = 0;
    557a:	10 82       	st	Z, r1
  block->acceleration = SOME_LARGE_VALUE; // Scaled down to maximum acceleration later
    557c:	49 e9       	ldi	r20, 0x99	; 153
    557e:	56 e7       	ldi	r21, 0x76	; 118
    5580:	66 e9       	ldi	r22, 0x96	; 150
    5582:	7e e7       	ldi	r23, 0x7E	; 126
    5584:	41 a3       	std	Z+33, r20	; 0x21
    5586:	52 a3       	std	Z+34, r21	; 0x22
    5588:	63 a3       	std	Z+35, r22	; 0x23
    558a:	74 a3       	std	Z+36, r23	; 0x24
    558c:	5c 01       	movw	r10, r24
    558e:	0f ef       	ldi	r16, 0xFF	; 255
    5590:	18 e0       	ldi	r17, 0x08	; 8
    5592:	ae 01       	movw	r20, r28
    5594:	4f 5f       	subi	r20, 0xFF	; 255
    5596:	5f 4f       	sbci	r21, 0xFF	; 255
    5598:	5c 8f       	std	Y+28, r21	; 0x1c
    559a:	4b 8f       	std	Y+27, r20	; 0x1b
    559c:	0f 2e       	mov	r0, r31
    559e:	f7 e2       	ldi	r31, 0x27	; 39
    55a0:	4f 2e       	mov	r4, r31
    55a2:	f2 e0       	ldi	r31, 0x02	; 2
    55a4:	5f 2e       	mov	r5, r31
    55a6:	f0 2d       	mov	r31, r0
    55a8:	7f 01       	movw	r14, r30
    55aa:	ce 01       	movw	r24, r28
    55ac:	0d 96       	adiw	r24, 0x0d	; 13
    55ae:	6c 01       	movw	r12, r24
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    55b0:	71 2c       	mov	r7, r1
    55b2:	be 8e       	std	Y+30, r11	; 0x1e
    55b4:	ad 8e       	std	Y+29, r10	; 0x1d
        delta_mm = ((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]))/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
    55b6:	ed 8d       	ldd	r30, Y+29	; 0x1d
    55b8:	fe 8d       	ldd	r31, Y+30	; 0x1e
    55ba:	61 91       	ld	r22, Z+
    55bc:	71 91       	ld	r23, Z+
    55be:	81 91       	ld	r24, Z+
    55c0:	91 91       	ld	r25, Z+
    55c2:	fe 8f       	std	Y+30, r31	; 0x1e
    55c4:	ed 8f       	std	Y+29, r30	; 0x1d
    55c6:	18 a3       	std	Y+32, r17	; 0x20
    55c8:	0f 8f       	std	Y+31, r16	; 0x1f
    55ca:	f8 01       	movw	r30, r16
    55cc:	20 81       	ld	r18, Z
    55ce:	31 81       	ldd	r19, Z+1	; 0x01
    55d0:	42 81       	ldd	r20, Z+2	; 0x02
    55d2:	53 81       	ldd	r21, Z+3	; 0x03
    55d4:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    55d8:	0e 94 9a 3e 	call	0x7d34	; 0x7d34 <lround>
    55dc:	eb 8d       	ldd	r30, Y+27	; 0x1b
    55de:	fc 8d       	ldd	r31, Y+28	; 0x1c
    55e0:	61 93       	st	Z+, r22
    55e2:	71 93       	st	Z+, r23
    55e4:	81 93       	st	Z+, r24
    55e6:	91 93       	st	Z+, r25
    55e8:	fc 8f       	std	Y+28, r31	; 0x1c
    55ea:	eb 8f       	std	Y+27, r30	; 0x1b
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
    55ec:	f2 01       	movw	r30, r4
    55ee:	81 90       	ld	r8, Z+
    55f0:	91 90       	ld	r9, Z+
    55f2:	a1 90       	ld	r10, Z+
    55f4:	b1 90       	ld	r11, Z+
    55f6:	2f 01       	movw	r4, r30
    55f8:	68 19       	sub	r22, r8
    55fa:	79 09       	sbc	r23, r9
    55fc:	8a 09       	sbc	r24, r10
    55fe:	9b 09       	sbc	r25, r11
    5600:	9b 01       	movw	r18, r22
    5602:	ac 01       	movw	r20, r24
    5604:	3a f4       	brpl	.+14     	; 0x5614 <plan_buffer_line+0xfc>
    5606:	22 27       	eor	r18, r18
    5608:	33 27       	eor	r19, r19
    560a:	a9 01       	movw	r20, r18
    560c:	26 1b       	sub	r18, r22
    560e:	37 0b       	sbc	r19, r23
    5610:	48 0b       	sbc	r20, r24
    5612:	59 0b       	sbc	r21, r25
    5614:	f7 01       	movw	r30, r14
    5616:	21 83       	std	Z+1, r18	; 0x01
    5618:	32 83       	std	Z+2, r19	; 0x02
    561a:	43 83       	std	Z+3, r20	; 0x03
    561c:	54 83       	std	Z+4, r21	; 0x04
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    561e:	f1 01       	movw	r30, r2
    5620:	85 84       	ldd	r8, Z+13	; 0x0d
    5622:	96 84       	ldd	r9, Z+14	; 0x0e
    5624:	a7 84       	ldd	r10, Z+15	; 0x0f
    5626:	b0 88       	ldd	r11, Z+16	; 0x10
    5628:	28 15       	cp	r18, r8
    562a:	39 05       	cpc	r19, r9
    562c:	4a 05       	cpc	r20, r10
    562e:	5b 05       	cpc	r21, r11
    5630:	10 f4       	brcc	.+4      	; 0x5636 <plan_buffer_line+0x11e>
    5632:	a5 01       	movw	r20, r10
    5634:	94 01       	movw	r18, r8
    5636:	f1 01       	movw	r30, r2
    5638:	25 87       	std	Z+13, r18	; 0x0d
    563a:	36 87       	std	Z+14, r19	; 0x0e
    563c:	47 87       	std	Z+15, r20	; 0x0f
    563e:	50 8b       	std	Z+16, r21	; 0x10
      delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
    5640:	0e 94 2e 3d 	call	0x7a5c	; 0x7a5c <__floatsisf>
    5644:	ef 8d       	ldd	r30, Y+31	; 0x1f
    5646:	f8 a1       	ldd	r31, Y+32	; 0x20
    5648:	20 81       	ld	r18, Z
    564a:	31 81       	ldd	r19, Z+1	; 0x01
    564c:	42 81       	ldd	r20, Z+2	; 0x02
    564e:	53 81       	ldd	r21, Z+3	; 0x03
    5650:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    5654:	4b 01       	movw	r8, r22
    5656:	5c 01       	movw	r10, r24
    #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
    5658:	f6 01       	movw	r30, r12
    565a:	61 93       	st	Z+, r22
    565c:	71 93       	st	Z+, r23
    565e:	81 93       	st	Z+, r24
    5660:	91 93       	st	Z+, r25
    5662:	6f 01       	movw	r12, r30
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    5664:	20 e0       	ldi	r18, 0x00	; 0
    5666:	30 e0       	ldi	r19, 0x00	; 0
    5668:	a9 01       	movw	r20, r18
    566a:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    566e:	88 23       	and	r24, r24
    5670:	44 f4       	brge	.+16     	; 0x5682 <plan_buffer_line+0x16a>
    5672:	f1 01       	movw	r30, r2
    5674:	60 80       	ld	r6, Z
    5676:	87 2d       	mov	r24, r7
    5678:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <get_direction_pin_mask>
    567c:	86 29       	or	r24, r6
    567e:	f1 01       	movw	r30, r2
    5680:	80 83       	st	Z, r24
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    5682:	a5 01       	movw	r20, r10
    5684:	94 01       	movw	r18, r8
    5686:	c5 01       	movw	r24, r10
    5688:	b4 01       	movw	r22, r8
    568a:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    568e:	f1 01       	movw	r30, r2
    5690:	25 a1       	ldd	r18, Z+37	; 0x25
    5692:	36 a1       	ldd	r19, Z+38	; 0x26
    5694:	47 a1       	ldd	r20, Z+39	; 0x27
    5696:	50 a5       	ldd	r21, Z+40	; 0x28
    5698:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    569c:	f1 01       	movw	r30, r2
    569e:	65 a3       	std	Z+37, r22	; 0x25
    56a0:	76 a3       	std	Z+38, r23	; 0x26
    56a2:	87 a3       	std	Z+39, r24	; 0x27
    56a4:	90 a7       	std	Z+40, r25	; 0x28
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    56a6:	73 94       	inc	r7
    56a8:	0c 5f       	subi	r16, 0xFC	; 252
    56aa:	1f 4f       	sbci	r17, 0xFF	; 255
    56ac:	f4 e0       	ldi	r31, 0x04	; 4
    56ae:	ef 0e       	add	r14, r31
    56b0:	f1 1c       	adc	r15, r1
    56b2:	23 e0       	ldi	r18, 0x03	; 3
    56b4:	72 12       	cpse	r7, r18
    56b6:	7f cf       	rjmp	.-258    	; 0x55b6 <plan_buffer_line+0x9e>
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
  }
  block->millimeters = sqrt(block->millimeters); // Complete millimeters calculation with sqrt()
    56b8:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    56bc:	6b 01       	movw	r12, r22
    56be:	7c 01       	movw	r14, r24
    56c0:	f1 01       	movw	r30, r2
    56c2:	65 a3       	std	Z+37, r22	; 0x25
    56c4:	76 a3       	std	Z+38, r23	; 0x26
    56c6:	87 a3       	std	Z+39, r24	; 0x27
    56c8:	90 a7       	std	Z+40, r25	; 0x28
  
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
    56ca:	85 85       	ldd	r24, Z+13	; 0x0d
    56cc:	96 85       	ldd	r25, Z+14	; 0x0e
    56ce:	a7 85       	ldd	r26, Z+15	; 0x0f
    56d0:	b0 89       	ldd	r27, Z+16	; 0x10
    56d2:	89 2b       	or	r24, r25
    56d4:	8a 2b       	or	r24, r26
    56d6:	8b 2b       	or	r24, r27
    56d8:	09 f4       	brne	.+2      	; 0x56dc <plan_buffer_line+0x1c4>
    56da:	1f c2       	rjmp	.+1086   	; 0x5b1a <plan_buffer_line+0x602>
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    56dc:	20 e0       	ldi	r18, 0x00	; 0
    56de:	30 e0       	ldi	r19, 0x00	; 0
    56e0:	a9 01       	movw	r20, r18
    56e2:	69 a1       	ldd	r22, Y+33	; 0x21
    56e4:	7a a1       	ldd	r23, Y+34	; 0x22
    56e6:	8b a1       	ldd	r24, Y+35	; 0x23
    56e8:	9c a1       	ldd	r25, Y+36	; 0x24
    56ea:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    56ee:	88 23       	and	r24, r24
    56f0:	e4 f0       	brlt	.+56     	; 0x572a <plan_buffer_line+0x212>
  else if (invert_feed_rate) { feed_rate = block->millimeters/feed_rate; }
    56f2:	fd a1       	ldd	r31, Y+37	; 0x25
    56f4:	ff 23       	and	r31, r31
    56f6:	61 f0       	breq	.+24     	; 0x5710 <plan_buffer_line+0x1f8>
    56f8:	29 a1       	ldd	r18, Y+33	; 0x21
    56fa:	3a a1       	ldd	r19, Y+34	; 0x22
    56fc:	4b a1       	ldd	r20, Y+35	; 0x23
    56fe:	5c a1       	ldd	r21, Y+36	; 0x24
    5700:	c7 01       	movw	r24, r14
    5702:	b6 01       	movw	r22, r12
    5704:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    5708:	69 a3       	std	Y+33, r22	; 0x21
    570a:	7a a3       	std	Y+34, r23	; 0x22
    570c:	8b a3       	std	Y+35, r24	; 0x23
    570e:	9c a3       	std	Y+36, r25	; 0x24
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    5710:	20 e0       	ldi	r18, 0x00	; 0
    5712:	30 e0       	ldi	r19, 0x00	; 0
    5714:	40 e8       	ldi	r20, 0x80	; 128
    5716:	5f e3       	ldi	r21, 0x3F	; 63
    5718:	69 a1       	ldd	r22, Y+33	; 0x21
    571a:	7a a1       	ldd	r23, Y+34	; 0x22
    571c:	8b a1       	ldd	r24, Y+35	; 0x23
    571e:	9c a1       	ldd	r25, Y+36	; 0x24
    5720:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5724:	88 23       	and	r24, r24
    5726:	84 f4       	brge	.+32     	; 0x5748 <plan_buffer_line+0x230>
    5728:	09 c0       	rjmp	.+18     	; 0x573c <plan_buffer_line+0x224>
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    572a:	29 e9       	ldi	r18, 0x99	; 153
    572c:	29 a3       	std	Y+33, r18	; 0x21
    572e:	46 e7       	ldi	r20, 0x76	; 118
    5730:	4a a3       	std	Y+34, r20	; 0x22
    5732:	56 e9       	ldi	r21, 0x96	; 150
    5734:	5b a3       	std	Y+35, r21	; 0x23
    5736:	8e e7       	ldi	r24, 0x7E	; 126
    5738:	8c a3       	std	Y+36, r24	; 0x24
    573a:	06 c0       	rjmp	.+12     	; 0x5748 <plan_buffer_line+0x230>
  else if (invert_feed_rate) { feed_rate = block->millimeters/feed_rate; }
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    573c:	19 a2       	std	Y+33, r1	; 0x21
    573e:	1a a2       	std	Y+34, r1	; 0x22
    5740:	90 e8       	ldi	r25, 0x80	; 128
    5742:	9b a3       	std	Y+35, r25	; 0x23
    5744:	ef e3       	ldi	r30, 0x3F	; 63
    5746:	ec a3       	std	Y+36, r30	; 0x24
  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled 
  // down such that no individual axes maximum values are exceeded with respect to the line direction. 
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
    5748:	a7 01       	movw	r20, r14
    574a:	96 01       	movw	r18, r12
    574c:	60 e0       	ldi	r22, 0x00	; 0
    574e:	70 e0       	ldi	r23, 0x00	; 0
    5750:	80 e8       	ldi	r24, 0x80	; 128
    5752:	9f e3       	ldi	r25, 0x3F	; 63
    5754:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    5758:	6a a7       	std	Y+42, r22	; 0x2a
    575a:	7b a7       	std	Y+43, r23	; 0x2b
    575c:	8c a7       	std	Y+44, r24	; 0x2c
    575e:	9d a7       	std	Y+45, r25	; 0x2d
    5760:	03 e3       	ldi	r16, 0x33	; 51
    5762:	12 e0       	ldi	r17, 0x02	; 2
    5764:	0f 2e       	mov	r0, r31
    5766:	fb e0       	ldi	r31, 0x0B	; 11
    5768:	4f 2e       	mov	r4, r31
    576a:	f9 e0       	ldi	r31, 0x09	; 9
    576c:	5f 2e       	mov	r5, r31
    576e:	f0 2d       	mov	r31, r0
    5770:	ae 01       	movw	r20, r28
    5772:	47 5e       	subi	r20, 0xE7	; 231
    5774:	5f 4f       	sbci	r21, 0xFF	; 255
    5776:	5a 8f       	std	Y+26, r21	; 0x1a
    5778:	49 8f       	std	Y+25, r20	; 0x19
    577a:	ce 01       	movw	r24, r28
    577c:	0d 96       	adiw	r24, 0x0d	; 13
  float junction_cos_theta = 0;
    577e:	1f 8e       	std	Y+31, r1	; 0x1f
    5780:	1d a2       	std	Y+37, r1	; 0x25
    5782:	1e a2       	std	Y+38, r1	; 0x26
    5784:	1f a2       	std	Y+39, r1	; 0x27
    5786:	3c 8e       	std	Y+28, r3	; 0x1c
    5788:	2b 8e       	std	Y+27, r2	; 0x1b
    578a:	1e 8f       	std	Y+30, r17	; 0x1e
    578c:	0d 8f       	std	Y+29, r16	; 0x1d
    578e:	8c 01       	movw	r16, r24
    5790:	32 01       	movw	r6, r4
    5792:	29 a0       	ldd	r2, Y+33	; 0x21
    5794:	3a a0       	ldd	r3, Y+34	; 0x22
    5796:	4b a0       	ldd	r4, Y+35	; 0x23
    5798:	5c a0       	ldd	r5, Y+36	; 0x24
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    579a:	f8 01       	movw	r30, r16
    579c:	c0 80       	ld	r12, Z
    579e:	d1 80       	ldd	r13, Z+1	; 0x01
    57a0:	e2 80       	ldd	r14, Z+2	; 0x02
    57a2:	f3 80       	ldd	r15, Z+3	; 0x03
    57a4:	20 e0       	ldi	r18, 0x00	; 0
    57a6:	30 e0       	ldi	r19, 0x00	; 0
    57a8:	a9 01       	movw	r20, r18
    57aa:	c7 01       	movw	r24, r14
    57ac:	b6 01       	movw	r22, r12
    57ae:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    57b2:	88 23       	and	r24, r24
    57b4:	09 f4       	brne	.+2      	; 0x57b8 <plan_buffer_line+0x2a0>
    57b6:	7e c0       	rjmp	.+252    	; 0x58b4 <plan_buffer_line+0x39c>
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
    57b8:	a7 01       	movw	r20, r14
    57ba:	96 01       	movw	r18, r12
    57bc:	6a a5       	ldd	r22, Y+42	; 0x2a
    57be:	7b a5       	ldd	r23, Y+43	; 0x2b
    57c0:	8c a5       	ldd	r24, Y+44	; 0x2c
    57c2:	9d a5       	ldd	r25, Y+45	; 0x2d
    57c4:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    57c8:	6b 01       	movw	r12, r22
    57ca:	7c 01       	movw	r14, r24
    57cc:	f8 01       	movw	r30, r16
    57ce:	60 83       	st	Z, r22
    57d0:	71 83       	std	Z+1, r23	; 0x01
    57d2:	82 83       	std	Z+2, r24	; 0x02
    57d4:	93 83       	std	Z+3, r25	; 0x03
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.
    57d6:	9b 01       	movw	r18, r22
    57d8:	ac 01       	movw	r20, r24
    57da:	60 e0       	ldi	r22, 0x00	; 0
    57dc:	70 e0       	ldi	r23, 0x00	; 0
    57de:	80 e8       	ldi	r24, 0x80	; 128
    57e0:	9f e3       	ldi	r25, 0x3F	; 63
    57e2:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    57e6:	4b 01       	movw	r8, r22
    57e8:	5c 01       	movw	r10, r24
    57ea:	e8 94       	clt
    57ec:	b7 f8       	bld	r11, 7
    57ee:	79 a6       	std	Y+41, r7	; 0x29
    57f0:	68 a6       	std	Y+40, r6	; 0x28

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    57f2:	f3 01       	movw	r30, r6
    57f4:	20 81       	ld	r18, Z
    57f6:	31 81       	ldd	r19, Z+1	; 0x01
    57f8:	42 81       	ldd	r20, Z+2	; 0x02
    57fa:	53 81       	ldd	r21, Z+3	; 0x03
    57fc:	c5 01       	movw	r24, r10
    57fe:	b4 01       	movw	r22, r8
    5800:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5804:	69 a3       	std	Y+33, r22	; 0x21
    5806:	7a a3       	std	Y+34, r23	; 0x22
    5808:	8b a3       	std	Y+35, r24	; 0x23
    580a:	9c a3       	std	Y+36, r25	; 0x24
    580c:	22 2d       	mov	r18, r2
    580e:	33 2d       	mov	r19, r3
    5810:	44 2d       	mov	r20, r4
    5812:	55 2d       	mov	r21, r5
    5814:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    5818:	18 16       	cp	r1, r24
    581a:	24 f4       	brge	.+8      	; 0x5824 <plan_buffer_line+0x30c>
    581c:	29 a2       	std	Y+33, r2	; 0x21
    581e:	3a a2       	std	Y+34, r3	; 0x22
    5820:	4b a2       	std	Y+35, r4	; 0x23
    5822:	5c a2       	std	Y+36, r5	; 0x24
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    5824:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5826:	fc 8d       	ldd	r31, Y+28	; 0x1c
    5828:	21 a0       	ldd	r2, Z+33	; 0x21
    582a:	32 a0       	ldd	r3, Z+34	; 0x22
    582c:	43 a0       	ldd	r4, Z+35	; 0x23
    582e:	54 a0       	ldd	r5, Z+36	; 0x24
    5830:	e8 a5       	ldd	r30, Y+40	; 0x28
    5832:	f9 a5       	ldd	r31, Y+41	; 0x29
    5834:	24 85       	ldd	r18, Z+12	; 0x0c
    5836:	35 85       	ldd	r19, Z+13	; 0x0d
    5838:	46 85       	ldd	r20, Z+14	; 0x0e
    583a:	57 85       	ldd	r21, Z+15	; 0x0f
    583c:	c5 01       	movw	r24, r10
    583e:	b4 01       	movw	r22, r8
    5840:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5844:	86 2e       	mov	r8, r22
    5846:	97 2e       	mov	r9, r23
    5848:	a8 2e       	mov	r10, r24
    584a:	b9 2e       	mov	r11, r25
    584c:	26 2f       	mov	r18, r22
    584e:	37 2f       	mov	r19, r23
    5850:	48 2f       	mov	r20, r24
    5852:	59 2f       	mov	r21, r25
    5854:	62 2d       	mov	r22, r2
    5856:	73 2d       	mov	r23, r3
    5858:	84 2d       	mov	r24, r4
    585a:	95 2d       	mov	r25, r5
    585c:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5860:	88 23       	and	r24, r24
    5862:	24 f0       	brlt	.+8      	; 0x586c <plan_buffer_line+0x354>
    5864:	28 2c       	mov	r2, r8
    5866:	39 2c       	mov	r3, r9
    5868:	4a 2c       	mov	r4, r10
    586a:	5b 2c       	mov	r5, r11
    586c:	82 2d       	mov	r24, r2
    586e:	93 2d       	mov	r25, r3
    5870:	a4 2d       	mov	r26, r4
    5872:	b5 2d       	mov	r27, r5
    5874:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5876:	fc 8d       	ldd	r31, Y+28	; 0x1c
    5878:	81 a3       	std	Z+33, r24	; 0x21
    587a:	92 a3       	std	Z+34, r25	; 0x22
    587c:	a3 a3       	std	Z+35, r26	; 0x23
    587e:	b4 a3       	std	Z+36, r27	; 0x24

      // Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction
      // between the current move and the previous move is simply the dot product of the two unit vectors, 
      // where prev_unit_vec is negative. Used later to compute maximum junction speed.
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    5880:	ed 8d       	ldd	r30, Y+29	; 0x1d
    5882:	fe 8d       	ldd	r31, Y+30	; 0x1e
    5884:	20 81       	ld	r18, Z
    5886:	31 81       	ldd	r19, Z+1	; 0x01
    5888:	42 81       	ldd	r20, Z+2	; 0x02
    588a:	53 81       	ldd	r21, Z+3	; 0x03
    588c:	c7 01       	movw	r24, r14
    588e:	b6 01       	movw	r22, r12
    5890:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5894:	9b 01       	movw	r18, r22
    5896:	ac 01       	movw	r20, r24
    5898:	6f 8d       	ldd	r22, Y+31	; 0x1f
    589a:	7d a1       	ldd	r23, Y+37	; 0x25
    589c:	8e a1       	ldd	r24, Y+38	; 0x26
    589e:	9f a1       	ldd	r25, Y+39	; 0x27
    58a0:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    58a4:	6f 8f       	std	Y+31, r22	; 0x1f
    58a6:	7d a3       	std	Y+37, r23	; 0x25
    58a8:	8e a3       	std	Y+38, r24	; 0x26
    58aa:	9f a3       	std	Y+39, r25	; 0x27
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    58ac:	29 a0       	ldd	r2, Y+33	; 0x21
    58ae:	3a a0       	ldd	r3, Y+34	; 0x22
    58b0:	4b a0       	ldd	r4, Y+35	; 0x23
    58b2:	5c a0       	ldd	r5, Y+36	; 0x24
    58b4:	0c 5f       	subi	r16, 0xFC	; 252
    58b6:	1f 4f       	sbci	r17, 0xFF	; 255
    58b8:	4d 8d       	ldd	r20, Y+29	; 0x1d
    58ba:	5e 8d       	ldd	r21, Y+30	; 0x1e
    58bc:	4c 5f       	subi	r20, 0xFC	; 252
    58be:	5f 4f       	sbci	r21, 0xFF	; 255
    58c0:	5e 8f       	std	Y+30, r21	; 0x1e
    58c2:	4d 8f       	std	Y+29, r20	; 0x1d
    58c4:	54 e0       	ldi	r21, 0x04	; 4
    58c6:	65 0e       	add	r6, r21
    58c8:	71 1c       	adc	r7, r1
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    58ca:	89 8d       	ldd	r24, Y+25	; 0x19
    58cc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    58ce:	08 17       	cp	r16, r24
    58d0:	19 07       	cpc	r17, r25
    58d2:	09 f0       	breq	.+2      	; 0x58d6 <plan_buffer_line+0x3be>
    58d4:	62 cf       	rjmp	.-316    	; 0x579a <plan_buffer_line+0x282>
    58d6:	29 a2       	std	Y+33, r2	; 0x21
    58d8:	3a a2       	std	Y+34, r3	; 0x22
    58da:	2b 8c       	ldd	r2, Y+27	; 0x1b
    58dc:	3c 8c       	ldd	r3, Y+28	; 0x1c
    58de:	4b a2       	std	Y+35, r4	; 0x23
    58e0:	5c a2       	std	Y+36, r5	; 0x24
    58e2:	ef 8c       	ldd	r14, Y+31	; 0x1f
    58e4:	fd a0       	ldd	r15, Y+37	; 0x25
    58e6:	0e a1       	ldd	r16, Y+38	; 0x26
    58e8:	1f a1       	ldd	r17, Y+39	; 0x27
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    }
  }
  
  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if (block_buffer_head == block_buffer_tail) {
    58ea:	90 91 45 02 	lds	r25, 0x0245
    58ee:	80 91 46 02 	lds	r24, 0x0246
    58f2:	98 13       	cpse	r25, r24
    58f4:	0a c0       	rjmp	.+20     	; 0x590a <plan_buffer_line+0x3f2>
  
    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    block->entry_speed_sqr = 0.0;
    58f6:	f1 01       	movw	r30, r2
    58f8:	11 8a       	std	Z+17, r1	; 0x11
    58fa:	12 8a       	std	Z+18, r1	; 0x12
    58fc:	13 8a       	std	Z+19, r1	; 0x13
    58fe:	14 8a       	std	Z+20, r1	; 0x14
    block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
    5900:	11 8e       	std	Z+25, r1	; 0x19
    5902:	12 8e       	std	Z+26, r1	; 0x1a
    5904:	13 8e       	std	Z+27, r1	; 0x1b
    5906:	14 8e       	std	Z+28, r1	; 0x1c
    5908:	75 c0       	rjmp	.+234    	; 0x59f4 <plan_buffer_line+0x4dc>
       changed dynamically during operation nor can the line move geometry. This must be kept in
       memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
       change the overall maximum entry speed conditions of all blocks.
    */
    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.99) {
    590a:	24 ea       	ldi	r18, 0xA4	; 164
    590c:	30 e7       	ldi	r19, 0x70	; 112
    590e:	4d e7       	ldi	r20, 0x7D	; 125
    5910:	5f e3       	ldi	r21, 0x3F	; 63
    5912:	6f 8d       	ldd	r22, Y+31	; 0x1f
    5914:	7d a1       	ldd	r23, Y+37	; 0x25
    5916:	8e a1       	ldd	r24, Y+38	; 0x26
    5918:	9f a1       	ldd	r25, Y+39	; 0x27
    591a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    591e:	18 16       	cp	r1, r24
    5920:	34 f4       	brge	.+12     	; 0x592e <plan_buffer_line+0x416>
      //  For a 0 degree acute junction, just set minimum junction speed. 
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
    5922:	f1 01       	movw	r30, r2
    5924:	11 8e       	std	Z+25, r1	; 0x19
    5926:	12 8e       	std	Z+26, r1	; 0x1a
    5928:	13 8e       	std	Z+27, r1	; 0x1b
    592a:	14 8e       	std	Z+28, r1	; 0x1c
    592c:	63 c0       	rjmp	.+198    	; 0x59f4 <plan_buffer_line+0x4dc>
    } else {
      junction_cos_theta = max(junction_cos_theta,-0.99); // Check for numerical round-off to avoid divide by zero.
    592e:	24 ea       	ldi	r18, 0xA4	; 164
    5930:	30 e7       	ldi	r19, 0x70	; 112
    5932:	4d e7       	ldi	r20, 0x7D	; 125
    5934:	5f eb       	ldi	r21, 0xBF	; 191
    5936:	6e 2d       	mov	r22, r14
    5938:	7f 2d       	mov	r23, r15
    593a:	80 2f       	mov	r24, r16
    593c:	91 2f       	mov	r25, r17
    593e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    5942:	18 16       	cp	r1, r24
    5944:	44 f0       	brlt	.+16     	; 0x5956 <plan_buffer_line+0x43e>
    5946:	f4 ea       	ldi	r31, 0xA4	; 164
    5948:	ff 8f       	std	Y+31, r31	; 0x1f
    594a:	20 e7       	ldi	r18, 0x70	; 112
    594c:	2d a3       	std	Y+37, r18	; 0x25
    594e:	4d e7       	ldi	r20, 0x7D	; 125
    5950:	4e a3       	std	Y+38, r20	; 0x26
    5952:	5f eb       	ldi	r21, 0xBF	; 191
    5954:	5f a3       	std	Y+39, r21	; 0x27
      float sin_theta_d2 = sqrt(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Always positive.
    5956:	2f 8d       	ldd	r18, Y+31	; 0x1f
    5958:	3d a1       	ldd	r19, Y+37	; 0x25
    595a:	4e a1       	ldd	r20, Y+38	; 0x26
    595c:	5f a1       	ldd	r21, Y+39	; 0x27
    595e:	60 e0       	ldi	r22, 0x00	; 0
    5960:	70 e0       	ldi	r23, 0x00	; 0
    5962:	80 e8       	ldi	r24, 0x80	; 128
    5964:	9f e3       	ldi	r25, 0x3F	; 63
    5966:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    596a:	20 e0       	ldi	r18, 0x00	; 0
    596c:	30 e0       	ldi	r19, 0x00	; 0
    596e:	40 e0       	ldi	r20, 0x00	; 0
    5970:	5f e3       	ldi	r21, 0x3F	; 63
    5972:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5976:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    597a:	6b 01       	movw	r12, r22
    597c:	7c 01       	movw	r14, r24

      // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
      // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
      block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
    597e:	20 91 34 09 	lds	r18, 0x0934
    5982:	30 91 35 09 	lds	r19, 0x0935
    5986:	40 91 36 09 	lds	r20, 0x0936
    598a:	50 91 37 09 	lds	r21, 0x0937
    598e:	f1 01       	movw	r30, r2
    5990:	61 a1       	ldd	r22, Z+33	; 0x21
    5992:	72 a1       	ldd	r23, Z+34	; 0x22
    5994:	83 a1       	ldd	r24, Z+35	; 0x23
    5996:	94 a1       	ldd	r25, Z+36	; 0x24
    5998:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    599c:	a7 01       	movw	r20, r14
    599e:	96 01       	movw	r18, r12
    59a0:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    59a4:	4b 01       	movw	r8, r22
    59a6:	5c 01       	movw	r10, r24
    59a8:	a7 01       	movw	r20, r14
    59aa:	96 01       	movw	r18, r12
    59ac:	60 e0       	ldi	r22, 0x00	; 0
    59ae:	70 e0       	ldi	r23, 0x00	; 0
    59b0:	80 e8       	ldi	r24, 0x80	; 128
    59b2:	9f e3       	ldi	r25, 0x3F	; 63
    59b4:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    59b8:	9b 01       	movw	r18, r22
    59ba:	ac 01       	movw	r20, r24
    59bc:	c5 01       	movw	r24, r10
    59be:	b4 01       	movw	r22, r8
    59c0:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    59c4:	e6 2e       	mov	r14, r22
    59c6:	f7 2e       	mov	r15, r23
    59c8:	08 2f       	mov	r16, r24
    59ca:	19 2f       	mov	r17, r25
    59cc:	20 e0       	ldi	r18, 0x00	; 0
    59ce:	30 e0       	ldi	r19, 0x00	; 0
    59d0:	a9 01       	movw	r20, r18
    59d2:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    59d6:	88 23       	and	r24, r24
    59d8:	24 f4       	brge	.+8      	; 0x59e2 <plan_buffer_line+0x4ca>
    59da:	e1 2c       	mov	r14, r1
    59dc:	f1 2c       	mov	r15, r1
    59de:	00 e0       	ldi	r16, 0x00	; 0
    59e0:	10 e0       	ldi	r17, 0x00	; 0
    59e2:	4e 2d       	mov	r20, r14
    59e4:	5f 2d       	mov	r21, r15
    59e6:	60 2f       	mov	r22, r16
    59e8:	71 2f       	mov	r23, r17
    59ea:	f1 01       	movw	r30, r2
    59ec:	41 8f       	std	Z+25, r20	; 0x19
    59ee:	52 8f       	std	Z+26, r21	; 0x1a
    59f0:	63 8f       	std	Z+27, r22	; 0x1b
    59f2:	74 8f       	std	Z+28, r23	; 0x1c

    }
  }

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
    59f4:	29 a1       	ldd	r18, Y+33	; 0x21
    59f6:	3a a1       	ldd	r19, Y+34	; 0x22
    59f8:	4b a1       	ldd	r20, Y+35	; 0x23
    59fa:	5c a1       	ldd	r21, Y+36	; 0x24
    59fc:	69 a1       	ldd	r22, Y+33	; 0x21
    59fe:	7a a1       	ldd	r23, Y+34	; 0x22
    5a00:	8b a1       	ldd	r24, Y+35	; 0x23
    5a02:	9c a1       	ldd	r25, Y+36	; 0x24
    5a04:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5a08:	16 2f       	mov	r17, r22
    5a0a:	07 2f       	mov	r16, r23
    5a0c:	f8 2e       	mov	r15, r24
    5a0e:	e9 2e       	mov	r14, r25
    5a10:	86 2f       	mov	r24, r22
    5a12:	90 2f       	mov	r25, r16
    5a14:	af 2d       	mov	r26, r15
    5a16:	be 2d       	mov	r27, r14
    5a18:	f1 01       	movw	r30, r2
    5a1a:	85 8f       	std	Z+29, r24	; 0x1d
    5a1c:	96 8f       	std	Z+30, r25	; 0x1e
    5a1e:	a7 8f       	std	Z+31, r26	; 0x1f
    5a20:	b0 a3       	std	Z+32, r27	; 0x20
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    5a22:	91 8c       	ldd	r9, Z+25	; 0x19
    5a24:	82 8c       	ldd	r8, Z+26	; 0x1a
    5a26:	73 8c       	ldd	r7, Z+27	; 0x1b
    5a28:	64 8c       	ldd	r6, Z+28	; 0x1c
    5a2a:	a0 90 3f 02 	lds	r10, 0x023F
    5a2e:	b0 90 40 02 	lds	r11, 0x0240
    5a32:	c0 90 41 02 	lds	r12, 0x0241
    5a36:	d0 90 42 02 	lds	r13, 0x0242
    5a3a:	2a 2d       	mov	r18, r10
    5a3c:	3b 2d       	mov	r19, r11
    5a3e:	4c 2d       	mov	r20, r12
    5a40:	5d 2d       	mov	r21, r13
    5a42:	61 2f       	mov	r22, r17
    5a44:	70 2f       	mov	r23, r16
    5a46:	8f 2d       	mov	r24, r15
    5a48:	9e 2d       	mov	r25, r14
    5a4a:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5a4e:	88 23       	and	r24, r24
    5a50:	0c f4       	brge	.+2      	; 0x5a54 <plan_buffer_line+0x53c>
    5a52:	55 c0       	rjmp	.+170    	; 0x5afe <plan_buffer_line+0x5e6>
    5a54:	2a 2d       	mov	r18, r10
    5a56:	3b 2d       	mov	r19, r11
    5a58:	4c 2d       	mov	r20, r12
    5a5a:	5d 2d       	mov	r21, r13
    5a5c:	69 2d       	mov	r22, r9
    5a5e:	78 2d       	mov	r23, r8
    5a60:	87 2d       	mov	r24, r7
    5a62:	96 2d       	mov	r25, r6
    5a64:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5a68:	88 23       	and	r24, r24
    5a6a:	ac f0       	brlt	.+42     	; 0x5a96 <plan_buffer_line+0x57e>
    5a6c:	2a 2d       	mov	r18, r10
    5a6e:	3b 2d       	mov	r19, r11
    5a70:	4c 2d       	mov	r20, r12
    5a72:	5d 2d       	mov	r21, r13
    5a74:	61 2f       	mov	r22, r17
    5a76:	70 2f       	mov	r23, r16
    5a78:	8f 2d       	mov	r24, r15
    5a7a:	9e 2d       	mov	r25, r14
    5a7c:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5a80:	88 23       	and	r24, r24
    5a82:	2c f4       	brge	.+10     	; 0x5a8e <plan_buffer_line+0x576>
    5a84:	91 2e       	mov	r9, r17
    5a86:	80 2e       	mov	r8, r16
    5a88:	7f 2c       	mov	r7, r15
    5a8a:	6e 2c       	mov	r6, r14
    5a8c:	04 c0       	rjmp	.+8      	; 0x5a96 <plan_buffer_line+0x57e>
    5a8e:	9a 2c       	mov	r9, r10
    5a90:	8b 2c       	mov	r8, r11
    5a92:	7c 2c       	mov	r7, r12
    5a94:	6d 2c       	mov	r6, r13
    5a96:	89 2d       	mov	r24, r9
    5a98:	98 2d       	mov	r25, r8
    5a9a:	a7 2d       	mov	r26, r7
    5a9c:	b6 2d       	mov	r27, r6
    5a9e:	f1 01       	movw	r30, r2
    5aa0:	85 8b       	std	Z+21, r24	; 0x15
    5aa2:	96 8b       	std	Z+22, r25	; 0x16
    5aa4:	a7 8b       	std	Z+23, r26	; 0x17
    5aa6:	b0 8f       	std	Z+24, r27	; 0x18
                                   min(block->nominal_speed_sqr,pl.previous_nominal_speed_sqr));
  
  // Update previous path unit_vector and nominal speed (squared)
  memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
    5aa8:	8c e0       	ldi	r24, 0x0C	; 12
    5aaa:	fe 01       	movw	r30, r28
    5aac:	3d 96       	adiw	r30, 0x0d	; 13
    5aae:	a3 e3       	ldi	r26, 0x33	; 51
    5ab0:	b2 e0       	ldi	r27, 0x02	; 2
    5ab2:	01 90       	ld	r0, Z+
    5ab4:	0d 92       	st	X+, r0
    5ab6:	8a 95       	dec	r24
    5ab8:	e1 f7       	brne	.-8      	; 0x5ab2 <plan_buffer_line+0x59a>
  pl.previous_nominal_speed_sqr = block->nominal_speed_sqr;
    5aba:	81 2f       	mov	r24, r17
    5abc:	90 2f       	mov	r25, r16
    5abe:	af 2d       	mov	r26, r15
    5ac0:	be 2d       	mov	r27, r14
    5ac2:	80 93 3f 02 	sts	0x023F, r24
    5ac6:	90 93 40 02 	sts	0x0240, r25
    5aca:	a0 93 41 02 	sts	0x0241, r26
    5ace:	b0 93 42 02 	sts	0x0242, r27
    
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
    5ad2:	8c e0       	ldi	r24, 0x0C	; 12
    5ad4:	fe 01       	movw	r30, r28
    5ad6:	31 96       	adiw	r30, 0x01	; 1
    5ad8:	a7 e2       	ldi	r26, 0x27	; 39
    5ada:	b2 e0       	ldi	r27, 0x02	; 2
    5adc:	01 90       	ld	r0, Z+
    5ade:	0d 92       	st	X+, r0
    5ae0:	8a 95       	dec	r24
    5ae2:	e1 f7       	brne	.-8      	; 0x5adc <plan_buffer_line+0x5c4>

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
    5ae4:	80 91 44 02 	lds	r24, 0x0244
    5ae8:	80 93 45 02 	sts	0x0245, r24


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    5aec:	8f 5f       	subi	r24, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    5aee:	80 32       	cpi	r24, 0x20	; 32
    5af0:	09 f4       	brne	.+2      	; 0x5af4 <plan_buffer_line+0x5dc>
    5af2:	80 e0       	ldi	r24, 0x00	; 0
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
    5af4:	80 93 44 02 	sts	0x0244, r24
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
    5af8:	0e 94 04 29 	call	0x5208	; 0x5208 <planner_recalculate>
    5afc:	0e c0       	rjmp	.+28     	; 0x5b1a <plan_buffer_line+0x602>

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    5afe:	29 2d       	mov	r18, r9
    5b00:	38 2d       	mov	r19, r8
    5b02:	47 2d       	mov	r20, r7
    5b04:	56 2d       	mov	r21, r6
    5b06:	61 2f       	mov	r22, r17
    5b08:	70 2f       	mov	r23, r16
    5b0a:	8f 2d       	mov	r24, r15
    5b0c:	9e 2d       	mov	r25, r14
    5b0e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    5b12:	18 16       	cp	r1, r24
    5b14:	0c f0       	brlt	.+2      	; 0x5b18 <plan_buffer_line+0x600>
    5b16:	b6 cf       	rjmp	.-148    	; 0x5a84 <plan_buffer_line+0x56c>
    5b18:	be cf       	rjmp	.-132    	; 0x5a96 <plan_buffer_line+0x57e>
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
}
    5b1a:	ad 96       	adiw	r28, 0x2d	; 45
    5b1c:	0f b6       	in	r0, 0x3f	; 63
    5b1e:	f8 94       	cli
    5b20:	de bf       	out	0x3e, r29	; 62
    5b22:	0f be       	out	0x3f, r0	; 63
    5b24:	cd bf       	out	0x3d, r28	; 61
    5b26:	df 91       	pop	r29
    5b28:	cf 91       	pop	r28
    5b2a:	1f 91       	pop	r17
    5b2c:	0f 91       	pop	r16
    5b2e:	ff 90       	pop	r15
    5b30:	ef 90       	pop	r14
    5b32:	df 90       	pop	r13
    5b34:	cf 90       	pop	r12
    5b36:	bf 90       	pop	r11
    5b38:	af 90       	pop	r10
    5b3a:	9f 90       	pop	r9
    5b3c:	8f 90       	pop	r8
    5b3e:	7f 90       	pop	r7
    5b40:	6f 90       	pop	r6
    5b42:	5f 90       	pop	r5
    5b44:	4f 90       	pop	r4
    5b46:	3f 90       	pop	r3
    5b48:	2f 90       	pop	r2
    5b4a:	08 95       	ret

00005b4c <plan_sync_position>:
        pl.position[idx] = (sys.position[A_MOTOR] - sys.position[B_MOTOR])/2;
      } else {
        pl.position[idx] = sys.position[idx];
      }
    #else
      pl.position[idx] = sys.position[idx];
    5b4c:	80 91 6c 07 	lds	r24, 0x076C
    5b50:	90 91 6d 07 	lds	r25, 0x076D
    5b54:	a0 91 6e 07 	lds	r26, 0x076E
    5b58:	b0 91 6f 07 	lds	r27, 0x076F
    5b5c:	80 93 27 02 	sts	0x0227, r24
    5b60:	90 93 28 02 	sts	0x0228, r25
    5b64:	a0 93 29 02 	sts	0x0229, r26
    5b68:	b0 93 2a 02 	sts	0x022A, r27
    5b6c:	80 91 70 07 	lds	r24, 0x0770
    5b70:	90 91 71 07 	lds	r25, 0x0771
    5b74:	a0 91 72 07 	lds	r26, 0x0772
    5b78:	b0 91 73 07 	lds	r27, 0x0773
    5b7c:	80 93 2b 02 	sts	0x022B, r24
    5b80:	90 93 2c 02 	sts	0x022C, r25
    5b84:	a0 93 2d 02 	sts	0x022D, r26
    5b88:	b0 93 2e 02 	sts	0x022E, r27
    5b8c:	80 91 74 07 	lds	r24, 0x0774
    5b90:	90 91 75 07 	lds	r25, 0x0775
    5b94:	a0 91 76 07 	lds	r26, 0x0776
    5b98:	b0 91 77 07 	lds	r27, 0x0777
    5b9c:	80 93 2f 02 	sts	0x022F, r24
    5ba0:	90 93 30 02 	sts	0x0230, r25
    5ba4:	a0 93 31 02 	sts	0x0231, r26
    5ba8:	b0 93 32 02 	sts	0x0232, r27
    5bac:	08 95       	ret

00005bae <plan_get_block_buffer_count>:


// Returns the number of active blocks are in the planner buffer.
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
    5bae:	80 91 45 02 	lds	r24, 0x0245
    5bb2:	90 91 46 02 	lds	r25, 0x0246
    5bb6:	89 17       	cp	r24, r25
    5bb8:	10 f0       	brcs	.+4      	; 0x5bbe <plan_get_block_buffer_count+0x10>
    5bba:	89 1b       	sub	r24, r25
    5bbc:	08 95       	ret
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
    5bbe:	80 5e       	subi	r24, 0xE0	; 224
    5bc0:	89 1b       	sub	r24, r25
}
    5bc2:	08 95       	ret

00005bc4 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    5bc4:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    5bc8:	80 91 46 02 	lds	r24, 0x0246
    5bcc:	80 93 43 02 	sts	0x0243, r24
  planner_recalculate();  
    5bd0:	0e 94 04 29 	call	0x5208	; 0x5208 <planner_recalculate>
    5bd4:	08 95       	ret

00005bd6 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized. 
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
uint8_t read_float(char *line, uint8_t *char_counter, float *float_ptr)                  
{
    5bd6:	4f 92       	push	r4
    5bd8:	5f 92       	push	r5
    5bda:	6f 92       	push	r6
    5bdc:	7f 92       	push	r7
    5bde:	9f 92       	push	r9
    5be0:	af 92       	push	r10
    5be2:	bf 92       	push	r11
    5be4:	cf 92       	push	r12
    5be6:	df 92       	push	r13
    5be8:	ef 92       	push	r14
    5bea:	ff 92       	push	r15
    5bec:	0f 93       	push	r16
    5bee:	1f 93       	push	r17
    5bf0:	cf 93       	push	r28
    5bf2:	df 93       	push	r29
    5bf4:	7c 01       	movw	r14, r24
    5bf6:	8b 01       	movw	r16, r22
    5bf8:	6a 01       	movw	r12, r20
  char *ptr = line + *char_counter;
    5bfa:	fb 01       	movw	r30, r22
    5bfc:	80 81       	ld	r24, Z
    5bfe:	f7 01       	movw	r30, r14
    5c00:	e8 0f       	add	r30, r24
    5c02:	f1 1d       	adc	r31, r1
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
    5c04:	40 81       	ld	r20, Z
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    5c06:	4d 32       	cpi	r20, 0x2D	; 45
    5c08:	39 f4       	brne	.+14     	; 0x5c18 <read_float+0x42>
    isnegative = true;
    c = *ptr++;
    5c0a:	9f 01       	movw	r18, r30
    5c0c:	2e 5f       	subi	r18, 0xFE	; 254
    5c0e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c10:	41 81       	ldd	r20, Z+1	; 0x01
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    isnegative = true;
    5c12:	aa 24       	eor	r10, r10
    5c14:	a3 94       	inc	r10
    5c16:	0c c0       	rjmp	.+24     	; 0x5c30 <read_float+0x5a>
    c = *ptr++;
  } else if (c == '+') {
    5c18:	4b 32       	cpi	r20, 0x2B	; 43
    5c1a:	29 f0       	breq	.+10     	; 0x5c26 <read_float+0x50>
{
  char *ptr = line + *char_counter;
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
    5c1c:	9f 01       	movw	r18, r30
    5c1e:	2f 5f       	subi	r18, 0xFF	; 255
    5c20:	3f 4f       	sbci	r19, 0xFF	; 255
  
  // Capture initial positive/minus character
  bool isnegative = false;
    5c22:	a1 2c       	mov	r10, r1
    5c24:	05 c0       	rjmp	.+10     	; 0x5c30 <read_float+0x5a>
  if (c == '-') {
    isnegative = true;
    c = *ptr++;
  } else if (c == '+') {
    c = *ptr++;
    5c26:	9f 01       	movw	r18, r30
    5c28:	2e 5f       	subi	r18, 0xFE	; 254
    5c2a:	3f 4f       	sbci	r19, 0xFF	; 255
    5c2c:	41 81       	ldd	r20, Z+1	; 0x01
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
    5c2e:	a1 2c       	mov	r10, r1
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
    5c30:	e0 e0       	ldi	r30, 0x00	; 0
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
    5c32:	50 e0       	ldi	r21, 0x00	; 0
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
    5c34:	b1 2c       	mov	r11, r1
  } else if (c == '+') {
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
    5c36:	60 e0       	ldi	r22, 0x00	; 0
    5c38:	70 e0       	ldi	r23, 0x00	; 0
    5c3a:	cb 01       	movw	r24, r22
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
      isdecimal = true;
    5c3c:	f1 e0       	ldi	r31, 0x01	; 1
    5c3e:	e9 01       	movw	r28, r18
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
  while(1) {
    c -= '0';
    5c40:	40 53       	subi	r20, 0x30	; 48
    if (c <= 9) {
    5c42:	4a 30       	cpi	r20, 0x0A	; 10
    5c44:	20 f5       	brcc	.+72     	; 0x5c8e <read_float+0xb8>
      ndigit++;
    5c46:	5f 5f       	subi	r21, 0xFF	; 255
      if (ndigit <= MAX_INT_DIGITS) {
    5c48:	59 30       	cpi	r21, 0x09	; 9
    5c4a:	e8 f4       	brcc	.+58     	; 0x5c86 <read_float+0xb0>
        if (isdecimal) { exp--; }
    5c4c:	e1 11       	cpse	r30, r1
    5c4e:	ba 94       	dec	r11
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
    5c50:	2b 01       	movw	r4, r22
    5c52:	3c 01       	movw	r6, r24
    5c54:	44 0c       	add	r4, r4
    5c56:	55 1c       	adc	r5, r5
    5c58:	66 1c       	adc	r6, r6
    5c5a:	77 1c       	adc	r7, r7
    5c5c:	44 0c       	add	r4, r4
    5c5e:	55 1c       	adc	r5, r5
    5c60:	66 1c       	adc	r6, r6
    5c62:	77 1c       	adc	r7, r7
    5c64:	dc 01       	movw	r26, r24
    5c66:	cb 01       	movw	r24, r22
    5c68:	84 0d       	add	r24, r4
    5c6a:	95 1d       	adc	r25, r5
    5c6c:	a6 1d       	adc	r26, r6
    5c6e:	b7 1d       	adc	r27, r7
    5c70:	88 0f       	add	r24, r24
    5c72:	99 1f       	adc	r25, r25
    5c74:	aa 1f       	adc	r26, r26
    5c76:	bb 1f       	adc	r27, r27
    5c78:	bc 01       	movw	r22, r24
    5c7a:	cd 01       	movw	r24, r26
    5c7c:	64 0f       	add	r22, r20
    5c7e:	71 1d       	adc	r23, r1
    5c80:	81 1d       	adc	r24, r1
    5c82:	91 1d       	adc	r25, r1
    5c84:	09 c0       	rjmp	.+18     	; 0x5c98 <read_float+0xc2>
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
    5c86:	e1 11       	cpse	r30, r1
    5c88:	07 c0       	rjmp	.+14     	; 0x5c98 <read_float+0xc2>
    5c8a:	b3 94       	inc	r11
    5c8c:	05 c0       	rjmp	.+10     	; 0x5c98 <read_float+0xc2>
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
    5c8e:	4e 3f       	cpi	r20, 0xFE	; 254
    5c90:	39 f4       	brne	.+14     	; 0x5ca0 <read_float+0xca>
    5c92:	e1 11       	cpse	r30, r1
    5c94:	07 c0       	rjmp	.+14     	; 0x5ca4 <read_float+0xce>
      isdecimal = true;
    5c96:	ef 2f       	mov	r30, r31
    } else {
      break;
    }
    c = *ptr++;
    5c98:	48 81       	ld	r20, Y
    5c9a:	2f 5f       	subi	r18, 0xFF	; 255
    5c9c:	3f 4f       	sbci	r19, 0xFF	; 255
  }
    5c9e:	cf cf       	rjmp	.-98     	; 0x5c3e <read_float+0x68>
    5ca0:	9b 2c       	mov	r9, r11
    5ca2:	01 c0       	rjmp	.+2      	; 0x5ca6 <read_float+0xd0>
    5ca4:	9b 2c       	mov	r9, r11
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
    5ca6:	55 23       	and	r21, r21
    5ca8:	09 f4       	brne	.+2      	; 0x5cac <read_float+0xd6>
    5caa:	50 c0       	rjmp	.+160    	; 0x5d4c <read_float+0x176>
  
  // Convert integer into floating point.
  float fval;
  fval = (float)intval;
    5cac:	0e 94 2c 3d 	call	0x7a58	; 0x7a58 <__floatunsisf>
    5cb0:	2b 01       	movw	r4, r22
    5cb2:	3c 01       	movw	r6, r24
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    5cb4:	20 e0       	ldi	r18, 0x00	; 0
    5cb6:	30 e0       	ldi	r19, 0x00	; 0
    5cb8:	a9 01       	movw	r20, r18
    5cba:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5cbe:	88 23       	and	r24, r24
    5cc0:	69 f1       	breq	.+90     	; 0x5d1c <read_float+0x146>
    while (exp <= -2) {
    5cc2:	ff ef       	ldi	r31, 0xFF	; 255
    5cc4:	9f 16       	cp	r9, r31
    5cc6:	7c f4       	brge	.+30     	; 0x5ce6 <read_float+0x110>
      fval *= 0.01; 
    5cc8:	2a e0       	ldi	r18, 0x0A	; 10
    5cca:	37 ed       	ldi	r19, 0xD7	; 215
    5ccc:	43 e2       	ldi	r20, 0x23	; 35
    5cce:	5c e3       	ldi	r21, 0x3C	; 60
    5cd0:	c3 01       	movw	r24, r6
    5cd2:	b2 01       	movw	r22, r4
    5cd4:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5cd8:	2b 01       	movw	r4, r22
    5cda:	3c 01       	movw	r6, r24
    5cdc:	b3 94       	inc	r11
    5cde:	b3 94       	inc	r11
  fval = (float)intval;
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    while (exp <= -2) {
    5ce0:	8f ef       	ldi	r24, 0xFF	; 255
    5ce2:	b8 16       	cp	r11, r24
    5ce4:	8c f3       	brlt	.-30     	; 0x5cc8 <read_float+0xf2>
      fval *= 0.01; 
      exp += 2;
    }
    if (exp < 0) { 
    5ce6:	bb 20       	and	r11, r11
    5ce8:	5c f4       	brge	.+22     	; 0x5d00 <read_float+0x12a>
      fval *= 0.1; 
    5cea:	2d ec       	ldi	r18, 0xCD	; 205
    5cec:	3c ec       	ldi	r19, 0xCC	; 204
    5cee:	4c ec       	ldi	r20, 0xCC	; 204
    5cf0:	5d e3       	ldi	r21, 0x3D	; 61
    5cf2:	c3 01       	movw	r24, r6
    5cf4:	b2 01       	movw	r22, r4
    5cf6:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5cfa:	2b 01       	movw	r4, r22
    5cfc:	3c 01       	movw	r6, r24
    5cfe:	0e c0       	rjmp	.+28     	; 0x5d1c <read_float+0x146>
    } else if (exp > 0) {
    5d00:	1b 14       	cp	r1, r11
    5d02:	64 f4       	brge	.+24     	; 0x5d1c <read_float+0x146>
      do {
        fval *= 10.0;
    5d04:	20 e0       	ldi	r18, 0x00	; 0
    5d06:	30 e0       	ldi	r19, 0x00	; 0
    5d08:	40 e2       	ldi	r20, 0x20	; 32
    5d0a:	51 e4       	ldi	r21, 0x41	; 65
    5d0c:	c3 01       	movw	r24, r6
    5d0e:	b2 01       	movw	r22, r4
    5d10:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5d14:	2b 01       	movw	r4, r22
    5d16:	3c 01       	movw	r6, r24
      } while (--exp > 0);
    5d18:	ba 94       	dec	r11
    5d1a:	a1 f7       	brne	.-24     	; 0x5d04 <read_float+0x12e>
    } 
  }

  // Assign floating point value with correct sign.    
  if (isnegative) {
    5d1c:	aa 20       	and	r10, r10
    5d1e:	51 f0       	breq	.+20     	; 0x5d34 <read_float+0x15e>
    *float_ptr = -fval;
    5d20:	77 fa       	bst	r7, 7
    5d22:	70 94       	com	r7
    5d24:	77 f8       	bld	r7, 7
    5d26:	70 94       	com	r7
    5d28:	f6 01       	movw	r30, r12
    5d2a:	40 82       	st	Z, r4
    5d2c:	51 82       	std	Z+1, r5	; 0x01
    5d2e:	62 82       	std	Z+2, r6	; 0x02
    5d30:	73 82       	std	Z+3, r7	; 0x03
    5d32:	05 c0       	rjmp	.+10     	; 0x5d3e <read_float+0x168>
  } else {
    *float_ptr = fval;
    5d34:	f6 01       	movw	r30, r12
    5d36:	40 82       	st	Z, r4
    5d38:	51 82       	std	Z+1, r5	; 0x01
    5d3a:	62 82       	std	Z+2, r6	; 0x02
    5d3c:	73 82       	std	Z+3, r7	; 0x03
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
    5d3e:	ce 19       	sub	r28, r14
    5d40:	df 09       	sbc	r29, r15
    5d42:	c1 50       	subi	r28, 0x01	; 1
    5d44:	f8 01       	movw	r30, r16
    5d46:	c0 83       	st	Z, r28
  
  return(true);
    5d48:	81 e0       	ldi	r24, 0x01	; 1
    5d4a:	01 c0       	rjmp	.+2      	; 0x5d4e <read_float+0x178>
    }
    c = *ptr++;
  }
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
    5d4c:	80 e0       	ldi	r24, 0x00	; 0
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
  
  return(true);
}
    5d4e:	df 91       	pop	r29
    5d50:	cf 91       	pop	r28
    5d52:	1f 91       	pop	r17
    5d54:	0f 91       	pop	r16
    5d56:	ff 90       	pop	r15
    5d58:	ef 90       	pop	r14
    5d5a:	df 90       	pop	r13
    5d5c:	cf 90       	pop	r12
    5d5e:	bf 90       	pop	r11
    5d60:	af 90       	pop	r10
    5d62:	9f 90       	pop	r9
    5d64:	7f 90       	pop	r7
    5d66:	6f 90       	pop	r6
    5d68:	5f 90       	pop	r5
    5d6a:	4f 90       	pop	r4
    5d6c:	08 95       	ret

00005d6e <delay_ms>:

// Delays variable defined milliseconds. Compiler compatibility fix for _delay_ms(),
// which only accepts constants in future compiler releases.
void delay_ms(uint16_t ms) 
{
  while ( ms-- ) { _delay_ms(1); }
    5d6e:	00 97       	sbiw	r24, 0x00	; 0
    5d70:	49 f0       	breq	.+18     	; 0x5d84 <delay_ms+0x16>
    5d72:	ef ef       	ldi	r30, 0xFF	; 255
    5d74:	f1 e1       	ldi	r31, 0x11	; 17
    5d76:	31 97       	sbiw	r30, 0x01	; 1
    5d78:	f1 f7       	brne	.-4      	; 0x5d76 <delay_ms+0x8>
    5d7a:	00 c0       	rjmp	.+0      	; 0x5d7c <delay_ms+0xe>
    5d7c:	00 00       	nop
    5d7e:	01 97       	sbiw	r24, 0x01	; 1
    5d80:	00 97       	sbiw	r24, 0x00	; 0
    5d82:	b9 f7       	brne	.-18     	; 0x5d72 <delay_ms+0x4>
    5d84:	08 95       	ret

00005d86 <delay_us>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    5d86:	61 15       	cp	r22, r1
    5d88:	71 05       	cpc	r23, r1
    5d8a:	81 05       	cpc	r24, r1
    5d8c:	91 05       	cpc	r25, r1
    5d8e:	e1 f1       	breq	.+120    	; 0x5e08 <delay_us+0x82>
    if (us < 10) { 
    5d90:	6a 30       	cpi	r22, 0x0A	; 10
    5d92:	71 05       	cpc	r23, r1
    5d94:	81 05       	cpc	r24, r1
    5d96:	91 05       	cpc	r25, r1
    5d98:	48 f4       	brcc	.+18     	; 0x5dac <delay_us+0x26>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5d9a:	26 e0       	ldi	r18, 0x06	; 6
    5d9c:	2a 95       	dec	r18
    5d9e:	f1 f7       	brne	.-4      	; 0x5d9c <delay_us+0x16>
    5da0:	00 00       	nop
      _delay_us(1);
      us--;
    5da2:	61 50       	subi	r22, 0x01	; 1
    5da4:	71 09       	sbc	r23, r1
    5da6:	81 09       	sbc	r24, r1
    5da8:	91 09       	sbc	r25, r1
    5daa:	29 c0       	rjmp	.+82     	; 0x5dfe <delay_us+0x78>
    } else if (us < 100) {
    5dac:	64 36       	cpi	r22, 0x64	; 100
    5dae:	71 05       	cpc	r23, r1
    5db0:	81 05       	cpc	r24, r1
    5db2:	91 05       	cpc	r25, r1
    5db4:	48 f4       	brcc	.+18     	; 0x5dc8 <delay_us+0x42>
    5db6:	ed e3       	ldi	r30, 0x3D	; 61
    5db8:	ea 95       	dec	r30
    5dba:	f1 f7       	brne	.-4      	; 0x5db8 <delay_us+0x32>
    5dbc:	00 c0       	rjmp	.+0      	; 0x5dbe <delay_us+0x38>
      _delay_us(10);
      us -= 10;
    5dbe:	6a 50       	subi	r22, 0x0A	; 10
    5dc0:	71 09       	sbc	r23, r1
    5dc2:	81 09       	sbc	r24, r1
    5dc4:	91 09       	sbc	r25, r1
    5dc6:	1b c0       	rjmp	.+54     	; 0x5dfe <delay_us+0x78>
    } else if (us < 1000) {
    5dc8:	68 3e       	cpi	r22, 0xE8	; 232
    5dca:	f3 e0       	ldi	r31, 0x03	; 3
    5dcc:	7f 07       	cpc	r23, r31
    5dce:	81 05       	cpc	r24, r1
    5dd0:	91 05       	cpc	r25, r1
    5dd2:	58 f4       	brcc	.+22     	; 0x5dea <delay_us+0x64>
    5dd4:	ec ec       	ldi	r30, 0xCC	; 204
    5dd6:	f1 e0       	ldi	r31, 0x01	; 1
    5dd8:	31 97       	sbiw	r30, 0x01	; 1
    5dda:	f1 f7       	brne	.-4      	; 0x5dd8 <delay_us+0x52>
    5ddc:	00 c0       	rjmp	.+0      	; 0x5dde <delay_us+0x58>
    5dde:	00 00       	nop
      _delay_us(100);
      us -= 100;
    5de0:	64 56       	subi	r22, 0x64	; 100
    5de2:	71 09       	sbc	r23, r1
    5de4:	81 09       	sbc	r24, r1
    5de6:	91 09       	sbc	r25, r1
    5de8:	0a c0       	rjmp	.+20     	; 0x5dfe <delay_us+0x78>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5dea:	ef ef       	ldi	r30, 0xFF	; 255
    5dec:	f1 e1       	ldi	r31, 0x11	; 17
    5dee:	31 97       	sbiw	r30, 0x01	; 1
    5df0:	f1 f7       	brne	.-4      	; 0x5dee <delay_us+0x68>
    5df2:	00 c0       	rjmp	.+0      	; 0x5df4 <delay_us+0x6e>
    5df4:	00 00       	nop
    } else {
      _delay_ms(1);
      us -= 1000;
    5df6:	68 5e       	subi	r22, 0xE8	; 232
    5df8:	73 40       	sbci	r23, 0x03	; 3
    5dfa:	81 09       	sbc	r24, r1
    5dfc:	91 09       	sbc	r25, r1
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    5dfe:	61 15       	cp	r22, r1
    5e00:	71 05       	cpc	r23, r1
    5e02:	81 05       	cpc	r24, r1
    5e04:	91 05       	cpc	r25, r1
    5e06:	21 f6       	brne	.-120    	; 0x5d90 <delay_us+0xa>
    5e08:	08 95       	ret

00005e0a <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    5e0a:	8f 92       	push	r8
    5e0c:	9f 92       	push	r9
    5e0e:	af 92       	push	r10
    5e10:	bf 92       	push	r11
    5e12:	cf 92       	push	r12
    5e14:	df 92       	push	r13
    5e16:	ef 92       	push	r14
    5e18:	ff 92       	push	r15
    5e1a:	69 01       	movw	r12, r18
    5e1c:	7a 01       	movw	r14, r20
    5e1e:	9b 01       	movw	r18, r22
    5e20:	ac 01       	movw	r20, r24
    5e22:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5e26:	4b 01       	movw	r8, r22
    5e28:	5c 01       	movw	r10, r24
    5e2a:	a7 01       	movw	r20, r14
    5e2c:	96 01       	movw	r18, r12
    5e2e:	c7 01       	movw	r24, r14
    5e30:	b6 01       	movw	r22, r12
    5e32:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5e36:	9b 01       	movw	r18, r22
    5e38:	ac 01       	movw	r20, r24
    5e3a:	c5 01       	movw	r24, r10
    5e3c:	b4 01       	movw	r22, r8
    5e3e:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    5e42:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    5e46:	ff 90       	pop	r15
    5e48:	ef 90       	pop	r14
    5e4a:	df 90       	pop	r13
    5e4c:	cf 90       	pop	r12
    5e4e:	bf 90       	pop	r11
    5e50:	af 90       	pop	r10
    5e52:	9f 90       	pop	r9
    5e54:	8f 90       	pop	r8
    5e56:	08 95       	ret

00005e58 <limits_disable>:
}


void limits_disable()
{
  LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    5e58:	ec e6       	ldi	r30, 0x6C	; 108
    5e5a:	f0 e0       	ldi	r31, 0x00	; 0
    5e5c:	80 81       	ld	r24, Z
    5e5e:	81 7f       	andi	r24, 0xF1	; 241
    5e60:	80 83       	st	Z, r24
  PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    5e62:	e8 e6       	ldi	r30, 0x68	; 104
    5e64:	f0 e0       	ldi	r31, 0x00	; 0
    5e66:	80 81       	ld	r24, Z
    5e68:	8d 7f       	andi	r24, 0xFD	; 253
    5e6a:	80 83       	st	Z, r24
    5e6c:	08 95       	ret

00005e6e <limits_init>:
#define HOMING_AXIS_SEARCH_SCALAR  1.5 // Must be > 1 to ensure limit switch will be engaged.


void limits_init() 
{
  LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    5e6e:	84 b1       	in	r24, 0x04	; 4
    5e70:	81 7f       	andi	r24, 0xF1	; 241
    5e72:	84 b9       	out	0x04, r24	; 4

  #ifdef DISABLE_LIMIT_PIN_PULL_UP
    LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
  #else
    LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    5e74:	85 b1       	in	r24, 0x05	; 5
    5e76:	8e 60       	ori	r24, 0x0E	; 14
    5e78:	85 b9       	out	0x05, r24	; 5
  #endif

  if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    5e7a:	80 91 3c 09 	lds	r24, 0x093C
    5e7e:	83 ff       	sbrs	r24, 3
    5e80:	0b c0       	rjmp	.+22     	; 0x5e98 <limits_init+0x2a>
    LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    5e82:	ec e6       	ldi	r30, 0x6C	; 108
    5e84:	f0 e0       	ldi	r31, 0x00	; 0
    5e86:	80 81       	ld	r24, Z
    5e88:	8e 60       	ori	r24, 0x0E	; 14
    5e8a:	80 83       	st	Z, r24
    PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    5e8c:	e8 e6       	ldi	r30, 0x68	; 104
    5e8e:	f0 e0       	ldi	r31, 0x00	; 0
    5e90:	80 81       	ld	r24, Z
    5e92:	82 60       	ori	r24, 0x02	; 2
    5e94:	80 83       	st	Z, r24
    5e96:	08 95       	ret
  } else {
    limits_disable(); 
    5e98:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <limits_disable>
    5e9c:	08 95       	ret

00005e9e <__vector_5>:
// homing cycles and will not respond correctly. Upon user request or need, there may be a
// special pinout for an e-stop, but it is generally recommended to just directly connect
// your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
#ifndef ENABLE_SOFTWARE_DEBOUNCE
  ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process. 
  {
    5e9e:	1f 92       	push	r1
    5ea0:	0f 92       	push	r0
    5ea2:	0f b6       	in	r0, 0x3f	; 63
    5ea4:	0f 92       	push	r0
    5ea6:	11 24       	eor	r1, r1
    5ea8:	2f 93       	push	r18
    5eaa:	3f 93       	push	r19
    5eac:	4f 93       	push	r20
    5eae:	5f 93       	push	r21
    5eb0:	6f 93       	push	r22
    5eb2:	7f 93       	push	r23
    5eb4:	8f 93       	push	r24
    5eb6:	9f 93       	push	r25
    5eb8:	af 93       	push	r26
    5eba:	bf 93       	push	r27
    5ebc:	ef 93       	push	r30
    5ebe:	ff 93       	push	r31
    // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
    // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
    // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
    // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
    // limit setting if their limits are constantly triggering after a reset and move their axes.
    if (sys.state != STATE_ALARM) { 
    5ec0:	80 91 68 07 	lds	r24, 0x0768
    5ec4:	81 30       	cpi	r24, 0x01	; 1
    5ec6:	71 f0       	breq	.+28     	; 0x5ee4 <__vector_5+0x46>
      if (!(sys.rt_exec_alarm)) {
    5ec8:	80 91 6b 07 	lds	r24, 0x076B
    5ecc:	81 11       	cpse	r24, r1
    5ece:	0a c0       	rjmp	.+20     	; 0x5ee4 <__vector_5+0x46>
        mc_reset(); // Initiate system kill.
    5ed0:	0e 94 a5 0c 	call	0x194a	; 0x194a <mc_reset>
        bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
    5ed4:	8f b7       	in	r24, 0x3f	; 63
    5ed6:	f8 94       	cli
    5ed8:	eb e6       	ldi	r30, 0x6B	; 107
    5eda:	f7 e0       	ldi	r31, 0x07	; 7
    5edc:	90 81       	ld	r25, Z
    5ede:	93 60       	ori	r25, 0x03	; 3
    5ee0:	90 83       	st	Z, r25
    5ee2:	8f bf       	out	0x3f, r24	; 63
      }
    }
  }  
    5ee4:	ff 91       	pop	r31
    5ee6:	ef 91       	pop	r30
    5ee8:	bf 91       	pop	r27
    5eea:	af 91       	pop	r26
    5eec:	9f 91       	pop	r25
    5eee:	8f 91       	pop	r24
    5ef0:	7f 91       	pop	r23
    5ef2:	6f 91       	pop	r22
    5ef4:	5f 91       	pop	r21
    5ef6:	4f 91       	pop	r20
    5ef8:	3f 91       	pop	r19
    5efa:	2f 91       	pop	r18
    5efc:	0f 90       	pop	r0
    5efe:	0f be       	out	0x3f, r0	; 63
    5f00:	0f 90       	pop	r0
    5f02:	1f 90       	pop	r1
    5f04:	18 95       	reti

00005f06 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically 
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask) 
{
    5f06:	2f 92       	push	r2
    5f08:	3f 92       	push	r3
    5f0a:	4f 92       	push	r4
    5f0c:	5f 92       	push	r5
    5f0e:	6f 92       	push	r6
    5f10:	7f 92       	push	r7
    5f12:	8f 92       	push	r8
    5f14:	9f 92       	push	r9
    5f16:	af 92       	push	r10
    5f18:	bf 92       	push	r11
    5f1a:	cf 92       	push	r12
    5f1c:	df 92       	push	r13
    5f1e:	ef 92       	push	r14
    5f20:	ff 92       	push	r15
    5f22:	0f 93       	push	r16
    5f24:	1f 93       	push	r17
    5f26:	cf 93       	push	r28
    5f28:	df 93       	push	r29
    5f2a:	cd b7       	in	r28, 0x3d	; 61
    5f2c:	de b7       	in	r29, 0x3e	; 62
    5f2e:	e3 97       	sbiw	r28, 0x33	; 51
    5f30:	0f b6       	in	r0, 0x3f	; 63
    5f32:	f8 94       	cli
    5f34:	de bf       	out	0x3e, r29	; 62
    5f36:	0f be       	out	0x3f, r0	; 63
    5f38:	cd bf       	out	0x3d, r28	; 61
    5f3a:	a8 2e       	mov	r10, r24
  if (sys.abort) { return; } // Block if system reset has been issued.
    5f3c:	80 91 67 07 	lds	r24, 0x0767
    5f40:	81 11       	cpse	r24, r1
    5f42:	7b c2       	rjmp	.+1270   	; 0x643a <limits_go_home+0x534>

  // Initialize homing in search mode to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    5f44:	80 91 42 09 	lds	r24, 0x0942
    5f48:	90 91 43 09 	lds	r25, 0x0943
    5f4c:	a0 91 44 09 	lds	r26, 0x0944
    5f50:	b0 91 45 09 	lds	r27, 0x0945
    5f54:	88 a3       	std	Y+32, r24	; 0x20
    5f56:	99 a3       	std	Y+33, r25	; 0x21
    5f58:	aa a3       	std	Y+34, r26	; 0x22
    5f5a:	bb a3       	std	Y+35, r27	; 0x23
    5f5c:	de 01       	movw	r26, r28
    5f5e:	1d 96       	adiw	r26, 0x0d	; 13
    5f60:	be 8b       	std	Y+22, r27	; 0x16
    5f62:	ad 8b       	std	Y+21, r26	; 0x15
    5f64:	fe 01       	movw	r30, r28
    5f66:	70 96       	adiw	r30, 0x10	; 16
    5f68:	fc 8b       	std	Y+20, r31	; 0x14
    5f6a:	eb 8b       	std	Y+19, r30	; 0x13
    5f6c:	1f 01       	movw	r2, r30
    5f6e:	0f 2e       	mov	r0, r31
    5f70:	f3 e2       	ldi	r31, 0x23	; 35
    5f72:	4f 2e       	mov	r4, r31
    5f74:	f9 e0       	ldi	r31, 0x09	; 9
    5f76:	5f 2e       	mov	r5, r31
    5f78:	f0 2d       	mov	r31, r0
    5f7a:	3f 01       	movw	r6, r30
    5f7c:	8d 01       	movw	r16, r26
  uint8_t invert_pin, idx;
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  float target[N_AXIS];
  
  uint8_t limit_pin[N_AXIS], step_pin[N_AXIS];
  float max_travel = 0.0;
    5f7e:	81 2c       	mov	r8, r1
    5f80:	91 2c       	mov	r9, r1
    5f82:	b1 2c       	mov	r11, r1
    5f84:	a9 8e       	std	Y+25, r10	; 0x19
    5f86:	ab 2c       	mov	r10, r11
    5f88:	f0 2e       	mov	r15, r16
    5f8a:	3d 89       	ldd	r19, Y+21	; 0x15
    5f8c:	f3 1a       	sub	r15, r19
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize limit and step pin masks
    limit_pin[idx] = get_limit_pin_mask(idx);
    5f8e:	8f 2d       	mov	r24, r15
    5f90:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <get_limit_pin_mask>
    5f94:	d8 01       	movw	r26, r16
    5f96:	8d 93       	st	X+, r24
    5f98:	8d 01       	movw	r16, r26
    step_pin[idx] = get_step_pin_mask(idx);
    5f9a:	8f 2d       	mov	r24, r15
    5f9c:	0e 94 e6 28 	call	0x51cc	; 0x51cc <get_step_pin_mask>
    5fa0:	f3 01       	movw	r30, r6
    5fa2:	81 93       	st	Z+, r24
    5fa4:	3f 01       	movw	r6, r30
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif
    
    // Determine travel distance to the furthest homing switch based on user max travel settings.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (max_travel > settings.max_travel[idx]) { max_travel = settings.max_travel[idx]; }
    5fa6:	d2 01       	movw	r26, r4
    5fa8:	cd 90       	ld	r12, X+
    5faa:	dd 90       	ld	r13, X+
    5fac:	ed 90       	ld	r14, X+
    5fae:	fd 90       	ld	r15, X+
    5fb0:	2d 01       	movw	r4, r26
    5fb2:	2b 2d       	mov	r18, r11
    5fb4:	38 2d       	mov	r19, r8
    5fb6:	49 2d       	mov	r20, r9
    5fb8:	5a 2d       	mov	r21, r10
    5fba:	c7 01       	movw	r24, r14
    5fbc:	b6 01       	movw	r22, r12
    5fbe:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    5fc2:	88 23       	and	r24, r24
    5fc4:	24 f4       	brge	.+8      	; 0x5fce <limits_go_home+0xc8>
    5fc6:	bc 2c       	mov	r11, r12
    5fc8:	8d 2c       	mov	r8, r13
    5fca:	9e 2c       	mov	r9, r14
    5fcc:	af 2c       	mov	r10, r15
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  float target[N_AXIS];
  
  uint8_t limit_pin[N_AXIS], step_pin[N_AXIS];
  float max_travel = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {  
    5fce:	02 15       	cp	r16, r2
    5fd0:	13 05       	cpc	r17, r3
    5fd2:	d1 f6       	brne	.-76     	; 0x5f88 <limits_go_home+0x82>
    5fd4:	fb 2c       	mov	r15, r11
    5fd6:	ba 2c       	mov	r11, r10
    5fd8:	a9 8c       	ldd	r10, Y+25	; 0x19
    
    // Determine travel distance to the furthest homing switch based on user max travel settings.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (max_travel > settings.max_travel[idx]) { max_travel = settings.max_travel[idx]; }
  }
  max_travel *= -HOMING_AXIS_SEARCH_SCALAR; // Ensure homing switches engaged by over-estimating max travel.
    5fda:	20 e0       	ldi	r18, 0x00	; 0
    5fdc:	30 e0       	ldi	r19, 0x00	; 0
    5fde:	40 ec       	ldi	r20, 0xC0	; 192
    5fe0:	5f eb       	ldi	r21, 0xBF	; 191
    5fe2:	6f 2d       	mov	r22, r15
    5fe4:	78 2d       	mov	r23, r8
    5fe6:	89 2d       	mov	r24, r9
    5fe8:	9b 2d       	mov	r25, r11
    5fea:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    5fee:	6c a3       	std	Y+36, r22	; 0x24
    5ff0:	7d a3       	std	Y+37, r23	; 0x25
    5ff2:	8e a3       	std	Y+38, r24	; 0x26
    5ff4:	9f a3       	std	Y+39, r25	; 0x27
  
  plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
    5ff6:	0e 94 34 2a 	call	0x5468	; 0x5468 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    5ffa:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <plan_sync_position>
    5ffe:	b6 e0       	ldi	r27, 0x06	; 6
    6000:	be a7       	std	Y+46, r27	; 0x2e
void limits_go_home(uint8_t cycle_mask) 
{
  if (sys.abort) { return; } // Block if system reset has been issued.

  // Initialize homing in search mode to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    6002:	e1 e0       	ldi	r30, 0x01	; 1
    6004:	ec 8f       	std	Y+28, r30	; 0x1c

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    6006:	9e 01       	movw	r18, r28
    6008:	2f 5f       	subi	r18, 0xFF	; 255
    600a:	3f 4f       	sbci	r19, 0xFF	; 255
    600c:	38 8f       	std	Y+24, r19	; 0x18
    600e:	2f 8b       	std	Y+23, r18	; 0x17
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    6010:	8a 2d       	mov	r24, r10
    6012:	90 e0       	ldi	r25, 0x00	; 0
    6014:	9b 8f       	std	Y+27, r25	; 0x1b
    6016:	8a 8f       	std	Y+26, r24	; 0x1a
    6018:	9a 8d       	ldd	r25, Y+26	; 0x1a
    601a:	9d 8f       	std	Y+29, r25	; 0x1d
    601c:	ab 8d       	ldd	r26, Y+27	; 0x1b
    601e:	af a7       	std	Y+47, r26	; 0x2f

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    sys.homing_axis_lock = axislock;
    6020:	0f 2e       	mov	r0, r31
    6022:	f8 e7       	ldi	r31, 0x78	; 120
    6024:	4f 2e       	mov	r4, r31
    6026:	f7 e0       	ldi	r31, 0x07	; 7
    6028:	5f 2e       	mov	r5, r31
    602a:	f0 2d       	mov	r31, r0
    602c:	3e 01       	movw	r6, r28
    602e:	b3 e1       	ldi	r27, 0x13	; 19
    6030:	6b 0e       	add	r6, r27
    6032:	71 1c       	adc	r7, r1
      }
      sys.homing_axis_lock = axislock;
      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
      // Check only for user reset. No time to run protocol_execute_realtime() in this loop.

      if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) { // Abort homing and alarm upon safety door.
    6034:	0f 2e       	mov	r0, r31
    6036:	fa e6       	ldi	r31, 0x6A	; 106
    6038:	cf 2e       	mov	r12, r31
    603a:	f7 e0       	ldi	r31, 0x07	; 7
    603c:	df 2e       	mov	r13, r31
    603e:	f0 2d       	mov	r31, r0
    6040:	2d 88       	ldd	r2, Y+21	; 0x15
    6042:	ee 88       	ldd	r14, Y+22	; 0x16
    6044:	fb 88       	ldd	r15, Y+19	; 0x13
    6046:	3c 88       	ldd	r3, Y+20	; 0x14
    6048:	9f 2c       	mov	r9, r15
    604a:	83 2c       	mov	r8, r3
    604c:	3e 2c       	mov	r3, r14
  plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
  plan_sync_position(); // Sync planner position to current machine position.
  
  do {
    // Initialize invert_pin boolean based on approach and invert pin user setting.
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    604e:	80 91 3c 09 	lds	r24, 0x093C
    6052:	86 fd       	sbrc	r24, 6
    6054:	02 c0       	rjmp	.+4      	; 0x605a <limits_go_home+0x154>
    6056:	ec 8c       	ldd	r14, Y+28	; 0x1c
    6058:	03 c0       	rjmp	.+6      	; 0x6060 <limits_go_home+0x15a>
    else { invert_pin = !approach; }
    605a:	81 e0       	ldi	r24, 0x01	; 1
    605c:	ec 8c       	ldd	r14, Y+28	; 0x1c
    605e:	e8 26       	eor	r14, r24

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    6060:	6c e6       	ldi	r22, 0x6C	; 108
    6062:	77 e0       	ldi	r23, 0x07	; 7
    6064:	ce 01       	movw	r24, r28
    6066:	01 96       	adiw	r24, 0x01	; 1
    6068:	0e 94 98 3b 	call	0x7730	; 0x7730 <system_convert_array_steps_to_mpos>
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
        n_active_axis++;
        if (approach) {
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] -= max_travel; }
    606c:	80 91 3d 09 	lds	r24, 0x093D
    6070:	e8 2f       	mov	r30, r24
    6072:	f0 e0       	ldi	r31, 0x00	; 0
    6074:	ff 8f       	std	Y+31, r31	; 0x1f
    6076:	ee 8f       	std	Y+30, r30	; 0x1e
    6078:	ff 89       	ldd	r31, Y+23	; 0x17
    607a:	fa ab       	std	Y+50, r31	; 0x32
    607c:	28 8d       	ldd	r18, Y+24	; 0x18
    607e:	2b ab       	std	Y+51, r18	; 0x33
    6080:	ce 01       	movw	r24, r28
    6082:	01 96       	adiw	r24, 0x01	; 1
    6084:	00 e0       	ldi	r16, 0x00	; 0
    6086:	10 e0       	ldi	r17, 0x00	; 0
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    else { invert_pin = !approach; }

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;
    6088:	f1 2c       	mov	r15, r1
    // Initialize invert_pin boolean based on approach and invert pin user setting.
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    else { invert_pin = !approach; }

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    608a:	19 8e       	std	Y+25, r1	; 0x19
    608c:	59 a6       	std	Y+41, r5	; 0x29
    608e:	48 a6       	std	Y+40, r4	; 0x28
    6090:	7b a6       	std	Y+43, r7	; 0x2b
    6092:	6a a6       	std	Y+42, r6	; 0x2a
    6094:	dd a6       	std	Y+45, r13	; 0x2d
    6096:	cc a6       	std	Y+44, r12	; 0x2c
    6098:	5f a4       	ldd	r5, Y+47	; 0x2f
    609a:	d9 2c       	mov	r13, r9
    609c:	9f 2c       	mov	r9, r15
    609e:	78 2c       	mov	r7, r8
    60a0:	8e 2c       	mov	r8, r14
    60a2:	7c 01       	movw	r14, r24
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    60a4:	ad 8c       	ldd	r10, Y+29	; 0x1d
    60a6:	b5 2c       	mov	r11, r5
    60a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    60aa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    60ac:	00 2e       	mov	r0, r16
    60ae:	02 c0       	rjmp	.+4      	; 0x60b4 <limits_go_home+0x1ae>
    60b0:	95 95       	asr	r25
    60b2:	87 95       	ror	r24
    60b4:	0a 94       	dec	r0
    60b6:	e2 f7       	brpl	.-8      	; 0x60b0 <limits_go_home+0x1aa>
    60b8:	80 ff       	sbrs	r24, 0
    60ba:	62 c0       	rjmp	.+196    	; 0x6180 <limits_go_home+0x27a>
        n_active_axis++;
    60bc:	99 8d       	ldd	r25, Y+25	; 0x19
    60be:	9f 5f       	subi	r25, 0xFF	; 255
    60c0:	99 8f       	std	Y+25, r25	; 0x19
        if (approach) {
    60c2:	ac 8d       	ldd	r26, Y+28	; 0x1c
    60c4:	aa 23       	and	r26, r26
    60c6:	71 f1       	breq	.+92     	; 0x6124 <limits_go_home+0x21e>
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] -= max_travel; }
    60c8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    60ca:	9f 8d       	ldd	r25, Y+31	; 0x1f
    60cc:	00 2e       	mov	r0, r16
    60ce:	02 c0       	rjmp	.+4      	; 0x60d4 <limits_go_home+0x1ce>
    60d0:	95 95       	asr	r25
    60d2:	87 95       	ror	r24
    60d4:	0a 94       	dec	r0
    60d6:	e2 f7       	brpl	.-8      	; 0x60d0 <limits_go_home+0x1ca>
    60d8:	80 ff       	sbrs	r24, 0
    60da:	12 c0       	rjmp	.+36     	; 0x6100 <limits_go_home+0x1fa>
    60dc:	2c a1       	ldd	r18, Y+36	; 0x24
    60de:	3d a1       	ldd	r19, Y+37	; 0x25
    60e0:	4e a1       	ldd	r20, Y+38	; 0x26
    60e2:	5f a1       	ldd	r21, Y+39	; 0x27
    60e4:	f7 01       	movw	r30, r14
    60e6:	60 81       	ld	r22, Z
    60e8:	71 81       	ldd	r23, Z+1	; 0x01
    60ea:	82 81       	ldd	r24, Z+2	; 0x02
    60ec:	93 81       	ldd	r25, Z+3	; 0x03
    60ee:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    60f2:	d7 01       	movw	r26, r14
    60f4:	6d 93       	st	X+, r22
    60f6:	7d 93       	st	X+, r23
    60f8:	8d 93       	st	X+, r24
    60fa:	9c 93       	st	X, r25
    60fc:	13 97       	sbiw	r26, 0x03	; 3
    60fe:	94 c1       	rjmp	.+808    	; 0x6428 <limits_go_home+0x522>
          else { target[idx] += max_travel; }
    6100:	2c a1       	ldd	r18, Y+36	; 0x24
    6102:	3d a1       	ldd	r19, Y+37	; 0x25
    6104:	4e a1       	ldd	r20, Y+38	; 0x26
    6106:	5f a1       	ldd	r21, Y+39	; 0x27
    6108:	f7 01       	movw	r30, r14
    610a:	60 81       	ld	r22, Z
    610c:	71 81       	ldd	r23, Z+1	; 0x01
    610e:	82 81       	ldd	r24, Z+2	; 0x02
    6110:	93 81       	ldd	r25, Z+3	; 0x03
    6112:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    6116:	d7 01       	movw	r26, r14
    6118:	6d 93       	st	X+, r22
    611a:	7d 93       	st	X+, r23
    611c:	8d 93       	st	X+, r24
    611e:	9c 93       	st	X, r25
    6120:	13 97       	sbiw	r26, 0x03	; 3
    6122:	82 c1       	rjmp	.+772    	; 0x6428 <limits_go_home+0x522>
        } else { 
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] += max_travel; }
    6124:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6126:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6128:	00 2e       	mov	r0, r16
    612a:	02 c0       	rjmp	.+4      	; 0x6130 <limits_go_home+0x22a>
    612c:	95 95       	asr	r25
    612e:	87 95       	ror	r24
    6130:	0a 94       	dec	r0
    6132:	e2 f7       	brpl	.-8      	; 0x612c <limits_go_home+0x226>
    6134:	80 ff       	sbrs	r24, 0
    6136:	12 c0       	rjmp	.+36     	; 0x615c <limits_go_home+0x256>
    6138:	2c a1       	ldd	r18, Y+36	; 0x24
    613a:	3d a1       	ldd	r19, Y+37	; 0x25
    613c:	4e a1       	ldd	r20, Y+38	; 0x26
    613e:	5f a1       	ldd	r21, Y+39	; 0x27
    6140:	f7 01       	movw	r30, r14
    6142:	60 81       	ld	r22, Z
    6144:	71 81       	ldd	r23, Z+1	; 0x01
    6146:	82 81       	ldd	r24, Z+2	; 0x02
    6148:	93 81       	ldd	r25, Z+3	; 0x03
    614a:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    614e:	d7 01       	movw	r26, r14
    6150:	6d 93       	st	X+, r22
    6152:	7d 93       	st	X+, r23
    6154:	8d 93       	st	X+, r24
    6156:	9c 93       	st	X, r25
    6158:	13 97       	sbiw	r26, 0x03	; 3
    615a:	66 c1       	rjmp	.+716    	; 0x6428 <limits_go_home+0x522>
          else { target[idx] -= max_travel; }
    615c:	2c a1       	ldd	r18, Y+36	; 0x24
    615e:	3d a1       	ldd	r19, Y+37	; 0x25
    6160:	4e a1       	ldd	r20, Y+38	; 0x26
    6162:	5f a1       	ldd	r21, Y+39	; 0x27
    6164:	f7 01       	movw	r30, r14
    6166:	60 81       	ld	r22, Z
    6168:	71 81       	ldd	r23, Z+1	; 0x01
    616a:	82 81       	ldd	r24, Z+2	; 0x02
    616c:	93 81       	ldd	r25, Z+3	; 0x03
    616e:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    6172:	d7 01       	movw	r26, r14
    6174:	6d 93       	st	X+, r22
    6176:	7d 93       	st	X+, r23
    6178:	8d 93       	st	X+, r24
    617a:	9c 93       	st	X, r25
    617c:	13 97       	sbiw	r26, 0x03	; 3
    617e:	54 c1       	rjmp	.+680    	; 0x6428 <limits_go_home+0x522>
    6180:	0f 5f       	subi	r16, 0xFF	; 255
    6182:	1f 4f       	sbci	r17, 0xFF	; 255
    6184:	b4 e0       	ldi	r27, 0x04	; 4
    6186:	eb 0e       	add	r14, r27
    6188:	f1 1c       	adc	r15, r1
    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    for (idx=0; idx<N_AXIS; idx++) {
    618a:	03 30       	cpi	r16, 0x03	; 3
    618c:	11 05       	cpc	r17, r1
    618e:	09 f0       	breq	.+2      	; 0x6192 <limits_go_home+0x28c>
    6190:	89 cf       	rjmp	.-238    	; 0x60a4 <limits_go_home+0x19e>
    6192:	e8 2c       	mov	r14, r8
    6194:	f9 2c       	mov	r15, r9
    6196:	b9 aa       	std	Y+49, r11	; 0x31
    6198:	a8 aa       	std	Y+48, r10	; 0x30
    619a:	48 a4       	ldd	r4, Y+40	; 0x28
    619c:	59 a4       	ldd	r5, Y+41	; 0x29
    619e:	9d 2c       	mov	r9, r13
    61a0:	cc a4       	ldd	r12, Y+44	; 0x2c
    61a2:	dd a4       	ldd	r13, Y+45	; 0x2d
    61a4:	87 2c       	mov	r8, r7
    61a6:	6a a4       	ldd	r6, Y+42	; 0x2a
    61a8:	7b a4       	ldd	r7, Y+43	; 0x2b
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    61aa:	e9 8d       	ldd	r30, Y+25	; 0x19
    61ac:	6e 2f       	mov	r22, r30
    61ae:	70 e0       	ldi	r23, 0x00	; 0
    61b0:	80 e0       	ldi	r24, 0x00	; 0
    61b2:	90 e0       	ldi	r25, 0x00	; 0
    61b4:	0e 94 2c 3d 	call	0x7a58	; 0x7a58 <__floatunsisf>
    61b8:	0e 94 57 3f 	call	0x7eae	; 0x7eae <sqrt>
    sys.homing_axis_lock = axislock;
    61bc:	d2 01       	movw	r26, r4
    61be:	fc 92       	st	X, r15
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    61c0:	28 a1       	ldd	r18, Y+32	; 0x20
    61c2:	39 a1       	ldd	r19, Y+33	; 0x21
    61c4:	4a a1       	ldd	r20, Y+34	; 0x22
    61c6:	5b a1       	ldd	r21, Y+35	; 0x23
    61c8:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    61cc:	ab 01       	movw	r20, r22
    61ce:	bc 01       	movw	r22, r24
    uint8_t limit_state;
    
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, homing_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan homing motion.
    #else
      plan_buffer_line(target, homing_rate, false); // Bypass mc_line(). Directly plan homing motion.
    61d0:	20 e0       	ldi	r18, 0x00	; 0
    61d2:	ce 01       	movw	r24, r28
    61d4:	01 96       	adiw	r24, 0x01	; 1
    61d6:	0e 94 8c 2a 	call	0x5518	; 0x5518 <plan_buffer_line>
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    61da:	0e 94 5f 1e 	call	0x3cbe	; 0x3cbe <st_prep_buffer>
    st_wake_up(); // Initiate motion
    61de:	0e 94 0c 1b 	call	0x3618	; 0x3618 <st_wake_up>
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
    61e2:	1e e0       	ldi	r17, 0x0E	; 14
    61e4:	0f 2d       	mov	r16, r15
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    st_wake_up(); // Initiate motion
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
    61e6:	23 b1       	in	r18, 0x03	; 3
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
    61e8:	e1 10       	cpse	r14, r1
    61ea:	21 27       	eor	r18, r17
    61ec:	a2 2d       	mov	r26, r2
    61ee:	b3 2d       	mov	r27, r3
    61f0:	e9 2d       	mov	r30, r9
    61f2:	f8 2d       	mov	r31, r8
      for (idx=0; idx<N_AXIS; idx++) {
        if (axislock & step_pin[idx]) {
    61f4:	81 91       	ld	r24, Z+
    61f6:	98 2f       	mov	r25, r24
    61f8:	90 23       	and	r25, r16
    61fa:	29 f0       	breq	.+10     	; 0x6206 <limits_go_home+0x300>
          if (limit_state & limit_pin[idx]) { axislock &= ~(step_pin[idx]); }
    61fc:	9c 91       	ld	r25, X
    61fe:	92 23       	and	r25, r18
    6200:	11 f0       	breq	.+4      	; 0x6206 <limits_go_home+0x300>
    6202:	80 95       	com	r24
    6204:	08 23       	and	r16, r24
    6206:	11 96       	adiw	r26, 0x01	; 1
    st_wake_up(); // Initiate motion
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
      for (idx=0; idx<N_AXIS; idx++) {
    6208:	e6 15       	cp	r30, r6
    620a:	f7 05       	cpc	r31, r7
    620c:	99 f7       	brne	.-26     	; 0x61f4 <limits_go_home+0x2ee>
        if (axislock & step_pin[idx]) {
          if (limit_state & limit_pin[idx]) { axislock &= ~(step_pin[idx]); }
        }
      }
      sys.homing_axis_lock = axislock;
    620e:	f2 01       	movw	r30, r4
    6210:	00 83       	st	Z, r16
      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    6212:	0e 94 5f 1e 	call	0x3cbe	; 0x3cbe <st_prep_buffer>
      // Check only for user reset. No time to run protocol_execute_realtime() in this loop.

      if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) { // Abort homing and alarm upon safety door.
    6216:	d6 01       	movw	r26, r12
    6218:	8c 91       	ld	r24, X
    621a:	80 73       	andi	r24, 0x30	; 48
    621c:	41 f0       	breq	.+16     	; 0x622e <limits_go_home+0x328>
        if (sys.rt_exec_state & EXEC_SAFETY_DOOR) { mc_reset(); }  
    621e:	80 91 6a 07 	lds	r24, 0x076A
    6222:	85 fd       	sbrc	r24, 5
    6224:	0e 94 a5 0c 	call	0x194a	; 0x194a <mc_reset>
        protocol_execute_realtime();
    6228:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
        return;
    622c:	06 c1       	rjmp	.+524    	; 0x643a <limits_go_home+0x534>
      }
    } while (STEP_MASK & axislock);
    622e:	80 2f       	mov	r24, r16
    6230:	84 75       	andi	r24, 0x54	; 84
    6232:	c9 f6       	brne	.-78     	; 0x61e6 <limits_go_home+0x2e0>
    
    st_reset(); // Immediately force kill steppers and reset step segment buffer.
    6234:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <st_reset>
    plan_reset(); // Reset planner buffer. Zero planner positions. Ensure homing motion is cleared.
    6238:	0e 94 34 2a 	call	0x5468	; 0x5468 <plan_reset>
    plan_sync_position(); // Sync planner position to current machine position
    623c:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <plan_sync_position>

    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    6240:	80 91 46 09 	lds	r24, 0x0946
    6244:	90 91 47 09 	lds	r25, 0x0947
    6248:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    homing_rate = settings.homing_feed_rate;
    624c:	80 91 3e 09 	lds	r24, 0x093E
    6250:	90 91 3f 09 	lds	r25, 0x093F
    6254:	a0 91 40 09 	lds	r26, 0x0940
    6258:	b0 91 41 09 	lds	r27, 0x0941
    625c:	88 a3       	std	Y+32, r24	; 0x20
    625e:	99 a3       	std	Y+33, r25	; 0x21
    6260:	aa a3       	std	Y+34, r26	; 0x22
    6262:	bb a3       	std	Y+35, r27	; 0x23
    approach = !approach;
    6264:	81 e0       	ldi	r24, 0x01	; 1
    6266:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6268:	98 27       	eor	r25, r24
    626a:	9c 8f       	std	Y+28, r25	; 0x1c
    626c:	ae a5       	ldd	r26, Y+46	; 0x2e
    626e:	a1 50       	subi	r26, 0x01	; 1
    6270:	ae a7       	std	Y+46, r26	; 0x2e
    
  } while (n_cycle-- > 0);
    6272:	a1 11       	cpse	r26, r1
    6274:	ec ce       	rjmp	.-552    	; 0x604e <limits_go_home+0x148>
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
      #ifndef HOMING_FORCE_SET_ORIGIN
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6276:	c0 90 3d 09 	lds	r12, 0x093D
    627a:	d1 2c       	mov	r13, r1
    627c:	e1 2c       	mov	r14, r1
    627e:	f1 2c       	mov	r15, r1
    6280:	00 e0       	ldi	r16, 0x00	; 0
    6282:	10 e0       	ldi	r17, 0x00	; 0
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
    6284:	81 2c       	mov	r8, r1
    6286:	91 2c       	mov	r9, r1
    6288:	a1 2c       	mov	r10, r1
    628a:	b1 2c       	mov	r11, r1
    628c:	68 a8       	ldd	r6, Y+48	; 0x30
    628e:	79 a8       	ldd	r7, Y+49	; 0x31
  #endif
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    6290:	c3 01       	movw	r24, r6
    6292:	00 2e       	mov	r0, r16
    6294:	02 c0       	rjmp	.+4      	; 0x629a <limits_go_home+0x394>
    6296:	95 95       	asr	r25
    6298:	87 95       	ror	r24
    629a:	0a 94       	dec	r0
    629c:	e2 f7       	brpl	.-8      	; 0x6296 <limits_go_home+0x390>
    629e:	80 ff       	sbrs	r24, 0
    62a0:	28 c0       	rjmp	.+80     	; 0x62f2 <limits_go_home+0x3ec>
      set_axis_position = 0;     
      #ifndef HOMING_FORCE_SET_ORIGIN
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    62a2:	c6 01       	movw	r24, r12
    62a4:	00 2e       	mov	r0, r16
    62a6:	02 c0       	rjmp	.+4      	; 0x62ac <limits_go_home+0x3a6>
    62a8:	95 95       	asr	r25
    62aa:	87 95       	ror	r24
    62ac:	0a 94       	dec	r0
    62ae:	e2 f7       	brpl	.-8      	; 0x62a8 <limits_go_home+0x3a2>
    62b0:	80 ff       	sbrs	r24, 0
    62b2:	14 c0       	rjmp	.+40     	; 0x62dc <limits_go_home+0x3d6>
    62b4:	f7 01       	movw	r30, r14
    62b6:	e1 50       	subi	r30, 0x01	; 1
    62b8:	f7 4f       	sbci	r31, 0xF7	; 247
          set_axis_position = lround(settings.max_travel[idx]*settings.steps_per_mm[idx]);
    62ba:	20 81       	ld	r18, Z
    62bc:	31 81       	ldd	r19, Z+1	; 0x01
    62be:	42 81       	ldd	r20, Z+2	; 0x02
    62c0:	53 81       	ldd	r21, Z+3	; 0x03
    62c2:	64 a1       	ldd	r22, Z+36	; 0x24
    62c4:	75 a1       	ldd	r23, Z+37	; 0x25
    62c6:	86 a1       	ldd	r24, Z+38	; 0x26
    62c8:	97 a1       	ldd	r25, Z+39	; 0x27
    62ca:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    62ce:	0e 94 9a 3e 	call	0x7d34	; 0x7d34 <lround>
    62d2:	46 2f       	mov	r20, r22
    62d4:	37 2f       	mov	r19, r23
    62d6:	28 2f       	mov	r18, r24
    62d8:	89 2f       	mov	r24, r25
    62da:	04 c0       	rjmp	.+8      	; 0x62e4 <limits_go_home+0x3de>
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
    62dc:	48 2d       	mov	r20, r8
    62de:	39 2d       	mov	r19, r9
    62e0:	2a 2d       	mov	r18, r10
    62e2:	8b 2d       	mov	r24, r11
    62e4:	f7 01       	movw	r30, r14
    62e6:	e9 59       	subi	r30, 0x99	; 153
    62e8:	f8 4f       	sbci	r31, 0xF8	; 248
          sys.position[B_MOTOR] = off_axis_position + set_axis_position;
        } else {
          sys.position[idx] = set_axis_position;
        }        
      #else 
        sys.position[idx] = set_axis_position;
    62ea:	45 83       	std	Z+5, r20	; 0x05
    62ec:	36 83       	std	Z+6, r19	; 0x06
    62ee:	27 83       	std	Z+7, r18	; 0x07
    62f0:	80 87       	std	Z+8, r24	; 0x08
    62f2:	0f 5f       	subi	r16, 0xFF	; 255
    62f4:	1f 4f       	sbci	r17, 0xFF	; 255
    62f6:	b4 e0       	ldi	r27, 0x04	; 4
    62f8:	eb 0e       	add	r14, r27
    62fa:	f1 1c       	adc	r15, r1
  #ifdef COREXY
    int32_t off_axis_position = 0;
  #endif
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    62fc:	03 30       	cpi	r16, 0x03	; 3
    62fe:	11 05       	cpc	r17, r1
    6300:	39 f6       	brne	.-114    	; 0x6290 <limits_go_home+0x38a>
        sys.position[idx] = set_axis_position;
      #endif

    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    6302:	0e 94 a6 2d 	call	0x5b4c	; 0x5b4c <plan_sync_position>

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    6306:	20 e0       	ldi	r18, 0x00	; 0
    6308:	30 e0       	ldi	r19, 0x00	; 0
    630a:	a9 01       	movw	r20, r18
    630c:	60 91 48 09 	lds	r22, 0x0948
    6310:	70 91 49 09 	lds	r23, 0x0949
    6314:	80 91 4a 09 	lds	r24, 0x094A
    6318:	90 91 4b 09 	lds	r25, 0x094B
    631c:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    6320:	18 16       	cp	r1, r24
    6322:	0c f0       	brlt	.+2      	; 0x6326 <limits_go_home+0x420>
    6324:	7d c0       	rjmp	.+250    	; 0x6420 <limits_go_home+0x51a>
    6326:	0f 2e       	mov	r0, r31
    6328:	f3 e2       	ldi	r31, 0x23	; 35
    632a:	cf 2e       	mov	r12, r31
    632c:	f9 e0       	ldi	r31, 0x09	; 9
    632e:	df 2e       	mov	r13, r31
    6330:	f0 2d       	mov	r31, r0
    6332:	ea a8       	ldd	r14, Y+50	; 0x32
    6334:	fb a8       	ldd	r15, Y+51	; 0x33
    6336:	00 e0       	ldi	r16, 0x00	; 0
    6338:	10 e0       	ldi	r17, 0x00	; 0
      if (cycle_mask & bit(idx)) {
        #ifdef HOMING_FORCE_SET_ORIGIN
          target[idx] = settings.homing_pulloff;  
          if ( bit_isfalse(settings.homing_dir_mask,bit(idx)) ) { target[idx] = -target[idx]; }     
        #else
          if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    633a:	0f 2e       	mov	r0, r31
    633c:	fd e3       	ldi	r31, 0x3D	; 61
    633e:	af 2e       	mov	r10, r31
    6340:	f9 e0       	ldi	r31, 0x09	; 9
    6342:	bf 2e       	mov	r11, r31
    6344:	f0 2d       	mov	r31, r0
            target[idx] = settings.homing_pulloff+settings.max_travel[idx];
          } else {
            target[idx] = -settings.homing_pulloff;
    6346:	0f 2e       	mov	r0, r31
    6348:	f8 e4       	ldi	r31, 0x48	; 72
    634a:	8f 2e       	mov	r8, r31
    634c:	f9 e0       	ldi	r31, 0x09	; 9
    634e:	9f 2e       	mov	r9, r31
    6350:	f0 2d       	mov	r31, r0
    6352:	68 a8       	ldd	r6, Y+48	; 0x30
    6354:	79 a8       	ldd	r7, Y+49	; 0x31
  plan_sync_position(); // Sync planner position to homed machine position.

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    for (idx=0; idx<N_AXIS; idx++) {
      if (cycle_mask & bit(idx)) {
    6356:	c3 01       	movw	r24, r6
    6358:	00 2e       	mov	r0, r16
    635a:	02 c0       	rjmp	.+4      	; 0x6360 <limits_go_home+0x45a>
    635c:	95 95       	asr	r25
    635e:	87 95       	ror	r24
    6360:	0a 94       	dec	r0
    6362:	e2 f7       	brpl	.-8      	; 0x635c <limits_go_home+0x456>
    6364:	80 ff       	sbrs	r24, 0
    6366:	2a c0       	rjmp	.+84     	; 0x63bc <limits_go_home+0x4b6>
        #ifdef HOMING_FORCE_SET_ORIGIN
          target[idx] = settings.homing_pulloff;  
          if ( bit_isfalse(settings.homing_dir_mask,bit(idx)) ) { target[idx] = -target[idx]; }     
        #else
          if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6368:	f5 01       	movw	r30, r10
    636a:	80 81       	ld	r24, Z
    636c:	90 e0       	ldi	r25, 0x00	; 0
    636e:	00 2e       	mov	r0, r16
    6370:	02 c0       	rjmp	.+4      	; 0x6376 <limits_go_home+0x470>
    6372:	95 95       	asr	r25
    6374:	87 95       	ror	r24
    6376:	0a 94       	dec	r0
    6378:	e2 f7       	brpl	.-8      	; 0x6372 <limits_go_home+0x46c>
    637a:	80 ff       	sbrs	r24, 0
    637c:	13 c0       	rjmp	.+38     	; 0x63a4 <limits_go_home+0x49e>
            target[idx] = settings.homing_pulloff+settings.max_travel[idx];
    637e:	d6 01       	movw	r26, r12
    6380:	2d 91       	ld	r18, X+
    6382:	3d 91       	ld	r19, X+
    6384:	4d 91       	ld	r20, X+
    6386:	5c 91       	ld	r21, X
    6388:	f4 01       	movw	r30, r8
    638a:	60 81       	ld	r22, Z
    638c:	71 81       	ldd	r23, Z+1	; 0x01
    638e:	82 81       	ldd	r24, Z+2	; 0x02
    6390:	93 81       	ldd	r25, Z+3	; 0x03
    6392:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    6396:	d7 01       	movw	r26, r14
    6398:	6d 93       	st	X+, r22
    639a:	7d 93       	st	X+, r23
    639c:	8d 93       	st	X+, r24
    639e:	9c 93       	st	X, r25
    63a0:	13 97       	sbiw	r26, 0x03	; 3
    63a2:	17 c0       	rjmp	.+46     	; 0x63d2 <limits_go_home+0x4cc>
          } else {
            target[idx] = -settings.homing_pulloff;
    63a4:	f4 01       	movw	r30, r8
    63a6:	80 81       	ld	r24, Z
    63a8:	91 81       	ldd	r25, Z+1	; 0x01
    63aa:	a2 81       	ldd	r26, Z+2	; 0x02
    63ac:	b3 81       	ldd	r27, Z+3	; 0x03
    63ae:	b0 58       	subi	r27, 0x80	; 128
    63b0:	f7 01       	movw	r30, r14
    63b2:	80 83       	st	Z, r24
    63b4:	91 83       	std	Z+1, r25	; 0x01
    63b6:	a2 83       	std	Z+2, r26	; 0x02
    63b8:	b3 83       	std	Z+3, r27	; 0x03
    63ba:	0b c0       	rjmp	.+22     	; 0x63d2 <limits_go_home+0x4cc>
          }
        #endif      
      } else {
        // Non-active cycle axis. Set target to not move during pull-off. 
        target[idx] = system_convert_axis_steps_to_mpos(sys.position, idx);
    63bc:	60 2f       	mov	r22, r16
    63be:	8c e6       	ldi	r24, 0x6C	; 108
    63c0:	97 e0       	ldi	r25, 0x07	; 7
    63c2:	0e 94 7c 3b 	call	0x76f8	; 0x76f8 <system_convert_axis_steps_to_mpos>
    63c6:	d7 01       	movw	r26, r14
    63c8:	6d 93       	st	X+, r22
    63ca:	7d 93       	st	X+, r23
    63cc:	8d 93       	st	X+, r24
    63ce:	9c 93       	st	X, r25
    63d0:	13 97       	sbiw	r26, 0x03	; 3
    63d2:	0f 5f       	subi	r16, 0xFF	; 255
    63d4:	1f 4f       	sbci	r17, 0xFF	; 255
    63d6:	b4 e0       	ldi	r27, 0x04	; 4
    63d8:	eb 0e       	add	r14, r27
    63da:	f1 1c       	adc	r15, r1
    63dc:	e4 e0       	ldi	r30, 0x04	; 4
    63de:	ce 0e       	add	r12, r30
    63e0:	d1 1c       	adc	r13, r1
  }
  plan_sync_position(); // Sync planner position to homed machine position.

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    for (idx=0; idx<N_AXIS; idx++) {
    63e2:	03 30       	cpi	r16, 0x03	; 3
    63e4:	11 05       	cpc	r17, r1
    63e6:	09 f0       	breq	.+2      	; 0x63ea <limits_go_home+0x4e4>
    63e8:	b6 cf       	rjmp	.-148    	; 0x6356 <limits_go_home+0x450>
      }
    }      
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, settings.homing_seek_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan motion.
    #else
      plan_buffer_line(target, settings.homing_seek_rate, false); // Bypass mc_line(). Directly plan motion.
    63ea:	40 91 42 09 	lds	r20, 0x0942
    63ee:	50 91 43 09 	lds	r21, 0x0943
    63f2:	60 91 44 09 	lds	r22, 0x0944
    63f6:	70 91 45 09 	lds	r23, 0x0945
    63fa:	20 e0       	ldi	r18, 0x00	; 0
    63fc:	ce 01       	movw	r24, r28
    63fe:	01 96       	adiw	r24, 0x01	; 1
    6400:	0e 94 8c 2a 	call	0x5518	; 0x5518 <plan_buffer_line>
    #endif
  
    // Initiate pull-off using main motion control routines. 
    // TODO : Clean up state routines so that this motion still shows homing state.
    sys.state = STATE_IDLE;
    6404:	10 92 68 07 	sts	0x0768, r1
    bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
    6408:	8f b7       	in	r24, 0x3f	; 63
    640a:	f8 94       	cli
    640c:	ea e6       	ldi	r30, 0x6A	; 106
    640e:	f7 e0       	ldi	r31, 0x07	; 7
    6410:	90 81       	ld	r25, Z
    6412:	92 60       	ori	r25, 0x02	; 2
    6414:	90 83       	st	Z, r25
    6416:	8f bf       	out	0x3f, r24	; 63
    protocol_execute_realtime();
    6418:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
    protocol_buffer_synchronize(); // Complete pull-off motion.
    641c:	0e 94 f0 1a 	call	0x35e0	; 0x35e0 <protocol_buffer_synchronize>
  }
  
  // Set system state to homing before returning. 
  sys.state = STATE_HOMING; 
    6420:	84 e0       	ldi	r24, 0x04	; 4
    6422:	80 93 68 07 	sts	0x0768, r24
    6426:	09 c0       	rjmp	.+18     	; 0x643a <limits_go_home+0x534>
    6428:	e0 e1       	ldi	r30, 0x10	; 16
    642a:	f0 e0       	ldi	r31, 0x00	; 0
    642c:	ec 0f       	add	r30, r28
    642e:	fd 1f       	adc	r31, r29
    6430:	e0 0f       	add	r30, r16
    6432:	f1 1f       	adc	r31, r17
          else { target[idx] -= max_travel; }
        }
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    6434:	80 81       	ld	r24, Z
    6436:	98 2a       	or	r9, r24
    6438:	a3 ce       	rjmp	.-698    	; 0x6180 <limits_go_home+0x27a>
    protocol_buffer_synchronize(); // Complete pull-off motion.
  }
  
  // Set system state to homing before returning. 
  sys.state = STATE_HOMING; 
}
    643a:	e3 96       	adiw	r28, 0x33	; 51
    643c:	0f b6       	in	r0, 0x3f	; 63
    643e:	f8 94       	cli
    6440:	de bf       	out	0x3e, r29	; 62
    6442:	0f be       	out	0x3f, r0	; 63
    6444:	cd bf       	out	0x3d, r28	; 61
    6446:	df 91       	pop	r29
    6448:	cf 91       	pop	r28
    644a:	1f 91       	pop	r17
    644c:	0f 91       	pop	r16
    644e:	ff 90       	pop	r15
    6450:	ef 90       	pop	r14
    6452:	df 90       	pop	r13
    6454:	cf 90       	pop	r12
    6456:	bf 90       	pop	r11
    6458:	af 90       	pop	r10
    645a:	9f 90       	pop	r9
    645c:	8f 90       	pop	r8
    645e:	7f 90       	pop	r7
    6460:	6f 90       	pop	r6
    6462:	5f 90       	pop	r5
    6464:	4f 90       	pop	r4
    6466:	3f 90       	pop	r3
    6468:	2f 90       	pop	r2
    646a:	08 95       	ret

0000646c <limits_soft_check>:


// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
    646c:	af 92       	push	r10
    646e:	bf 92       	push	r11
    6470:	cf 92       	push	r12
    6472:	df 92       	push	r13
    6474:	ef 92       	push	r14
    6476:	ff 92       	push	r15
    6478:	0f 93       	push	r16
    647a:	1f 93       	push	r17
    647c:	cf 93       	push	r28
    647e:	df 93       	push	r29
    6480:	ec 01       	movw	r28, r24
    6482:	03 e2       	ldi	r16, 0x23	; 35
    6484:	19 e0       	ldi	r17, 0x09	; 9
    6486:	0f 2e       	mov	r0, r31
    6488:	ff e2       	ldi	r31, 0x2F	; 47
    648a:	af 2e       	mov	r10, r31
    648c:	f9 e0       	ldi	r31, 0x09	; 9
    648e:	bf 2e       	mov	r11, r31
    6490:	f0 2d       	mov	r31, r0
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { soft_limit_error = true; }
      }
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { soft_limit_error = true; }
    6492:	c9 90       	ld	r12, Y+
    6494:	d9 90       	ld	r13, Y+
    6496:	e9 90       	ld	r14, Y+
    6498:	f9 90       	ld	r15, Y+
    649a:	20 e0       	ldi	r18, 0x00	; 0
    649c:	30 e0       	ldi	r19, 0x00	; 0
    649e:	a9 01       	movw	r20, r18
    64a0:	c7 01       	movw	r24, r14
    64a2:	b6 01       	movw	r22, r12
    64a4:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    64a8:	18 16       	cp	r1, r24
    64aa:	64 f0       	brlt	.+24     	; 0x64c4 <limits_soft_check+0x58>
    64ac:	f8 01       	movw	r30, r16
    64ae:	21 91       	ld	r18, Z+
    64b0:	31 91       	ld	r19, Z+
    64b2:	41 91       	ld	r20, Z+
    64b4:	51 91       	ld	r21, Z+
    64b6:	8f 01       	movw	r16, r30
    64b8:	c7 01       	movw	r24, r14
    64ba:	b6 01       	movw	r22, r12
    64bc:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    64c0:	88 23       	and	r24, r24
    64c2:	34 f5       	brge	.+76     	; 0x6510 <limits_soft_check+0xa4>
    
    if (soft_limit_error) {
      // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within 
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
    64c4:	80 91 68 07 	lds	r24, 0x0768
    64c8:	88 30       	cpi	r24, 0x08	; 8
    64ca:	a9 f4       	brne	.+42     	; 0x64f6 <limits_soft_check+0x8a>
        bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD);
    64cc:	8f b7       	in	r24, 0x3f	; 63
    64ce:	f8 94       	cli
    64d0:	ea e6       	ldi	r30, 0x6A	; 106
    64d2:	f7 e0       	ldi	r31, 0x07	; 7
    64d4:	90 81       	ld	r25, Z
    64d6:	98 60       	ori	r25, 0x08	; 8
    64d8:	90 83       	st	Z, r25
    64da:	8f bf       	out	0x3f, r24	; 63
        do {
          protocol_execute_realtime();
          if (sys.abort) { return; }
    64dc:	c7 e6       	ldi	r28, 0x67	; 103
    64de:	d7 e0       	ldi	r29, 0x07	; 7
        } while ( sys.state != STATE_IDLE );
    64e0:	08 e6       	ldi	r16, 0x68	; 104
    64e2:	17 e0       	ldi	r17, 0x07	; 7
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
        bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD);
        do {
          protocol_execute_realtime();
    64e4:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
          if (sys.abort) { return; }
    64e8:	88 81       	ld	r24, Y
    64ea:	81 11       	cpse	r24, r1
    64ec:	15 c0       	rjmp	.+42     	; 0x6518 <limits_soft_check+0xac>
        } while ( sys.state != STATE_IDLE );
    64ee:	f8 01       	movw	r30, r16
    64f0:	80 81       	ld	r24, Z
    64f2:	81 11       	cpse	r24, r1
    64f4:	f7 cf       	rjmp	.-18     	; 0x64e4 <limits_soft_check+0x78>
      }
    
      mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    64f6:	0e 94 a5 0c 	call	0x194a	; 0x194a <mc_reset>
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
    64fa:	8f b7       	in	r24, 0x3f	; 63
    64fc:	f8 94       	cli
    64fe:	eb e6       	ldi	r30, 0x6B	; 107
    6500:	f7 e0       	ldi	r31, 0x07	; 7
    6502:	90 81       	ld	r25, Z
    6504:	95 60       	ori	r25, 0x05	; 5
    6506:	90 83       	st	Z, r25
    6508:	8f bf       	out	0x3f, r24	; 63
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    650a:	0e 94 d7 18 	call	0x31ae	; 0x31ae <protocol_execute_realtime>
      return;
    650e:	04 c0       	rjmp	.+8      	; 0x6518 <limits_soft_check+0xac>
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
  uint8_t idx;
  uint8_t soft_limit_error = false;
  for (idx=0; idx<N_AXIS; idx++) {
    6510:	0a 15       	cp	r16, r10
    6512:	1b 05       	cpc	r17, r11
    6514:	09 f0       	breq	.+2      	; 0x6518 <limits_soft_check+0xac>
    6516:	bd cf       	rjmp	.-134    	; 0x6492 <limits_soft_check+0x26>
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
      return;
    }
  }
}
    6518:	df 91       	pop	r29
    651a:	cf 91       	pop	r28
    651c:	1f 91       	pop	r17
    651e:	0f 91       	pop	r16
    6520:	ff 90       	pop	r15
    6522:	ef 90       	pop	r14
    6524:	df 90       	pop	r13
    6526:	cf 90       	pop	r12
    6528:	bf 90       	pop	r11
    652a:	af 90       	pop	r10
    652c:	08 95       	ret

0000652e <printString>:

#include "grbl.h"


void printString(const char *s)
{
    652e:	cf 93       	push	r28
    6530:	df 93       	push	r29
    6532:	ec 01       	movw	r28, r24
  while (*s)
    6534:	88 81       	ld	r24, Y
    6536:	88 23       	and	r24, r24
    6538:	31 f0       	breq	.+12     	; 0x6546 <printString+0x18>
    653a:	21 96       	adiw	r28, 0x01	; 1
    serial_write(*s++);
    653c:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
#include "grbl.h"


void printString(const char *s)
{
  while (*s)
    6540:	89 91       	ld	r24, Y+
    6542:	81 11       	cpse	r24, r1
    6544:	fb cf       	rjmp	.-10     	; 0x653c <printString+0xe>
    serial_write(*s++);
}
    6546:	df 91       	pop	r29
    6548:	cf 91       	pop	r28
    654a:	08 95       	ret

0000654c <printPgmString>:


// Print a string stored in PGM-memory
void printPgmString(const char *s)
{
    654c:	cf 93       	push	r28
    654e:	df 93       	push	r29
  char c;
  while ((c = pgm_read_byte_near(s++)))
    6550:	ec 01       	movw	r28, r24
    6552:	21 96       	adiw	r28, 0x01	; 1
    6554:	fc 01       	movw	r30, r24
    6556:	84 91       	lpm	r24, Z
    6558:	88 23       	and	r24, r24
    655a:	39 f0       	breq	.+14     	; 0x656a <printPgmString+0x1e>
    serial_write(c);
    655c:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>

// Print a string stored in PGM-memory
void printPgmString(const char *s)
{
  char c;
  while ((c = pgm_read_byte_near(s++)))
    6560:	fe 01       	movw	r30, r28
    6562:	84 91       	lpm	r24, Z
    6564:	21 96       	adiw	r28, 0x01	; 1
    6566:	81 11       	cpse	r24, r1
    6568:	f9 cf       	rjmp	.-14     	; 0x655c <printPgmString+0x10>
    serial_write(c);
}
    656a:	df 91       	pop	r29
    656c:	cf 91       	pop	r28
    656e:	08 95       	ret

00006570 <print_uint8_base2>:
// 			'A' + buf[i - 1] - 10);
// }


void print_uint8_base2(uint8_t n)
{ 
    6570:	ef 92       	push	r14
    6572:	ff 92       	push	r15
    6574:	0f 93       	push	r16
    6576:	1f 93       	push	r17
    6578:	cf 93       	push	r28
    657a:	df 93       	push	r29
    657c:	cd b7       	in	r28, 0x3d	; 61
    657e:	de b7       	in	r29, 0x3e	; 62
    6580:	28 97       	sbiw	r28, 0x08	; 8
    6582:	0f b6       	in	r0, 0x3f	; 63
    6584:	f8 94       	cli
    6586:	de bf       	out	0x3e, r29	; 62
    6588:	0f be       	out	0x3f, r0	; 63
    658a:	cd bf       	out	0x3d, r28	; 61
    658c:	fe 01       	movw	r30, r28
    658e:	31 96       	adiw	r30, 0x01	; 1
    6590:	7f 01       	movw	r14, r30
    6592:	9e 01       	movw	r18, r28
    6594:	27 5f       	subi	r18, 0xF7	; 247
    6596:	3f 4f       	sbci	r19, 0xFF	; 255
	unsigned char buf[8];
	uint8_t i = 0;

	for (; i < 8; i++) {
		buf[i] = n & 1;
    6598:	98 2f       	mov	r25, r24
    659a:	91 70       	andi	r25, 0x01	; 1
    659c:	91 93       	st	Z+, r25
		n >>= 1;
    659e:	86 95       	lsr	r24
void print_uint8_base2(uint8_t n)
{ 
	unsigned char buf[8];
	uint8_t i = 0;

	for (; i < 8; i++) {
    65a0:	e2 17       	cp	r30, r18
    65a2:	f3 07       	cpc	r31, r19
    65a4:	c9 f7       	brne	.-14     	; 0x6598 <print_uint8_base2+0x28>
    65a6:	8e 01       	movw	r16, r28
    65a8:	07 5f       	subi	r16, 0xF7	; 247
    65aa:	1f 4f       	sbci	r17, 0xFF	; 255
		buf[i] = n & 1;
		n >>= 1;
	}

	for (; i > 0; i--)
		serial_write('0' + buf[i - 1]);
    65ac:	f8 01       	movw	r30, r16
    65ae:	82 91       	ld	r24, -Z
    65b0:	8f 01       	movw	r16, r30
    65b2:	80 5d       	subi	r24, 0xD0	; 208
    65b4:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
	for (; i < 8; i++) {
		buf[i] = n & 1;
		n >>= 1;
	}

	for (; i > 0; i--)
    65b8:	0e 15       	cp	r16, r14
    65ba:	1f 05       	cpc	r17, r15
    65bc:	b9 f7       	brne	.-18     	; 0x65ac <print_uint8_base2+0x3c>
		serial_write('0' + buf[i - 1]);
}
    65be:	28 96       	adiw	r28, 0x08	; 8
    65c0:	0f b6       	in	r0, 0x3f	; 63
    65c2:	f8 94       	cli
    65c4:	de bf       	out	0x3e, r29	; 62
    65c6:	0f be       	out	0x3f, r0	; 63
    65c8:	cd bf       	out	0x3d, r28	; 61
    65ca:	df 91       	pop	r29
    65cc:	cf 91       	pop	r28
    65ce:	1f 91       	pop	r17
    65d0:	0f 91       	pop	r16
    65d2:	ff 90       	pop	r15
    65d4:	ef 90       	pop	r14
    65d6:	08 95       	ret

000065d8 <print_uint8_base10>:


void print_uint8_base10(uint8_t n)
{ 
    65d8:	1f 93       	push	r17
    65da:	cf 93       	push	r28
    65dc:	df 93       	push	r29
    65de:	00 d0       	rcall	.+0      	; 0x65e0 <print_uint8_base10+0x8>
    65e0:	1f 92       	push	r1
    65e2:	cd b7       	in	r28, 0x3d	; 61
    65e4:	de b7       	in	r29, 0x3e	; 62
  if (n == 0) {
    65e6:	81 11       	cpse	r24, r1
    65e8:	04 c0       	rjmp	.+8      	; 0x65f2 <print_uint8_base10+0x1a>
    serial_write('0');
    65ea:	80 e3       	ldi	r24, 0x30	; 48
    65ec:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
    65f0:	28 c0       	rjmp	.+80     	; 0x6642 <print_uint8_base10+0x6a>
}


void print_uint8_base10(uint8_t n)
{ 
  if (n == 0) {
    65f2:	90 e0       	ldi	r25, 0x00	; 0

  unsigned char buf[3];
  uint8_t i = 0;

  while (n > 0) {
      buf[i++] = n % 10 + '0';
    65f4:	4d ec       	ldi	r20, 0xCD	; 205
    65f6:	11 e0       	ldi	r17, 0x01	; 1
    65f8:	19 0f       	add	r17, r25
    65fa:	e1 e0       	ldi	r30, 0x01	; 1
    65fc:	f0 e0       	ldi	r31, 0x00	; 0
    65fe:	ec 0f       	add	r30, r28
    6600:	fd 1f       	adc	r31, r29
    6602:	e9 0f       	add	r30, r25
    6604:	f1 1d       	adc	r31, r1
    6606:	84 9f       	mul	r24, r20
    6608:	91 2d       	mov	r25, r1
    660a:	11 24       	eor	r1, r1
    660c:	96 95       	lsr	r25
    660e:	96 95       	lsr	r25
    6610:	96 95       	lsr	r25
    6612:	29 2f       	mov	r18, r25
    6614:	22 0f       	add	r18, r18
    6616:	32 2f       	mov	r19, r18
    6618:	33 0f       	add	r19, r19
    661a:	33 0f       	add	r19, r19
    661c:	23 0f       	add	r18, r19
    661e:	82 1b       	sub	r24, r18
    6620:	80 5d       	subi	r24, 0xD0	; 208
    6622:	80 83       	st	Z, r24
      n /= 10;
    6624:	89 2f       	mov	r24, r25
  } 

  unsigned char buf[3];
  uint8_t i = 0;

  while (n > 0) {
    6626:	99 23       	and	r25, r25
    6628:	11 f0       	breq	.+4      	; 0x662e <print_uint8_base10+0x56>
      buf[i++] = n % 10 + '0';
    662a:	91 2f       	mov	r25, r17
    662c:	e4 cf       	rjmp	.-56     	; 0x65f6 <print_uint8_base10+0x1e>
      n /= 10;
  }

  for (; i > 0; i--)
    662e:	11 23       	and	r17, r17
    6630:	41 f0       	breq	.+16     	; 0x6642 <print_uint8_base10+0x6a>
      serial_write(buf[i - 1]);
    6632:	fe 01       	movw	r30, r28
    6634:	e1 0f       	add	r30, r17
    6636:	f1 1d       	adc	r31, r1
    6638:	80 81       	ld	r24, Z
    663a:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
  while (n > 0) {
      buf[i++] = n % 10 + '0';
      n /= 10;
  }

  for (; i > 0; i--)
    663e:	11 50       	subi	r17, 0x01	; 1
    6640:	c1 f7       	brne	.-16     	; 0x6632 <print_uint8_base10+0x5a>
      serial_write(buf[i - 1]);
}
    6642:	0f 90       	pop	r0
    6644:	0f 90       	pop	r0
    6646:	0f 90       	pop	r0
    6648:	df 91       	pop	r29
    664a:	cf 91       	pop	r28
    664c:	1f 91       	pop	r17
    664e:	08 95       	ret

00006650 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up 
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    6650:	8f 92       	push	r8
    6652:	9f 92       	push	r9
    6654:	af 92       	push	r10
    6656:	bf 92       	push	r11
    6658:	cf 92       	push	r12
    665a:	df 92       	push	r13
    665c:	ef 92       	push	r14
    665e:	ff 92       	push	r15
    6660:	0f 93       	push	r16
    6662:	1f 93       	push	r17
    6664:	cf 93       	push	r28
    6666:	df 93       	push	r29
    6668:	cd b7       	in	r28, 0x3d	; 61
    666a:	de b7       	in	r29, 0x3e	; 62
    666c:	2a 97       	sbiw	r28, 0x0a	; 10
    666e:	0f b6       	in	r0, 0x3f	; 63
    6670:	f8 94       	cli
    6672:	de bf       	out	0x3e, r29	; 62
    6674:	0f be       	out	0x3f, r0	; 63
    6676:	cd bf       	out	0x3d, r28	; 61
    6678:	6b 01       	movw	r12, r22
    667a:	7c 01       	movw	r14, r24
    667c:	14 2f       	mov	r17, r20
  if (n < 0) {
    667e:	20 e0       	ldi	r18, 0x00	; 0
    6680:	30 e0       	ldi	r19, 0x00	; 0
    6682:	a9 01       	movw	r20, r18
    6684:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__cmpsf2>
    6688:	88 23       	and	r24, r24
    668a:	3c f4       	brge	.+14     	; 0x669a <printFloat+0x4a>
    serial_write('-');
    668c:	8d e2       	ldi	r24, 0x2D	; 45
    668e:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
    n = -n;
    6692:	f7 fa       	bst	r15, 7
    6694:	f0 94       	com	r15
    6696:	f7 f8       	bld	r15, 7
    6698:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    669a:	12 30       	cpi	r17, 0x02	; 2
    669c:	88 f0       	brcs	.+34     	; 0x66c0 <printFloat+0x70>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    669e:	01 2f       	mov	r16, r17
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    66a0:	20 e0       	ldi	r18, 0x00	; 0
    66a2:	30 e0       	ldi	r19, 0x00	; 0
    66a4:	48 ec       	ldi	r20, 0xC8	; 200
    66a6:	52 e4       	ldi	r21, 0x42	; 66
    66a8:	c7 01       	movw	r24, r14
    66aa:	b6 01       	movw	r22, r12
    66ac:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    66b0:	6b 01       	movw	r12, r22
    66b2:	7c 01       	movw	r14, r24
    decimals -= 2;
    66b4:	02 50       	subi	r16, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    66b6:	02 30       	cpi	r16, 0x02	; 2
    66b8:	98 f7       	brcc	.-26     	; 0x66a0 <printFloat+0x50>
    66ba:	81 2f       	mov	r24, r17
    66bc:	81 70       	andi	r24, 0x01	; 1
    66be:	01 c0       	rjmp	.+2      	; 0x66c2 <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    66c0:	81 2f       	mov	r24, r17
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    66c2:	88 23       	and	r24, r24
    66c4:	51 f0       	breq	.+20     	; 0x66da <printFloat+0x8a>
    66c6:	20 e0       	ldi	r18, 0x00	; 0
    66c8:	30 e0       	ldi	r19, 0x00	; 0
    66ca:	40 e2       	ldi	r20, 0x20	; 32
    66cc:	51 e4       	ldi	r21, 0x41	; 65
    66ce:	c7 01       	movw	r24, r14
    66d0:	b6 01       	movw	r22, r12
    66d2:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    66d6:	6b 01       	movw	r12, r22
    66d8:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    66da:	20 e0       	ldi	r18, 0x00	; 0
    66dc:	30 e0       	ldi	r19, 0x00	; 0
    66de:	40 e0       	ldi	r20, 0x00	; 0
    66e0:	5f e3       	ldi	r21, 0x3F	; 63
    66e2:	c7 01       	movw	r24, r14
    66e4:	b6 01       	movw	r22, r12
    66e6:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
    66ea:	0e 94 fb 3c 	call	0x79f6	; 0x79f6 <__fixsfsi>
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
    66ee:	2e e2       	ldi	r18, 0x2E	; 46
    66f0:	fe 01       	movw	r30, r28
    66f2:	e1 0f       	add	r30, r17
    66f4:	f1 1d       	adc	r31, r1
    66f6:	21 83       	std	Z+1, r18	; 0x01
  while(a > 0) {
    66f8:	61 15       	cp	r22, r1
    66fa:	71 05       	cpc	r23, r1
    66fc:	81 05       	cpc	r24, r1
    66fe:	91 05       	cpc	r25, r1
    6700:	49 f1       	breq	.+82     	; 0x6754 <printFloat+0x104>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    6702:	20 e0       	ldi	r18, 0x00	; 0
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    6704:	01 e0       	ldi	r16, 0x01	; 1
    6706:	01 0f       	add	r16, r17
    buf[i++] = (a % 10) + '0'; // Get digit
    6708:	0f 2e       	mov	r0, r31
    670a:	fa e0       	ldi	r31, 0x0A	; 10
    670c:	8f 2e       	mov	r8, r31
    670e:	91 2c       	mov	r9, r1
    6710:	a1 2c       	mov	r10, r1
    6712:	b1 2c       	mov	r11, r1
    6714:	f0 2d       	mov	r31, r0
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    6716:	21 13       	cpse	r18, r17
    6718:	01 c0       	rjmp	.+2      	; 0x671c <printFloat+0xcc>
    671a:	20 2f       	mov	r18, r16
    buf[i++] = (a % 10) + '0'; // Get digit
    671c:	dd 24       	eor	r13, r13
    671e:	d3 94       	inc	r13
    6720:	d2 0e       	add	r13, r18
    6722:	ee 24       	eor	r14, r14
    6724:	e3 94       	inc	r14
    6726:	f1 2c       	mov	r15, r1
    6728:	ec 0e       	add	r14, r28
    672a:	fd 1e       	adc	r15, r29
    672c:	e2 0e       	add	r14, r18
    672e:	f1 1c       	adc	r15, r1
    6730:	a5 01       	movw	r20, r10
    6732:	94 01       	movw	r18, r8
    6734:	0e 94 b7 3f 	call	0x7f6e	; 0x7f6e <__udivmodsi4>
    6738:	60 5d       	subi	r22, 0xD0	; 208
    673a:	f7 01       	movw	r30, r14
    673c:	60 83       	st	Z, r22
    a /= 10;
    673e:	62 2f       	mov	r22, r18
    6740:	73 2f       	mov	r23, r19
    6742:	84 2f       	mov	r24, r20
    6744:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    6746:	61 15       	cp	r22, r1
    6748:	71 05       	cpc	r23, r1
    674a:	81 05       	cpc	r24, r1
    674c:	91 05       	cpc	r25, r1
    674e:	19 f0       	breq	.+6      	; 0x6756 <printFloat+0x106>
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    6750:	2d 2d       	mov	r18, r13
    6752:	e1 cf       	rjmp	.-62     	; 0x6716 <printFloat+0xc6>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    6754:	d1 2c       	mov	r13, r1
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    6756:	d1 16       	cp	r13, r17
    6758:	70 f4       	brcc	.+28     	; 0x6776 <printFloat+0x126>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    675a:	90 e3       	ldi	r25, 0x30	; 48
    675c:	81 e0       	ldi	r24, 0x01	; 1
    675e:	8d 0d       	add	r24, r13
    6760:	e1 e0       	ldi	r30, 0x01	; 1
    6762:	f0 e0       	ldi	r31, 0x00	; 0
    6764:	ec 0f       	add	r30, r28
    6766:	fd 1f       	adc	r31, r29
    6768:	ed 0d       	add	r30, r13
    676a:	f1 1d       	adc	r31, r1
    676c:	90 83       	st	Z, r25
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    676e:	81 17       	cp	r24, r17
    6770:	29 f0       	breq	.+10     	; 0x677c <printFloat+0x12c>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    6772:	d8 2e       	mov	r13, r24
    6774:	f3 cf       	rjmp	.-26     	; 0x675c <printFloat+0x10c>
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    6776:	1d 11       	cpse	r17, r13
    6778:	0b c0       	rjmp	.+22     	; 0x6790 <printFloat+0x140>
    677a:	1d 2d       	mov	r17, r13
    i++;
    buf[i++] = '0'; 
    677c:	68 94       	set
    677e:	dd 24       	eor	r13, r13
    6780:	d1 f8       	bld	r13, 1
    6782:	d1 0e       	add	r13, r17
  }
  while (i < decimal_places) { 
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    i++;
    6784:	1f 5f       	subi	r17, 0xFF	; 255
    buf[i++] = '0'; 
    6786:	fe 01       	movw	r30, r28
    6788:	e1 0f       	add	r30, r17
    678a:	f1 1d       	adc	r31, r1
    678c:	80 e3       	ldi	r24, 0x30	; 48
    678e:	81 83       	std	Z+1, r24	; 0x01
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    6790:	dd 20       	and	r13, r13
    6792:	41 f0       	breq	.+16     	; 0x67a4 <printFloat+0x154>
    serial_write(buf[i-1]);
    6794:	fe 01       	movw	r30, r28
    6796:	ed 0d       	add	r30, r13
    6798:	f1 1d       	adc	r31, r1
    679a:	80 81       	ld	r24, Z
    679c:	0e 94 0c 18 	call	0x3018	; 0x3018 <serial_write>
    i++;
    buf[i++] = '0'; 
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    67a0:	da 94       	dec	r13
    67a2:	c1 f7       	brne	.-16     	; 0x6794 <printFloat+0x144>
    serial_write(buf[i-1]);
}
    67a4:	2a 96       	adiw	r28, 0x0a	; 10
    67a6:	0f b6       	in	r0, 0x3f	; 63
    67a8:	f8 94       	cli
    67aa:	de bf       	out	0x3e, r29	; 62
    67ac:	0f be       	out	0x3f, r0	; 63
    67ae:	cd bf       	out	0x3d, r28	; 61
    67b0:	df 91       	pop	r29
    67b2:	cf 91       	pop	r28
    67b4:	1f 91       	pop	r17
    67b6:	0f 91       	pop	r16
    67b8:	ff 90       	pop	r15
    67ba:	ef 90       	pop	r14
    67bc:	df 90       	pop	r13
    67be:	cf 90       	pop	r12
    67c0:	bf 90       	pop	r11
    67c2:	af 90       	pop	r10
    67c4:	9f 90       	pop	r9
    67c6:	8f 90       	pop	r8
    67c8:	08 95       	ret

000067ca <printFloat_CoordValue>:
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
//  - SettingValue: Handles all floating point settings values (always in mm.)
void printFloat_CoordValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) { 
    67ca:	20 91 3c 09 	lds	r18, 0x093C
    67ce:	20 ff       	sbrs	r18, 0
    67d0:	0a c0       	rjmp	.+20     	; 0x67e6 <printFloat_CoordValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    67d2:	2b e8       	ldi	r18, 0x8B	; 139
    67d4:	32 e4       	ldi	r19, 0x42	; 66
    67d6:	41 e2       	ldi	r20, 0x21	; 33
    67d8:	5d e3       	ldi	r21, 0x3D	; 61
    67da:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    67de:	44 e0       	ldi	r20, 0x04	; 4
    67e0:	0e 94 28 33 	call	0x6650	; 0x6650 <printFloat>
    67e4:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    67e6:	43 e0       	ldi	r20, 0x03	; 3
    67e8:	0e 94 28 33 	call	0x6650	; 0x6650 <printFloat>
    67ec:	08 95       	ret

000067ee <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    67ee:	20 91 3c 09 	lds	r18, 0x093C
    67f2:	20 ff       	sbrs	r18, 0
    67f4:	0a c0       	rjmp	.+20     	; 0x680a <printFloat_RateValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    67f6:	2b e8       	ldi	r18, 0x8B	; 139
    67f8:	32 e4       	ldi	r19, 0x42	; 66
    67fa:	41 e2       	ldi	r20, 0x21	; 33
    67fc:	5d e3       	ldi	r21, 0x3D	; 61
    67fe:	0e 94 ca 3e 	call	0x7d94	; 0x7d94 <__mulsf3>
    6802:	41 e0       	ldi	r20, 0x01	; 1
    6804:	0e 94 28 33 	call	0x6650	; 0x6650 <printFloat>
    6808:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    680a:	40 e0       	ldi	r20, 0x00	; 0
    680c:	0e 94 28 33 	call	0x6650	; 0x6650 <printFloat>
    6810:	08 95       	ret

00006812 <printFloat_SettingValue>:
  }
}

void printFloat_SettingValue(float n) { printFloat(n,N_DECIMAL_SETTINGVALUE); }
    6812:	43 e0       	ldi	r20, 0x03	; 3
    6814:	0e 94 28 33 	call	0x6650	; 0x6650 <printFloat>
    6818:	08 95       	ret

0000681a <probe_init>:


// Probe pin initialization routine.
void probe_init() 
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    681a:	24 98       	cbi	0x04, 4	; 4
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    681c:	2c 9a       	sbi	0x05, 4	; 5
    681e:	08 95       	ret

00006820 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to 
// appropriately set the pin logic according to setting for normal-high/normal-low operation 
// and the probing cycle modes for toward-workpiece/away-from-workpiece. 
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    6820:	10 92 54 09 	sts	0x0954, r1
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    6824:	90 91 3c 09 	lds	r25, 0x093C
    6828:	99 23       	and	r25, r25
    682a:	1c f0       	brlt	.+6      	; 0x6832 <probe_configure_invert_mask+0x12>
    682c:	90 e1       	ldi	r25, 0x10	; 16
    682e:	90 93 54 09 	sts	0x0954, r25
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    6832:	88 23       	and	r24, r24
    6834:	31 f0       	breq	.+12     	; 0x6842 <probe_configure_invert_mask+0x22>
    6836:	90 91 54 09 	lds	r25, 0x0954
    683a:	80 e1       	ldi	r24, 0x10	; 16
    683c:	89 27       	eor	r24, r25
    683e:	80 93 54 09 	sts	0x0954, r24
    6842:	08 95       	ret

00006844 <probe_get_state>:
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    6844:	83 b1       	in	r24, 0x03	; 3
    6846:	80 71       	andi	r24, 0x10	; 16
    6848:	90 91 54 09 	lds	r25, 0x0954
    684c:	89 27       	eor	r24, r25
    684e:	08 95       	ret

00006850 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (sys.probe_state == PROBE_ACTIVE) {
    6850:	80 91 79 07 	lds	r24, 0x0779
    6854:	81 30       	cpi	r24, 0x01	; 1
    6856:	a1 f4       	brne	.+40     	; 0x6880 <probe_state_monitor+0x30>
    if (probe_get_state()) {
    6858:	0e 94 22 34 	call	0x6844	; 0x6844 <probe_get_state>
    685c:	88 23       	and	r24, r24
    685e:	81 f0       	breq	.+32     	; 0x6880 <probe_state_monitor+0x30>
      sys.probe_state = PROBE_OFF;
    6860:	10 92 79 07 	sts	0x0779, r1
      memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS);
    6864:	8c e0       	ldi	r24, 0x0C	; 12
    6866:	ec e6       	ldi	r30, 0x6C	; 108
    6868:	f7 e0       	ldi	r31, 0x07	; 7
    686a:	aa e7       	ldi	r26, 0x7A	; 122
    686c:	b7 e0       	ldi	r27, 0x07	; 7
    686e:	01 90       	ld	r0, Z+
    6870:	0d 92       	st	X+, r0
    6872:	8a 95       	dec	r24
    6874:	e1 f7       	brne	.-8      	; 0x686e <probe_state_monitor+0x1e>
      bit_true(sys.rt_exec_state, EXEC_MOTION_CANCEL);
    6876:	ea e6       	ldi	r30, 0x6A	; 106
    6878:	f7 e0       	ldi	r31, 0x07	; 7
    687a:	80 81       	ld	r24, Z
    687c:	80 64       	ori	r24, 0x40	; 64
    687e:	80 83       	st	Z, r24
    6880:	08 95       	ret

00006882 <report_status_message>:
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
// NOTE: In silent mode, all error codes are greater than zero.
// TODO: Install silent mode to return only numeric values, primarily for GUIs.
void report_status_message(uint8_t status_code) 
{
    6882:	cf 93       	push	r28
    6884:	c8 2f       	mov	r28, r24
  if (status_code == 0) { // STATUS_OK
    6886:	81 11       	cpse	r24, r1
    6888:	05 c0       	rjmp	.+10     	; 0x6894 <report_status_message+0x12>
    printPgmString(PSTR("ok\r\n"));
    688a:	80 eb       	ldi	r24, 0xB0	; 176
    688c:	99 e0       	ldi	r25, 0x09	; 9
    688e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6892:	66 c0       	rjmp	.+204    	; 0x6960 <report_status_message+0xde>
  } else {
    printPgmString(PSTR("error: "));
    6894:	88 ea       	ldi	r24, 0xA8	; 168
    6896:	99 e0       	ldi	r25, 0x09	; 9
    6898:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    switch(status_code) {          
    689c:	4c 2f       	mov	r20, r28
    689e:	50 e0       	ldi	r21, 0x00	; 0
    68a0:	fa 01       	movw	r30, r20
    68a2:	31 97       	sbiw	r30, 0x01	; 1
    68a4:	e6 31       	cpi	r30, 0x16	; 22
    68a6:	f1 05       	cpc	r31, r1
    68a8:	08 f0       	brcs	.+2      	; 0x68ac <report_status_message+0x2a>
    68aa:	4f c0       	rjmp	.+158    	; 0x694a <report_status_message+0xc8>
    68ac:	e5 50       	subi	r30, 0x05	; 5
    68ae:	ff 4f       	sbci	r31, 0xFF	; 255
    68b0:	0c 94 d9 3f 	jmp	0x7fb2	; 0x7fb2 <__tablejump2__>
      case STATUS_EXPECTED_COMMAND_LETTER:
      printPgmString(PSTR("Expected command letter")); break;
    68b4:	80 e9       	ldi	r24, 0x90	; 144
    68b6:	99 e0       	ldi	r25, 0x09	; 9
    68b8:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    68bc:	4d c0       	rjmp	.+154    	; 0x6958 <report_status_message+0xd6>
      case STATUS_BAD_NUMBER_FORMAT:
      printPgmString(PSTR("Bad number format")); break;
    68be:	8e e7       	ldi	r24, 0x7E	; 126
    68c0:	99 e0       	ldi	r25, 0x09	; 9
    68c2:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    68c6:	48 c0       	rjmp	.+144    	; 0x6958 <report_status_message+0xd6>
      case STATUS_INVALID_STATEMENT:
      printPgmString(PSTR("Invalid statement")); break;
    68c8:	8c e6       	ldi	r24, 0x6C	; 108
    68ca:	99 e0       	ldi	r25, 0x09	; 9
    68cc:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    68d0:	43 c0       	rjmp	.+134    	; 0x6958 <report_status_message+0xd6>
      case STATUS_NEGATIVE_VALUE:
      printPgmString(PSTR("Value < 0")); break;
    68d2:	82 e6       	ldi	r24, 0x62	; 98
    68d4:	99 e0       	ldi	r25, 0x09	; 9
    68d6:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    68da:	3e c0       	rjmp	.+124    	; 0x6958 <report_status_message+0xd6>
      case STATUS_SETTING_DISABLED:
      printPgmString(PSTR("Setting disabled")); break;
    68dc:	81 e5       	ldi	r24, 0x51	; 81
    68de:	99 e0       	ldi	r25, 0x09	; 9
    68e0:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    68e4:	39 c0       	rjmp	.+114    	; 0x6958 <report_status_message+0xd6>
      case STATUS_SETTING_STEP_PULSE_MIN:
      printPgmString(PSTR("Value < 3 usec")); break;
    68e6:	82 e4       	ldi	r24, 0x42	; 66
    68e8:	99 e0       	ldi	r25, 0x09	; 9
    68ea:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    68ee:	34 c0       	rjmp	.+104    	; 0x6958 <report_status_message+0xd6>
      case STATUS_SETTING_READ_FAIL:
      printPgmString(PSTR("EEPROM read fail. Using defaults")); break;
    68f0:	81 e2       	ldi	r24, 0x21	; 33
    68f2:	99 e0       	ldi	r25, 0x09	; 9
    68f4:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    68f8:	2f c0       	rjmp	.+94     	; 0x6958 <report_status_message+0xd6>
      case STATUS_IDLE_ERROR:
      printPgmString(PSTR("Not idle")); break;
    68fa:	88 e1       	ldi	r24, 0x18	; 24
    68fc:	99 e0       	ldi	r25, 0x09	; 9
    68fe:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6902:	2a c0       	rjmp	.+84     	; 0x6958 <report_status_message+0xd6>
      case STATUS_ALARM_LOCK:
      printPgmString(PSTR("Alarm lock")); break;
    6904:	8d e0       	ldi	r24, 0x0D	; 13
    6906:	99 e0       	ldi	r25, 0x09	; 9
    6908:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    690c:	25 c0       	rjmp	.+74     	; 0x6958 <report_status_message+0xd6>
      case STATUS_SOFT_LIMIT_ERROR:
      printPgmString(PSTR("Homing not enabled")); break;
    690e:	8a ef       	ldi	r24, 0xFA	; 250
    6910:	98 e0       	ldi	r25, 0x08	; 8
    6912:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6916:	20 c0       	rjmp	.+64     	; 0x6958 <report_status_message+0xd6>
      case STATUS_OVERFLOW:
      printPgmString(PSTR("Line overflow")); break; 
    6918:	8c ee       	ldi	r24, 0xEC	; 236
    691a:	98 e0       	ldi	r25, 0x08	; 8
    691c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6920:	1b c0       	rjmp	.+54     	; 0x6958 <report_status_message+0xd6>
      // case STATUS_MAX_STEP_RATE_EXCEEDED: 
      // printPgmString(PSTR("Step rate > 30kHz")); break;
      case STATUS_JOG_ONGOING_LOCK:
	  printPgmString(PSTR("Jogging ongoing; Ignoring GCode")); break;
    6922:	8c ec       	ldi	r24, 0xCC	; 204
    6924:	98 e0       	ldi	r25, 0x08	; 8
    6926:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    692a:	16 c0       	rjmp	.+44     	; 0x6958 <report_status_message+0xd6>
	  
      // Common g-code parser errors.
      case STATUS_GCODE_MODAL_GROUP_VIOLATION:
      printPgmString(PSTR("Modal group violation")); break;
    692c:	86 eb       	ldi	r24, 0xB6	; 182
    692e:	98 e0       	ldi	r25, 0x08	; 8
    6930:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6934:	11 c0       	rjmp	.+34     	; 0x6958 <report_status_message+0xd6>
      case STATUS_GCODE_UNSUPPORTED_COMMAND:
      printPgmString(PSTR("Unsupported command")); break;
    6936:	82 ea       	ldi	r24, 0xA2	; 162
    6938:	98 e0       	ldi	r25, 0x08	; 8
    693a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    693e:	0c c0       	rjmp	.+24     	; 0x6958 <report_status_message+0xd6>
      case STATUS_GCODE_UNDEFINED_FEED_RATE:
      printPgmString(PSTR("Undefined feed rate")); break;
    6940:	8e e8       	ldi	r24, 0x8E	; 142
    6942:	98 e0       	ldi	r25, 0x08	; 8
    6944:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6948:	07 c0       	rjmp	.+14     	; 0x6958 <report_status_message+0xd6>
      default:
        // Remaining g-code parser errors with error codes
        printPgmString(PSTR("Invalid gcode ID:"));
    694a:	8c e7       	ldi	r24, 0x7C	; 124
    694c:	98 e0       	ldi	r25, 0x08	; 8
    694e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
        print_uint8_base10(status_code); // Print error code for user reference
    6952:	8c 2f       	mov	r24, r28
    6954:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
    }
    printPgmString(PSTR("\r\n"));
    6958:	89 e7       	ldi	r24, 0x79	; 121
    695a:	98 e0       	ldi	r25, 0x08	; 8
    695c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }
}
    6960:	cf 91       	pop	r28
    6962:	08 95       	ret

00006964 <report_alarm_message>:

// Prints alarm messages.
void report_alarm_message(int8_t alarm_code)
{
    6964:	cf 93       	push	r28
    6966:	c8 2f       	mov	r28, r24
  printPgmString(PSTR("ALARM: "));
    6968:	81 e7       	ldi	r24, 0x71	; 113
    696a:	98 e0       	ldi	r25, 0x08	; 8
    696c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  switch (alarm_code) {
    6970:	cd 3f       	cpi	r28, 0xFD	; 253
    6972:	91 f0       	breq	.+36     	; 0x6998 <report_alarm_message+0x34>
    6974:	1c f4       	brge	.+6      	; 0x697c <report_alarm_message+0x18>
    6976:	cc 3f       	cpi	r28, 0xFC	; 252
    6978:	a1 f0       	breq	.+40     	; 0x69a2 <report_alarm_message+0x3e>
    697a:	17 c0       	rjmp	.+46     	; 0x69aa <report_alarm_message+0x46>
    697c:	ce 3f       	cpi	r28, 0xFE	; 254
    697e:	39 f0       	breq	.+14     	; 0x698e <report_alarm_message+0x2a>
    6980:	cf 3f       	cpi	r28, 0xFF	; 255
    6982:	99 f4       	brne	.+38     	; 0x69aa <report_alarm_message+0x46>
    case ALARM_HARD_LIMIT_ERROR: 
    printPgmString(PSTR("Hard limit")); break;
    6984:	86 e6       	ldi	r24, 0x66	; 102
    6986:	98 e0       	ldi	r25, 0x08	; 8
    6988:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    698c:	0e c0       	rjmp	.+28     	; 0x69aa <report_alarm_message+0x46>
    case ALARM_SOFT_LIMIT_ERROR:
    printPgmString(PSTR("Soft limit")); break;
    698e:	8b e5       	ldi	r24, 0x5B	; 91
    6990:	98 e0       	ldi	r25, 0x08	; 8
    6992:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6996:	09 c0       	rjmp	.+18     	; 0x69aa <report_alarm_message+0x46>
    case ALARM_ABORT_CYCLE: 
    printPgmString(PSTR("Abort during cycle")); break;
    6998:	88 e4       	ldi	r24, 0x48	; 72
    699a:	98 e0       	ldi	r25, 0x08	; 8
    699c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    69a0:	04 c0       	rjmp	.+8      	; 0x69aa <report_alarm_message+0x46>
    case ALARM_PROBE_FAIL:
    printPgmString(PSTR("Probe fail")); break;
    69a2:	8d e3       	ldi	r24, 0x3D	; 61
    69a4:	98 e0       	ldi	r25, 0x08	; 8
    69a6:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }
  printPgmString(PSTR("\r\n"));
    69aa:	8a e3       	ldi	r24, 0x3A	; 58
    69ac:	98 e0       	ldi	r25, 0x08	; 8
    69ae:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  delay_ms(500); // Force delay to ensure message clears serial write buffer.
    69b2:	84 ef       	ldi	r24, 0xF4	; 244
    69b4:	91 e0       	ldi	r25, 0x01	; 1
    69b6:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <delay_ms>
}
    69ba:	cf 91       	pop	r28
    69bc:	08 95       	ret

000069be <report_feedback_message>:
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
// TODO: Install silence feedback messages option in settings
void report_feedback_message(uint8_t message_code)
{
    69be:	cf 93       	push	r28
    69c0:	c8 2f       	mov	r28, r24
  printPgmString(PSTR("["));
    69c2:	88 e3       	ldi	r24, 0x38	; 56
    69c4:	98 e0       	ldi	r25, 0x08	; 8
    69c6:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  switch(message_code) {
    69ca:	c3 30       	cpi	r28, 0x03	; 3
    69cc:	b1 f0       	breq	.+44     	; 0x69fa <report_feedback_message+0x3c>
    69ce:	28 f4       	brcc	.+10     	; 0x69da <report_feedback_message+0x1c>
    69d0:	c1 30       	cpi	r28, 0x01	; 1
    69d2:	49 f0       	breq	.+18     	; 0x69e6 <report_feedback_message+0x28>
    69d4:	c2 30       	cpi	r28, 0x02	; 2
    69d6:	61 f0       	breq	.+24     	; 0x69f0 <report_feedback_message+0x32>
    69d8:	23 c0       	rjmp	.+70     	; 0x6a20 <report_feedback_message+0x62>
    69da:	c5 30       	cpi	r28, 0x05	; 5
    69dc:	c1 f0       	breq	.+48     	; 0x6a0e <report_feedback_message+0x50>
    69de:	90 f0       	brcs	.+36     	; 0x6a04 <report_feedback_message+0x46>
    69e0:	c6 30       	cpi	r28, 0x06	; 6
    69e2:	d1 f0       	breq	.+52     	; 0x6a18 <report_feedback_message+0x5a>
    69e4:	1d c0       	rjmp	.+58     	; 0x6a20 <report_feedback_message+0x62>
    case MESSAGE_CRITICAL_EVENT:
    printPgmString(PSTR("Reset to continue")); break;
    69e6:	86 e2       	ldi	r24, 0x26	; 38
    69e8:	98 e0       	ldi	r25, 0x08	; 8
    69ea:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    69ee:	18 c0       	rjmp	.+48     	; 0x6a20 <report_feedback_message+0x62>
    case MESSAGE_ALARM_LOCK:
    printPgmString(PSTR("'$H'|'$X' to unlock")); break;
    69f0:	82 e1       	ldi	r24, 0x12	; 18
    69f2:	98 e0       	ldi	r25, 0x08	; 8
    69f4:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    69f8:	13 c0       	rjmp	.+38     	; 0x6a20 <report_feedback_message+0x62>
    case MESSAGE_ALARM_UNLOCK:
    printPgmString(PSTR("Caution: Unlocked")); break;
    69fa:	80 e0       	ldi	r24, 0x00	; 0
    69fc:	98 e0       	ldi	r25, 0x08	; 8
    69fe:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a02:	0e c0       	rjmp	.+28     	; 0x6a20 <report_feedback_message+0x62>
    case MESSAGE_ENABLED:
    printPgmString(PSTR("Enabled")); break;
    6a04:	88 ef       	ldi	r24, 0xF8	; 248
    6a06:	97 e0       	ldi	r25, 0x07	; 7
    6a08:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a0c:	09 c0       	rjmp	.+18     	; 0x6a20 <report_feedback_message+0x62>
    case MESSAGE_DISABLED:
    printPgmString(PSTR("Disabled")); break; 
    6a0e:	8f ee       	ldi	r24, 0xEF	; 239
    6a10:	97 e0       	ldi	r25, 0x07	; 7
    6a12:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a16:	04 c0       	rjmp	.+8      	; 0x6a20 <report_feedback_message+0x62>
    case MESSAGE_SAFETY_DOOR_AJAR:
    printPgmString(PSTR("Check Door")); break;
    6a18:	84 ee       	ldi	r24, 0xE4	; 228
    6a1a:	97 e0       	ldi	r25, 0x07	; 7
    6a1c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }
  printPgmString(PSTR("]\r\n"));
    6a20:	80 ee       	ldi	r24, 0xE0	; 224
    6a22:	97 e0       	ldi	r25, 0x07	; 7
    6a24:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
}
    6a28:	cf 91       	pop	r28
    6a2a:	08 95       	ret

00006a2c <report_init_message>:


// Welcome message
void report_init_message()
{
  printPgmString(PSTR("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n"));
    6a2c:	8a eb       	ldi	r24, 0xBA	; 186
    6a2e:	97 e0       	ldi	r25, 0x07	; 7
    6a30:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a34:	08 95       	ret

00006a36 <report_grbl_help>:
}

// Grbl help message
void report_grbl_help() {
  printPgmString(PSTR("$$ (view Grbl settings)\r\n"
    6a36:	86 e7       	ldi	r24, 0x76	; 118
    6a38:	96 e0       	ldi	r25, 0x06	; 6
    6a3a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a3e:	08 95       	ret

00006a40 <report_grbl_settings>:
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6a40:	cf 92       	push	r12
    6a42:	df 92       	push	r13
    6a44:	ef 92       	push	r14
    6a46:	ff 92       	push	r15
    6a48:	0f 93       	push	r16
    6a4a:	1f 93       	push	r17
    6a4c:	cf 93       	push	r28
    6a4e:	df 93       	push	r29
  // Print Grbl settings.
  printPgmString(PSTR("$0=")); print_uint8_base10(settings.pulse_microseconds);
    6a50:	82 e7       	ldi	r24, 0x72	; 114
    6a52:	96 e0       	ldi	r25, 0x06	; 6
    6a54:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a58:	80 91 2f 09 	lds	r24, 0x092F
    6a5c:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (step pulse, usec)\r\n$1=")); print_uint8_base10(settings.stepper_idle_lock_time);
    6a60:	89 e5       	ldi	r24, 0x59	; 89
    6a62:	96 e0       	ldi	r25, 0x06	; 6
    6a64:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a68:	80 91 32 09 	lds	r24, 0x0932
    6a6c:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (step idle delay, msec)\r\n$2=")); print_uint8_base10(settings.step_invert_mask); 
    6a70:	8b e3       	ldi	r24, 0x3B	; 59
    6a72:	96 e0       	ldi	r25, 0x06	; 6
    6a74:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a78:	c0 e3       	ldi	r28, 0x30	; 48
    6a7a:	d9 e0       	ldi	r29, 0x09	; 9
    6a7c:	88 81       	ld	r24, Y
    6a7e:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (step port invert mask:")); print_uint8_base2(settings.step_invert_mask);  
    6a82:	82 e2       	ldi	r24, 0x22	; 34
    6a84:	96 e0       	ldi	r25, 0x06	; 6
    6a86:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a8a:	88 81       	ld	r24, Y
    6a8c:	0e 94 b8 32 	call	0x6570	; 0x6570 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$3=")); print_uint8_base10(settings.dir_invert_mask); 
    6a90:	8b e1       	ldi	r24, 0x1B	; 27
    6a92:	96 e0       	ldi	r25, 0x06	; 6
    6a94:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6a98:	c1 e3       	ldi	r28, 0x31	; 49
    6a9a:	d9 e0       	ldi	r29, 0x09	; 9
    6a9c:	88 81       	ld	r24, Y
    6a9e:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (dir port invert mask:")); print_uint8_base2(settings.dir_invert_mask);  
    6aa2:	83 e0       	ldi	r24, 0x03	; 3
    6aa4:	96 e0       	ldi	r25, 0x06	; 6
    6aa6:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6aaa:	88 81       	ld	r24, Y
    6aac:	0e 94 b8 32 	call	0x6570	; 0x6570 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$4=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
    6ab0:	8c ef       	ldi	r24, 0xFC	; 252
    6ab2:	95 e0       	ldi	r25, 0x05	; 5
    6ab4:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6ab8:	cc e3       	ldi	r28, 0x3C	; 60
    6aba:	d9 e0       	ldi	r29, 0x09	; 9
    6abc:	88 81       	ld	r24, Y
    6abe:	82 fb       	bst	r24, 2
    6ac0:	88 27       	eor	r24, r24
    6ac2:	80 f9       	bld	r24, 0
    6ac4:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (step enable invert, bool)\r\n$5=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
    6ac8:	8b ed       	ldi	r24, 0xDB	; 219
    6aca:	95 e0       	ldi	r25, 0x05	; 5
    6acc:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6ad0:	88 81       	ld	r24, Y
    6ad2:	86 fb       	bst	r24, 6
    6ad4:	88 27       	eor	r24, r24
    6ad6:	80 f9       	bld	r24, 0
    6ad8:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (limit pins invert, bool)\r\n$6=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
    6adc:	8b eb       	ldi	r24, 0xBB	; 187
    6ade:	95 e0       	ldi	r25, 0x05	; 5
    6ae0:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6ae4:	88 81       	ld	r24, Y
    6ae6:	88 1f       	adc	r24, r24
    6ae8:	88 27       	eor	r24, r24
    6aea:	88 1f       	adc	r24, r24
    6aec:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (probe pin invert, bool)\r\n$10=")); print_uint8_base10(settings.status_report_mask);
    6af0:	8b e9       	ldi	r24, 0x9B	; 155
    6af2:	95 e0       	ldi	r25, 0x05	; 5
    6af4:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6af8:	03 e3       	ldi	r16, 0x33	; 51
    6afa:	19 e0       	ldi	r17, 0x09	; 9
    6afc:	f8 01       	movw	r30, r16
    6afe:	80 81       	ld	r24, Z
    6b00:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (status report mask:")); print_uint8_base2(settings.status_report_mask);
    6b04:	85 e8       	ldi	r24, 0x85	; 133
    6b06:	95 e0       	ldi	r25, 0x05	; 5
    6b08:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6b0c:	f8 01       	movw	r30, r16
    6b0e:	80 81       	ld	r24, Z
    6b10:	0e 94 b8 32 	call	0x6570	; 0x6570 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$11=")); printFloat_SettingValue(settings.junction_deviation);
    6b14:	8d e7       	ldi	r24, 0x7D	; 125
    6b16:	95 e0       	ldi	r25, 0x05	; 5
    6b18:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6b1c:	60 91 34 09 	lds	r22, 0x0934
    6b20:	70 91 35 09 	lds	r23, 0x0935
    6b24:	80 91 36 09 	lds	r24, 0x0936
    6b28:	90 91 37 09 	lds	r25, 0x0937
    6b2c:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
  printPgmString(PSTR(" (junction deviation, mm)\r\n$12=")); printFloat_SettingValue(settings.arc_tolerance);
    6b30:	8d e5       	ldi	r24, 0x5D	; 93
    6b32:	95 e0       	ldi	r25, 0x05	; 5
    6b34:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6b38:	60 91 38 09 	lds	r22, 0x0938
    6b3c:	70 91 39 09 	lds	r23, 0x0939
    6b40:	80 91 3a 09 	lds	r24, 0x093A
    6b44:	90 91 3b 09 	lds	r25, 0x093B
    6b48:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
  printPgmString(PSTR(" (arc tolerance, mm)\r\n$13=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
    6b4c:	82 e4       	ldi	r24, 0x42	; 66
    6b4e:	95 e0       	ldi	r25, 0x05	; 5
    6b50:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6b54:	88 81       	ld	r24, Y
    6b56:	81 70       	andi	r24, 0x01	; 1
    6b58:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (report inches, bool)\r\n$20=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
    6b5c:	85 e2       	ldi	r24, 0x25	; 37
    6b5e:	95 e0       	ldi	r25, 0x05	; 5
    6b60:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6b64:	88 81       	ld	r24, Y
    6b66:	85 fb       	bst	r24, 5
    6b68:	88 27       	eor	r24, r24
    6b6a:	80 f9       	bld	r24, 0
    6b6c:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (soft limits, bool)\r\n$21=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
    6b70:	8a e0       	ldi	r24, 0x0A	; 10
    6b72:	95 e0       	ldi	r25, 0x05	; 5
    6b74:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6b78:	88 81       	ld	r24, Y
    6b7a:	83 fb       	bst	r24, 3
    6b7c:	88 27       	eor	r24, r24
    6b7e:	80 f9       	bld	r24, 0
    6b80:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (hard limits, bool)\r\n$22=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
    6b84:	8f ee       	ldi	r24, 0xEF	; 239
    6b86:	94 e0       	ldi	r25, 0x04	; 4
    6b88:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6b8c:	88 81       	ld	r24, Y
    6b8e:	82 95       	swap	r24
    6b90:	81 70       	andi	r24, 0x01	; 1
    6b92:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (homing cycle, bool)\r\n$23=")); print_uint8_base10(settings.homing_dir_mask);
    6b96:	83 ed       	ldi	r24, 0xD3	; 211
    6b98:	94 e0       	ldi	r25, 0x04	; 4
    6b9a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6b9e:	cd e3       	ldi	r28, 0x3D	; 61
    6ba0:	d9 e0       	ldi	r29, 0x09	; 9
    6ba2:	88 81       	ld	r24, Y
    6ba4:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (homing dir invert mask:")); print_uint8_base2(settings.homing_dir_mask);  
    6ba8:	89 eb       	ldi	r24, 0xB9	; 185
    6baa:	94 e0       	ldi	r25, 0x04	; 4
    6bac:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6bb0:	88 81       	ld	r24, Y
    6bb2:	0e 94 b8 32 	call	0x6570	; 0x6570 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$24=")); printFloat_SettingValue(settings.homing_feed_rate);
    6bb6:	81 eb       	ldi	r24, 0xB1	; 177
    6bb8:	94 e0       	ldi	r25, 0x04	; 4
    6bba:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6bbe:	60 91 3e 09 	lds	r22, 0x093E
    6bc2:	70 91 3f 09 	lds	r23, 0x093F
    6bc6:	80 91 40 09 	lds	r24, 0x0940
    6bca:	90 91 41 09 	lds	r25, 0x0941
    6bce:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing feed, mm/min)\r\n$25=")); printFloat_SettingValue(settings.homing_seek_rate);
    6bd2:	84 e9       	ldi	r24, 0x94	; 148
    6bd4:	94 e0       	ldi	r25, 0x04	; 4
    6bd6:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6bda:	60 91 42 09 	lds	r22, 0x0942
    6bde:	70 91 43 09 	lds	r23, 0x0943
    6be2:	80 91 44 09 	lds	r24, 0x0944
    6be6:	90 91 45 09 	lds	r25, 0x0945
    6bea:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing seek, mm/min)\r\n$26=")); print_uint8_base10(settings.homing_debounce_delay);
    6bee:	87 e7       	ldi	r24, 0x77	; 119
    6bf0:	94 e0       	ldi	r25, 0x04	; 4
    6bf2:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6bf6:	80 91 46 09 	lds	r24, 0x0946
    6bfa:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR(" (homing debounce, msec)\r\n$27=")); printFloat_SettingValue(settings.homing_pulloff);
    6bfe:	88 e5       	ldi	r24, 0x58	; 88
    6c00:	94 e0       	ldi	r25, 0x04	; 4
    6c02:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6c06:	60 91 48 09 	lds	r22, 0x0948
    6c0a:	70 91 49 09 	lds	r23, 0x0949
    6c0e:	80 91 4a 09 	lds	r24, 0x094A
    6c12:	90 91 4b 09 	lds	r25, 0x094B
    6c16:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing pull-off, mm)\r\n$30=")); printFloat_SettingValue(settings.z_zero_pulloff);
    6c1a:	8b e3       	ldi	r24, 0x3B	; 59
    6c1c:	94 e0       	ldi	r25, 0x04	; 4
    6c1e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6c22:	60 91 4c 09 	lds	r22, 0x094C
    6c26:	70 91 4d 09 	lds	r23, 0x094D
    6c2a:	80 91 4e 09 	lds	r24, 0x094E
    6c2e:	90 91 4f 09 	lds	r25, 0x094F
    6c32:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
  printPgmString(PSTR(" (Z zero pull-off, mm)\r\n$31=")); printFloat_SettingValue(settings.z_zero_gauge);
    6c36:	8e e1       	ldi	r24, 0x1E	; 30
    6c38:	94 e0       	ldi	r25, 0x04	; 4
    6c3a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6c3e:	60 91 50 09 	lds	r22, 0x0950
    6c42:	70 91 51 09 	lds	r23, 0x0951
    6c46:	80 91 52 09 	lds	r24, 0x0952
    6c4a:	90 91 53 09 	lds	r25, 0x0953
    6c4e:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
  printPgmString(PSTR(" (Z zero gauge, mm)\r\n"));
    6c52:	88 e0       	ldi	r24, 0x08	; 8
    6c54:	94 e0       	ldi	r25, 0x04	; 4
    6c56:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
    6c5a:	0f 2e       	mov	r0, r31
    6c5c:	f4 e6       	ldi	r31, 0x64	; 100
    6c5e:	df 2e       	mov	r13, r31
    6c60:	f0 2d       	mov	r31, r0
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    6c62:	10 e0       	ldi	r17, 0x00	; 0
    6c64:	0f 2e       	mov	r0, r31
    6c66:	ff ef       	ldi	r31, 0xFF	; 255
    6c68:	ef 2e       	mov	r14, r31
    6c6a:	f8 e0       	ldi	r31, 0x08	; 8
    6c6c:	ff 2e       	mov	r15, r31
    6c6e:	f0 2d       	mov	r31, r0
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6c70:	c1 2c       	mov	r12, r1
    6c72:	7a c0       	rjmp	.+244    	; 0x6d68 <report_grbl_settings+0x328>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printPgmString(PSTR("$"));
    6c74:	86 e0       	ldi	r24, 0x06	; 6
    6c76:	94 e0       	ldi	r25, 0x04	; 4
    6c78:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
      print_uint8_base10(val+idx);
    6c7c:	80 2f       	mov	r24, r16
    6c7e:	8d 0d       	add	r24, r13
    6c80:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
      printPgmString(PSTR("="));
    6c84:	84 e0       	ldi	r24, 0x04	; 4
    6c86:	94 e0       	ldi	r25, 0x04	; 4
    6c88:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
      switch (set_idx) {
    6c8c:	11 30       	cpi	r17, 0x01	; 1
    6c8e:	69 f0       	breq	.+26     	; 0x6caa <report_grbl_settings+0x26a>
    6c90:	28 f0       	brcs	.+10     	; 0x6c9c <report_grbl_settings+0x25c>
    6c92:	12 30       	cpi	r17, 0x02	; 2
    6c94:	89 f0       	breq	.+34     	; 0x6cb8 <report_grbl_settings+0x278>
    6c96:	13 30       	cpi	r17, 0x03	; 3
    6c98:	e1 f0       	breq	.+56     	; 0x6cd2 <report_grbl_settings+0x292>
    6c9a:	24 c0       	rjmp	.+72     	; 0x6ce4 <report_grbl_settings+0x2a4>
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
    6c9c:	68 81       	ld	r22, Y
    6c9e:	79 81       	ldd	r23, Y+1	; 0x01
    6ca0:	8a 81       	ldd	r24, Y+2	; 0x02
    6ca2:	9b 81       	ldd	r25, Y+3	; 0x03
    6ca4:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
    6ca8:	1d c0       	rjmp	.+58     	; 0x6ce4 <report_grbl_settings+0x2a4>
        case 1: printFloat_SettingValue(settings.max_rate[idx]); break;
    6caa:	6c 85       	ldd	r22, Y+12	; 0x0c
    6cac:	7d 85       	ldd	r23, Y+13	; 0x0d
    6cae:	8e 85       	ldd	r24, Y+14	; 0x0e
    6cb0:	9f 85       	ldd	r25, Y+15	; 0x0f
    6cb2:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
    6cb6:	16 c0       	rjmp	.+44     	; 0x6ce4 <report_grbl_settings+0x2a4>
        case 2: printFloat_SettingValue(settings.acceleration[idx]/(60*60)); break;
    6cb8:	20 e0       	ldi	r18, 0x00	; 0
    6cba:	30 e0       	ldi	r19, 0x00	; 0
    6cbc:	41 e6       	ldi	r20, 0x61	; 97
    6cbe:	55 e4       	ldi	r21, 0x45	; 69
    6cc0:	68 8d       	ldd	r22, Y+24	; 0x18
    6cc2:	79 8d       	ldd	r23, Y+25	; 0x19
    6cc4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6cc6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6cc8:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
    6ccc:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
    6cd0:	09 c0       	rjmp	.+18     	; 0x6ce4 <report_grbl_settings+0x2a4>
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
    6cd2:	8c a1       	ldd	r24, Y+36	; 0x24
    6cd4:	9d a1       	ldd	r25, Y+37	; 0x25
    6cd6:	ae a1       	ldd	r26, Y+38	; 0x26
    6cd8:	bf a1       	ldd	r27, Y+39	; 0x27
    6cda:	bc 01       	movw	r22, r24
    6cdc:	cd 01       	movw	r24, r26
    6cde:	90 58       	subi	r25, 0x80	; 128
    6ce0:	0e 94 09 34 	call	0x6812	; 0x6812 <printFloat_SettingValue>
      }
      printPgmString(PSTR(" ("));
    6ce4:	81 e0       	ldi	r24, 0x01	; 1
    6ce6:	94 e0       	ldi	r25, 0x04	; 4
    6ce8:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
      switch (idx) {
    6cec:	01 30       	cpi	r16, 0x01	; 1
    6cee:	49 f0       	breq	.+18     	; 0x6d02 <report_grbl_settings+0x2c2>
    6cf0:	18 f0       	brcs	.+6      	; 0x6cf8 <report_grbl_settings+0x2b8>
    6cf2:	02 30       	cpi	r16, 0x02	; 2
    6cf4:	59 f0       	breq	.+22     	; 0x6d0c <report_grbl_settings+0x2cc>
    6cf6:	0e c0       	rjmp	.+28     	; 0x6d14 <report_grbl_settings+0x2d4>
        case X_AXIS: printPgmString(PSTR("x")); break;
    6cf8:	8f ef       	ldi	r24, 0xFF	; 255
    6cfa:	93 e0       	ldi	r25, 0x03	; 3
    6cfc:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6d00:	09 c0       	rjmp	.+18     	; 0x6d14 <report_grbl_settings+0x2d4>
        case Y_AXIS: printPgmString(PSTR("y")); break;
    6d02:	8d ef       	ldi	r24, 0xFD	; 253
    6d04:	93 e0       	ldi	r25, 0x03	; 3
    6d06:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6d0a:	04 c0       	rjmp	.+8      	; 0x6d14 <report_grbl_settings+0x2d4>
        case Z_AXIS: printPgmString(PSTR("z")); break;
    6d0c:	8b ef       	ldi	r24, 0xFB	; 251
    6d0e:	93 e0       	ldi	r25, 0x03	; 3
    6d10:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
      }
      switch (set_idx) {
    6d14:	11 30       	cpi	r17, 0x01	; 1
    6d16:	59 f0       	breq	.+22     	; 0x6d2e <report_grbl_settings+0x2ee>
    6d18:	28 f0       	brcs	.+10     	; 0x6d24 <report_grbl_settings+0x2e4>
    6d1a:	12 30       	cpi	r17, 0x02	; 2
    6d1c:	69 f0       	breq	.+26     	; 0x6d38 <report_grbl_settings+0x2f8>
    6d1e:	13 30       	cpi	r17, 0x03	; 3
    6d20:	81 f0       	breq	.+32     	; 0x6d42 <report_grbl_settings+0x302>
    6d22:	13 c0       	rjmp	.+38     	; 0x6d4a <report_grbl_settings+0x30a>
        case 0: printPgmString(PSTR(", step/mm")); break;
    6d24:	81 ef       	ldi	r24, 0xF1	; 241
    6d26:	93 e0       	ldi	r25, 0x03	; 3
    6d28:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6d2c:	0e c0       	rjmp	.+28     	; 0x6d4a <report_grbl_settings+0x30a>
        case 1: printPgmString(PSTR(" max rate, mm/min")); break;
    6d2e:	8f ed       	ldi	r24, 0xDF	; 223
    6d30:	93 e0       	ldi	r25, 0x03	; 3
    6d32:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6d36:	09 c0       	rjmp	.+18     	; 0x6d4a <report_grbl_settings+0x30a>
        case 2: printPgmString(PSTR(" accel, mm/sec^2")); break;
    6d38:	8e ec       	ldi	r24, 0xCE	; 206
    6d3a:	93 e0       	ldi	r25, 0x03	; 3
    6d3c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6d40:	04 c0       	rjmp	.+8      	; 0x6d4a <report_grbl_settings+0x30a>
        case 3: printPgmString(PSTR(" max travel, mm")); break;
    6d42:	8e eb       	ldi	r24, 0xBE	; 190
    6d44:	93 e0       	ldi	r25, 0x03	; 3
    6d46:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
      }      
      printPgmString(PSTR(")\r\n"));
    6d4a:	8a eb       	ldi	r24, 0xBA	; 186
    6d4c:	93 e0       	ldi	r25, 0x03	; 3
    6d4e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
    6d52:	0f 5f       	subi	r16, 0xFF	; 255
    6d54:	24 96       	adiw	r28, 0x04	; 4
    6d56:	03 30       	cpi	r16, 0x03	; 3
    6d58:	09 f0       	breq	.+2      	; 0x6d5c <report_grbl_settings+0x31c>
    6d5a:	8c cf       	rjmp	.-232    	; 0x6c74 <report_grbl_settings+0x234>
        case 2: printPgmString(PSTR(" accel, mm/sec^2")); break;
        case 3: printPgmString(PSTR(" max travel, mm")); break;
      }      
      printPgmString(PSTR(")\r\n"));
    }
    val += AXIS_SETTINGS_INCREMENT;
    6d5c:	fa e0       	ldi	r31, 0x0A	; 10
    6d5e:	df 0e       	add	r13, r31
  printPgmString(PSTR(" (Z zero gauge, mm)\r\n"));

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    6d60:	1f 5f       	subi	r17, 0xFF	; 255
    6d62:	8c e8       	ldi	r24, 0x8C	; 140
    6d64:	d8 16       	cp	r13, r24
    6d66:	19 f0       	breq	.+6      	; 0x6d6e <report_grbl_settings+0x32e>
    6d68:	e7 01       	movw	r28, r14
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6d6a:	0c 2d       	mov	r16, r12
    6d6c:	83 cf       	rjmp	.-250    	; 0x6c74 <report_grbl_settings+0x234>
      }      
      printPgmString(PSTR(")\r\n"));
    }
    val += AXIS_SETTINGS_INCREMENT;
  }  
}
    6d6e:	df 91       	pop	r29
    6d70:	cf 91       	pop	r28
    6d72:	1f 91       	pop	r17
    6d74:	0f 91       	pop	r16
    6d76:	ff 90       	pop	r15
    6d78:	ef 90       	pop	r14
    6d7a:	df 90       	pop	r13
    6d7c:	cf 90       	pop	r12
    6d7e:	08 95       	ret

00006d80 <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported). 
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters()
{
    6d80:	cf 93       	push	r28
  uint8_t i;
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:"));
    6d82:	84 eb       	ldi	r24, 0xB4	; 180
    6d84:	93 e0       	ldi	r25, 0x03	; 3
    6d86:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  for (i=0; i< N_AXIS; i++) {
    6d8a:	c0 e0       	ldi	r28, 0x00	; 0
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
    6d8c:	6c 2f       	mov	r22, r28
    6d8e:	8a e7       	ldi	r24, 0x7A	; 122
    6d90:	97 e0       	ldi	r25, 0x07	; 7
    6d92:	0e 94 7c 3b 	call	0x76f8	; 0x76f8 <system_convert_axis_steps_to_mpos>
    printFloat_CoordValue(print_position[i]);
    6d96:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6d9a:	c2 30       	cpi	r28, 0x02	; 2
    6d9c:	20 f4       	brcc	.+8      	; 0x6da6 <report_probe_parameters+0x26>
    6d9e:	82 eb       	ldi	r24, 0xB2	; 178
    6da0:	93 e0       	ldi	r25, 0x03	; 3
    6da2:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  uint8_t i;
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:"));
  for (i=0; i< N_AXIS; i++) {
    6da6:	cf 5f       	subi	r28, 0xFF	; 255
    6da8:	c3 30       	cpi	r28, 0x03	; 3
    6daa:	81 f7       	brne	.-32     	; 0x6d8c <report_probe_parameters+0xc>
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
    printFloat_CoordValue(print_position[i]);
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
  }
  printPgmString(PSTR(":"));
    6dac:	80 eb       	ldi	r24, 0xB0	; 176
    6dae:	93 e0       	ldi	r25, 0x03	; 3
    6db0:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  print_uint8_base10(sys.probe_succeeded);
    6db4:	80 91 86 07 	lds	r24, 0x0786
    6db8:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR("]\r\n"));
    6dbc:	8c ea       	ldi	r24, 0xAC	; 172
    6dbe:	93 e0       	ldi	r25, 0x03	; 3
    6dc0:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
}
    6dc4:	cf 91       	pop	r28
    6dc6:	08 95       	ret

00006dc8 <report_ngc_parameters>:


// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
    6dc8:	df 92       	push	r13
    6dca:	ef 92       	push	r14
    6dcc:	ff 92       	push	r15
    6dce:	0f 93       	push	r16
    6dd0:	1f 93       	push	r17
    6dd2:	cf 93       	push	r28
    6dd4:	df 93       	push	r29
    6dd6:	cd b7       	in	r28, 0x3d	; 61
    6dd8:	de b7       	in	r29, 0x3e	; 62
    6dda:	2c 97       	sbiw	r28, 0x0c	; 12
    6ddc:	0f b6       	in	r0, 0x3f	; 63
    6dde:	f8 94       	cli
    6de0:	de bf       	out	0x3e, r29	; 62
    6de2:	0f be       	out	0x3f, r0	; 63
    6de4:	cd bf       	out	0x3d, r28	; 61
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    6de6:	e1 2c       	mov	r14, r1
      case 6: printPgmString(PSTR("28")); break;
      case 7: printPgmString(PSTR("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printPgmString(PSTR(":"));         
    for (i=0; i<N_AXIS; i++) {
    6de8:	d1 2c       	mov	r13, r1
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    if (!(settings_read_coord_data(coord_select,coord_data))) { 
    6dea:	be 01       	movw	r22, r28
    6dec:	6f 5f       	subi	r22, 0xFF	; 255
    6dee:	7f 4f       	sbci	r23, 0xFF	; 255
    6df0:	8e 2d       	mov	r24, r14
    6df2:	0e 94 1a 27 	call	0x4e34	; 0x4e34 <settings_read_coord_data>
    6df6:	81 11       	cpse	r24, r1
    6df8:	04 c0       	rjmp	.+8      	; 0x6e02 <report_ngc_parameters+0x3a>
      report_status_message(STATUS_SETTING_READ_FAIL); 
    6dfa:	87 e0       	ldi	r24, 0x07	; 7
    6dfc:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
    6e00:	70 c0       	rjmp	.+224    	; 0x6ee2 <report_ngc_parameters+0x11a>
      return;
    } 
    printPgmString(PSTR("[G"));
    6e02:	89 ea       	ldi	r24, 0xA9	; 169
    6e04:	93 e0       	ldi	r25, 0x03	; 3
    6e06:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    switch (coord_select) {
    6e0a:	86 e0       	ldi	r24, 0x06	; 6
    6e0c:	e8 16       	cp	r14, r24
    6e0e:	21 f0       	breq	.+8      	; 0x6e18 <report_ngc_parameters+0x50>
    6e10:	e7 e0       	ldi	r30, 0x07	; 7
    6e12:	ee 16       	cp	r14, r30
    6e14:	31 f0       	breq	.+12     	; 0x6e22 <report_ngc_parameters+0x5a>
    6e16:	0a c0       	rjmp	.+20     	; 0x6e2c <report_ngc_parameters+0x64>
      case 6: printPgmString(PSTR("28")); break;
    6e18:	86 ea       	ldi	r24, 0xA6	; 166
    6e1a:	93 e0       	ldi	r25, 0x03	; 3
    6e1c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6e20:	09 c0       	rjmp	.+18     	; 0x6e34 <report_ngc_parameters+0x6c>
      case 7: printPgmString(PSTR("30")); break;
    6e22:	83 ea       	ldi	r24, 0xA3	; 163
    6e24:	93 e0       	ldi	r25, 0x03	; 3
    6e26:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6e2a:	04 c0       	rjmp	.+8      	; 0x6e34 <report_ngc_parameters+0x6c>
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    6e2c:	86 e3       	ldi	r24, 0x36	; 54
    6e2e:	8e 0d       	add	r24, r14
    6e30:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
    }  
    printPgmString(PSTR(":"));         
    6e34:	81 ea       	ldi	r24, 0xA1	; 161
    6e36:	93 e0       	ldi	r25, 0x03	; 3
    6e38:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6e3c:	8e 01       	movw	r16, r28
    6e3e:	0f 5f       	subi	r16, 0xFF	; 255
    6e40:	1f 4f       	sbci	r17, 0xFF	; 255
    for (i=0; i<N_AXIS; i++) {
    6e42:	fd 2c       	mov	r15, r13
      printFloat_CoordValue(coord_data[i]);
    6e44:	f8 01       	movw	r30, r16
    6e46:	61 91       	ld	r22, Z+
    6e48:	71 91       	ld	r23, Z+
    6e4a:	81 91       	ld	r24, Z+
    6e4c:	91 91       	ld	r25, Z+
    6e4e:	8f 01       	movw	r16, r30
    6e50:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6e54:	f1 e0       	ldi	r31, 0x01	; 1
    6e56:	ff 15       	cp	r31, r15
    6e58:	28 f0       	brcs	.+10     	; 0x6e64 <report_ngc_parameters+0x9c>
    6e5a:	8f e9       	ldi	r24, 0x9F	; 159
    6e5c:	93 e0       	ldi	r25, 0x03	; 3
    6e5e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6e62:	04 c0       	rjmp	.+8      	; 0x6e6c <report_ngc_parameters+0xa4>
      else { printPgmString(PSTR("]\r\n")); }
    6e64:	8b e9       	ldi	r24, 0x9B	; 155
    6e66:	93 e0       	ldi	r25, 0x03	; 3
    6e68:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
      case 6: printPgmString(PSTR("28")); break;
      case 7: printPgmString(PSTR("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printPgmString(PSTR(":"));         
    for (i=0; i<N_AXIS; i++) {
    6e6c:	f3 94       	inc	r15
    6e6e:	83 e0       	ldi	r24, 0x03	; 3
    6e70:	f8 12       	cpse	r15, r24
    6e72:	e8 cf       	rjmp	.-48     	; 0x6e44 <report_ngc_parameters+0x7c>
// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    6e74:	e3 94       	inc	r14
    6e76:	e8 e0       	ldi	r30, 0x08	; 8
    6e78:	ee 12       	cpse	r14, r30
    6e7a:	b7 cf       	rjmp	.-146    	; 0x6dea <report_ngc_parameters+0x22>
      printFloat_CoordValue(coord_data[i]);
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
      else { printPgmString(PSTR("]\r\n")); }
    } 
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
    6e7c:	85 e9       	ldi	r24, 0x95	; 149
    6e7e:	93 e0       	ldi	r25, 0x03	; 3
    6e80:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6e84:	06 eb       	ldi	r16, 0xB6	; 182
    6e86:	17 e0       	ldi	r17, 0x07	; 7
  for (i=0; i<N_AXIS; i++) {
    6e88:	f1 2c       	mov	r15, r1
    printFloat_CoordValue(gc_state.coord_offset[i]);
    6e8a:	f8 01       	movw	r30, r16
    6e8c:	61 91       	ld	r22, Z+
    6e8e:	71 91       	ld	r23, Z+
    6e90:	81 91       	ld	r24, Z+
    6e92:	91 91       	ld	r25, Z+
    6e94:	8f 01       	movw	r16, r30
    6e96:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6e9a:	f1 e0       	ldi	r31, 0x01	; 1
    6e9c:	ff 15       	cp	r31, r15
    6e9e:	28 f0       	brcs	.+10     	; 0x6eaa <report_ngc_parameters+0xe2>
    6ea0:	83 e9       	ldi	r24, 0x93	; 147
    6ea2:	93 e0       	ldi	r25, 0x03	; 3
    6ea4:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6ea8:	04 c0       	rjmp	.+8      	; 0x6eb2 <report_ngc_parameters+0xea>
    else { printPgmString(PSTR("]\r\n")); }
    6eaa:	8f e8       	ldi	r24, 0x8F	; 143
    6eac:	93 e0       	ldi	r25, 0x03	; 3
    6eae:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
      else { printPgmString(PSTR("]\r\n")); }
    } 
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
  for (i=0; i<N_AXIS; i++) {
    6eb2:	f3 94       	inc	r15
    6eb4:	83 e0       	ldi	r24, 0x03	; 3
    6eb6:	f8 12       	cpse	r15, r24
    6eb8:	e8 cf       	rjmp	.-48     	; 0x6e8a <report_ngc_parameters+0xc2>
    printFloat_CoordValue(gc_state.coord_offset[i]);
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    else { printPgmString(PSTR("]\r\n")); }
  } 
  printPgmString(PSTR("[TLO:")); // Print tool length offset value
    6eba:	89 e8       	ldi	r24, 0x89	; 137
    6ebc:	93 e0       	ldi	r25, 0x03	; 3
    6ebe:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  printFloat_CoordValue(gc_state.tool_length_offset);
    6ec2:	60 91 c2 07 	lds	r22, 0x07C2
    6ec6:	70 91 c3 07 	lds	r23, 0x07C3
    6eca:	80 91 c4 07 	lds	r24, 0x07C4
    6ece:	90 91 c5 07 	lds	r25, 0x07C5
    6ed2:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
  printPgmString(PSTR("]\r\n"));
    6ed6:	85 e8       	ldi	r24, 0x85	; 133
    6ed8:	93 e0       	ldi	r25, 0x03	; 3
    6eda:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  report_probe_parameters(); // Print probe parameters. Not persistent in memory.
    6ede:	0e 94 c0 36 	call	0x6d80	; 0x6d80 <report_probe_parameters>
}
    6ee2:	2c 96       	adiw	r28, 0x0c	; 12
    6ee4:	0f b6       	in	r0, 0x3f	; 63
    6ee6:	f8 94       	cli
    6ee8:	de bf       	out	0x3e, r29	; 62
    6eea:	0f be       	out	0x3f, r0	; 63
    6eec:	cd bf       	out	0x3d, r28	; 61
    6eee:	df 91       	pop	r29
    6ef0:	cf 91       	pop	r28
    6ef2:	1f 91       	pop	r17
    6ef4:	0f 91       	pop	r16
    6ef6:	ff 90       	pop	r15
    6ef8:	ef 90       	pop	r14
    6efa:	df 90       	pop	r13
    6efc:	08 95       	ret

00006efe <report_gcode_modes>:


// Print current gcode parser mode state
void report_gcode_modes()
{
  printPgmString(PSTR("["));
    6efe:	83 e8       	ldi	r24, 0x83	; 131
    6f00:	93 e0       	ldi	r25, 0x03	; 3
    6f02:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  
  switch (gc_state.modal.motion) {
    6f06:	80 91 87 07 	lds	r24, 0x0787
    6f0a:	90 e0       	ldi	r25, 0x00	; 0
    6f0c:	89 30       	cpi	r24, 0x09	; 9
    6f0e:	91 05       	cpc	r25, r1
    6f10:	88 f5       	brcc	.+98     	; 0x6f74 <report_gcode_modes+0x76>
    6f12:	fc 01       	movw	r30, r24
    6f14:	ef 5e       	subi	r30, 0xEF	; 239
    6f16:	fe 4f       	sbci	r31, 0xFE	; 254
    6f18:	0c 94 d9 3f 	jmp	0x7fb2	; 0x7fb2 <__tablejump2__>
    case MOTION_MODE_SEEK : printPgmString(PSTR("G0")); break;
    6f1c:	80 e8       	ldi	r24, 0x80	; 128
    6f1e:	93 e0       	ldi	r25, 0x03	; 3
    6f20:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f24:	27 c0       	rjmp	.+78     	; 0x6f74 <report_gcode_modes+0x76>
    case MOTION_MODE_LINEAR : printPgmString(PSTR("G1")); break;
    6f26:	8d e7       	ldi	r24, 0x7D	; 125
    6f28:	93 e0       	ldi	r25, 0x03	; 3
    6f2a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f2e:	22 c0       	rjmp	.+68     	; 0x6f74 <report_gcode_modes+0x76>
    case MOTION_MODE_CW_ARC : printPgmString(PSTR("G2")); break;
    6f30:	8a e7       	ldi	r24, 0x7A	; 122
    6f32:	93 e0       	ldi	r25, 0x03	; 3
    6f34:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f38:	1d c0       	rjmp	.+58     	; 0x6f74 <report_gcode_modes+0x76>
    case MOTION_MODE_CCW_ARC : printPgmString(PSTR("G3")); break;
    6f3a:	87 e7       	ldi	r24, 0x77	; 119
    6f3c:	93 e0       	ldi	r25, 0x03	; 3
    6f3e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f42:	18 c0       	rjmp	.+48     	; 0x6f74 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_TOWARD : printPgmString(PSTR("G38.2")); break;    
    6f44:	81 e7       	ldi	r24, 0x71	; 113
    6f46:	93 e0       	ldi	r25, 0x03	; 3
    6f48:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f4c:	13 c0       	rjmp	.+38     	; 0x6f74 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_TOWARD_NO_ERROR : printPgmString(PSTR("G38.3")); break;    
    6f4e:	8b e6       	ldi	r24, 0x6B	; 107
    6f50:	93 e0       	ldi	r25, 0x03	; 3
    6f52:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f56:	0e c0       	rjmp	.+28     	; 0x6f74 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_AWAY : printPgmString(PSTR("G38.4")); break;    
    6f58:	85 e6       	ldi	r24, 0x65	; 101
    6f5a:	93 e0       	ldi	r25, 0x03	; 3
    6f5c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f60:	09 c0       	rjmp	.+18     	; 0x6f74 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_AWAY_NO_ERROR : printPgmString(PSTR("G38.5")); break;    
    6f62:	8f e5       	ldi	r24, 0x5F	; 95
    6f64:	93 e0       	ldi	r25, 0x03	; 3
    6f66:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f6a:	04 c0       	rjmp	.+8      	; 0x6f74 <report_gcode_modes+0x76>
    case MOTION_MODE_NONE : printPgmString(PSTR("G80")); break;
    6f6c:	8b e5       	ldi	r24, 0x5B	; 91
    6f6e:	93 e0       	ldi	r25, 0x03	; 3
    6f70:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }

  printPgmString(PSTR(" G"));
    6f74:	88 e5       	ldi	r24, 0x58	; 88
    6f76:	93 e0       	ldi	r25, 0x03	; 3
    6f78:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  print_uint8_base10(gc_state.modal.coord_select+54);
    6f7c:	80 91 8d 07 	lds	r24, 0x078D
    6f80:	8a 5c       	subi	r24, 0xCA	; 202
    6f82:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  
  switch (gc_state.modal.plane_select) {
    6f86:	80 91 8b 07 	lds	r24, 0x078B
    6f8a:	81 30       	cpi	r24, 0x01	; 1
    6f8c:	49 f0       	breq	.+18     	; 0x6fa0 <report_gcode_modes+0xa2>
    6f8e:	18 f0       	brcs	.+6      	; 0x6f96 <report_gcode_modes+0x98>
    6f90:	82 30       	cpi	r24, 0x02	; 2
    6f92:	59 f0       	breq	.+22     	; 0x6faa <report_gcode_modes+0xac>
    6f94:	0e c0       	rjmp	.+28     	; 0x6fb2 <report_gcode_modes+0xb4>
    case PLANE_SELECT_XY : printPgmString(PSTR(" G17")); break;
    6f96:	83 e5       	ldi	r24, 0x53	; 83
    6f98:	93 e0       	ldi	r25, 0x03	; 3
    6f9a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6f9e:	09 c0       	rjmp	.+18     	; 0x6fb2 <report_gcode_modes+0xb4>
    case PLANE_SELECT_ZX : printPgmString(PSTR(" G18")); break;
    6fa0:	8e e4       	ldi	r24, 0x4E	; 78
    6fa2:	93 e0       	ldi	r25, 0x03	; 3
    6fa4:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6fa8:	04 c0       	rjmp	.+8      	; 0x6fb2 <report_gcode_modes+0xb4>
    case PLANE_SELECT_YZ : printPgmString(PSTR(" G19")); break;
    6faa:	89 e4       	ldi	r24, 0x49	; 73
    6fac:	93 e0       	ldi	r25, 0x03	; 3
    6fae:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }
  
  if (gc_state.modal.units == UNITS_MODE_MM) { printPgmString(PSTR(" G21")); }
    6fb2:	80 91 89 07 	lds	r24, 0x0789
    6fb6:	81 11       	cpse	r24, r1
    6fb8:	05 c0       	rjmp	.+10     	; 0x6fc4 <report_gcode_modes+0xc6>
    6fba:	84 e4       	ldi	r24, 0x44	; 68
    6fbc:	93 e0       	ldi	r25, 0x03	; 3
    6fbe:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6fc2:	04 c0       	rjmp	.+8      	; 0x6fcc <report_gcode_modes+0xce>
  else { printPgmString(PSTR(" G20")); }
    6fc4:	8f e3       	ldi	r24, 0x3F	; 63
    6fc6:	93 e0       	ldi	r25, 0x03	; 3
    6fc8:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  
  if (gc_state.modal.distance == DISTANCE_MODE_ABSOLUTE) { printPgmString(PSTR(" G90")); }
    6fcc:	80 91 8a 07 	lds	r24, 0x078A
    6fd0:	81 11       	cpse	r24, r1
    6fd2:	05 c0       	rjmp	.+10     	; 0x6fde <report_gcode_modes+0xe0>
    6fd4:	8a e3       	ldi	r24, 0x3A	; 58
    6fd6:	93 e0       	ldi	r25, 0x03	; 3
    6fd8:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6fdc:	04 c0       	rjmp	.+8      	; 0x6fe6 <report_gcode_modes+0xe8>
  else { printPgmString(PSTR(" G91")); }
    6fde:	85 e3       	ldi	r24, 0x35	; 53
    6fe0:	93 e0       	ldi	r25, 0x03	; 3
    6fe2:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  
  if (gc_state.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { printPgmString(PSTR(" G93")); }
    6fe6:	80 91 88 07 	lds	r24, 0x0788
    6fea:	81 30       	cpi	r24, 0x01	; 1
    6fec:	29 f4       	brne	.+10     	; 0x6ff8 <report_gcode_modes+0xfa>
    6fee:	80 e3       	ldi	r24, 0x30	; 48
    6ff0:	93 e0       	ldi	r25, 0x03	; 3
    6ff2:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    6ff6:	04 c0       	rjmp	.+8      	; 0x7000 <report_gcode_modes+0x102>
  else { printPgmString(PSTR(" G94")); }
    6ff8:	8b e2       	ldi	r24, 0x2B	; 43
    6ffa:	93 e0       	ldi	r25, 0x03	; 3
    6ffc:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    
  switch (gc_state.modal.program_flow) {
    7000:	80 91 8e 07 	lds	r24, 0x078E
    7004:	81 30       	cpi	r24, 0x01	; 1
    7006:	49 f0       	breq	.+18     	; 0x701a <report_gcode_modes+0x11c>
    7008:	18 f0       	brcs	.+6      	; 0x7010 <report_gcode_modes+0x112>
    700a:	82 30       	cpi	r24, 0x02	; 2
    700c:	59 f0       	breq	.+22     	; 0x7024 <report_gcode_modes+0x126>
    700e:	0e c0       	rjmp	.+28     	; 0x702c <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_RUNNING : printPgmString(PSTR(" M0")); break;
    7010:	87 e2       	ldi	r24, 0x27	; 39
    7012:	93 e0       	ldi	r25, 0x03	; 3
    7014:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    7018:	09 c0       	rjmp	.+18     	; 0x702c <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_PAUSED : printPgmString(PSTR(" M1")); break;
    701a:	83 e2       	ldi	r24, 0x23	; 35
    701c:	93 e0       	ldi	r25, 0x03	; 3
    701e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    7022:	04 c0       	rjmp	.+8      	; 0x702c <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_COMPLETED : printPgmString(PSTR(" M2")); break;
    7024:	8f e1       	ldi	r24, 0x1F	; 31
    7026:	93 e0       	ldi	r25, 0x03	; 3
    7028:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }

  switch (gc_state.modal.spindle) {
    702c:	80 91 90 07 	lds	r24, 0x0790
    7030:	81 30       	cpi	r24, 0x01	; 1
    7032:	21 f0       	breq	.+8      	; 0x703c <report_gcode_modes+0x13e>
    7034:	68 f0       	brcs	.+26     	; 0x7050 <report_gcode_modes+0x152>
    7036:	82 30       	cpi	r24, 0x02	; 2
    7038:	31 f0       	breq	.+12     	; 0x7046 <report_gcode_modes+0x148>
    703a:	0e c0       	rjmp	.+28     	; 0x7058 <report_gcode_modes+0x15a>
    case SPINDLE_ENABLE_CW : printPgmString(PSTR(" M3")); break;
    703c:	8b e1       	ldi	r24, 0x1B	; 27
    703e:	93 e0       	ldi	r25, 0x03	; 3
    7040:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    7044:	09 c0       	rjmp	.+18     	; 0x7058 <report_gcode_modes+0x15a>
    case SPINDLE_ENABLE_CCW : printPgmString(PSTR(" M4")); break;
    7046:	87 e1       	ldi	r24, 0x17	; 23
    7048:	93 e0       	ldi	r25, 0x03	; 3
    704a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    704e:	04 c0       	rjmp	.+8      	; 0x7058 <report_gcode_modes+0x15a>
    case SPINDLE_DISABLE : printPgmString(PSTR(" M5")); break;
    7050:	83 e1       	ldi	r24, 0x13	; 19
    7052:	93 e0       	ldi	r25, 0x03	; 3
    7054:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }
  
  switch (gc_state.modal.coolant) {
    7058:	80 91 8f 07 	lds	r24, 0x078F
    705c:	88 23       	and	r24, r24
    705e:	19 f0       	breq	.+6      	; 0x7066 <report_gcode_modes+0x168>
    7060:	82 30       	cpi	r24, 0x02	; 2
    7062:	31 f0       	breq	.+12     	; 0x7070 <report_gcode_modes+0x172>
    7064:	09 c0       	rjmp	.+18     	; 0x7078 <report_gcode_modes+0x17a>
    case COOLANT_DISABLE : printPgmString(PSTR(" M9")); break;
    7066:	8f e0       	ldi	r24, 0x0F	; 15
    7068:	93 e0       	ldi	r25, 0x03	; 3
    706a:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    706e:	04 c0       	rjmp	.+8      	; 0x7078 <report_gcode_modes+0x17a>
    case COOLANT_FLOOD_ENABLE : printPgmString(PSTR(" M8")); break;
    7070:	8b e0       	ldi	r24, 0x0B	; 11
    7072:	93 e0       	ldi	r25, 0x03	; 3
    7074:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    #ifdef ENABLE_M7
      case COOLANT_MIST_ENABLE : printPgmString(PSTR(" M7")); break;
    #endif
  }
  
  printPgmString(PSTR(" T"));
    7078:	88 e0       	ldi	r24, 0x08	; 8
    707a:	93 e0       	ldi	r25, 0x03	; 3
    707c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  print_uint8_base10(gc_state.tool);
    7080:	80 91 99 07 	lds	r24, 0x0799
    7084:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  
  printPgmString(PSTR(" F"));
    7088:	85 e0       	ldi	r24, 0x05	; 5
    708a:	93 e0       	ldi	r25, 0x03	; 3
    708c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  printFloat_RateValue(gc_state.feed_rate);
    7090:	60 91 95 07 	lds	r22, 0x0795
    7094:	70 91 96 07 	lds	r23, 0x0796
    7098:	80 91 97 07 	lds	r24, 0x0797
    709c:	90 91 98 07 	lds	r25, 0x0798
    70a0:	0e 94 f7 33 	call	0x67ee	; 0x67ee <printFloat_RateValue>
  #ifdef VARIABLE_SPINDLE
    printPgmString(PSTR(" S"));
    printFloat_RateValue(gc_state.spindle_speed);
  #endif

  printPgmString(PSTR("]\r\n"));
    70a4:	81 e0       	ldi	r24, 0x01	; 1
    70a6:	93 e0       	ldi	r25, 0x03	; 3
    70a8:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    70ac:	08 95       	ret

000070ae <report_startup_line>:
}

// Prints specified startup line
void report_startup_line(uint8_t n, char *line)
{
    70ae:	1f 93       	push	r17
    70b0:	cf 93       	push	r28
    70b2:	df 93       	push	r29
    70b4:	18 2f       	mov	r17, r24
    70b6:	eb 01       	movw	r28, r22
  printPgmString(PSTR("$N")); print_uint8_base10(n);
    70b8:	8e ef       	ldi	r24, 0xFE	; 254
    70ba:	92 e0       	ldi	r25, 0x02	; 2
    70bc:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    70c0:	81 2f       	mov	r24, r17
    70c2:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  printPgmString(PSTR("=")); printString(line);
    70c6:	8c ef       	ldi	r24, 0xFC	; 252
    70c8:	92 e0       	ldi	r25, 0x02	; 2
    70ca:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    70ce:	ce 01       	movw	r24, r28
    70d0:	0e 94 97 32 	call	0x652e	; 0x652e <printString>
  printPgmString(PSTR("\r\n"));
    70d4:	89 ef       	ldi	r24, 0xF9	; 249
    70d6:	92 e0       	ldi	r25, 0x02	; 2
    70d8:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
}
    70dc:	df 91       	pop	r29
    70de:	cf 91       	pop	r28
    70e0:	1f 91       	pop	r17
    70e2:	08 95       	ret

000070e4 <report_build_info>:


// Prints build info line
void report_build_info(char *line)
{
    70e4:	cf 93       	push	r28
    70e6:	df 93       	push	r29
    70e8:	ec 01       	movw	r28, r24
  printPgmString(PSTR("[" GRBL_VERSION "." GRBL_VERSION_BUILD ":"));
    70ea:	80 ee       	ldi	r24, 0xE0	; 224
    70ec:	92 e0       	ldi	r25, 0x02	; 2
    70ee:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  printString(line);
    70f2:	ce 01       	movw	r24, r28
    70f4:	0e 94 97 32 	call	0x652e	; 0x652e <printString>
  printPgmString(PSTR("]\r\n"));
    70f8:	8c ed       	ldi	r24, 0xDC	; 220
    70fa:	92 e0       	ldi	r25, 0x02	; 2
    70fc:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
}
    7100:	df 91       	pop	r29
    7102:	cf 91       	pop	r28
    7104:	08 95       	ret

00007106 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly, 
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    7106:	bf 92       	push	r11
    7108:	cf 92       	push	r12
    710a:	df 92       	push	r13
    710c:	ef 92       	push	r14
    710e:	ff 92       	push	r15
    7110:	0f 93       	push	r16
    7112:	1f 93       	push	r17
    7114:	cf 93       	push	r28
    7116:	df 93       	push	r29
    7118:	cd b7       	in	r28, 0x3d	; 61
    711a:	de b7       	in	r29, 0x3e	; 62
    711c:	68 97       	sbiw	r28, 0x18	; 24
    711e:	0f b6       	in	r0, 0x3f	; 63
    7120:	f8 94       	cli
    7122:	de bf       	out	0x3e, r29	; 62
    7124:	0f be       	out	0x3f, r0	; 63
    7126:	cd bf       	out	0x3d, r28	; 61
  // the system power on location (0,0,0) and work coordinate position (G54 and G92 applied). Eventually
  // to be added are distance to go on block, processed block id, and feed rate. Also a settings bitmask
  // for a user to select the desired real-time data.
  uint8_t i;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys.position,sizeof(sys.position));
    7128:	8c e0       	ldi	r24, 0x0C	; 12
    712a:	ec e6       	ldi	r30, 0x6C	; 108
    712c:	f7 e0       	ldi	r31, 0x07	; 7
    712e:	de 01       	movw	r26, r28
    7130:	11 96       	adiw	r26, 0x01	; 1
    7132:	01 90       	ld	r0, Z+
    7134:	0d 92       	st	X+, r0
    7136:	8a 95       	dec	r24
    7138:	e1 f7       	brne	.-8      	; 0x7132 <report_realtime_status+0x2c>
  float print_position[N_AXIS];
 
  // Report current machine state
  switch (sys.state) {
    713a:	80 91 68 07 	lds	r24, 0x0768
    713e:	88 30       	cpi	r24, 0x08	; 8
    7140:	c9 f0       	breq	.+50     	; 0x7174 <report_realtime_status+0x6e>
    7142:	40 f4       	brcc	.+16     	; 0x7154 <report_realtime_status+0x4e>
    7144:	81 30       	cpi	r24, 0x01	; 1
    7146:	29 f1       	breq	.+74     	; 0x7192 <report_realtime_status+0x8c>
    7148:	80 f0       	brcs	.+32     	; 0x716a <report_realtime_status+0x64>
    714a:	82 30       	cpi	r24, 0x02	; 2
    714c:	39 f1       	breq	.+78     	; 0x719c <report_realtime_status+0x96>
    714e:	84 30       	cpi	r24, 0x04	; 4
    7150:	d9 f0       	breq	.+54     	; 0x7188 <report_realtime_status+0x82>
    7152:	32 c0       	rjmp	.+100    	; 0x71b8 <report_realtime_status+0xb2>
    7154:	80 32       	cpi	r24, 0x20	; 32
    7156:	39 f1       	breq	.+78     	; 0x71a6 <report_realtime_status+0xa0>
    7158:	18 f4       	brcc	.+6      	; 0x7160 <report_realtime_status+0x5a>
    715a:	80 31       	cpi	r24, 0x10	; 16
    715c:	81 f0       	breq	.+32     	; 0x717e <report_realtime_status+0x78>
    715e:	2c c0       	rjmp	.+88     	; 0x71b8 <report_realtime_status+0xb2>
    7160:	80 34       	cpi	r24, 0x40	; 64
    7162:	41 f0       	breq	.+16     	; 0x7174 <report_realtime_status+0x6e>
    7164:	80 38       	cpi	r24, 0x80	; 128
    7166:	21 f1       	breq	.+72     	; 0x71b0 <report_realtime_status+0xaa>
    7168:	27 c0       	rjmp	.+78     	; 0x71b8 <report_realtime_status+0xb2>
    case STATE_IDLE: printPgmString(PSTR("<Idle")); break;
    716a:	86 ed       	ldi	r24, 0xD6	; 214
    716c:	92 e0       	ldi	r25, 0x02	; 2
    716e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    7172:	22 c0       	rjmp	.+68     	; 0x71b8 <report_realtime_status+0xb2>
    case STATE_MOTION_CANCEL: // Report run state.
    case STATE_CYCLE: printPgmString(PSTR("<Run")); break;
    7174:	81 ed       	ldi	r24, 0xD1	; 209
    7176:	92 e0       	ldi	r25, 0x02	; 2
    7178:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    717c:	1d c0       	rjmp	.+58     	; 0x71b8 <report_realtime_status+0xb2>
    case STATE_HOLD: printPgmString(PSTR("<Hold")); break;
    717e:	8b ec       	ldi	r24, 0xCB	; 203
    7180:	92 e0       	ldi	r25, 0x02	; 2
    7182:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    7186:	18 c0       	rjmp	.+48     	; 0x71b8 <report_realtime_status+0xb2>
    case STATE_HOMING: printPgmString(PSTR("<Home")); break;
    7188:	85 ec       	ldi	r24, 0xC5	; 197
    718a:	92 e0       	ldi	r25, 0x02	; 2
    718c:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    7190:	13 c0       	rjmp	.+38     	; 0x71b8 <report_realtime_status+0xb2>
    case STATE_ALARM: printPgmString(PSTR("<Alarm")); break;
    7192:	8e eb       	ldi	r24, 0xBE	; 190
    7194:	92 e0       	ldi	r25, 0x02	; 2
    7196:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    719a:	0e c0       	rjmp	.+28     	; 0x71b8 <report_realtime_status+0xb2>
    case STATE_CHECK_MODE: printPgmString(PSTR("<Check")); break;
    719c:	87 eb       	ldi	r24, 0xB7	; 183
    719e:	92 e0       	ldi	r25, 0x02	; 2
    71a0:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    71a4:	09 c0       	rjmp	.+18     	; 0x71b8 <report_realtime_status+0xb2>
    case STATE_SAFETY_DOOR: printPgmString(PSTR("<Door")); break;
    71a6:	81 eb       	ldi	r24, 0xB1	; 177
    71a8:	92 e0       	ldi	r25, 0x02	; 2
    71aa:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    71ae:	04 c0       	rjmp	.+8      	; 0x71b8 <report_realtime_status+0xb2>
	case STATE_JOG: printPgmString(PSTR("<Jog")); break;
    71b0:	8c ea       	ldi	r24, 0xAC	; 172
    71b2:	92 e0       	ldi	r25, 0x02	; 2
    71b4:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }
 
  // If reporting a position, convert the current step count (current_position) to millimeters.
  if (bit_istrue(settings.status_report_mask,(BITFLAG_RT_STATUS_MACHINE_POSITION | BITFLAG_RT_STATUS_WORK_POSITION))) {
    71b8:	80 91 33 09 	lds	r24, 0x0933
    71bc:	83 70       	andi	r24, 0x03	; 3
    71be:	39 f0       	breq	.+14     	; 0x71ce <report_realtime_status+0xc8>
    system_convert_array_steps_to_mpos(print_position,current_position);
    71c0:	be 01       	movw	r22, r28
    71c2:	6f 5f       	subi	r22, 0xFF	; 255
    71c4:	7f 4f       	sbci	r23, 0xFF	; 255
    71c6:	ce 01       	movw	r24, r28
    71c8:	0d 96       	adiw	r24, 0x0d	; 13
    71ca:	0e 94 98 3b 	call	0x7730	; 0x7730 <system_convert_array_steps_to_mpos>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    71ce:	80 91 33 09 	lds	r24, 0x0933
    71d2:	80 ff       	sbrs	r24, 0
    71d4:	1e c0       	rjmp	.+60     	; 0x7212 <report_realtime_status+0x10c>
    printPgmString(PSTR(",MPos:")); 
    71d6:	85 ea       	ldi	r24, 0xA5	; 165
    71d8:	92 e0       	ldi	r25, 0x02	; 2
    71da:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    71de:	6d 85       	ldd	r22, Y+13	; 0x0d
    71e0:	7e 85       	ldd	r23, Y+14	; 0x0e
    71e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    71e4:	98 89       	ldd	r25, Y+16	; 0x10
    71e6:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    71ea:	83 ea       	ldi	r24, 0xA3	; 163
    71ec:	92 e0       	ldi	r25, 0x02	; 2
    71ee:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    71f2:	69 89       	ldd	r22, Y+17	; 0x11
    71f4:	7a 89       	ldd	r23, Y+18	; 0x12
    71f6:	8b 89       	ldd	r24, Y+19	; 0x13
    71f8:	9c 89       	ldd	r25, Y+20	; 0x14
    71fa:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    71fe:	83 ea       	ldi	r24, 0xA3	; 163
    7200:	92 e0       	ldi	r25, 0x02	; 2
    7202:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    7206:	6d 89       	ldd	r22, Y+21	; 0x15
    7208:	7e 89       	ldd	r23, Y+22	; 0x16
    720a:	8f 89       	ldd	r24, Y+23	; 0x17
    720c:	98 8d       	ldd	r25, Y+24	; 0x18
    720e:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    7212:	80 91 33 09 	lds	r24, 0x0933
    7216:	81 ff       	sbrs	r24, 1
    7218:	4c c0       	rjmp	.+152    	; 0x72b2 <report_realtime_status+0x1ac>
    printPgmString(PSTR(",WPos:")); 
    721a:	8c e9       	ldi	r24, 0x9C	; 156
    721c:	92 e0       	ldi	r25, 0x02	; 2
    721e:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    7222:	8e 01       	movw	r16, r28
    7224:	03 5f       	subi	r16, 0xF3	; 243
    7226:	1f 4f       	sbci	r17, 0xFF	; 255
    7228:	0f 2e       	mov	r0, r31
    722a:	fa ea       	ldi	r31, 0xAA	; 170
    722c:	ef 2e       	mov	r14, r31
    722e:	f7 e0       	ldi	r31, 0x07	; 7
    7230:	ff 2e       	mov	r15, r31
    7232:	f0 2d       	mov	r31, r0
    for (i=0; i< N_AXIS; i++) {
    7234:	b1 2c       	mov	r11, r1
      // Apply work coordinate offsets and tool length offset to current position.
      print_position[i] -= gc_state.coord_system[i]+gc_state.coord_offset[i];
    7236:	f7 01       	movw	r30, r14
    7238:	61 91       	ld	r22, Z+
    723a:	71 91       	ld	r23, Z+
    723c:	81 91       	ld	r24, Z+
    723e:	91 91       	ld	r25, Z+
    7240:	7f 01       	movw	r14, r30
    7242:	20 85       	ldd	r18, Z+8	; 0x08
    7244:	31 85       	ldd	r19, Z+9	; 0x09
    7246:	42 85       	ldd	r20, Z+10	; 0x0a
    7248:	53 85       	ldd	r21, Z+11	; 0x0b
    724a:	0e 94 b3 3b 	call	0x7766	; 0x7766 <__addsf3>
    724e:	9b 01       	movw	r18, r22
    7250:	ac 01       	movw	r20, r24
    7252:	f8 01       	movw	r30, r16
    7254:	60 81       	ld	r22, Z
    7256:	71 81       	ldd	r23, Z+1	; 0x01
    7258:	82 81       	ldd	r24, Z+2	; 0x02
    725a:	93 81       	ldd	r25, Z+3	; 0x03
    725c:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    7260:	f8 01       	movw	r30, r16
    7262:	60 83       	st	Z, r22
    7264:	71 83       	std	Z+1, r23	; 0x01
    7266:	82 83       	std	Z+2, r24	; 0x02
    7268:	93 83       	std	Z+3, r25	; 0x03
      if (i == TOOL_LENGTH_OFFSET_AXIS) { print_position[i] -= gc_state.tool_length_offset; }    
    726a:	f2 e0       	ldi	r31, 0x02	; 2
    726c:	bf 12       	cpse	r11, r31
    726e:	12 c0       	rjmp	.+36     	; 0x7294 <report_realtime_status+0x18e>
    7270:	20 91 c2 07 	lds	r18, 0x07C2
    7274:	30 91 c3 07 	lds	r19, 0x07C3
    7278:	40 91 c4 07 	lds	r20, 0x07C4
    727c:	50 91 c5 07 	lds	r21, 0x07C5
    7280:	0e 94 b2 3b 	call	0x7764	; 0x7764 <__subsf3>
    7284:	f8 01       	movw	r30, r16
    7286:	60 83       	st	Z, r22
    7288:	71 83       	std	Z+1, r23	; 0x01
    728a:	82 83       	std	Z+2, r24	; 0x02
    728c:	93 83       	std	Z+3, r25	; 0x03
      printFloat_CoordValue(print_position[i]);
    728e:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
    7292:	0f c0       	rjmp	.+30     	; 0x72b2 <report_realtime_status+0x1ac>
    7294:	0e 94 e5 33 	call	0x67ca	; 0x67ca <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    7298:	f1 e0       	ldi	r31, 0x01	; 1
    729a:	fb 15       	cp	r31, r11
    729c:	20 f0       	brcs	.+8      	; 0x72a6 <report_realtime_status+0x1a0>
    729e:	8a e9       	ldi	r24, 0x9A	; 154
    72a0:	92 e0       	ldi	r25, 0x02	; 2
    72a2:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printPgmString(PSTR(",WPos:")); 
    for (i=0; i< N_AXIS; i++) {
    72a6:	b3 94       	inc	r11
    72a8:	0c 5f       	subi	r16, 0xFC	; 252
    72aa:	1f 4f       	sbci	r17, 0xFF	; 255
    72ac:	23 e0       	ldi	r18, 0x03	; 3
    72ae:	b2 12       	cpse	r11, r18
    72b0:	c2 cf       	rjmp	.-124    	; 0x7236 <report_realtime_status+0x130>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
        
  // Returns the number of active blocks are in the planner buffer.
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_PLANNER_BUFFER)) {
    72b2:	80 91 33 09 	lds	r24, 0x0933
    72b6:	82 ff       	sbrs	r24, 2
    72b8:	08 c0       	rjmp	.+16     	; 0x72ca <report_realtime_status+0x1c4>
    printPgmString(PSTR(",Buf:"));
    72ba:	84 e9       	ldi	r24, 0x94	; 148
    72bc:	92 e0       	ldi	r25, 0x02	; 2
    72be:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    print_uint8_base10(plan_get_block_buffer_count());
    72c2:	0e 94 d7 2d 	call	0x5bae	; 0x5bae <plan_get_block_buffer_count>
    72c6:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
  }

  // Report serial read buffer status
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_SERIAL_RX)) {
    72ca:	80 91 33 09 	lds	r24, 0x0933
    72ce:	83 ff       	sbrs	r24, 3
    72d0:	08 c0       	rjmp	.+16     	; 0x72e2 <report_realtime_status+0x1dc>
    printPgmString(PSTR(",RX:"));
    72d2:	8f e8       	ldi	r24, 0x8F	; 143
    72d4:	92 e0       	ldi	r25, 0x02	; 2
    72d6:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
    print_uint8_base10(serial_get_rx_buffer_count());
    72da:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <serial_get_rx_buffer_count>
    72de:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <print_uint8_base10>
    print_uint8_base2(LIMIT_PIN & LIMIT_MASK);  
    printPgmString(PSTR(",Ctl:"));
    print_uint8_base2(CONTROL_PIN & CONTROL_MASK);
  #endif
  
  printPgmString(PSTR(">\r\n"));
    72e2:	8b e8       	ldi	r24, 0x8B	; 139
    72e4:	92 e0       	ldi	r25, 0x02	; 2
    72e6:	0e 94 a6 32 	call	0x654c	; 0x654c <printPgmString>
}
    72ea:	68 96       	adiw	r28, 0x18	; 24
    72ec:	0f b6       	in	r0, 0x3f	; 63
    72ee:	f8 94       	cli
    72f0:	de bf       	out	0x3e, r29	; 62
    72f2:	0f be       	out	0x3f, r0	; 63
    72f4:	cd bf       	out	0x3d, r28	; 61
    72f6:	df 91       	pop	r29
    72f8:	cf 91       	pop	r28
    72fa:	1f 91       	pop	r17
    72fc:	0f 91       	pop	r16
    72fe:	ff 90       	pop	r15
    7300:	ef 90       	pop	r14
    7302:	df 90       	pop	r13
    7304:	cf 90       	pop	r12
    7306:	bf 90       	pop	r11
    7308:	08 95       	ret

0000730a <system_init>:
#include "grbl.h"


void system_init() 
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    730a:	87 b1       	in	r24, 0x07	; 7
    730c:	88 7f       	andi	r24, 0xF8	; 248
    730e:	87 b9       	out	0x07, r24	; 7
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    7310:	88 b1       	in	r24, 0x08	; 8
    7312:	87 60       	ori	r24, 0x07	; 7
    7314:	88 b9       	out	0x08, r24	; 8
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    7316:	ed e6       	ldi	r30, 0x6D	; 109
    7318:	f0 e0       	ldi	r31, 0x00	; 0
    731a:	80 81       	ld	r24, Z
    731c:	87 60       	ori	r24, 0x07	; 7
    731e:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    7320:	e8 e6       	ldi	r30, 0x68	; 104
    7322:	f0 e0       	ldi	r31, 0x00	; 0
    7324:	80 81       	ld	r24, Z
    7326:	84 60       	ori	r24, 0x04	; 4
    7328:	80 83       	st	Z, r24
    732a:	08 95       	ret

0000732c <__vector_6>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when 
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect) 
{
    732c:	1f 92       	push	r1
    732e:	0f 92       	push	r0
    7330:	0f b6       	in	r0, 0x3f	; 63
    7332:	0f 92       	push	r0
    7334:	11 24       	eor	r1, r1
    7336:	2f 93       	push	r18
    7338:	3f 93       	push	r19
    733a:	4f 93       	push	r20
    733c:	5f 93       	push	r21
    733e:	6f 93       	push	r22
    7340:	7f 93       	push	r23
    7342:	8f 93       	push	r24
    7344:	9f 93       	push	r25
    7346:	af 93       	push	r26
    7348:	bf 93       	push	r27
    734a:	ef 93       	push	r30
    734c:	ff 93       	push	r31
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    734e:	86 b1       	in	r24, 0x06	; 6
  #ifndef INVERT_CONTROL_PIN
    pin ^= CONTROL_MASK;
    7350:	80 95       	com	r24
    7352:	87 70       	andi	r24, 0x07	; 7
  #endif
  // Enter only if any CONTROL pin is detected as active.
  if (pin) { 
    7354:	a9 f0       	breq	.+42     	; 0x7380 <__vector_6+0x54>
    if (bit_istrue(pin,bit(RESET_BIT))) {
    7356:	80 ff       	sbrs	r24, 0
    7358:	03 c0       	rjmp	.+6      	; 0x7360 <__vector_6+0x34>
      mc_reset();
    735a:	0e 94 a5 0c 	call	0x194a	; 0x194a <mc_reset>
    735e:	10 c0       	rjmp	.+32     	; 0x7380 <__vector_6+0x54>
    } else if (bit_istrue(pin,bit(CYCLE_START_BIT))) {
    7360:	98 2f       	mov	r25, r24
    7362:	94 70       	andi	r25, 0x04	; 4
    7364:	31 f0       	breq	.+12     	; 0x7372 <__vector_6+0x46>
      bit_true(sys.rt_exec_state, EXEC_CYCLE_START);
    7366:	ea e6       	ldi	r30, 0x6A	; 106
    7368:	f7 e0       	ldi	r31, 0x07	; 7
    736a:	80 81       	ld	r24, Z
    736c:	82 60       	ori	r24, 0x02	; 2
    736e:	80 83       	st	Z, r24
    7370:	07 c0       	rjmp	.+14     	; 0x7380 <__vector_6+0x54>
    #ifndef ENABLE_SAFETY_DOOR_INPUT_PIN
      } else if (bit_istrue(pin,bit(FEED_HOLD_BIT))) {
    7372:	81 ff       	sbrs	r24, 1
    7374:	05 c0       	rjmp	.+10     	; 0x7380 <__vector_6+0x54>
        bit_true(sys.rt_exec_state, EXEC_FEED_HOLD); 
    7376:	ea e6       	ldi	r30, 0x6A	; 106
    7378:	f7 e0       	ldi	r31, 0x07	; 7
    737a:	80 81       	ld	r24, Z
    737c:	88 60       	ori	r24, 0x08	; 8
    737e:	80 83       	st	Z, r24
      } else if (bit_istrue(pin,bit(SAFETY_DOOR_BIT))) {
        bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
    #endif
    } 
  }
}
    7380:	ff 91       	pop	r31
    7382:	ef 91       	pop	r30
    7384:	bf 91       	pop	r27
    7386:	af 91       	pop	r26
    7388:	9f 91       	pop	r25
    738a:	8f 91       	pop	r24
    738c:	7f 91       	pop	r23
    738e:	6f 91       	pop	r22
    7390:	5f 91       	pop	r21
    7392:	4f 91       	pop	r20
    7394:	3f 91       	pop	r19
    7396:	2f 91       	pop	r18
    7398:	0f 90       	pop	r0
    739a:	0f be       	out	0x3f, r0	; 63
    739c:	0f 90       	pop	r0
    739e:	1f 90       	pop	r1
    73a0:	18 95       	reti

000073a2 <system_check_safety_door_ajar>:
      return(bit_isfalse(CONTROL_PIN,bit(SAFETY_DOOR_BIT)));
    #endif
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
  #endif
}
    73a2:	80 e0       	ldi	r24, 0x00	; 0
    73a4:	08 95       	ret

000073a6 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
    73a6:	1f 93       	push	r17
    73a8:	cf 93       	push	r28
    73aa:	df 93       	push	r29
    73ac:	ec 01       	movw	r28, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    73ae:	10 e0       	ldi	r17, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    73b0:	be 01       	movw	r22, r28
    73b2:	81 2f       	mov	r24, r17
    73b4:	0e 94 e8 26 	call	0x4dd0	; 0x4dd0 <settings_read_startup_line>
    73b8:	81 11       	cpse	r24, r1
    73ba:	04 c0       	rjmp	.+8      	; 0x73c4 <system_execute_startup+0x1e>
      report_status_message(STATUS_SETTING_READ_FAIL);
    73bc:	87 e0       	ldi	r24, 0x07	; 7
    73be:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
    73c2:	0b c0       	rjmp	.+22     	; 0x73da <system_execute_startup+0x34>
    } else {
      if (line[0] != 0) {
    73c4:	88 81       	ld	r24, Y
    73c6:	88 23       	and	r24, r24
    73c8:	41 f0       	breq	.+16     	; 0x73da <system_execute_startup+0x34>
        printString(line); // Echo startup line to indicate execution.
    73ca:	ce 01       	movw	r24, r28
    73cc:	0e 94 97 32 	call	0x652e	; 0x652e <printString>
        report_status_message(gc_execute_line(line));
    73d0:	ce 01       	movw	r24, r28
    73d2:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <gc_execute_line>
    73d6:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    73da:	1f 5f       	subi	r17, 0xFF	; 255
    73dc:	12 30       	cpi	r17, 0x02	; 2
    73de:	41 f7       	brne	.-48     	; 0x73b0 <system_execute_startup+0xa>
        printString(line); // Echo startup line to indicate execution.
        report_status_message(gc_execute_line(line));
      }
    } 
  }  
}
    73e0:	df 91       	pop	r29
    73e2:	cf 91       	pop	r28
    73e4:	1f 91       	pop	r17
    73e6:	08 95       	ret

000073e8 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle, 
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
    73e8:	8f 92       	push	r8
    73ea:	9f 92       	push	r9
    73ec:	af 92       	push	r10
    73ee:	bf 92       	push	r11
    73f0:	cf 92       	push	r12
    73f2:	df 92       	push	r13
    73f4:	ef 92       	push	r14
    73f6:	ff 92       	push	r15
    73f8:	1f 93       	push	r17
    73fa:	cf 93       	push	r28
    73fc:	df 93       	push	r29
    73fe:	cd b7       	in	r28, 0x3d	; 61
    7400:	de b7       	in	r29, 0x3e	; 62
    7402:	29 97       	sbiw	r28, 0x09	; 9
    7404:	0f b6       	in	r0, 0x3f	; 63
    7406:	f8 94       	cli
    7408:	de bf       	out	0x3e, r29	; 62
    740a:	0f be       	out	0x3f, r0	; 63
    740c:	cd bf       	out	0x3d, r28	; 61
    740e:	7c 01       	movw	r14, r24
  uint8_t char_counter = 1; 
    7410:	81 e0       	ldi	r24, 0x01	; 1
    7412:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    7414:	f7 01       	movw	r30, r14
    7416:	81 81       	ldd	r24, Z+1	; 0x01
    7418:	83 34       	cpi	r24, 0x43	; 67
    741a:	41 f1       	breq	.+80     	; 0x746c <system_execute_line+0x84>
    741c:	28 f4       	brcc	.+10     	; 0x7428 <system_execute_line+0x40>
    741e:	88 23       	and	r24, r24
    7420:	41 f0       	breq	.+16     	; 0x7432 <system_execute_line+0x4a>
    7422:	84 32       	cpi	r24, 0x24	; 36
    7424:	51 f0       	breq	.+20     	; 0x743a <system_execute_line+0x52>
    7426:	4f c0       	rjmp	.+158    	; 0x74c6 <system_execute_line+0xde>
    7428:	87 34       	cpi	r24, 0x47	; 71
    742a:	b1 f0       	breq	.+44     	; 0x7458 <system_execute_line+0x70>
    742c:	88 35       	cpi	r24, 0x58	; 88
    742e:	c9 f1       	breq	.+114    	; 0x74a2 <system_execute_line+0xba>
    7430:	4a c0       	rjmp	.+148    	; 0x74c6 <system_execute_line+0xde>
    case 0 : report_grbl_help(); break;
    7432:	0e 94 1b 35 	call	0x6a36	; 0x6a36 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7436:	80 e0       	ldi	r24, 0x00	; 0
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    7438:	4d c1       	rjmp	.+666    	; 0x76d4 <system_execute_line+0x2ec>
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    743a:	82 e0       	ldi	r24, 0x02	; 2
    743c:	89 83       	std	Y+1, r24	; 0x01
    743e:	f7 01       	movw	r30, r14
    7440:	82 81       	ldd	r24, Z+2	; 0x02
    7442:	81 11       	cpse	r24, r1
    7444:	21 c1       	rjmp	.+578    	; 0x7688 <system_execute_line+0x2a0>
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7446:	80 91 68 07 	lds	r24, 0x0768
    744a:	88 71       	andi	r24, 0x18	; 24
    744c:	09 f0       	breq	.+2      	; 0x7450 <system_execute_line+0x68>
    744e:	1e c1       	rjmp	.+572    	; 0x768c <system_execute_line+0x2a4>
      else { report_grbl_settings(); }
    7450:	0e 94 20 35 	call	0x6a40	; 0x6a40 <report_grbl_settings>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7454:	80 e0       	ldi	r24, 0x00	; 0
    case 0 : report_grbl_help(); break;
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
      else { report_grbl_settings(); }
      break;
    7456:	3e c1       	rjmp	.+636    	; 0x76d4 <system_execute_line+0x2ec>
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7458:	82 e0       	ldi	r24, 0x02	; 2
    745a:	89 83       	std	Y+1, r24	; 0x01
    745c:	f7 01       	movw	r30, r14
    745e:	82 81       	ldd	r24, Z+2	; 0x02
    7460:	81 11       	cpse	r24, r1
    7462:	16 c1       	rjmp	.+556    	; 0x7690 <system_execute_line+0x2a8>
      else { report_gcode_modes(); }
    7464:	0e 94 7f 37 	call	0x6efe	; 0x6efe <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7468:	80 e0       	ldi	r24, 0x00	; 0
      break;
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      else { report_gcode_modes(); }
      break;   
    746a:	34 c1       	rjmp	.+616    	; 0x76d4 <system_execute_line+0x2ec>
    case 'C' : // Set check g-code mode [IDLE/CHECK]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    746c:	82 e0       	ldi	r24, 0x02	; 2
    746e:	89 83       	std	Y+1, r24	; 0x01
    7470:	f7 01       	movw	r30, r14
    7472:	82 81       	ldd	r24, Z+2	; 0x02
    7474:	81 11       	cpse	r24, r1
    7476:	0e c1       	rjmp	.+540    	; 0x7694 <system_execute_line+0x2ac>
      // Perform reset when toggling off. Check g-code mode should only work if Grbl
      // is idle and ready, regardless of alarm locks. This is mainly to keep things
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
    7478:	80 91 68 07 	lds	r24, 0x0768
    747c:	82 30       	cpi	r24, 0x02	; 2
    747e:	39 f4       	brne	.+14     	; 0x748e <system_execute_line+0xa6>
        mc_reset(); 
    7480:	0e 94 a5 0c 	call	0x194a	; 0x194a <mc_reset>
        report_feedback_message(MESSAGE_DISABLED);
    7484:	85 e0       	ldi	r24, 0x05	; 5
    7486:	0e 94 df 34 	call	0x69be	; 0x69be <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    748a:	80 e0       	ldi	r24, 0x00	; 0
    748c:	23 c1       	rjmp	.+582    	; 0x76d4 <system_execute_line+0x2ec>
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
        mc_reset(); 
        report_feedback_message(MESSAGE_DISABLED);
      } else {
        if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    748e:	81 11       	cpse	r24, r1
    7490:	03 c1       	rjmp	.+518    	; 0x7698 <system_execute_line+0x2b0>
        sys.state = STATE_CHECK_MODE;
    7492:	82 e0       	ldi	r24, 0x02	; 2
    7494:	80 93 68 07 	sts	0x0768, r24
        report_feedback_message(MESSAGE_ENABLED);
    7498:	84 e0       	ldi	r24, 0x04	; 4
    749a:	0e 94 df 34 	call	0x69be	; 0x69be <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    749e:	80 e0       	ldi	r24, 0x00	; 0
    74a0:	19 c1       	rjmp	.+562    	; 0x76d4 <system_execute_line+0x2ec>
        sys.state = STATE_CHECK_MODE;
        report_feedback_message(MESSAGE_ENABLED);
      }
      break; 
    case 'X' : // Disable alarm lock [ALARM]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    74a2:	82 e0       	ldi	r24, 0x02	; 2
    74a4:	89 83       	std	Y+1, r24	; 0x01
    74a6:	f7 01       	movw	r30, r14
    74a8:	82 81       	ldd	r24, Z+2	; 0x02
    74aa:	81 11       	cpse	r24, r1
    74ac:	f7 c0       	rjmp	.+494    	; 0x769c <system_execute_line+0x2b4>
      if (sys.state == STATE_ALARM) { 
    74ae:	80 91 68 07 	lds	r24, 0x0768
    74b2:	81 30       	cpi	r24, 0x01	; 1
    74b4:	09 f0       	breq	.+2      	; 0x74b8 <system_execute_line+0xd0>
    74b6:	f4 c0       	rjmp	.+488    	; 0x76a0 <system_execute_line+0x2b8>
        report_feedback_message(MESSAGE_ALARM_UNLOCK);
    74b8:	83 e0       	ldi	r24, 0x03	; 3
    74ba:	0e 94 df 34 	call	0x69be	; 0x69be <report_feedback_message>
        sys.state = STATE_IDLE;
    74be:	10 92 68 07 	sts	0x0768, r1
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74c2:	80 e0       	ldi	r24, 0x00	; 0
    74c4:	07 c1       	rjmp	.+526    	; 0x76d4 <system_execute_line+0x2ec>
      // handled by the planner. It would be possible for the jog subprogram to insert blocks into the
      // block buffer without having the planner plan them. It would need to manage de/ac-celerations 
      // on its own carefully. This approach could be effective and possibly size/memory efficient.        
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    74c6:	90 91 68 07 	lds	r25, 0x0768
    74ca:	92 30       	cpi	r25, 0x02	; 2
    74cc:	08 f0       	brcs	.+2      	; 0x74d0 <system_execute_line+0xe8>
    74ce:	ea c0       	rjmp	.+468    	; 0x76a4 <system_execute_line+0x2bc>
      switch( line[char_counter] ) {
    74d0:	88 34       	cpi	r24, 0x48	; 72
    74d2:	a1 f0       	breq	.+40     	; 0x74fc <system_execute_line+0x114>
    74d4:	18 f4       	brcc	.+6      	; 0x74dc <system_execute_line+0xf4>
    74d6:	83 32       	cpi	r24, 0x23	; 35
    74d8:	39 f0       	breq	.+14     	; 0x74e8 <system_execute_line+0x100>
    74da:	66 c0       	rjmp	.+204    	; 0x75a8 <system_execute_line+0x1c0>
    74dc:	89 34       	cpi	r24, 0x49	; 73
    74de:	21 f1       	breq	.+72     	; 0x7528 <system_execute_line+0x140>
    74e0:	8e 34       	cpi	r24, 0x4E	; 78
    74e2:	09 f4       	brne	.+2      	; 0x74e6 <system_execute_line+0xfe>
    74e4:	44 c0       	rjmp	.+136    	; 0x756e <system_execute_line+0x186>
    74e6:	60 c0       	rjmp	.+192    	; 0x75a8 <system_execute_line+0x1c0>
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    74e8:	82 e0       	ldi	r24, 0x02	; 2
    74ea:	89 83       	std	Y+1, r24	; 0x01
    74ec:	f7 01       	movw	r30, r14
    74ee:	82 81       	ldd	r24, Z+2	; 0x02
    74f0:	81 11       	cpse	r24, r1
    74f2:	da c0       	rjmp	.+436    	; 0x76a8 <system_execute_line+0x2c0>
          else { report_ngc_parameters(); }
    74f4:	0e 94 e4 36 	call	0x6dc8	; 0x6dc8 <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74f8:	80 e0       	ldi	r24, 0x00	; 0
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;          
    74fa:	ec c0       	rjmp	.+472    	; 0x76d4 <system_execute_line+0x2ec>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
    74fc:	80 91 3c 09 	lds	r24, 0x093C
    7500:	84 ff       	sbrs	r24, 4
    7502:	d4 c0       	rjmp	.+424    	; 0x76ac <system_execute_line+0x2c4>
            sys.state = STATE_HOMING; // Set system state variable
    7504:	84 e0       	ldi	r24, 0x04	; 4
    7506:	80 93 68 07 	sts	0x0768, r24
              bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
              protocol_execute_realtime(); // Enter safety door mode.
            }
            
            
            mc_homing_cycle(); 
    750a:	0e 94 0a 0c 	call	0x1814	; 0x1814 <mc_homing_cycle>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
    750e:	80 91 67 07 	lds	r24, 0x0767
    7512:	81 11       	cpse	r24, r1
    7514:	cd c0       	rjmp	.+410    	; 0x76b0 <system_execute_line+0x2c8>
              sys.state = STATE_IDLE; // Set to IDLE when complete.
    7516:	10 92 68 07 	sts	0x0768, r1
              st_go_idle(); // Set steppers to the settings idle state before returning.
    751a:	0e 94 4b 1b 	call	0x3696	; 0x3696 <st_go_idle>
              system_execute_startup(line); 
    751e:	c7 01       	movw	r24, r14
    7520:	0e 94 d3 39 	call	0x73a6	; 0x73a6 <system_execute_startup>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7524:	80 e0       	ldi	r24, 0x00	; 0
    7526:	d6 c0       	rjmp	.+428    	; 0x76d4 <system_execute_line+0x2ec>
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
    7528:	82 e0       	ldi	r24, 0x02	; 2
    752a:	89 83       	std	Y+1, r24	; 0x01
    752c:	f7 01       	movw	r30, r14
    752e:	82 81       	ldd	r24, Z+2	; 0x02
    7530:	81 11       	cpse	r24, r1
    7532:	08 c0       	rjmp	.+16     	; 0x7544 <system_execute_line+0x15c>
            settings_read_build_info(line);
    7534:	c7 01       	movw	r24, r14
    7536:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <settings_read_build_info>
            report_build_info(line);
    753a:	c7 01       	movw	r24, r14
    753c:	0e 94 72 38 	call	0x70e4	; 0x70e4 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7540:	80 e0       	ldi	r24, 0x00	; 0
    7542:	c8 c0       	rjmp	.+400    	; 0x76d4 <system_execute_line+0x2ec>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7544:	8d 33       	cpi	r24, 0x3D	; 61
    7546:	09 f0       	breq	.+2      	; 0x754a <system_execute_line+0x162>
    7548:	b5 c0       	rjmp	.+362    	; 0x76b4 <system_execute_line+0x2cc>
    754a:	83 e0       	ldi	r24, 0x03	; 3
            helper_var = char_counter; // Set helper variable as counter to start of user info line.
            do {
              line[char_counter-helper_var] = line[char_counter];
    754c:	f7 01       	movw	r30, r14
    754e:	e8 0f       	add	r30, r24
    7550:	f1 1d       	adc	r31, r1
    7552:	90 81       	ld	r25, Z
    7554:	df 01       	movw	r26, r30
    7556:	13 97       	sbiw	r26, 0x03	; 3
    7558:	9c 93       	st	X, r25
            } while (line[char_counter++] != 0);
    755a:	8f 5f       	subi	r24, 0xFF	; 255
    755c:	90 81       	ld	r25, Z
    755e:	91 11       	cpse	r25, r1
    7560:	f5 cf       	rjmp	.-22     	; 0x754c <system_execute_line+0x164>
    7562:	89 83       	std	Y+1, r24	; 0x01
            settings_store_build_info(line);
    7564:	c7 01       	movw	r24, r14
    7566:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    756a:	80 e0       	ldi	r24, 0x00	; 0
    756c:	b3 c0       	rjmp	.+358    	; 0x76d4 <system_execute_line+0x2ec>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break;                 
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    756e:	82 e0       	ldi	r24, 0x02	; 2
    7570:	89 83       	std	Y+1, r24	; 0x01
    7572:	f7 01       	movw	r30, r14
    7574:	82 81       	ldd	r24, Z+2	; 0x02
    7576:	81 11       	cpse	r24, r1
    7578:	13 c0       	rjmp	.+38     	; 0x75a0 <system_execute_line+0x1b8>
    757a:	10 e0       	ldi	r17, 0x00	; 0
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    757c:	b7 01       	movw	r22, r14
    757e:	81 2f       	mov	r24, r17
    7580:	0e 94 e8 26 	call	0x4dd0	; 0x4dd0 <settings_read_startup_line>
    7584:	81 11       	cpse	r24, r1
    7586:	04 c0       	rjmp	.+8      	; 0x7590 <system_execute_line+0x1a8>
                report_status_message(STATUS_SETTING_READ_FAIL);
    7588:	87 e0       	ldi	r24, 0x07	; 7
    758a:	0e 94 41 34 	call	0x6882	; 0x6882 <report_status_message>
    758e:	04 c0       	rjmp	.+8      	; 0x7598 <system_execute_line+0x1b0>
              } else {
                report_startup_line(helper_var,line);
    7590:	b7 01       	movw	r22, r14
    7592:	81 2f       	mov	r24, r17
    7594:	0e 94 57 38 	call	0x70ae	; 0x70ae <report_startup_line>
            settings_store_build_info(line);
          }
          break;                 
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    7598:	1f 5f       	subi	r17, 0xFF	; 255
    759a:	12 30       	cpi	r17, 0x02	; 2
    759c:	79 f7       	brne	.-34     	; 0x757c <system_execute_line+0x194>
    759e:	8c c0       	rjmp	.+280    	; 0x76b8 <system_execute_line+0x2d0>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    75a0:	91 11       	cpse	r25, r1
    75a2:	8c c0       	rjmp	.+280    	; 0x76bc <system_execute_line+0x2d4>
            helper_var = true;  // Set helper_var to flag storing method. 
    75a4:	11 e0       	ldi	r17, 0x01	; 1
    75a6:	01 c0       	rjmp	.+2      	; 0x75aa <system_execute_line+0x1c2>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
    75a8:	10 e0       	ldi	r17, 0x00	; 0
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    75aa:	ae 01       	movw	r20, r28
    75ac:	4e 5f       	subi	r20, 0xFE	; 254
    75ae:	5f 4f       	sbci	r21, 0xFF	; 255
    75b0:	be 01       	movw	r22, r28
    75b2:	6f 5f       	subi	r22, 0xFF	; 255
    75b4:	7f 4f       	sbci	r23, 0xFF	; 255
    75b6:	c7 01       	movw	r24, r14
    75b8:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <read_float>
    75bc:	88 23       	and	r24, r24
    75be:	09 f4       	brne	.+2      	; 0x75c2 <system_execute_line+0x1da>
    75c0:	7f c0       	rjmp	.+254    	; 0x76c0 <system_execute_line+0x2d8>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    75c2:	89 81       	ldd	r24, Y+1	; 0x01
    75c4:	21 e0       	ldi	r18, 0x01	; 1
    75c6:	28 0f       	add	r18, r24
    75c8:	29 83       	std	Y+1, r18	; 0x01
    75ca:	f7 01       	movw	r30, r14
    75cc:	e8 0f       	add	r30, r24
    75ce:	f1 1d       	adc	r31, r1
    75d0:	80 81       	ld	r24, Z
    75d2:	8d 33       	cpi	r24, 0x3D	; 61
    75d4:	09 f0       	breq	.+2      	; 0x75d8 <system_execute_line+0x1f0>
    75d6:	76 c0       	rjmp	.+236    	; 0x76c4 <system_execute_line+0x2dc>
          if (helper_var) { // Store startup line
    75d8:	11 23       	and	r17, r17
    75da:	39 f1       	breq	.+78     	; 0x762a <system_execute_line+0x242>
    75dc:	42 2f       	mov	r20, r18
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    75de:	30 e0       	ldi	r19, 0x00	; 0
    75e0:	84 2f       	mov	r24, r20
    75e2:	90 e0       	ldi	r25, 0x00	; 0
    75e4:	f7 01       	movw	r30, r14
    75e6:	e8 0f       	add	r30, r24
    75e8:	f9 1f       	adc	r31, r25
    75ea:	50 81       	ld	r21, Z
    75ec:	82 1b       	sub	r24, r18
    75ee:	93 0b       	sbc	r25, r19
    75f0:	d7 01       	movw	r26, r14
    75f2:	a8 0f       	add	r26, r24
    75f4:	b9 1f       	adc	r27, r25
    75f6:	5c 93       	st	X, r21
            } while (line[char_counter++] != 0);
    75f8:	4f 5f       	subi	r20, 0xFF	; 255
    75fa:	80 81       	ld	r24, Z
    75fc:	81 11       	cpse	r24, r1
    75fe:	f0 cf       	rjmp	.-32     	; 0x75e0 <system_execute_line+0x1f8>
    7600:	49 83       	std	Y+1, r20	; 0x01
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    7602:	c7 01       	movw	r24, r14
    7604:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <gc_execute_line>
    7608:	18 2f       	mov	r17, r24
            if (helper_var) { return(helper_var); }
    760a:	81 11       	cpse	r24, r1
    760c:	5d c0       	rjmp	.+186    	; 0x76c8 <system_execute_line+0x2e0>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    760e:	6a 81       	ldd	r22, Y+2	; 0x02
    7610:	7b 81       	ldd	r23, Y+3	; 0x03
    7612:	8c 81       	ldd	r24, Y+4	; 0x04
    7614:	9d 81       	ldd	r25, Y+5	; 0x05
    7616:	0e 94 98 3f 	call	0x7f30	; 0x7f30 <trunc>
    761a:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
    761e:	86 2f       	mov	r24, r22
              settings_store_startup_line(helper_var,line);
    7620:	b7 01       	movw	r22, r14
    7622:	0e 94 c6 25 	call	0x4b8c	; 0x4b8c <settings_store_startup_line>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7626:	81 2f       	mov	r24, r17
    7628:	55 c0       	rjmp	.+170    	; 0x76d4 <system_execute_line+0x2ec>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    762a:	ae 01       	movw	r20, r28
    762c:	4a 5f       	subi	r20, 0xFA	; 250
    762e:	5f 4f       	sbci	r21, 0xFF	; 255
    7630:	be 01       	movw	r22, r28
    7632:	6f 5f       	subi	r22, 0xFF	; 255
    7634:	7f 4f       	sbci	r23, 0xFF	; 255
    7636:	c7 01       	movw	r24, r14
    7638:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <read_float>
    763c:	88 23       	and	r24, r24
    763e:	09 f4       	brne	.+2      	; 0x7642 <system_execute_line+0x25a>
    7640:	44 c0       	rjmp	.+136    	; 0x76ca <system_execute_line+0x2e2>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7642:	89 81       	ldd	r24, Y+1	; 0x01
    7644:	f7 01       	movw	r30, r14
    7646:	e8 0f       	add	r30, r24
    7648:	f1 1d       	adc	r31, r1
    764a:	80 81       	ld	r24, Z
    764c:	81 11       	cpse	r24, r1
    764e:	3f c0       	rjmp	.+126    	; 0x76ce <system_execute_line+0x2e6>
    7650:	ca 80       	ldd	r12, Y+2	; 0x02
    7652:	db 80       	ldd	r13, Y+3	; 0x03
    7654:	ec 80       	ldd	r14, Y+4	; 0x04
    7656:	fd 80       	ldd	r15, Y+5	; 0x05
    7658:	20 e0       	ldi	r18, 0x00	; 0
    765a:	30 e0       	ldi	r19, 0x00	; 0
    765c:	4f e7       	ldi	r20, 0x7F	; 127
    765e:	53 e4       	ldi	r21, 0x43	; 67
    7660:	c7 01       	movw	r24, r14
    7662:	b6 01       	movw	r22, r12
    7664:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__gesf2>
    7668:	18 16       	cp	r1, r24
    766a:	9c f1       	brlt	.+102    	; 0x76d2 <system_execute_line+0x2ea>
            return(settings_store_global_setting((uint8_t)parameter, value));
    766c:	8e 80       	ldd	r8, Y+6	; 0x06
    766e:	9f 80       	ldd	r9, Y+7	; 0x07
    7670:	a8 84       	ldd	r10, Y+8	; 0x08
    7672:	b9 84       	ldd	r11, Y+9	; 0x09
    7674:	c7 01       	movw	r24, r14
    7676:	b6 01       	movw	r22, r12
    7678:	0e 94 00 3d 	call	0x7a00	; 0x7a00 <__fixunssfsi>
    767c:	86 2f       	mov	r24, r22
    767e:	b5 01       	movw	r22, r10
    7680:	a4 01       	movw	r20, r8
    7682:	0e 94 51 27 	call	0x4ea2	; 0x4ea2 <settings_store_global_setting>
    7686:	26 c0       	rjmp	.+76     	; 0x76d4 <system_execute_line+0x2ec>
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7688:	83 e0       	ldi	r24, 0x03	; 3
    768a:	24 c0       	rjmp	.+72     	; 0x76d4 <system_execute_line+0x2ec>
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    768c:	88 e0       	ldi	r24, 0x08	; 8
    768e:	22 c0       	rjmp	.+68     	; 0x76d4 <system_execute_line+0x2ec>
      else { report_grbl_settings(); }
      break;
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7690:	83 e0       	ldi	r24, 0x03	; 3
    7692:	20 c0       	rjmp	.+64     	; 0x76d4 <system_execute_line+0x2ec>
      else { report_gcode_modes(); }
      break;   
    case 'C' : // Set check g-code mode [IDLE/CHECK]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7694:	83 e0       	ldi	r24, 0x03	; 3
    7696:	1e c0       	rjmp	.+60     	; 0x76d4 <system_execute_line+0x2ec>
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
        mc_reset(); 
        report_feedback_message(MESSAGE_DISABLED);
      } else {
        if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7698:	88 e0       	ldi	r24, 0x08	; 8
    769a:	1c c0       	rjmp	.+56     	; 0x76d4 <system_execute_line+0x2ec>
        sys.state = STATE_CHECK_MODE;
        report_feedback_message(MESSAGE_ENABLED);
      }
      break; 
    case 'X' : // Disable alarm lock [ALARM]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    769c:	83 e0       	ldi	r24, 0x03	; 3
    769e:	1a c0       	rjmp	.+52     	; 0x76d4 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76a0:	80 e0       	ldi	r24, 0x00	; 0
    76a2:	18 c0       	rjmp	.+48     	; 0x76d4 <system_execute_line+0x2ec>
      // handled by the planner. It would be possible for the jog subprogram to insert blocks into the
      // block buffer without having the planner plan them. It would need to manage de/ac-celerations 
      // on its own carefully. This approach could be effective and possibly size/memory efficient.        
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    76a4:	88 e0       	ldi	r24, 0x08	; 8
    76a6:	16 c0       	rjmp	.+44     	; 0x76d4 <system_execute_line+0x2ec>
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76a8:	83 e0       	ldi	r24, 0x03	; 3
    76aa:	14 c0       	rjmp	.+40     	; 0x76d4 <system_execute_line+0x2ec>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
              sys.state = STATE_IDLE; // Set to IDLE when complete.
              st_go_idle(); // Set steppers to the settings idle state before returning.
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
    76ac:	85 e0       	ldi	r24, 0x05	; 5
    76ae:	12 c0       	rjmp	.+36     	; 0x76d4 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76b0:	80 e0       	ldi	r24, 0x00	; 0
    76b2:	10 c0       	rjmp	.+32     	; 0x76d4 <system_execute_line+0x2ec>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    76b4:	83 e0       	ldi	r24, 0x03	; 3
    76b6:	0e c0       	rjmp	.+28     	; 0x76d4 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76b8:	80 e0       	ldi	r24, 0x00	; 0
    76ba:	0c c0       	rjmp	.+24     	; 0x76d4 <system_execute_line+0x2ec>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    76bc:	88 e0       	ldi	r24, 0x08	; 8
    76be:	0a c0       	rjmp	.+20     	; 0x76d4 <system_execute_line+0x2ec>
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    76c0:	82 e0       	ldi	r24, 0x02	; 2
    76c2:	08 c0       	rjmp	.+16     	; 0x76d4 <system_execute_line+0x2ec>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    76c4:	83 e0       	ldi	r24, 0x03	; 3
    76c6:	06 c0       	rjmp	.+12     	; 0x76d4 <system_execute_line+0x2ec>
    76c8:	05 c0       	rjmp	.+10     	; 0x76d4 <system_execute_line+0x2ec>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    76ca:	82 e0       	ldi	r24, 0x02	; 2
    76cc:	03 c0       	rjmp	.+6      	; 0x76d4 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    76ce:	83 e0       	ldi	r24, 0x03	; 3
    76d0:	01 c0       	rjmp	.+2      	; 0x76d4 <system_execute_line+0x2ec>
    76d2:	83 e0       	ldi	r24, 0x03	; 3
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    76d4:	29 96       	adiw	r28, 0x09	; 9
    76d6:	0f b6       	in	r0, 0x3f	; 63
    76d8:	f8 94       	cli
    76da:	de bf       	out	0x3e, r29	; 62
    76dc:	0f be       	out	0x3f, r0	; 63
    76de:	cd bf       	out	0x3d, r28	; 61
    76e0:	df 91       	pop	r29
    76e2:	cf 91       	pop	r28
    76e4:	1f 91       	pop	r17
    76e6:	ff 90       	pop	r15
    76e8:	ef 90       	pop	r14
    76ea:	df 90       	pop	r13
    76ec:	cf 90       	pop	r12
    76ee:	bf 90       	pop	r11
    76f0:	af 90       	pop	r10
    76f2:	9f 90       	pop	r9
    76f4:	8f 90       	pop	r8
    76f6:	08 95       	ret

000076f8 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    76f8:	cf 93       	push	r28
    76fa:	df 93       	push	r29
      pos = 0.5*((steps[A_MOTOR] + steps[B_MOTOR])/settings.steps_per_mm[idx]);
    } else { // (idx==B_MOTOR)
      pos = 0.5*((steps[A_MOTOR] - steps[B_MOTOR])/settings.steps_per_mm[idx]);
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    76fc:	c6 2f       	mov	r28, r22
    76fe:	d0 e0       	ldi	r29, 0x00	; 0
    7700:	cc 0f       	add	r28, r28
    7702:	dd 1f       	adc	r29, r29
    7704:	cc 0f       	add	r28, r28
    7706:	dd 1f       	adc	r29, r29
    7708:	8c 0f       	add	r24, r28
    770a:	9d 1f       	adc	r25, r29
    770c:	fc 01       	movw	r30, r24
    770e:	60 81       	ld	r22, Z
    7710:	71 81       	ldd	r23, Z+1	; 0x01
    7712:	82 81       	ldd	r24, Z+2	; 0x02
    7714:	93 81       	ldd	r25, Z+3	; 0x03
    7716:	0e 94 2e 3d 	call	0x7a5c	; 0x7a5c <__floatsisf>
    771a:	c1 50       	subi	r28, 0x01	; 1
    771c:	d7 4f       	sbci	r29, 0xF7	; 247
    771e:	28 81       	ld	r18, Y
    7720:	39 81       	ldd	r19, Y+1	; 0x01
    7722:	4a 81       	ldd	r20, Y+2	; 0x02
    7724:	5b 81       	ldd	r21, Y+3	; 0x03
    7726:	0e 94 93 3c 	call	0x7926	; 0x7926 <__divsf3>
  #endif
  return(pos);
}
    772a:	df 91       	pop	r29
    772c:	cf 91       	pop	r28
    772e:	08 95       	ret

00007730 <system_convert_array_steps_to_mpos>:
  

void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    7730:	ff 92       	push	r15
    7732:	0f 93       	push	r16
    7734:	1f 93       	push	r17
    7736:	cf 93       	push	r28
    7738:	df 93       	push	r29
    773a:	8b 01       	movw	r16, r22
    773c:	ec 01       	movw	r28, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    773e:	f1 2c       	mov	r15, r1
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    7740:	6f 2d       	mov	r22, r15
    7742:	c8 01       	movw	r24, r16
    7744:	0e 94 7c 3b 	call	0x76f8	; 0x76f8 <system_convert_axis_steps_to_mpos>
    7748:	69 93       	st	Y+, r22
    774a:	79 93       	st	Y+, r23
    774c:	89 93       	st	Y+, r24
    774e:	99 93       	st	Y+, r25
  

void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7750:	f3 94       	inc	r15
    7752:	83 e0       	ldi	r24, 0x03	; 3
    7754:	f8 12       	cpse	r15, r24
    7756:	f4 cf       	rjmp	.-24     	; 0x7740 <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    7758:	df 91       	pop	r29
    775a:	cf 91       	pop	r28
    775c:	1f 91       	pop	r17
    775e:	0f 91       	pop	r16
    7760:	ff 90       	pop	r15
    7762:	08 95       	ret

00007764 <__subsf3>:
    7764:	50 58       	subi	r21, 0x80	; 128

00007766 <__addsf3>:
    7766:	bb 27       	eor	r27, r27
    7768:	aa 27       	eor	r26, r26
    776a:	0e d0       	rcall	.+28     	; 0x7788 <__addsf3x>
    776c:	76 c2       	rjmp	.+1260   	; 0x7c5a <__fp_round>
    776e:	3f d2       	rcall	.+1150   	; 0x7bee <__fp_pscA>
    7770:	30 f0       	brcs	.+12     	; 0x777e <__addsf3+0x18>
    7772:	44 d2       	rcall	.+1160   	; 0x7bfc <__fp_pscB>
    7774:	20 f0       	brcs	.+8      	; 0x777e <__addsf3+0x18>
    7776:	31 f4       	brne	.+12     	; 0x7784 <__addsf3+0x1e>
    7778:	9f 3f       	cpi	r25, 0xFF	; 255
    777a:	11 f4       	brne	.+4      	; 0x7780 <__addsf3+0x1a>
    777c:	1e f4       	brtc	.+6      	; 0x7784 <__addsf3+0x1e>
    777e:	0f c2       	rjmp	.+1054   	; 0x7b9e <__fp_nan>
    7780:	0e f4       	brtc	.+2      	; 0x7784 <__addsf3+0x1e>
    7782:	e0 95       	com	r30
    7784:	e7 fb       	bst	r30, 7
    7786:	dc c1       	rjmp	.+952    	; 0x7b40 <__fp_inf>

00007788 <__addsf3x>:
    7788:	e9 2f       	mov	r30, r25
    778a:	89 d2       	rcall	.+1298   	; 0x7c9e <__fp_split3>
    778c:	80 f3       	brcs	.-32     	; 0x776e <__addsf3+0x8>
    778e:	ba 17       	cp	r27, r26
    7790:	62 07       	cpc	r22, r18
    7792:	73 07       	cpc	r23, r19
    7794:	84 07       	cpc	r24, r20
    7796:	95 07       	cpc	r25, r21
    7798:	18 f0       	brcs	.+6      	; 0x77a0 <__addsf3x+0x18>
    779a:	71 f4       	brne	.+28     	; 0x77b8 <__addsf3x+0x30>
    779c:	9e f5       	brtc	.+102    	; 0x7804 <__addsf3x+0x7c>
    779e:	b8 c2       	rjmp	.+1392   	; 0x7d10 <__fp_zero>
    77a0:	0e f4       	brtc	.+2      	; 0x77a4 <__addsf3x+0x1c>
    77a2:	e0 95       	com	r30
    77a4:	0b 2e       	mov	r0, r27
    77a6:	ba 2f       	mov	r27, r26
    77a8:	a0 2d       	mov	r26, r0
    77aa:	0b 01       	movw	r0, r22
    77ac:	b9 01       	movw	r22, r18
    77ae:	90 01       	movw	r18, r0
    77b0:	0c 01       	movw	r0, r24
    77b2:	ca 01       	movw	r24, r20
    77b4:	a0 01       	movw	r20, r0
    77b6:	11 24       	eor	r1, r1
    77b8:	ff 27       	eor	r31, r31
    77ba:	59 1b       	sub	r21, r25
    77bc:	99 f0       	breq	.+38     	; 0x77e4 <__addsf3x+0x5c>
    77be:	59 3f       	cpi	r21, 0xF9	; 249
    77c0:	50 f4       	brcc	.+20     	; 0x77d6 <__addsf3x+0x4e>
    77c2:	50 3e       	cpi	r21, 0xE0	; 224
    77c4:	68 f1       	brcs	.+90     	; 0x7820 <__addsf3x+0x98>
    77c6:	1a 16       	cp	r1, r26
    77c8:	f0 40       	sbci	r31, 0x00	; 0
    77ca:	a2 2f       	mov	r26, r18
    77cc:	23 2f       	mov	r18, r19
    77ce:	34 2f       	mov	r19, r20
    77d0:	44 27       	eor	r20, r20
    77d2:	58 5f       	subi	r21, 0xF8	; 248
    77d4:	f3 cf       	rjmp	.-26     	; 0x77bc <__addsf3x+0x34>
    77d6:	46 95       	lsr	r20
    77d8:	37 95       	ror	r19
    77da:	27 95       	ror	r18
    77dc:	a7 95       	ror	r26
    77de:	f0 40       	sbci	r31, 0x00	; 0
    77e0:	53 95       	inc	r21
    77e2:	c9 f7       	brne	.-14     	; 0x77d6 <__addsf3x+0x4e>
    77e4:	7e f4       	brtc	.+30     	; 0x7804 <__addsf3x+0x7c>
    77e6:	1f 16       	cp	r1, r31
    77e8:	ba 0b       	sbc	r27, r26
    77ea:	62 0b       	sbc	r22, r18
    77ec:	73 0b       	sbc	r23, r19
    77ee:	84 0b       	sbc	r24, r20
    77f0:	ba f0       	brmi	.+46     	; 0x7820 <__addsf3x+0x98>
    77f2:	91 50       	subi	r25, 0x01	; 1
    77f4:	a1 f0       	breq	.+40     	; 0x781e <__addsf3x+0x96>
    77f6:	ff 0f       	add	r31, r31
    77f8:	bb 1f       	adc	r27, r27
    77fa:	66 1f       	adc	r22, r22
    77fc:	77 1f       	adc	r23, r23
    77fe:	88 1f       	adc	r24, r24
    7800:	c2 f7       	brpl	.-16     	; 0x77f2 <__addsf3x+0x6a>
    7802:	0e c0       	rjmp	.+28     	; 0x7820 <__addsf3x+0x98>
    7804:	ba 0f       	add	r27, r26
    7806:	62 1f       	adc	r22, r18
    7808:	73 1f       	adc	r23, r19
    780a:	84 1f       	adc	r24, r20
    780c:	48 f4       	brcc	.+18     	; 0x7820 <__addsf3x+0x98>
    780e:	87 95       	ror	r24
    7810:	77 95       	ror	r23
    7812:	67 95       	ror	r22
    7814:	b7 95       	ror	r27
    7816:	f7 95       	ror	r31
    7818:	9e 3f       	cpi	r25, 0xFE	; 254
    781a:	08 f0       	brcs	.+2      	; 0x781e <__addsf3x+0x96>
    781c:	b3 cf       	rjmp	.-154    	; 0x7784 <__addsf3+0x1e>
    781e:	93 95       	inc	r25
    7820:	88 0f       	add	r24, r24
    7822:	08 f0       	brcs	.+2      	; 0x7826 <__addsf3x+0x9e>
    7824:	99 27       	eor	r25, r25
    7826:	ee 0f       	add	r30, r30
    7828:	97 95       	ror	r25
    782a:	87 95       	ror	r24
    782c:	08 95       	ret
    782e:	df d1       	rcall	.+958    	; 0x7bee <__fp_pscA>
    7830:	58 f0       	brcs	.+22     	; 0x7848 <__addsf3x+0xc0>
    7832:	80 e8       	ldi	r24, 0x80	; 128
    7834:	91 e0       	ldi	r25, 0x01	; 1
    7836:	09 f4       	brne	.+2      	; 0x783a <__addsf3x+0xb2>
    7838:	9e ef       	ldi	r25, 0xFE	; 254
    783a:	e0 d1       	rcall	.+960    	; 0x7bfc <__fp_pscB>
    783c:	28 f0       	brcs	.+10     	; 0x7848 <__addsf3x+0xc0>
    783e:	40 e8       	ldi	r20, 0x80	; 128
    7840:	51 e0       	ldi	r21, 0x01	; 1
    7842:	59 f4       	brne	.+22     	; 0x785a <atan2+0xe>
    7844:	5e ef       	ldi	r21, 0xFE	; 254
    7846:	09 c0       	rjmp	.+18     	; 0x785a <atan2+0xe>
    7848:	aa c1       	rjmp	.+852    	; 0x7b9e <__fp_nan>
    784a:	62 c2       	rjmp	.+1220   	; 0x7d10 <__fp_zero>

0000784c <atan2>:
    784c:	e9 2f       	mov	r30, r25
    784e:	e0 78       	andi	r30, 0x80	; 128
    7850:	26 d2       	rcall	.+1100   	; 0x7c9e <__fp_split3>
    7852:	68 f3       	brcs	.-38     	; 0x782e <__addsf3x+0xa6>
    7854:	09 2e       	mov	r0, r25
    7856:	05 2a       	or	r0, r21
    7858:	c1 f3       	breq	.-16     	; 0x784a <__addsf3x+0xc2>
    785a:	26 17       	cp	r18, r22
    785c:	37 07       	cpc	r19, r23
    785e:	48 07       	cpc	r20, r24
    7860:	59 07       	cpc	r21, r25
    7862:	38 f0       	brcs	.+14     	; 0x7872 <atan2+0x26>
    7864:	0e 2e       	mov	r0, r30
    7866:	07 f8       	bld	r0, 7
    7868:	e0 25       	eor	r30, r0
    786a:	69 f0       	breq	.+26     	; 0x7886 <atan2+0x3a>
    786c:	e0 25       	eor	r30, r0
    786e:	e0 64       	ori	r30, 0x40	; 64
    7870:	0a c0       	rjmp	.+20     	; 0x7886 <atan2+0x3a>
    7872:	ef 63       	ori	r30, 0x3F	; 63
    7874:	07 f8       	bld	r0, 7
    7876:	00 94       	com	r0
    7878:	07 fa       	bst	r0, 7
    787a:	db 01       	movw	r26, r22
    787c:	b9 01       	movw	r22, r18
    787e:	9d 01       	movw	r18, r26
    7880:	dc 01       	movw	r26, r24
    7882:	ca 01       	movw	r24, r20
    7884:	ad 01       	movw	r20, r26
    7886:	ef 93       	push	r30
    7888:	5d d0       	rcall	.+186    	; 0x7944 <__divsf3_pse>
    788a:	e7 d1       	rcall	.+974    	; 0x7c5a <__fp_round>
    788c:	0a d0       	rcall	.+20     	; 0x78a2 <atan>
    788e:	5f 91       	pop	r21
    7890:	55 23       	and	r21, r21
    7892:	31 f0       	breq	.+12     	; 0x78a0 <atan2+0x54>
    7894:	2b ed       	ldi	r18, 0xDB	; 219
    7896:	3f e0       	ldi	r19, 0x0F	; 15
    7898:	49 e4       	ldi	r20, 0x49	; 73
    789a:	50 fd       	sbrc	r21, 0
    789c:	49 ec       	ldi	r20, 0xC9	; 201
    789e:	63 cf       	rjmp	.-314    	; 0x7766 <__addsf3>
    78a0:	08 95       	ret

000078a2 <atan>:
    78a2:	df 93       	push	r29
    78a4:	dd 27       	eor	r29, r29
    78a6:	b9 2f       	mov	r27, r25
    78a8:	bf 77       	andi	r27, 0x7F	; 127
    78aa:	40 e8       	ldi	r20, 0x80	; 128
    78ac:	5f e3       	ldi	r21, 0x3F	; 63
    78ae:	16 16       	cp	r1, r22
    78b0:	17 06       	cpc	r1, r23
    78b2:	48 07       	cpc	r20, r24
    78b4:	5b 07       	cpc	r21, r27
    78b6:	10 f4       	brcc	.+4      	; 0x78bc <atan+0x1a>
    78b8:	d9 2f       	mov	r29, r25
    78ba:	35 d2       	rcall	.+1130   	; 0x7d26 <inverse>
    78bc:	9f 93       	push	r25
    78be:	8f 93       	push	r24
    78c0:	7f 93       	push	r23
    78c2:	6f 93       	push	r22
    78c4:	32 d3       	rcall	.+1636   	; 0x7f2a <square>
    78c6:	e4 e3       	ldi	r30, 0x34	; 52
    78c8:	f2 e0       	ldi	r31, 0x02	; 2
    78ca:	6c d1       	rcall	.+728    	; 0x7ba4 <__fp_powser>
    78cc:	c6 d1       	rcall	.+908    	; 0x7c5a <__fp_round>
    78ce:	2f 91       	pop	r18
    78d0:	3f 91       	pop	r19
    78d2:	4f 91       	pop	r20
    78d4:	5f 91       	pop	r21
    78d6:	6a d2       	rcall	.+1236   	; 0x7dac <__mulsf3x>
    78d8:	dd 23       	and	r29, r29
    78da:	49 f0       	breq	.+18     	; 0x78ee <atan+0x4c>
    78dc:	90 58       	subi	r25, 0x80	; 128
    78de:	a2 ea       	ldi	r26, 0xA2	; 162
    78e0:	2a ed       	ldi	r18, 0xDA	; 218
    78e2:	3f e0       	ldi	r19, 0x0F	; 15
    78e4:	49 ec       	ldi	r20, 0xC9	; 201
    78e6:	5f e3       	ldi	r21, 0x3F	; 63
    78e8:	d0 78       	andi	r29, 0x80	; 128
    78ea:	5d 27       	eor	r21, r29
    78ec:	4d df       	rcall	.-358    	; 0x7788 <__addsf3x>
    78ee:	df 91       	pop	r29
    78f0:	b4 c1       	rjmp	.+872    	; 0x7c5a <__fp_round>

000078f2 <ceil>:
    78f2:	f7 d1       	rcall	.+1006   	; 0x7ce2 <__fp_trunc>
    78f4:	80 f0       	brcs	.+32     	; 0x7916 <ceil+0x24>
    78f6:	9f 37       	cpi	r25, 0x7F	; 127
    78f8:	40 f4       	brcc	.+16     	; 0x790a <ceil+0x18>
    78fa:	91 11       	cpse	r25, r1
    78fc:	0e f4       	brtc	.+2      	; 0x7900 <ceil+0xe>
    78fe:	09 c2       	rjmp	.+1042   	; 0x7d12 <__fp_szero>
    7900:	60 e0       	ldi	r22, 0x00	; 0
    7902:	70 e0       	ldi	r23, 0x00	; 0
    7904:	80 e8       	ldi	r24, 0x80	; 128
    7906:	9f e3       	ldi	r25, 0x3F	; 63
    7908:	08 95       	ret
    790a:	26 f0       	brts	.+8      	; 0x7914 <ceil+0x22>
    790c:	1b 16       	cp	r1, r27
    790e:	61 1d       	adc	r22, r1
    7910:	71 1d       	adc	r23, r1
    7912:	81 1d       	adc	r24, r1
    7914:	1b c1       	rjmp	.+566    	; 0x7b4c <__fp_mintl>
    7916:	35 c1       	rjmp	.+618    	; 0x7b82 <__fp_mpack>

00007918 <__cmpsf2>:
    7918:	ef d0       	rcall	.+478    	; 0x7af8 <__fp_cmp>
    791a:	08 f4       	brcc	.+2      	; 0x791e <__cmpsf2+0x6>
    791c:	81 e0       	ldi	r24, 0x01	; 1
    791e:	08 95       	ret

00007920 <cos>:
    7920:	75 d1       	rcall	.+746    	; 0x7c0c <__fp_rempio2>
    7922:	e3 95       	inc	r30
    7924:	ab c1       	rjmp	.+854    	; 0x7c7c <__fp_sinus>

00007926 <__divsf3>:
    7926:	0c d0       	rcall	.+24     	; 0x7940 <__divsf3x>
    7928:	98 c1       	rjmp	.+816    	; 0x7c5a <__fp_round>
    792a:	68 d1       	rcall	.+720    	; 0x7bfc <__fp_pscB>
    792c:	40 f0       	brcs	.+16     	; 0x793e <__divsf3+0x18>
    792e:	5f d1       	rcall	.+702    	; 0x7bee <__fp_pscA>
    7930:	30 f0       	brcs	.+12     	; 0x793e <__divsf3+0x18>
    7932:	21 f4       	brne	.+8      	; 0x793c <__divsf3+0x16>
    7934:	5f 3f       	cpi	r21, 0xFF	; 255
    7936:	19 f0       	breq	.+6      	; 0x793e <__divsf3+0x18>
    7938:	03 c1       	rjmp	.+518    	; 0x7b40 <__fp_inf>
    793a:	51 11       	cpse	r21, r1
    793c:	ea c1       	rjmp	.+980    	; 0x7d12 <__fp_szero>
    793e:	2f c1       	rjmp	.+606    	; 0x7b9e <__fp_nan>

00007940 <__divsf3x>:
    7940:	ae d1       	rcall	.+860    	; 0x7c9e <__fp_split3>
    7942:	98 f3       	brcs	.-26     	; 0x792a <__divsf3+0x4>

00007944 <__divsf3_pse>:
    7944:	99 23       	and	r25, r25
    7946:	c9 f3       	breq	.-14     	; 0x793a <__divsf3+0x14>
    7948:	55 23       	and	r21, r21
    794a:	b1 f3       	breq	.-20     	; 0x7938 <__divsf3+0x12>
    794c:	95 1b       	sub	r25, r21
    794e:	55 0b       	sbc	r21, r21
    7950:	bb 27       	eor	r27, r27
    7952:	aa 27       	eor	r26, r26
    7954:	62 17       	cp	r22, r18
    7956:	73 07       	cpc	r23, r19
    7958:	84 07       	cpc	r24, r20
    795a:	38 f0       	brcs	.+14     	; 0x796a <__divsf3_pse+0x26>
    795c:	9f 5f       	subi	r25, 0xFF	; 255
    795e:	5f 4f       	sbci	r21, 0xFF	; 255
    7960:	22 0f       	add	r18, r18
    7962:	33 1f       	adc	r19, r19
    7964:	44 1f       	adc	r20, r20
    7966:	aa 1f       	adc	r26, r26
    7968:	a9 f3       	breq	.-22     	; 0x7954 <__divsf3_pse+0x10>
    796a:	33 d0       	rcall	.+102    	; 0x79d2 <__divsf3_pse+0x8e>
    796c:	0e 2e       	mov	r0, r30
    796e:	3a f0       	brmi	.+14     	; 0x797e <__divsf3_pse+0x3a>
    7970:	e0 e8       	ldi	r30, 0x80	; 128
    7972:	30 d0       	rcall	.+96     	; 0x79d4 <__divsf3_pse+0x90>
    7974:	91 50       	subi	r25, 0x01	; 1
    7976:	50 40       	sbci	r21, 0x00	; 0
    7978:	e6 95       	lsr	r30
    797a:	00 1c       	adc	r0, r0
    797c:	ca f7       	brpl	.-14     	; 0x7970 <__divsf3_pse+0x2c>
    797e:	29 d0       	rcall	.+82     	; 0x79d2 <__divsf3_pse+0x8e>
    7980:	fe 2f       	mov	r31, r30
    7982:	27 d0       	rcall	.+78     	; 0x79d2 <__divsf3_pse+0x8e>
    7984:	66 0f       	add	r22, r22
    7986:	77 1f       	adc	r23, r23
    7988:	88 1f       	adc	r24, r24
    798a:	bb 1f       	adc	r27, r27
    798c:	26 17       	cp	r18, r22
    798e:	37 07       	cpc	r19, r23
    7990:	48 07       	cpc	r20, r24
    7992:	ab 07       	cpc	r26, r27
    7994:	b0 e8       	ldi	r27, 0x80	; 128
    7996:	09 f0       	breq	.+2      	; 0x799a <__divsf3_pse+0x56>
    7998:	bb 0b       	sbc	r27, r27
    799a:	80 2d       	mov	r24, r0
    799c:	bf 01       	movw	r22, r30
    799e:	ff 27       	eor	r31, r31
    79a0:	93 58       	subi	r25, 0x83	; 131
    79a2:	5f 4f       	sbci	r21, 0xFF	; 255
    79a4:	2a f0       	brmi	.+10     	; 0x79b0 <__divsf3_pse+0x6c>
    79a6:	9e 3f       	cpi	r25, 0xFE	; 254
    79a8:	51 05       	cpc	r21, r1
    79aa:	68 f0       	brcs	.+26     	; 0x79c6 <__divsf3_pse+0x82>
    79ac:	c9 c0       	rjmp	.+402    	; 0x7b40 <__fp_inf>
    79ae:	b1 c1       	rjmp	.+866    	; 0x7d12 <__fp_szero>
    79b0:	5f 3f       	cpi	r21, 0xFF	; 255
    79b2:	ec f3       	brlt	.-6      	; 0x79ae <__divsf3_pse+0x6a>
    79b4:	98 3e       	cpi	r25, 0xE8	; 232
    79b6:	dc f3       	brlt	.-10     	; 0x79ae <__divsf3_pse+0x6a>
    79b8:	86 95       	lsr	r24
    79ba:	77 95       	ror	r23
    79bc:	67 95       	ror	r22
    79be:	b7 95       	ror	r27
    79c0:	f7 95       	ror	r31
    79c2:	9f 5f       	subi	r25, 0xFF	; 255
    79c4:	c9 f7       	brne	.-14     	; 0x79b8 <__divsf3_pse+0x74>
    79c6:	88 0f       	add	r24, r24
    79c8:	91 1d       	adc	r25, r1
    79ca:	96 95       	lsr	r25
    79cc:	87 95       	ror	r24
    79ce:	97 f9       	bld	r25, 7
    79d0:	08 95       	ret
    79d2:	e1 e0       	ldi	r30, 0x01	; 1
    79d4:	66 0f       	add	r22, r22
    79d6:	77 1f       	adc	r23, r23
    79d8:	88 1f       	adc	r24, r24
    79da:	bb 1f       	adc	r27, r27
    79dc:	62 17       	cp	r22, r18
    79de:	73 07       	cpc	r23, r19
    79e0:	84 07       	cpc	r24, r20
    79e2:	ba 07       	cpc	r27, r26
    79e4:	20 f0       	brcs	.+8      	; 0x79ee <__divsf3_pse+0xaa>
    79e6:	62 1b       	sub	r22, r18
    79e8:	73 0b       	sbc	r23, r19
    79ea:	84 0b       	sbc	r24, r20
    79ec:	ba 0b       	sbc	r27, r26
    79ee:	ee 1f       	adc	r30, r30
    79f0:	88 f7       	brcc	.-30     	; 0x79d4 <__divsf3_pse+0x90>
    79f2:	e0 95       	com	r30
    79f4:	08 95       	ret

000079f6 <__fixsfsi>:
    79f6:	04 d0       	rcall	.+8      	; 0x7a00 <__fixunssfsi>
    79f8:	68 94       	set
    79fa:	b1 11       	cpse	r27, r1
    79fc:	8a c1       	rjmp	.+788    	; 0x7d12 <__fp_szero>
    79fe:	08 95       	ret

00007a00 <__fixunssfsi>:
    7a00:	56 d1       	rcall	.+684    	; 0x7cae <__fp_splitA>
    7a02:	88 f0       	brcs	.+34     	; 0x7a26 <__fixunssfsi+0x26>
    7a04:	9f 57       	subi	r25, 0x7F	; 127
    7a06:	90 f0       	brcs	.+36     	; 0x7a2c <__fixunssfsi+0x2c>
    7a08:	b9 2f       	mov	r27, r25
    7a0a:	99 27       	eor	r25, r25
    7a0c:	b7 51       	subi	r27, 0x17	; 23
    7a0e:	a0 f0       	brcs	.+40     	; 0x7a38 <__fixunssfsi+0x38>
    7a10:	d1 f0       	breq	.+52     	; 0x7a46 <__fixunssfsi+0x46>
    7a12:	66 0f       	add	r22, r22
    7a14:	77 1f       	adc	r23, r23
    7a16:	88 1f       	adc	r24, r24
    7a18:	99 1f       	adc	r25, r25
    7a1a:	1a f0       	brmi	.+6      	; 0x7a22 <__fixunssfsi+0x22>
    7a1c:	ba 95       	dec	r27
    7a1e:	c9 f7       	brne	.-14     	; 0x7a12 <__fixunssfsi+0x12>
    7a20:	12 c0       	rjmp	.+36     	; 0x7a46 <__fixunssfsi+0x46>
    7a22:	b1 30       	cpi	r27, 0x01	; 1
    7a24:	81 f0       	breq	.+32     	; 0x7a46 <__fixunssfsi+0x46>
    7a26:	74 d1       	rcall	.+744    	; 0x7d10 <__fp_zero>
    7a28:	b1 e0       	ldi	r27, 0x01	; 1
    7a2a:	08 95       	ret
    7a2c:	71 c1       	rjmp	.+738    	; 0x7d10 <__fp_zero>
    7a2e:	67 2f       	mov	r22, r23
    7a30:	78 2f       	mov	r23, r24
    7a32:	88 27       	eor	r24, r24
    7a34:	b8 5f       	subi	r27, 0xF8	; 248
    7a36:	39 f0       	breq	.+14     	; 0x7a46 <__fixunssfsi+0x46>
    7a38:	b9 3f       	cpi	r27, 0xF9	; 249
    7a3a:	cc f3       	brlt	.-14     	; 0x7a2e <__fixunssfsi+0x2e>
    7a3c:	86 95       	lsr	r24
    7a3e:	77 95       	ror	r23
    7a40:	67 95       	ror	r22
    7a42:	b3 95       	inc	r27
    7a44:	d9 f7       	brne	.-10     	; 0x7a3c <__fixunssfsi+0x3c>
    7a46:	3e f4       	brtc	.+14     	; 0x7a56 <__fixunssfsi+0x56>
    7a48:	90 95       	com	r25
    7a4a:	80 95       	com	r24
    7a4c:	70 95       	com	r23
    7a4e:	61 95       	neg	r22
    7a50:	7f 4f       	sbci	r23, 0xFF	; 255
    7a52:	8f 4f       	sbci	r24, 0xFF	; 255
    7a54:	9f 4f       	sbci	r25, 0xFF	; 255
    7a56:	08 95       	ret

00007a58 <__floatunsisf>:
    7a58:	e8 94       	clt
    7a5a:	09 c0       	rjmp	.+18     	; 0x7a6e <__floatsisf+0x12>

00007a5c <__floatsisf>:
    7a5c:	97 fb       	bst	r25, 7
    7a5e:	3e f4       	brtc	.+14     	; 0x7a6e <__floatsisf+0x12>
    7a60:	90 95       	com	r25
    7a62:	80 95       	com	r24
    7a64:	70 95       	com	r23
    7a66:	61 95       	neg	r22
    7a68:	7f 4f       	sbci	r23, 0xFF	; 255
    7a6a:	8f 4f       	sbci	r24, 0xFF	; 255
    7a6c:	9f 4f       	sbci	r25, 0xFF	; 255
    7a6e:	99 23       	and	r25, r25
    7a70:	a9 f0       	breq	.+42     	; 0x7a9c <__floatsisf+0x40>
    7a72:	f9 2f       	mov	r31, r25
    7a74:	96 e9       	ldi	r25, 0x96	; 150
    7a76:	bb 27       	eor	r27, r27
    7a78:	93 95       	inc	r25
    7a7a:	f6 95       	lsr	r31
    7a7c:	87 95       	ror	r24
    7a7e:	77 95       	ror	r23
    7a80:	67 95       	ror	r22
    7a82:	b7 95       	ror	r27
    7a84:	f1 11       	cpse	r31, r1
    7a86:	f8 cf       	rjmp	.-16     	; 0x7a78 <__floatsisf+0x1c>
    7a88:	fa f4       	brpl	.+62     	; 0x7ac8 <__floatsisf+0x6c>
    7a8a:	bb 0f       	add	r27, r27
    7a8c:	11 f4       	brne	.+4      	; 0x7a92 <__floatsisf+0x36>
    7a8e:	60 ff       	sbrs	r22, 0
    7a90:	1b c0       	rjmp	.+54     	; 0x7ac8 <__floatsisf+0x6c>
    7a92:	6f 5f       	subi	r22, 0xFF	; 255
    7a94:	7f 4f       	sbci	r23, 0xFF	; 255
    7a96:	8f 4f       	sbci	r24, 0xFF	; 255
    7a98:	9f 4f       	sbci	r25, 0xFF	; 255
    7a9a:	16 c0       	rjmp	.+44     	; 0x7ac8 <__floatsisf+0x6c>
    7a9c:	88 23       	and	r24, r24
    7a9e:	11 f0       	breq	.+4      	; 0x7aa4 <__floatsisf+0x48>
    7aa0:	96 e9       	ldi	r25, 0x96	; 150
    7aa2:	11 c0       	rjmp	.+34     	; 0x7ac6 <__floatsisf+0x6a>
    7aa4:	77 23       	and	r23, r23
    7aa6:	21 f0       	breq	.+8      	; 0x7ab0 <__floatsisf+0x54>
    7aa8:	9e e8       	ldi	r25, 0x8E	; 142
    7aaa:	87 2f       	mov	r24, r23
    7aac:	76 2f       	mov	r23, r22
    7aae:	05 c0       	rjmp	.+10     	; 0x7aba <__floatsisf+0x5e>
    7ab0:	66 23       	and	r22, r22
    7ab2:	71 f0       	breq	.+28     	; 0x7ad0 <__floatsisf+0x74>
    7ab4:	96 e8       	ldi	r25, 0x86	; 134
    7ab6:	86 2f       	mov	r24, r22
    7ab8:	70 e0       	ldi	r23, 0x00	; 0
    7aba:	60 e0       	ldi	r22, 0x00	; 0
    7abc:	2a f0       	brmi	.+10     	; 0x7ac8 <__floatsisf+0x6c>
    7abe:	9a 95       	dec	r25
    7ac0:	66 0f       	add	r22, r22
    7ac2:	77 1f       	adc	r23, r23
    7ac4:	88 1f       	adc	r24, r24
    7ac6:	da f7       	brpl	.-10     	; 0x7abe <__floatsisf+0x62>
    7ac8:	88 0f       	add	r24, r24
    7aca:	96 95       	lsr	r25
    7acc:	87 95       	ror	r24
    7ace:	97 f9       	bld	r25, 7
    7ad0:	08 95       	ret

00007ad2 <floor>:
    7ad2:	07 d1       	rcall	.+526    	; 0x7ce2 <__fp_trunc>
    7ad4:	80 f0       	brcs	.+32     	; 0x7af6 <floor+0x24>
    7ad6:	9f 37       	cpi	r25, 0x7F	; 127
    7ad8:	40 f4       	brcc	.+16     	; 0x7aea <floor+0x18>
    7ada:	91 11       	cpse	r25, r1
    7adc:	0e f0       	brts	.+2      	; 0x7ae0 <floor+0xe>
    7ade:	19 c1       	rjmp	.+562    	; 0x7d12 <__fp_szero>
    7ae0:	60 e0       	ldi	r22, 0x00	; 0
    7ae2:	70 e0       	ldi	r23, 0x00	; 0
    7ae4:	80 e8       	ldi	r24, 0x80	; 128
    7ae6:	9f eb       	ldi	r25, 0xBF	; 191
    7ae8:	08 95       	ret
    7aea:	26 f4       	brtc	.+8      	; 0x7af4 <floor+0x22>
    7aec:	1b 16       	cp	r1, r27
    7aee:	61 1d       	adc	r22, r1
    7af0:	71 1d       	adc	r23, r1
    7af2:	81 1d       	adc	r24, r1
    7af4:	2b c0       	rjmp	.+86     	; 0x7b4c <__fp_mintl>
    7af6:	45 c0       	rjmp	.+138    	; 0x7b82 <__fp_mpack>

00007af8 <__fp_cmp>:
    7af8:	99 0f       	add	r25, r25
    7afa:	00 08       	sbc	r0, r0
    7afc:	55 0f       	add	r21, r21
    7afe:	aa 0b       	sbc	r26, r26
    7b00:	e0 e8       	ldi	r30, 0x80	; 128
    7b02:	fe ef       	ldi	r31, 0xFE	; 254
    7b04:	16 16       	cp	r1, r22
    7b06:	17 06       	cpc	r1, r23
    7b08:	e8 07       	cpc	r30, r24
    7b0a:	f9 07       	cpc	r31, r25
    7b0c:	c0 f0       	brcs	.+48     	; 0x7b3e <__fp_cmp+0x46>
    7b0e:	12 16       	cp	r1, r18
    7b10:	13 06       	cpc	r1, r19
    7b12:	e4 07       	cpc	r30, r20
    7b14:	f5 07       	cpc	r31, r21
    7b16:	98 f0       	brcs	.+38     	; 0x7b3e <__fp_cmp+0x46>
    7b18:	62 1b       	sub	r22, r18
    7b1a:	73 0b       	sbc	r23, r19
    7b1c:	84 0b       	sbc	r24, r20
    7b1e:	95 0b       	sbc	r25, r21
    7b20:	39 f4       	brne	.+14     	; 0x7b30 <__fp_cmp+0x38>
    7b22:	0a 26       	eor	r0, r26
    7b24:	61 f0       	breq	.+24     	; 0x7b3e <__fp_cmp+0x46>
    7b26:	23 2b       	or	r18, r19
    7b28:	24 2b       	or	r18, r20
    7b2a:	25 2b       	or	r18, r21
    7b2c:	21 f4       	brne	.+8      	; 0x7b36 <__fp_cmp+0x3e>
    7b2e:	08 95       	ret
    7b30:	0a 26       	eor	r0, r26
    7b32:	09 f4       	brne	.+2      	; 0x7b36 <__fp_cmp+0x3e>
    7b34:	a1 40       	sbci	r26, 0x01	; 1
    7b36:	a6 95       	lsr	r26
    7b38:	8f ef       	ldi	r24, 0xFF	; 255
    7b3a:	81 1d       	adc	r24, r1
    7b3c:	81 1d       	adc	r24, r1
    7b3e:	08 95       	ret

00007b40 <__fp_inf>:
    7b40:	97 f9       	bld	r25, 7
    7b42:	9f 67       	ori	r25, 0x7F	; 127
    7b44:	80 e8       	ldi	r24, 0x80	; 128
    7b46:	70 e0       	ldi	r23, 0x00	; 0
    7b48:	60 e0       	ldi	r22, 0x00	; 0
    7b4a:	08 95       	ret

00007b4c <__fp_mintl>:
    7b4c:	88 23       	and	r24, r24
    7b4e:	71 f4       	brne	.+28     	; 0x7b6c <__fp_mintl+0x20>
    7b50:	77 23       	and	r23, r23
    7b52:	21 f0       	breq	.+8      	; 0x7b5c <__fp_mintl+0x10>
    7b54:	98 50       	subi	r25, 0x08	; 8
    7b56:	87 2b       	or	r24, r23
    7b58:	76 2f       	mov	r23, r22
    7b5a:	07 c0       	rjmp	.+14     	; 0x7b6a <__fp_mintl+0x1e>
    7b5c:	66 23       	and	r22, r22
    7b5e:	11 f4       	brne	.+4      	; 0x7b64 <__fp_mintl+0x18>
    7b60:	99 27       	eor	r25, r25
    7b62:	0d c0       	rjmp	.+26     	; 0x7b7e <__fp_mintl+0x32>
    7b64:	90 51       	subi	r25, 0x10	; 16
    7b66:	86 2b       	or	r24, r22
    7b68:	70 e0       	ldi	r23, 0x00	; 0
    7b6a:	60 e0       	ldi	r22, 0x00	; 0
    7b6c:	2a f0       	brmi	.+10     	; 0x7b78 <__fp_mintl+0x2c>
    7b6e:	9a 95       	dec	r25
    7b70:	66 0f       	add	r22, r22
    7b72:	77 1f       	adc	r23, r23
    7b74:	88 1f       	adc	r24, r24
    7b76:	da f7       	brpl	.-10     	; 0x7b6e <__fp_mintl+0x22>
    7b78:	88 0f       	add	r24, r24
    7b7a:	96 95       	lsr	r25
    7b7c:	87 95       	ror	r24
    7b7e:	97 f9       	bld	r25, 7
    7b80:	08 95       	ret

00007b82 <__fp_mpack>:
    7b82:	9f 3f       	cpi	r25, 0xFF	; 255
    7b84:	31 f0       	breq	.+12     	; 0x7b92 <__fp_mpack_finite+0xc>

00007b86 <__fp_mpack_finite>:
    7b86:	91 50       	subi	r25, 0x01	; 1
    7b88:	20 f4       	brcc	.+8      	; 0x7b92 <__fp_mpack_finite+0xc>
    7b8a:	87 95       	ror	r24
    7b8c:	77 95       	ror	r23
    7b8e:	67 95       	ror	r22
    7b90:	b7 95       	ror	r27
    7b92:	88 0f       	add	r24, r24
    7b94:	91 1d       	adc	r25, r1
    7b96:	96 95       	lsr	r25
    7b98:	87 95       	ror	r24
    7b9a:	97 f9       	bld	r25, 7
    7b9c:	08 95       	ret

00007b9e <__fp_nan>:
    7b9e:	9f ef       	ldi	r25, 0xFF	; 255
    7ba0:	80 ec       	ldi	r24, 0xC0	; 192
    7ba2:	08 95       	ret

00007ba4 <__fp_powser>:
    7ba4:	df 93       	push	r29
    7ba6:	cf 93       	push	r28
    7ba8:	1f 93       	push	r17
    7baa:	0f 93       	push	r16
    7bac:	ff 92       	push	r15
    7bae:	ef 92       	push	r14
    7bb0:	df 92       	push	r13
    7bb2:	7b 01       	movw	r14, r22
    7bb4:	8c 01       	movw	r16, r24
    7bb6:	68 94       	set
    7bb8:	05 c0       	rjmp	.+10     	; 0x7bc4 <__fp_powser+0x20>
    7bba:	da 2e       	mov	r13, r26
    7bbc:	ef 01       	movw	r28, r30
    7bbe:	f6 d0       	rcall	.+492    	; 0x7dac <__mulsf3x>
    7bc0:	fe 01       	movw	r30, r28
    7bc2:	e8 94       	clt
    7bc4:	a5 91       	lpm	r26, Z+
    7bc6:	25 91       	lpm	r18, Z+
    7bc8:	35 91       	lpm	r19, Z+
    7bca:	45 91       	lpm	r20, Z+
    7bcc:	55 91       	lpm	r21, Z+
    7bce:	ae f3       	brts	.-22     	; 0x7bba <__fp_powser+0x16>
    7bd0:	ef 01       	movw	r28, r30
    7bd2:	da dd       	rcall	.-1100   	; 0x7788 <__addsf3x>
    7bd4:	fe 01       	movw	r30, r28
    7bd6:	97 01       	movw	r18, r14
    7bd8:	a8 01       	movw	r20, r16
    7bda:	da 94       	dec	r13
    7bdc:	79 f7       	brne	.-34     	; 0x7bbc <__fp_powser+0x18>
    7bde:	df 90       	pop	r13
    7be0:	ef 90       	pop	r14
    7be2:	ff 90       	pop	r15
    7be4:	0f 91       	pop	r16
    7be6:	1f 91       	pop	r17
    7be8:	cf 91       	pop	r28
    7bea:	df 91       	pop	r29
    7bec:	08 95       	ret

00007bee <__fp_pscA>:
    7bee:	00 24       	eor	r0, r0
    7bf0:	0a 94       	dec	r0
    7bf2:	16 16       	cp	r1, r22
    7bf4:	17 06       	cpc	r1, r23
    7bf6:	18 06       	cpc	r1, r24
    7bf8:	09 06       	cpc	r0, r25
    7bfa:	08 95       	ret

00007bfc <__fp_pscB>:
    7bfc:	00 24       	eor	r0, r0
    7bfe:	0a 94       	dec	r0
    7c00:	12 16       	cp	r1, r18
    7c02:	13 06       	cpc	r1, r19
    7c04:	14 06       	cpc	r1, r20
    7c06:	05 06       	cpc	r0, r21
    7c08:	08 95       	ret
    7c0a:	c9 cf       	rjmp	.-110    	; 0x7b9e <__fp_nan>

00007c0c <__fp_rempio2>:
    7c0c:	50 d0       	rcall	.+160    	; 0x7cae <__fp_splitA>
    7c0e:	e8 f3       	brcs	.-6      	; 0x7c0a <__fp_pscB+0xe>
    7c10:	e8 94       	clt
    7c12:	e0 e0       	ldi	r30, 0x00	; 0
    7c14:	bb 27       	eor	r27, r27
    7c16:	9f 57       	subi	r25, 0x7F	; 127
    7c18:	f0 f0       	brcs	.+60     	; 0x7c56 <__fp_rempio2+0x4a>
    7c1a:	2a ed       	ldi	r18, 0xDA	; 218
    7c1c:	3f e0       	ldi	r19, 0x0F	; 15
    7c1e:	49 ec       	ldi	r20, 0xC9	; 201
    7c20:	06 c0       	rjmp	.+12     	; 0x7c2e <__fp_rempio2+0x22>
    7c22:	ee 0f       	add	r30, r30
    7c24:	bb 0f       	add	r27, r27
    7c26:	66 1f       	adc	r22, r22
    7c28:	77 1f       	adc	r23, r23
    7c2a:	88 1f       	adc	r24, r24
    7c2c:	28 f0       	brcs	.+10     	; 0x7c38 <__fp_rempio2+0x2c>
    7c2e:	b2 3a       	cpi	r27, 0xA2	; 162
    7c30:	62 07       	cpc	r22, r18
    7c32:	73 07       	cpc	r23, r19
    7c34:	84 07       	cpc	r24, r20
    7c36:	28 f0       	brcs	.+10     	; 0x7c42 <__fp_rempio2+0x36>
    7c38:	b2 5a       	subi	r27, 0xA2	; 162
    7c3a:	62 0b       	sbc	r22, r18
    7c3c:	73 0b       	sbc	r23, r19
    7c3e:	84 0b       	sbc	r24, r20
    7c40:	e3 95       	inc	r30
    7c42:	9a 95       	dec	r25
    7c44:	72 f7       	brpl	.-36     	; 0x7c22 <__fp_rempio2+0x16>
    7c46:	80 38       	cpi	r24, 0x80	; 128
    7c48:	30 f4       	brcc	.+12     	; 0x7c56 <__fp_rempio2+0x4a>
    7c4a:	9a 95       	dec	r25
    7c4c:	bb 0f       	add	r27, r27
    7c4e:	66 1f       	adc	r22, r22
    7c50:	77 1f       	adc	r23, r23
    7c52:	88 1f       	adc	r24, r24
    7c54:	d2 f7       	brpl	.-12     	; 0x7c4a <__fp_rempio2+0x3e>
    7c56:	90 48       	sbci	r25, 0x80	; 128
    7c58:	96 cf       	rjmp	.-212    	; 0x7b86 <__fp_mpack_finite>

00007c5a <__fp_round>:
    7c5a:	09 2e       	mov	r0, r25
    7c5c:	03 94       	inc	r0
    7c5e:	00 0c       	add	r0, r0
    7c60:	11 f4       	brne	.+4      	; 0x7c66 <__fp_round+0xc>
    7c62:	88 23       	and	r24, r24
    7c64:	52 f0       	brmi	.+20     	; 0x7c7a <__fp_round+0x20>
    7c66:	bb 0f       	add	r27, r27
    7c68:	40 f4       	brcc	.+16     	; 0x7c7a <__fp_round+0x20>
    7c6a:	bf 2b       	or	r27, r31
    7c6c:	11 f4       	brne	.+4      	; 0x7c72 <__fp_round+0x18>
    7c6e:	60 ff       	sbrs	r22, 0
    7c70:	04 c0       	rjmp	.+8      	; 0x7c7a <__fp_round+0x20>
    7c72:	6f 5f       	subi	r22, 0xFF	; 255
    7c74:	7f 4f       	sbci	r23, 0xFF	; 255
    7c76:	8f 4f       	sbci	r24, 0xFF	; 255
    7c78:	9f 4f       	sbci	r25, 0xFF	; 255
    7c7a:	08 95       	ret

00007c7c <__fp_sinus>:
    7c7c:	ef 93       	push	r30
    7c7e:	e0 ff       	sbrs	r30, 0
    7c80:	06 c0       	rjmp	.+12     	; 0x7c8e <__fp_sinus+0x12>
    7c82:	a2 ea       	ldi	r26, 0xA2	; 162
    7c84:	2a ed       	ldi	r18, 0xDA	; 218
    7c86:	3f e0       	ldi	r19, 0x0F	; 15
    7c88:	49 ec       	ldi	r20, 0xC9	; 201
    7c8a:	5f eb       	ldi	r21, 0xBF	; 191
    7c8c:	7d dd       	rcall	.-1286   	; 0x7788 <__addsf3x>
    7c8e:	e5 df       	rcall	.-54     	; 0x7c5a <__fp_round>
    7c90:	0f 90       	pop	r0
    7c92:	03 94       	inc	r0
    7c94:	01 fc       	sbrc	r0, 1
    7c96:	90 58       	subi	r25, 0x80	; 128
    7c98:	e1 e6       	ldi	r30, 0x61	; 97
    7c9a:	f2 e0       	ldi	r31, 0x02	; 2
    7c9c:	57 c1       	rjmp	.+686    	; 0x7f4c <__fp_powsodd>

00007c9e <__fp_split3>:
    7c9e:	57 fd       	sbrc	r21, 7
    7ca0:	90 58       	subi	r25, 0x80	; 128
    7ca2:	44 0f       	add	r20, r20
    7ca4:	55 1f       	adc	r21, r21
    7ca6:	59 f0       	breq	.+22     	; 0x7cbe <__fp_splitA+0x10>
    7ca8:	5f 3f       	cpi	r21, 0xFF	; 255
    7caa:	71 f0       	breq	.+28     	; 0x7cc8 <__fp_splitA+0x1a>
    7cac:	47 95       	ror	r20

00007cae <__fp_splitA>:
    7cae:	88 0f       	add	r24, r24
    7cb0:	97 fb       	bst	r25, 7
    7cb2:	99 1f       	adc	r25, r25
    7cb4:	61 f0       	breq	.+24     	; 0x7cce <__fp_splitA+0x20>
    7cb6:	9f 3f       	cpi	r25, 0xFF	; 255
    7cb8:	79 f0       	breq	.+30     	; 0x7cd8 <__fp_splitA+0x2a>
    7cba:	87 95       	ror	r24
    7cbc:	08 95       	ret
    7cbe:	12 16       	cp	r1, r18
    7cc0:	13 06       	cpc	r1, r19
    7cc2:	14 06       	cpc	r1, r20
    7cc4:	55 1f       	adc	r21, r21
    7cc6:	f2 cf       	rjmp	.-28     	; 0x7cac <__fp_split3+0xe>
    7cc8:	46 95       	lsr	r20
    7cca:	f1 df       	rcall	.-30     	; 0x7cae <__fp_splitA>
    7ccc:	08 c0       	rjmp	.+16     	; 0x7cde <__fp_splitA+0x30>
    7cce:	16 16       	cp	r1, r22
    7cd0:	17 06       	cpc	r1, r23
    7cd2:	18 06       	cpc	r1, r24
    7cd4:	99 1f       	adc	r25, r25
    7cd6:	f1 cf       	rjmp	.-30     	; 0x7cba <__fp_splitA+0xc>
    7cd8:	86 95       	lsr	r24
    7cda:	71 05       	cpc	r23, r1
    7cdc:	61 05       	cpc	r22, r1
    7cde:	08 94       	sec
    7ce0:	08 95       	ret

00007ce2 <__fp_trunc>:
    7ce2:	e5 df       	rcall	.-54     	; 0x7cae <__fp_splitA>
    7ce4:	a0 f0       	brcs	.+40     	; 0x7d0e <__fp_trunc+0x2c>
    7ce6:	be e7       	ldi	r27, 0x7E	; 126
    7ce8:	b9 17       	cp	r27, r25
    7cea:	88 f4       	brcc	.+34     	; 0x7d0e <__fp_trunc+0x2c>
    7cec:	bb 27       	eor	r27, r27
    7cee:	9f 38       	cpi	r25, 0x8F	; 143
    7cf0:	60 f4       	brcc	.+24     	; 0x7d0a <__fp_trunc+0x28>
    7cf2:	16 16       	cp	r1, r22
    7cf4:	b1 1d       	adc	r27, r1
    7cf6:	67 2f       	mov	r22, r23
    7cf8:	78 2f       	mov	r23, r24
    7cfa:	88 27       	eor	r24, r24
    7cfc:	98 5f       	subi	r25, 0xF8	; 248
    7cfe:	f7 cf       	rjmp	.-18     	; 0x7cee <__fp_trunc+0xc>
    7d00:	86 95       	lsr	r24
    7d02:	77 95       	ror	r23
    7d04:	67 95       	ror	r22
    7d06:	b1 1d       	adc	r27, r1
    7d08:	93 95       	inc	r25
    7d0a:	96 39       	cpi	r25, 0x96	; 150
    7d0c:	c8 f3       	brcs	.-14     	; 0x7d00 <__fp_trunc+0x1e>
    7d0e:	08 95       	ret

00007d10 <__fp_zero>:
    7d10:	e8 94       	clt

00007d12 <__fp_szero>:
    7d12:	bb 27       	eor	r27, r27
    7d14:	66 27       	eor	r22, r22
    7d16:	77 27       	eor	r23, r23
    7d18:	cb 01       	movw	r24, r22
    7d1a:	97 f9       	bld	r25, 7
    7d1c:	08 95       	ret

00007d1e <__gesf2>:
    7d1e:	ec de       	rcall	.-552    	; 0x7af8 <__fp_cmp>
    7d20:	08 f4       	brcc	.+2      	; 0x7d24 <__gesf2+0x6>
    7d22:	8f ef       	ldi	r24, 0xFF	; 255
    7d24:	08 95       	ret

00007d26 <inverse>:
    7d26:	9b 01       	movw	r18, r22
    7d28:	ac 01       	movw	r20, r24
    7d2a:	60 e0       	ldi	r22, 0x00	; 0
    7d2c:	70 e0       	ldi	r23, 0x00	; 0
    7d2e:	80 e8       	ldi	r24, 0x80	; 128
    7d30:	9f e3       	ldi	r25, 0x3F	; 63
    7d32:	f9 cd       	rjmp	.-1038   	; 0x7926 <__divsf3>

00007d34 <lround>:
    7d34:	bc df       	rcall	.-136    	; 0x7cae <__fp_splitA>
    7d36:	58 f1       	brcs	.+86     	; 0x7d8e <lround+0x5a>
    7d38:	9e 57       	subi	r25, 0x7E	; 126
    7d3a:	58 f1       	brcs	.+86     	; 0x7d92 <lround+0x5e>
    7d3c:	98 51       	subi	r25, 0x18	; 24
    7d3e:	a0 f0       	brcs	.+40     	; 0x7d68 <lround+0x34>
    7d40:	e9 f0       	breq	.+58     	; 0x7d7c <lround+0x48>
    7d42:	98 30       	cpi	r25, 0x08	; 8
    7d44:	20 f5       	brcc	.+72     	; 0x7d8e <lround+0x5a>
    7d46:	09 2e       	mov	r0, r25
    7d48:	99 27       	eor	r25, r25
    7d4a:	66 0f       	add	r22, r22
    7d4c:	77 1f       	adc	r23, r23
    7d4e:	88 1f       	adc	r24, r24
    7d50:	99 1f       	adc	r25, r25
    7d52:	0a 94       	dec	r0
    7d54:	d1 f7       	brne	.-12     	; 0x7d4a <lround+0x16>
    7d56:	12 c0       	rjmp	.+36     	; 0x7d7c <lround+0x48>
    7d58:	06 2e       	mov	r0, r22
    7d5a:	67 2f       	mov	r22, r23
    7d5c:	78 2f       	mov	r23, r24
    7d5e:	88 27       	eor	r24, r24
    7d60:	98 5f       	subi	r25, 0xF8	; 248
    7d62:	11 f4       	brne	.+4      	; 0x7d68 <lround+0x34>
    7d64:	00 0c       	add	r0, r0
    7d66:	07 c0       	rjmp	.+14     	; 0x7d76 <lround+0x42>
    7d68:	99 3f       	cpi	r25, 0xF9	; 249
    7d6a:	b4 f3       	brlt	.-20     	; 0x7d58 <lround+0x24>
    7d6c:	86 95       	lsr	r24
    7d6e:	77 95       	ror	r23
    7d70:	67 95       	ror	r22
    7d72:	93 95       	inc	r25
    7d74:	d9 f7       	brne	.-10     	; 0x7d6c <lround+0x38>
    7d76:	61 1d       	adc	r22, r1
    7d78:	71 1d       	adc	r23, r1
    7d7a:	81 1d       	adc	r24, r1
    7d7c:	3e f4       	brtc	.+14     	; 0x7d8c <lround+0x58>
    7d7e:	90 95       	com	r25
    7d80:	80 95       	com	r24
    7d82:	70 95       	com	r23
    7d84:	61 95       	neg	r22
    7d86:	7f 4f       	sbci	r23, 0xFF	; 255
    7d88:	8f 4f       	sbci	r24, 0xFF	; 255
    7d8a:	9f 4f       	sbci	r25, 0xFF	; 255
    7d8c:	08 95       	ret
    7d8e:	68 94       	set
    7d90:	c0 cf       	rjmp	.-128    	; 0x7d12 <__fp_szero>
    7d92:	be cf       	rjmp	.-132    	; 0x7d10 <__fp_zero>

00007d94 <__mulsf3>:
    7d94:	0b d0       	rcall	.+22     	; 0x7dac <__mulsf3x>
    7d96:	61 cf       	rjmp	.-318    	; 0x7c5a <__fp_round>
    7d98:	2a df       	rcall	.-428    	; 0x7bee <__fp_pscA>
    7d9a:	28 f0       	brcs	.+10     	; 0x7da6 <__mulsf3+0x12>
    7d9c:	2f df       	rcall	.-418    	; 0x7bfc <__fp_pscB>
    7d9e:	18 f0       	brcs	.+6      	; 0x7da6 <__mulsf3+0x12>
    7da0:	95 23       	and	r25, r21
    7da2:	09 f0       	breq	.+2      	; 0x7da6 <__mulsf3+0x12>
    7da4:	cd ce       	rjmp	.-614    	; 0x7b40 <__fp_inf>
    7da6:	fb ce       	rjmp	.-522    	; 0x7b9e <__fp_nan>
    7da8:	11 24       	eor	r1, r1
    7daa:	b3 cf       	rjmp	.-154    	; 0x7d12 <__fp_szero>

00007dac <__mulsf3x>:
    7dac:	78 df       	rcall	.-272    	; 0x7c9e <__fp_split3>
    7dae:	a0 f3       	brcs	.-24     	; 0x7d98 <__mulsf3+0x4>

00007db0 <__mulsf3_pse>:
    7db0:	95 9f       	mul	r25, r21
    7db2:	d1 f3       	breq	.-12     	; 0x7da8 <__mulsf3+0x14>
    7db4:	95 0f       	add	r25, r21
    7db6:	50 e0       	ldi	r21, 0x00	; 0
    7db8:	55 1f       	adc	r21, r21
    7dba:	62 9f       	mul	r22, r18
    7dbc:	f0 01       	movw	r30, r0
    7dbe:	72 9f       	mul	r23, r18
    7dc0:	bb 27       	eor	r27, r27
    7dc2:	f0 0d       	add	r31, r0
    7dc4:	b1 1d       	adc	r27, r1
    7dc6:	63 9f       	mul	r22, r19
    7dc8:	aa 27       	eor	r26, r26
    7dca:	f0 0d       	add	r31, r0
    7dcc:	b1 1d       	adc	r27, r1
    7dce:	aa 1f       	adc	r26, r26
    7dd0:	64 9f       	mul	r22, r20
    7dd2:	66 27       	eor	r22, r22
    7dd4:	b0 0d       	add	r27, r0
    7dd6:	a1 1d       	adc	r26, r1
    7dd8:	66 1f       	adc	r22, r22
    7dda:	82 9f       	mul	r24, r18
    7ddc:	22 27       	eor	r18, r18
    7dde:	b0 0d       	add	r27, r0
    7de0:	a1 1d       	adc	r26, r1
    7de2:	62 1f       	adc	r22, r18
    7de4:	73 9f       	mul	r23, r19
    7de6:	b0 0d       	add	r27, r0
    7de8:	a1 1d       	adc	r26, r1
    7dea:	62 1f       	adc	r22, r18
    7dec:	83 9f       	mul	r24, r19
    7dee:	a0 0d       	add	r26, r0
    7df0:	61 1d       	adc	r22, r1
    7df2:	22 1f       	adc	r18, r18
    7df4:	74 9f       	mul	r23, r20
    7df6:	33 27       	eor	r19, r19
    7df8:	a0 0d       	add	r26, r0
    7dfa:	61 1d       	adc	r22, r1
    7dfc:	23 1f       	adc	r18, r19
    7dfe:	84 9f       	mul	r24, r20
    7e00:	60 0d       	add	r22, r0
    7e02:	21 1d       	adc	r18, r1
    7e04:	82 2f       	mov	r24, r18
    7e06:	76 2f       	mov	r23, r22
    7e08:	6a 2f       	mov	r22, r26
    7e0a:	11 24       	eor	r1, r1
    7e0c:	9f 57       	subi	r25, 0x7F	; 127
    7e0e:	50 40       	sbci	r21, 0x00	; 0
    7e10:	8a f0       	brmi	.+34     	; 0x7e34 <__mulsf3_pse+0x84>
    7e12:	e1 f0       	breq	.+56     	; 0x7e4c <__mulsf3_pse+0x9c>
    7e14:	88 23       	and	r24, r24
    7e16:	4a f0       	brmi	.+18     	; 0x7e2a <__mulsf3_pse+0x7a>
    7e18:	ee 0f       	add	r30, r30
    7e1a:	ff 1f       	adc	r31, r31
    7e1c:	bb 1f       	adc	r27, r27
    7e1e:	66 1f       	adc	r22, r22
    7e20:	77 1f       	adc	r23, r23
    7e22:	88 1f       	adc	r24, r24
    7e24:	91 50       	subi	r25, 0x01	; 1
    7e26:	50 40       	sbci	r21, 0x00	; 0
    7e28:	a9 f7       	brne	.-22     	; 0x7e14 <__mulsf3_pse+0x64>
    7e2a:	9e 3f       	cpi	r25, 0xFE	; 254
    7e2c:	51 05       	cpc	r21, r1
    7e2e:	70 f0       	brcs	.+28     	; 0x7e4c <__mulsf3_pse+0x9c>
    7e30:	87 ce       	rjmp	.-754    	; 0x7b40 <__fp_inf>
    7e32:	6f cf       	rjmp	.-290    	; 0x7d12 <__fp_szero>
    7e34:	5f 3f       	cpi	r21, 0xFF	; 255
    7e36:	ec f3       	brlt	.-6      	; 0x7e32 <__mulsf3_pse+0x82>
    7e38:	98 3e       	cpi	r25, 0xE8	; 232
    7e3a:	dc f3       	brlt	.-10     	; 0x7e32 <__mulsf3_pse+0x82>
    7e3c:	86 95       	lsr	r24
    7e3e:	77 95       	ror	r23
    7e40:	67 95       	ror	r22
    7e42:	b7 95       	ror	r27
    7e44:	f7 95       	ror	r31
    7e46:	e7 95       	ror	r30
    7e48:	9f 5f       	subi	r25, 0xFF	; 255
    7e4a:	c1 f7       	brne	.-16     	; 0x7e3c <__mulsf3_pse+0x8c>
    7e4c:	fe 2b       	or	r31, r30
    7e4e:	88 0f       	add	r24, r24
    7e50:	91 1d       	adc	r25, r1
    7e52:	96 95       	lsr	r25
    7e54:	87 95       	ror	r24
    7e56:	97 f9       	bld	r25, 7
    7e58:	08 95       	ret

00007e5a <round>:
    7e5a:	29 df       	rcall	.-430    	; 0x7cae <__fp_splitA>
    7e5c:	e0 f0       	brcs	.+56     	; 0x7e96 <round+0x3c>
    7e5e:	9e 37       	cpi	r25, 0x7E	; 126
    7e60:	d8 f0       	brcs	.+54     	; 0x7e98 <round+0x3e>
    7e62:	96 39       	cpi	r25, 0x96	; 150
    7e64:	b8 f4       	brcc	.+46     	; 0x7e94 <round+0x3a>
    7e66:	9e 38       	cpi	r25, 0x8E	; 142
    7e68:	48 f4       	brcc	.+18     	; 0x7e7c <round+0x22>
    7e6a:	67 2f       	mov	r22, r23
    7e6c:	78 2f       	mov	r23, r24
    7e6e:	88 27       	eor	r24, r24
    7e70:	98 5f       	subi	r25, 0xF8	; 248
    7e72:	f9 cf       	rjmp	.-14     	; 0x7e66 <round+0xc>
    7e74:	86 95       	lsr	r24
    7e76:	77 95       	ror	r23
    7e78:	67 95       	ror	r22
    7e7a:	93 95       	inc	r25
    7e7c:	95 39       	cpi	r25, 0x95	; 149
    7e7e:	d0 f3       	brcs	.-12     	; 0x7e74 <round+0x1a>
    7e80:	b6 2f       	mov	r27, r22
    7e82:	b1 70       	andi	r27, 0x01	; 1
    7e84:	6b 0f       	add	r22, r27
    7e86:	71 1d       	adc	r23, r1
    7e88:	81 1d       	adc	r24, r1
    7e8a:	20 f4       	brcc	.+8      	; 0x7e94 <round+0x3a>
    7e8c:	87 95       	ror	r24
    7e8e:	77 95       	ror	r23
    7e90:	67 95       	ror	r22
    7e92:	93 95       	inc	r25
    7e94:	5b ce       	rjmp	.-842    	; 0x7b4c <__fp_mintl>
    7e96:	75 ce       	rjmp	.-790    	; 0x7b82 <__fp_mpack>
    7e98:	3c cf       	rjmp	.-392    	; 0x7d12 <__fp_szero>

00007e9a <sin>:
    7e9a:	9f 93       	push	r25
    7e9c:	b7 de       	rcall	.-658    	; 0x7c0c <__fp_rempio2>
    7e9e:	0f 90       	pop	r0
    7ea0:	07 fc       	sbrc	r0, 7
    7ea2:	ee 5f       	subi	r30, 0xFE	; 254
    7ea4:	eb ce       	rjmp	.-554    	; 0x7c7c <__fp_sinus>
    7ea6:	11 f4       	brne	.+4      	; 0x7eac <sin+0x12>
    7ea8:	0e f4       	brtc	.+2      	; 0x7eac <sin+0x12>
    7eaa:	79 ce       	rjmp	.-782    	; 0x7b9e <__fp_nan>
    7eac:	6a ce       	rjmp	.-812    	; 0x7b82 <__fp_mpack>

00007eae <sqrt>:
    7eae:	ff de       	rcall	.-514    	; 0x7cae <__fp_splitA>
    7eb0:	d0 f3       	brcs	.-12     	; 0x7ea6 <sin+0xc>
    7eb2:	99 23       	and	r25, r25
    7eb4:	d9 f3       	breq	.-10     	; 0x7eac <sin+0x12>
    7eb6:	ce f3       	brts	.-14     	; 0x7eaa <sin+0x10>
    7eb8:	9f 57       	subi	r25, 0x7F	; 127
    7eba:	55 0b       	sbc	r21, r21
    7ebc:	87 ff       	sbrs	r24, 7
    7ebe:	3f d0       	rcall	.+126    	; 0x7f3e <__fp_norm2>
    7ec0:	00 24       	eor	r0, r0
    7ec2:	a0 e6       	ldi	r26, 0x60	; 96
    7ec4:	40 ea       	ldi	r20, 0xA0	; 160
    7ec6:	90 01       	movw	r18, r0
    7ec8:	80 58       	subi	r24, 0x80	; 128
    7eca:	56 95       	lsr	r21
    7ecc:	97 95       	ror	r25
    7ece:	28 f4       	brcc	.+10     	; 0x7eda <sqrt+0x2c>
    7ed0:	80 5c       	subi	r24, 0xC0	; 192
    7ed2:	66 0f       	add	r22, r22
    7ed4:	77 1f       	adc	r23, r23
    7ed6:	88 1f       	adc	r24, r24
    7ed8:	20 f0       	brcs	.+8      	; 0x7ee2 <sqrt+0x34>
    7eda:	26 17       	cp	r18, r22
    7edc:	37 07       	cpc	r19, r23
    7ede:	48 07       	cpc	r20, r24
    7ee0:	30 f4       	brcc	.+12     	; 0x7eee <sqrt+0x40>
    7ee2:	62 1b       	sub	r22, r18
    7ee4:	73 0b       	sbc	r23, r19
    7ee6:	84 0b       	sbc	r24, r20
    7ee8:	20 29       	or	r18, r0
    7eea:	31 29       	or	r19, r1
    7eec:	4a 2b       	or	r20, r26
    7eee:	a6 95       	lsr	r26
    7ef0:	17 94       	ror	r1
    7ef2:	07 94       	ror	r0
    7ef4:	20 25       	eor	r18, r0
    7ef6:	31 25       	eor	r19, r1
    7ef8:	4a 27       	eor	r20, r26
    7efa:	58 f7       	brcc	.-42     	; 0x7ed2 <sqrt+0x24>
    7efc:	66 0f       	add	r22, r22
    7efe:	77 1f       	adc	r23, r23
    7f00:	88 1f       	adc	r24, r24
    7f02:	20 f0       	brcs	.+8      	; 0x7f0c <sqrt+0x5e>
    7f04:	26 17       	cp	r18, r22
    7f06:	37 07       	cpc	r19, r23
    7f08:	48 07       	cpc	r20, r24
    7f0a:	30 f4       	brcc	.+12     	; 0x7f18 <sqrt+0x6a>
    7f0c:	62 0b       	sbc	r22, r18
    7f0e:	73 0b       	sbc	r23, r19
    7f10:	84 0b       	sbc	r24, r20
    7f12:	20 0d       	add	r18, r0
    7f14:	31 1d       	adc	r19, r1
    7f16:	41 1d       	adc	r20, r1
    7f18:	a0 95       	com	r26
    7f1a:	81 f7       	brne	.-32     	; 0x7efc <sqrt+0x4e>
    7f1c:	b9 01       	movw	r22, r18
    7f1e:	84 2f       	mov	r24, r20
    7f20:	91 58       	subi	r25, 0x81	; 129
    7f22:	88 0f       	add	r24, r24
    7f24:	96 95       	lsr	r25
    7f26:	87 95       	ror	r24
    7f28:	08 95       	ret

00007f2a <square>:
    7f2a:	9b 01       	movw	r18, r22
    7f2c:	ac 01       	movw	r20, r24
    7f2e:	32 cf       	rjmp	.-412    	; 0x7d94 <__mulsf3>

00007f30 <trunc>:
    7f30:	d8 de       	rcall	.-592    	; 0x7ce2 <__fp_trunc>
    7f32:	20 f0       	brcs	.+8      	; 0x7f3c <trunc+0xc>
    7f34:	9f 37       	cpi	r25, 0x7F	; 127
    7f36:	08 f4       	brcc	.+2      	; 0x7f3a <trunc+0xa>
    7f38:	ec ce       	rjmp	.-552    	; 0x7d12 <__fp_szero>
    7f3a:	08 ce       	rjmp	.-1008   	; 0x7b4c <__fp_mintl>
    7f3c:	22 ce       	rjmp	.-956    	; 0x7b82 <__fp_mpack>

00007f3e <__fp_norm2>:
    7f3e:	91 50       	subi	r25, 0x01	; 1
    7f40:	50 40       	sbci	r21, 0x00	; 0
    7f42:	66 0f       	add	r22, r22
    7f44:	77 1f       	adc	r23, r23
    7f46:	88 1f       	adc	r24, r24
    7f48:	d2 f7       	brpl	.-12     	; 0x7f3e <__fp_norm2>
    7f4a:	08 95       	ret

00007f4c <__fp_powsodd>:
    7f4c:	9f 93       	push	r25
    7f4e:	8f 93       	push	r24
    7f50:	7f 93       	push	r23
    7f52:	6f 93       	push	r22
    7f54:	ff 93       	push	r31
    7f56:	ef 93       	push	r30
    7f58:	9b 01       	movw	r18, r22
    7f5a:	ac 01       	movw	r20, r24
    7f5c:	1b df       	rcall	.-458    	; 0x7d94 <__mulsf3>
    7f5e:	ef 91       	pop	r30
    7f60:	ff 91       	pop	r31
    7f62:	20 de       	rcall	.-960    	; 0x7ba4 <__fp_powser>
    7f64:	2f 91       	pop	r18
    7f66:	3f 91       	pop	r19
    7f68:	4f 91       	pop	r20
    7f6a:	5f 91       	pop	r21
    7f6c:	13 cf       	rjmp	.-474    	; 0x7d94 <__mulsf3>

00007f6e <__udivmodsi4>:
    7f6e:	a1 e2       	ldi	r26, 0x21	; 33
    7f70:	1a 2e       	mov	r1, r26
    7f72:	aa 1b       	sub	r26, r26
    7f74:	bb 1b       	sub	r27, r27
    7f76:	fd 01       	movw	r30, r26
    7f78:	0d c0       	rjmp	.+26     	; 0x7f94 <__udivmodsi4_ep>

00007f7a <__udivmodsi4_loop>:
    7f7a:	aa 1f       	adc	r26, r26
    7f7c:	bb 1f       	adc	r27, r27
    7f7e:	ee 1f       	adc	r30, r30
    7f80:	ff 1f       	adc	r31, r31
    7f82:	a2 17       	cp	r26, r18
    7f84:	b3 07       	cpc	r27, r19
    7f86:	e4 07       	cpc	r30, r20
    7f88:	f5 07       	cpc	r31, r21
    7f8a:	20 f0       	brcs	.+8      	; 0x7f94 <__udivmodsi4_ep>
    7f8c:	a2 1b       	sub	r26, r18
    7f8e:	b3 0b       	sbc	r27, r19
    7f90:	e4 0b       	sbc	r30, r20
    7f92:	f5 0b       	sbc	r31, r21

00007f94 <__udivmodsi4_ep>:
    7f94:	66 1f       	adc	r22, r22
    7f96:	77 1f       	adc	r23, r23
    7f98:	88 1f       	adc	r24, r24
    7f9a:	99 1f       	adc	r25, r25
    7f9c:	1a 94       	dec	r1
    7f9e:	69 f7       	brne	.-38     	; 0x7f7a <__udivmodsi4_loop>
    7fa0:	60 95       	com	r22
    7fa2:	70 95       	com	r23
    7fa4:	80 95       	com	r24
    7fa6:	90 95       	com	r25
    7fa8:	9b 01       	movw	r18, r22
    7faa:	ac 01       	movw	r20, r24
    7fac:	bd 01       	movw	r22, r26
    7fae:	cf 01       	movw	r24, r30
    7fb0:	08 95       	ret

00007fb2 <__tablejump2__>:
    7fb2:	ee 0f       	add	r30, r30
    7fb4:	ff 1f       	adc	r31, r31

00007fb6 <__tablejump__>:
    7fb6:	05 90       	lpm	r0, Z+
    7fb8:	f4 91       	lpm	r31, Z
    7fba:	e0 2d       	mov	r30, r0
    7fbc:	09 94       	ijmp

00007fbe <__umulhisi3>:
    7fbe:	a2 9f       	mul	r26, r18
    7fc0:	b0 01       	movw	r22, r0
    7fc2:	b3 9f       	mul	r27, r19
    7fc4:	c0 01       	movw	r24, r0
    7fc6:	a3 9f       	mul	r26, r19
    7fc8:	70 0d       	add	r23, r0
    7fca:	81 1d       	adc	r24, r1
    7fcc:	11 24       	eor	r1, r1
    7fce:	91 1d       	adc	r25, r1
    7fd0:	b2 9f       	mul	r27, r18
    7fd2:	70 0d       	add	r23, r0
    7fd4:	81 1d       	adc	r24, r1
    7fd6:	11 24       	eor	r1, r1
    7fd8:	91 1d       	adc	r25, r1
    7fda:	08 95       	ret

00007fdc <__muluhisi3>:
    7fdc:	0e 94 df 3f 	call	0x7fbe	; 0x7fbe <__umulhisi3>
    7fe0:	a5 9f       	mul	r26, r21
    7fe2:	90 0d       	add	r25, r0
    7fe4:	b4 9f       	mul	r27, r20
    7fe6:	90 0d       	add	r25, r0
    7fe8:	a4 9f       	mul	r26, r20
    7fea:	80 0d       	add	r24, r0
    7fec:	91 1d       	adc	r25, r1
    7fee:	11 24       	eor	r1, r1
    7ff0:	08 95       	ret

00007ff2 <_exit>:
    7ff2:	f8 94       	cli

00007ff4 <__stop_program>:
    7ff4:	ff cf       	rjmp	.-2      	; 0x7ff4 <__stop_program>
