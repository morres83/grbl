
morres83_GRBL-JOG.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008038  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000855  00800100  00800100  000080ac  2**0
                  ALLOC
  2 .comment      00000030  00000000  00000000  000080ac  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000568  00000000  00000000  000080dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00008834  00000000  00000000  00008644  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000208c  00000000  00000000  00010e78  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00002979  00000000  00000000  00012f04  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00001238  00000000  00000000  00015880  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000173a  00000000  00000000  00016ab8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005f5e  00000000  00000000  000181f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000568  00000000  00000000  0001e150  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e4 04 	jmp	0x9c8	; 0x9c8 <__ctors_end>
       4:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
       8:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
       c:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      10:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      14:	0c 94 70 2f 	jmp	0x5ee0	; 0x5ee0 <__vector_5>
      18:	0c 94 b7 39 	jmp	0x736e	; 0x736e <__vector_6>
      1c:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      20:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      24:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      28:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      2c:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      30:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      34:	0c 94 9a 1b 	jmp	0x3734	; 0x3734 <__vector_13>
      38:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      3c:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      40:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      44:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      48:	0c 94 b0 1d 	jmp	0x3b60	; 0x3b60 <__vector_18>
      4c:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      50:	0c 94 76 18 	jmp	0x30ec	; 0x30ec <__vector_20>
      54:	0c 94 38 18 	jmp	0x3070	; 0x3070 <__vector_21>
      58:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      5c:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      60:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      64:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      68:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      6c:	0c 94 01 05 	jmp	0xa02	; 0xa02 <__bad_interrupt>
      70:	e2 0d       	add	r30, r2
      72:	e2 0d       	add	r30, r2
      74:	e2 0d       	add	r30, r2
      76:	e2 0d       	add	r30, r2
      78:	7d 0d       	add	r23, r13
      7a:	34 17       	cp	r19, r20
      7c:	34 17       	cp	r19, r20
      7e:	34 17       	cp	r19, r20
      80:	34 17       	cp	r19, r20
      82:	34 17       	cp	r19, r20
      84:	74 0d       	add	r23, r4
      86:	34 17       	cp	r19, r20
      88:	34 17       	cp	r19, r20
      8a:	34 17       	cp	r19, r20
      8c:	34 17       	cp	r19, r20
      8e:	34 17       	cp	r19, r20
      90:	34 17       	cp	r19, r20
      92:	43 0e       	add	r4, r19
      94:	43 0e       	add	r4, r19
      96:	43 0e       	add	r4, r19
      98:	78 0e       	add	r7, r24
      9a:	78 0e       	add	r7, r24
      9c:	34 17       	cp	r19, r20
      9e:	34 17       	cp	r19, r20
      a0:	34 17       	cp	r19, r20
      a2:	34 17       	cp	r19, r20
      a4:	34 17       	cp	r19, r20
      a6:	34 17       	cp	r19, r20
      a8:	74 0d       	add	r23, r4
      aa:	34 17       	cp	r19, r20
      ac:	74 0d       	add	r23, r4
      ae:	34 17       	cp	r19, r20
      b0:	34 17       	cp	r19, r20
      b2:	34 17       	cp	r19, r20
      b4:	34 17       	cp	r19, r20
      b6:	34 17       	cp	r19, r20
      b8:	34 17       	cp	r19, r20
      ba:	34 17       	cp	r19, r20
      bc:	e2 0d       	add	r30, r2
      be:	34 17       	cp	r19, r20
      c0:	a8 0e       	add	r10, r24
      c2:	34 17       	cp	r19, r20
      c4:	34 17       	cp	r19, r20
      c6:	86 0e       	add	r8, r22
      c8:	34 17       	cp	r19, r20
      ca:	34 17       	cp	r19, r20
      cc:	34 17       	cp	r19, r20
      ce:	34 17       	cp	r19, r20
      d0:	34 17       	cp	r19, r20
      d2:	86 0e       	add	r8, r22
      d4:	34 17       	cp	r19, r20
      d6:	34 17       	cp	r19, r20
      d8:	34 17       	cp	r19, r20
      da:	7d 0d       	add	r23, r13
      dc:	a1 0e       	add	r10, r17
      de:	a1 0e       	add	r10, r17
      e0:	a1 0e       	add	r10, r17
      e2:	a1 0e       	add	r10, r17
      e4:	a1 0e       	add	r10, r17
      e6:	a1 0e       	add	r10, r17
      e8:	34 17       	cp	r19, r20
      ea:	34 17       	cp	r19, r20
      ec:	34 17       	cp	r19, r20
      ee:	34 17       	cp	r19, r20
      f0:	34 17       	cp	r19, r20
      f2:	34 17       	cp	r19, r20
      f4:	34 17       	cp	r19, r20
      f6:	34 17       	cp	r19, r20
      f8:	34 17       	cp	r19, r20
      fa:	34 17       	cp	r19, r20
      fc:	34 17       	cp	r19, r20
      fe:	34 17       	cp	r19, r20
     100:	34 17       	cp	r19, r20
     102:	34 17       	cp	r19, r20
     104:	34 17       	cp	r19, r20
     106:	34 17       	cp	r19, r20
     108:	34 17       	cp	r19, r20
     10a:	34 17       	cp	r19, r20
     10c:	34 17       	cp	r19, r20
     10e:	34 17       	cp	r19, r20
     110:	e8 0d       	add	r30, r8
     112:	34 17       	cp	r19, r20
     114:	34 17       	cp	r19, r20
     116:	34 17       	cp	r19, r20
     118:	34 17       	cp	r19, r20
     11a:	34 17       	cp	r19, r20
     11c:	34 17       	cp	r19, r20
     11e:	34 17       	cp	r19, r20
     120:	34 17       	cp	r19, r20
     122:	34 17       	cp	r19, r20
     124:	5c 0e       	add	r5, r28
     126:	5c 0e       	add	r5, r28
     128:	74 0d       	add	r23, r4
     12a:	6a 0e       	add	r6, r26
     12c:	6a 0e       	add	r6, r26
     12e:	d3 0e       	add	r13, r19
     130:	d3 0e       	add	r13, r19
     132:	d3 0e       	add	r13, r19
     134:	e5 0e       	add	r14, r21
     136:	e5 0e       	add	r14, r21
     138:	e5 0e       	add	r14, r21
     13a:	4c 17       	cp	r20, r28
     13c:	4c 17       	cp	r20, r28
     13e:	fc 0e       	add	r15, r28
     140:	fc 0e       	add	r15, r28
     142:	4c 17       	cp	r20, r28
     144:	4c 17       	cp	r20, r28
     146:	4c 17       	cp	r20, r28
     148:	4c 17       	cp	r20, r28
     14a:	4c 17       	cp	r20, r28
     14c:	4c 17       	cp	r20, r28
     14e:	4c 17       	cp	r20, r28
     150:	4c 17       	cp	r20, r28
     152:	4c 17       	cp	r20, r28
     154:	4c 17       	cp	r20, r28
     156:	4c 17       	cp	r20, r28
     158:	4c 17       	cp	r20, r28
     15a:	4c 17       	cp	r20, r28
     15c:	4c 17       	cp	r20, r28
     15e:	4c 17       	cp	r20, r28
     160:	4c 17       	cp	r20, r28
     162:	4c 17       	cp	r20, r28
     164:	4c 17       	cp	r20, r28
     166:	4c 17       	cp	r20, r28
     168:	4c 17       	cp	r20, r28
     16a:	d3 0e       	add	r13, r19
     16c:	2f 0f       	add	r18, r31
     16e:	50 17       	cp	r21, r16
     170:	50 17       	cp	r21, r16
     172:	39 0f       	add	r19, r25
     174:	46 0f       	add	r20, r22
     176:	53 0f       	add	r21, r19
     178:	60 0f       	add	r22, r16
     17a:	50 17       	cp	r21, r16
     17c:	64 0f       	add	r22, r20
     17e:	50 17       	cp	r21, r16
     180:	72 0f       	add	r23, r18
     182:	50 17       	cp	r21, r16
     184:	7c 0f       	add	r23, r28
     186:	86 0f       	add	r24, r22
     188:	b6 0f       	add	r27, r22
     18a:	50 17       	cp	r21, r16
     18c:	50 17       	cp	r21, r16
     18e:	50 17       	cp	r21, r16
     190:	90 0f       	add	r25, r16
     192:	9d 0f       	add	r25, r29
     194:	aa 0f       	add	r26, r26
     196:	00 16       	cp	r0, r16
     198:	15 16       	cp	r1, r21
     19a:	34 16       	cp	r3, r20
     19c:	15 16       	cp	r1, r21
     19e:	3a 16       	cp	r3, r26
     1a0:	51 16       	cp	r5, r17
     1a2:	40 16       	cp	r4, r16
     1a4:	4a 16       	cp	r4, r26
     1a6:	66 16       	cp	r6, r22
     1a8:	70 16       	cp	r7, r16
     1aa:	7f 16       	cp	r7, r31
     1ac:	a4 16       	cp	r10, r20
     1ae:	c8 16       	cp	r12, r24
     1b0:	d9 16       	cp	r13, r25
     1b2:	eb 16       	cp	r14, r27
     1b4:	fc 16       	cp	r15, r28
     1b6:	ac 27       	eor	r26, r28
     1b8:	b2 27       	eor	r27, r18
     1ba:	b5 27       	eor	r27, r21
     1bc:	ba 27       	eor	r27, r26
     1be:	bf 27       	eor	r27, r31
     1c0:	cd 27       	eor	r28, r29
     1c2:	db 27       	eor	r29, r27
     1c4:	78 28       	or	r7, r8
     1c6:	78 28       	or	r7, r8
     1c8:	78 28       	or	r7, r8
     1ca:	e9 27       	eor	r30, r25
     1cc:	ec 27       	eor	r30, r28
     1ce:	f5 27       	eor	r31, r21
     1d0:	fe 27       	eor	r31, r30
     1d2:	78 28       	or	r7, r8
     1d4:	78 28       	or	r7, r8
     1d6:	78 28       	or	r7, r8
     1d8:	78 28       	or	r7, r8
     1da:	78 28       	or	r7, r8
     1dc:	78 28       	or	r7, r8
     1de:	0c 28       	or	r0, r12
     1e0:	1c 28       	or	r1, r12
     1e2:	2c 28       	or	r2, r12
     1e4:	3a 28       	or	r3, r10
     1e6:	3d 28       	or	r3, r13
     1e8:	46 28       	or	r4, r6
     1ea:	4f 28       	or	r4, r15
     1ec:	56 28       	or	r5, r6
     1ee:	78 28       	or	r7, r8
     1f0:	78 28       	or	r7, r8
     1f2:	5f 28       	or	r5, r15
     1f4:	68 28       	or	r6, r8
     1f6:	7b 34       	cpi	r23, 0x4B	; 75
     1f8:	80 34       	cpi	r24, 0x40	; 64
     1fa:	85 34       	cpi	r24, 0x45	; 69
     1fc:	8a 34       	cpi	r24, 0x4A	; 74
     1fe:	8f 34       	cpi	r24, 0x4F	; 79
     200:	94 34       	cpi	r25, 0x44	; 68
     202:	99 34       	cpi	r25, 0x49	; 73
     204:	9e 34       	cpi	r25, 0x4E	; 78
     206:	a3 34       	cpi	r26, 0x43	; 67
     208:	a8 34       	cpi	r26, 0x48	; 72
     20a:	ad 34       	cpi	r26, 0x4D	; 77
     20c:	c6 34       	cpi	r28, 0x46	; 70
     20e:	b2 34       	cpi	r27, 0x42	; 66
     210:	c6 34       	cpi	r28, 0x46	; 70
     212:	c6 34       	cpi	r28, 0x46	; 70
     214:	c6 34       	cpi	r28, 0x46	; 70
     216:	c6 34       	cpi	r28, 0x46	; 70
     218:	c6 34       	cpi	r28, 0x46	; 70
     21a:	c6 34       	cpi	r28, 0x46	; 70
     21c:	bc 34       	cpi	r27, 0x4C	; 76
     21e:	b7 34       	cpi	r27, 0x47	; 71
     220:	c1 34       	cpi	r28, 0x41	; 65
     222:	af 37       	cpi	r26, 0x7F	; 127
     224:	b4 37       	cpi	r27, 0x74	; 116
     226:	b9 37       	cpi	r27, 0x79	; 121
     228:	be 37       	cpi	r27, 0x7E	; 126
     22a:	c3 37       	cpi	r28, 0x73	; 115
     22c:	c8 37       	cpi	r28, 0x78	; 120
     22e:	cd 37       	cpi	r28, 0x7D	; 125
     230:	d2 37       	cpi	r29, 0x72	; 114
     232:	d7 37       	cpi	r29, 0x77	; 119
     234:	08 4a       	sbci	r16, 0xA8	; 168
     236:	d7 3b       	cpi	r29, 0xB7	; 183
     238:	3b ce       	rjmp	.-906    	; 0xfffffeb0 <__eeprom_end+0xff7efeb0>
     23a:	01 6e       	ori	r16, 0xE1	; 225
     23c:	84 bc       	out	0x24, r8	; 36
     23e:	bf fd       	.word	0xfdbf	; ????
     240:	c1 2f       	mov	r28, r17
     242:	3d 6c       	ori	r19, 0xCD	; 205
     244:	74 31       	cpi	r23, 0x14	; 20
     246:	9a bd       	out	0x2a, r25	; 42
     248:	56 83       	std	Z+6, r21	; 0x06
     24a:	3d da       	rcall	.-2950   	; 0xfffff6c6 <__eeprom_end+0xff7ef6c6>
     24c:	3d 00       	.word	0x003d	; ????
     24e:	c7 7f       	andi	r28, 0xF7	; 247
     250:	11 be       	out	0x31, r1	; 49
     252:	d9 e4       	ldi	r29, 0x49	; 73
     254:	bb 4c       	sbci	r27, 0xCB	; 203
     256:	3e 91       	ld	r19, -X
     258:	6b aa       	std	Y+51, r6	; 0x33
     25a:	aa be       	out	0x3a, r10	; 58
     25c:	00 00       	nop
     25e:	00 80       	ld	r0, Z
     260:	3f 05       	cpc	r19, r15
     262:	a8 4c       	sbci	r26, 0xC8	; 200
     264:	cd b2       	in	r12, 0x1d	; 29
     266:	d4 4e       	sbci	r29, 0xE4	; 228
     268:	b9 38       	cpi	r27, 0x89	; 137
     26a:	36 a9       	ldd	r19, Z+54	; 0x36
     26c:	02 0c       	add	r0, r2
     26e:	50 b9       	out	0x00, r21	; 0
     270:	91 86       	std	Z+9, r9	; 0x09
     272:	88 08       	sbc	r8, r8
     274:	3c a6       	std	Y+44, r3	; 0x2c
     276:	aa aa       	std	Y+50, r10	; 0x32
     278:	2a be       	out	0x3a, r2	; 58
     27a:	00 00       	nop
     27c:	00 80       	ld	r0, Z
     27e:	3f 00       	.word	0x003f	; ????

00000280 <__trampolines_end>:
     280:	4a 6f       	ori	r20, 0xFA	; 250
     282:	67 46       	sbci	r22, 0x67	; 103
     284:	0d 0a       	sbc	r0, r29
	...

00000287 <__c.2349>:
     287:	4a 6f 67 00                                         Jog.

0000028b <__c.2347>:
     28b:	69 64 6c 65 20 66 72 6f 6d 20 6a 6f 67 00           idle from jog.

00000299 <__c.2315>:
     299:	0d 0a 00                                            ...

0000029c <__c.2313>:
     29c:	20 00                                                .

0000029e <__c.2725>:
     29e:	3e 0d 0a 00                                         >...

000002a2 <__c.2723>:
     2a2:	2c 52 58 3a 00                                      ,RX:.

000002a7 <__c.2721>:
     2a7:	2c 42 75 66 3a 00                                   ,Buf:.

000002ad <__c.2716>:
     2ad:	2c 00                                               ,.

000002af <__c.2714>:
     2af:	2c 57 50 6f 73 3a 00                                ,WPos:.

000002b6 <__c.2709>:
     2b6:	2c 00                                               ,.

000002b8 <__c.2707>:
     2b8:	2c 4d 50 6f 73 3a 00                                ,MPos:.

000002bf <__c.2705>:
     2bf:	3c 4a 6f 67 00                                      <Jog.

000002c4 <__c.2702>:
     2c4:	3c 44 6f 6f 72 00                                   <Door.

000002ca <__c.2699>:
     2ca:	3c 43 68 65 63 6b 00                                <Check.

000002d1 <__c.2696>:
     2d1:	3c 41 6c 61 72 6d 00                                <Alarm.

000002d8 <__c.2693>:
     2d8:	3c 48 6f 6d 65 00                                   <Home.

000002de <__c.2690>:
     2de:	3c 48 6f 6c 64 00                                   <Hold.

000002e4 <__c.2687>:
     2e4:	3c 52 75 6e 00                                      <Run.

000002e9 <__c.2682>:
     2e9:	3c 49 64 6c 65 00                                   <Idle.

000002ef <__c.2674>:
     2ef:	5d 0d 0a 00                                         ]...

000002f3 <__c.2672>:
     2f3:	5b 30 2e 39 68 2f 47 52 42 4c 2d 4a 4f 47 2e 32     [0.9h/GRBL-JOG.2
     303:	30 31 35 30 32 31 30 3a 00                          0150210:.

0000030c <__c.2667>:
     30c:	0d 0a 00                                            ...

0000030f <__c.2665>:
     30f:	3d 00                                               =.

00000311 <__c.2663>:
     311:	24 4e 00                                            $N.

00000314 <__c.2657>:
     314:	5d 0d 0a 00                                         ]...

00000318 <__c.2655>:
     318:	20 46 00                                             F.

0000031b <__c.2653>:
     31b:	20 54 00                                             T.

0000031e <__c.2651>:
     31e:	20 4d 38 00                                          M8.

00000322 <__c.2647>:
     322:	20 4d 39 00                                          M9.

00000326 <__c.2644>:
     326:	20 4d 35 00                                          M5.

0000032a <__c.2641>:
     32a:	20 4d 34 00                                          M4.

0000032e <__c.2637>:
     32e:	20 4d 33 00                                          M3.

00000332 <__c.2634>:
     332:	20 4d 32 00                                          M2.

00000336 <__c.2631>:
     336:	20 4d 31 00                                          M1.

0000033a <__c.2627>:
     33a:	20 4d 30 00                                          M0.

0000033e <__c.2624>:
     33e:	20 47 39 34 00                                       G94.

00000343 <__c.2622>:
     343:	20 47 39 33 00                                       G93.

00000348 <__c.2620>:
     348:	20 47 39 31 00                                       G91.

0000034d <__c.2618>:
     34d:	20 47 39 30 00                                       G90.

00000352 <__c.2616>:
     352:	20 47 32 30 00                                       G20.

00000357 <__c.2614>:
     357:	20 47 32 31 00                                       G21.

0000035c <__c.2612>:
     35c:	20 47 31 39 00                                       G19.

00000361 <__c.2609>:
     361:	20 47 31 38 00                                       G18.

00000366 <__c.2605>:
     366:	20 47 31 37 00                                       G17.

0000036b <__c.2602>:
     36b:	20 47 00                                             G.

0000036e <__c.2600>:
     36e:	47 38 30 00                                         G80.

00000372 <__c.2597>:
     372:	47 33 38 2e 35 00                                   G38.5.

00000378 <__c.2594>:
     378:	47 33 38 2e 34 00                                   G38.4.

0000037e <__c.2591>:
     37e:	47 33 38 2e 33 00                                   G38.3.

00000384 <__c.2588>:
     384:	47 33 38 2e 32 00                                   G38.2.

0000038a <__c.2585>:
     38a:	47 33 00                                            G3.

0000038d <__c.2582>:
     38d:	47 32 00                                            G2.

00000390 <__c.2579>:
     390:	47 31 00                                            G1.

00000393 <__c.2575>:
     393:	47 30 00                                            G0.

00000396 <__c.2572>:
     396:	5b 00                                               [.

00000398 <__c.2568>:
     398:	5d 0d 0a 00                                         ]...

0000039c <__c.2566>:
     39c:	5b 54 4c 4f 3a 00                                   [TLO:.

000003a2 <__c.2561>:
     3a2:	5d 0d 0a 00                                         ]...

000003a6 <__c.2559>:
     3a6:	2c 00                                               ,.

000003a8 <__c.2557>:
     3a8:	5b 47 39 32 3a 00                                   [G92:.

000003ae <__c.2549>:
     3ae:	5d 0d 0a 00                                         ]...

000003b2 <__c.2547>:
     3b2:	2c 00                                               ,.

000003b4 <__c.2545>:
     3b4:	3a 00                                               :.

000003b6 <__c.2542>:
     3b6:	33 30 00                                            30.

000003b9 <__c.2538>:
     3b9:	32 38 00                                            28.

000003bc <__c.2535>:
     3bc:	5b 47 00                                            [G.

000003bf <__c.2528>:
     3bf:	5d 0d 0a 00                                         ]...

000003c3 <__c.2526>:
     3c3:	3a 00                                               :.

000003c5 <__c.2521>:
     3c5:	2c 00                                               ,.

000003c7 <__c.2519>:
     3c7:	5b 50 52 42 3a 00                                   [PRB:.

000003cd <__c.2507>:
     3cd:	29 0d 0a 00                                         )...

000003d1 <__c.2505>:
     3d1:	20 6d 61 78 20 74 72 61 76 65 6c 2c 20 6d 6d 00      max travel, mm.

000003e1 <__c.2502>:
     3e1:	20 61 63 63 65 6c 2c 20 6d 6d 2f 73 65 63 5e 32      accel, mm/sec^2
	...

000003f2 <__c.2499>:
     3f2:	20 6d 61 78 20 72 61 74 65 2c 20 6d 6d 2f 6d 69      max rate, mm/mi
     402:	6e 00                                               n.

00000404 <__c.2495>:
     404:	2c 20 73 74 65 70 2f 6d 6d 00                       , step/mm.

0000040e <__c.2492>:
     40e:	7a 00                                               z.

00000410 <__c.2489>:
     410:	79 00                                               y.

00000412 <__c.2485>:
     412:	78 00                                               x.

00000414 <__c.2482>:
     414:	20 28 00                                             (.

00000417 <__c.2475>:
     417:	3d 00                                               =.

00000419 <__c.2473>:
     419:	24 00                                               $.

0000041b <__c.2468>:
     41b:	20 28 5a 20 7a 65 72 6f 20 67 61 75 67 65 2c 20      (Z zero gauge, 
     42b:	6d 6d 29 0d 0a 00                                   mm)...

00000431 <__c.2466>:
     431:	20 28 5a 20 7a 65 72 6f 20 70 75 6c 6c 2d 6f 66      (Z zero pull-of
     441:	66 2c 20 6d 6d 29 0d 0a 24 33 31 3d 00              f, mm)..$31=.

0000044e <__c.2464>:
     44e:	20 28 68 6f 6d 69 6e 67 20 70 75 6c 6c 2d 6f 66      (homing pull-of
     45e:	66 2c 20 6d 6d 29 0d 0a 24 33 30 3d 00              f, mm)..$30=.

0000046b <__c.2462>:
     46b:	20 28 68 6f 6d 69 6e 67 20 64 65 62 6f 75 6e 63      (homing debounc
     47b:	65 2c 20 6d 73 65 63 29 0d 0a 24 32 37 3d 00        e, msec)..$27=.

0000048a <__c.2460>:
     48a:	20 28 68 6f 6d 69 6e 67 20 73 65 65 6b 2c 20 6d      (homing seek, m
     49a:	6d 2f 6d 69 6e 29 0d 0a 24 32 36 3d 00              m/min)..$26=.

000004a7 <__c.2458>:
     4a7:	20 28 68 6f 6d 69 6e 67 20 66 65 65 64 2c 20 6d      (homing feed, m
     4b7:	6d 2f 6d 69 6e 29 0d 0a 24 32 35 3d 00              m/min)..$25=.

000004c4 <__c.2456>:
     4c4:	29 0d 0a 24 32 34 3d 00                             )..$24=.

000004cc <__c.2454>:
     4cc:	20 28 68 6f 6d 69 6e 67 20 64 69 72 20 69 6e 76      (homing dir inv
     4dc:	65 72 74 20 6d 61 73 6b 3a 00                       ert mask:.

000004e6 <__c.2452>:
     4e6:	20 28 68 6f 6d 69 6e 67 20 63 79 63 6c 65 2c 20      (homing cycle, 
     4f6:	62 6f 6f 6c 29 0d 0a 24 32 33 3d 00                 bool)..$23=.

00000502 <__c.2450>:
     502:	20 28 68 61 72 64 20 6c 69 6d 69 74 73 2c 20 62      (hard limits, b
     512:	6f 6f 6c 29 0d 0a 24 32 32 3d 00                    ool)..$22=.

0000051d <__c.2448>:
     51d:	20 28 73 6f 66 74 20 6c 69 6d 69 74 73 2c 20 62      (soft limits, b
     52d:	6f 6f 6c 29 0d 0a 24 32 31 3d 00                    ool)..$21=.

00000538 <__c.2446>:
     538:	20 28 72 65 70 6f 72 74 20 69 6e 63 68 65 73 2c      (report inches,
     548:	20 62 6f 6f 6c 29 0d 0a 24 32 30 3d 00               bool)..$20=.

00000555 <__c.2444>:
     555:	20 28 61 72 63 20 74 6f 6c 65 72 61 6e 63 65 2c      (arc tolerance,
     565:	20 6d 6d 29 0d 0a 24 31 33 3d 00                     mm)..$13=.

00000570 <__c.2442>:
     570:	20 28 6a 75 6e 63 74 69 6f 6e 20 64 65 76 69 61      (junction devia
     580:	74 69 6f 6e 2c 20 6d 6d 29 0d 0a 24 31 32 3d 00     tion, mm)..$12=.

00000590 <__c.2440>:
     590:	29 0d 0a 24 31 31 3d 00                             )..$11=.

00000598 <__c.2438>:
     598:	20 28 73 74 61 74 75 73 20 72 65 70 6f 72 74 20      (status report 
     5a8:	6d 61 73 6b 3a 00                                   mask:.

000005ae <__c.2436>:
     5ae:	20 28 70 72 6f 62 65 20 70 69 6e 20 69 6e 76 65      (probe pin inve
     5be:	72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 31 30 3d 00     rt, bool)..$10=.

000005ce <__c.2434>:
     5ce:	20 28 6c 69 6d 69 74 20 70 69 6e 73 20 69 6e 76      (limit pins inv
     5de:	65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 36 3d 00     ert, bool)..$6=.

000005ee <__c.2432>:
     5ee:	20 28 73 74 65 70 20 65 6e 61 62 6c 65 20 69 6e      (step enable in
     5fe:	76 65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 35 3d     vert, bool)..$5=
	...

0000060f <__c.2430>:
     60f:	29 0d 0a 24 34 3d 00                                )..$4=.

00000616 <__c.2428>:
     616:	20 28 64 69 72 20 70 6f 72 74 20 69 6e 76 65 72      (dir port inver
     626:	74 20 6d 61 73 6b 3a 00                             t mask:.

0000062e <__c.2426>:
     62e:	29 0d 0a 24 33 3d 00                                )..$3=.

00000635 <__c.2424>:
     635:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     645:	72 74 20 6d 61 73 6b 3a 00                          rt mask:.

0000064e <__c.2422>:
     64e:	20 28 73 74 65 70 20 69 64 6c 65 20 64 65 6c 61      (step idle dela
     65e:	79 2c 20 6d 73 65 63 29 0d 0a 24 32 3d 00           y, msec)..$2=.

0000066c <__c.2420>:
     66c:	20 28 73 74 65 70 20 70 75 6c 73 65 2c 20 75 73      (step pulse, us
     67c:	65 63 29 0d 0a 24 31 3d 00                          ec)..$1=.

00000685 <__c.2418>:
     685:	24 30 3d 00                                         $0=.

00000689 <__c.2414>:
     689:	24 24 20 28 76 69 65 77 20 47 72 62 6c 20 73 65     $$ (view Grbl se
     699:	74 74 69 6e 67 73 29 0d 0a 24 23 20 28 76 69 65     ttings)..$# (vie
     6a9:	77 20 23 20 70 61 72 61 6d 65 74 65 72 73 29 0d     w # parameters).
     6b9:	0a 24 47 20 28 76 69 65 77 20 70 61 72 73 65 72     .$G (view parser
     6c9:	20 73 74 61 74 65 29 0d 0a 24 49 20 28 76 69 65      state)..$I (vie
     6d9:	77 20 62 75 69 6c 64 20 69 6e 66 6f 29 0d 0a 24     w build info)..$
     6e9:	4e 20 28 76 69 65 77 20 73 74 61 72 74 75 70 20     N (view startup 
     6f9:	62 6c 6f 63 6b 73 29 0d 0a 24 78 3d 76 61 6c 75     blocks)..$x=valu
     709:	65 20 28 73 61 76 65 20 47 72 62 6c 20 73 65 74     e (save Grbl set
     719:	74 69 6e 67 29 0d 0a 24 4e 78 3d 6c 69 6e 65 20     ting)..$Nx=line 
     729:	28 73 61 76 65 20 73 74 61 72 74 75 70 20 62 6c     (save startup bl
     739:	6f 63 6b 29 0d 0a 24 43 20 28 63 68 65 63 6b 20     ock)..$C (check 
     749:	67 63 6f 64 65 20 6d 6f 64 65 29 0d 0a 24 58 20     gcode mode)..$X 
     759:	28 6b 69 6c 6c 20 61 6c 61 72 6d 20 6c 6f 63 6b     (kill alarm lock
     769:	29 0d 0a 24 48 20 28 72 75 6e 20 68 6f 6d 69 6e     )..$H (run homin
     779:	67 20 63 79 63 6c 65 29 0d 0a 7e 20 28 63 79 63     g cycle)..~ (cyc
     789:	6c 65 20 73 74 61 72 74 29 0d 0a 21 20 28 66 65     le start)..! (fe
     799:	65 64 20 68 6f 6c 64 29 0d 0a 3f 20 28 63 75 72     ed hold)..? (cur
     7a9:	72 65 6e 74 20 73 74 61 74 75 73 29 0d 0a 63 74     rent status)..ct
     7b9:	72 6c 2d 78 20 28 72 65 73 65 74 20 47 72 62 6c     rl-x (reset Grbl
     7c9:	29 0d 0a 00                                         )...

000007cd <__c.2410>:
     7cd:	0d 0a 47 72 62 6c 20 30 2e 39 68 2f 47 52 42 4c     ..Grbl 0.9h/GRBL
     7dd:	2d 4a 4f 47 20 5b 27 24 27 20 66 6f 72 20 68 65     -JOG ['$' for he
     7ed:	6c 70 5d 0d 0a 00                                   lp]...

000007f3 <__c.2406>:
     7f3:	5d 0d 0a 00                                         ]...

000007f7 <__c.2404>:
     7f7:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

00000802 <__c.2401>:
     802:	44 69 73 61 62 6c 65 64 00                          Disabled.

0000080b <__c.2398>:
     80b:	45 6e 61 62 6c 65 64 00                             Enabled.

00000813 <__c.2395>:
     813:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     823:	64 00                                               d.

00000825 <__c.2392>:
     825:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     835:	6f 63 6b 00                                         ock.

00000839 <__c.2388>:
     839:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     849:	65 00                                               e.

0000084b <__c.2385>:
     84b:	5b 00                                               [.

0000084d <__c.2380>:
     84d:	0d 0a 00                                            ...

00000850 <__c.2378>:
     850:	50 72 6f 62 65 20 66 61 69 6c 00                    Probe fail.

0000085b <__c.2375>:
     85b:	41 62 6f 72 74 20 64 75 72 69 6e 67 20 63 79 63     Abort during cyc
     86b:	6c 65 00                                            le.

0000086e <__c.2372>:
     86e:	53 6f 66 74 20 6c 69 6d 69 74 00                    Soft limit.

00000879 <__c.2368>:
     879:	48 61 72 64 20 6c 69 6d 69 74 00                    Hard limit.

00000884 <__c.2365>:
     884:	41 4c 41 52 4d 3a 20 00                             ALARM: .

0000088c <__c.2360>:
     88c:	0d 0a 00                                            ...

0000088f <__c.2358>:
     88f:	49 6e 76 61 6c 69 64 20 67 63 6f 64 65 20 49 44     Invalid gcode ID
     89f:	3a 00                                               :.

000008a1 <__c.2355>:
     8a1:	55 6e 64 65 66 69 6e 65 64 20 66 65 65 64 20 72     Undefined feed r
     8b1:	61 74 65 00                                         ate.

000008b5 <__c.2352>:
     8b5:	55 6e 73 75 70 70 6f 72 74 65 64 20 63 6f 6d 6d     Unsupported comm
     8c5:	61 6e 64 00                                         and.

000008c9 <__c.2349>:
     8c9:	4d 6f 64 61 6c 20 67 72 6f 75 70 20 76 69 6f 6c     Modal group viol
     8d9:	61 74 69 6f 6e 00                                   ation.

000008df <__c.2346>:
     8df:	4a 6f 67 67 69 6e 67 20 6f 6e 67 6f 69 6e 67 3b     Jogging ongoing;
     8ef:	20 49 67 6e 6f 72 69 6e 67 20 47 43 6f 64 65 00      Ignoring GCode.

000008ff <__c.2343>:
     8ff:	4c 69 6e 65 20 6f 76 65 72 66 6c 6f 77 00           Line overflow.

0000090d <__c.2340>:
     90d:	48 6f 6d 69 6e 67 20 6e 6f 74 20 65 6e 61 62 6c     Homing not enabl
     91d:	65 64 00                                            ed.

00000920 <__c.2337>:
     920:	41 6c 61 72 6d 20 6c 6f 63 6b 00                    Alarm lock.

0000092b <__c.2334>:
     92b:	4e 6f 74 20 69 64 6c 65 00                          Not idle.

00000934 <__c.2331>:
     934:	45 45 50 52 4f 4d 20 72 65 61 64 20 66 61 69 6c     EEPROM read fail
     944:	2e 20 55 73 69 6e 67 20 64 65 66 61 75 6c 74 73     . Using defaults
	...

00000955 <__c.2328>:
     955:	56 61 6c 75 65 20 3c 20 33 20 75 73 65 63 00        Value < 3 usec.

00000964 <__c.2325>:
     964:	53 65 74 74 69 6e 67 20 64 69 73 61 62 6c 65 64     Setting disabled
	...

00000975 <__c.2322>:
     975:	56 61 6c 75 65 20 3c 20 30 00                       Value < 0.

0000097f <__c.2319>:
     97f:	49 6e 76 61 6c 69 64 20 73 74 61 74 65 6d 65 6e     Invalid statemen
     98f:	74 00                                               t.

00000991 <__c.2316>:
     991:	42 61 64 20 6e 75 6d 62 65 72 20 66 6f 72 6d 61     Bad number forma
     9a1:	74 00                                               t.

000009a3 <__c.2312>:
     9a3:	45 78 70 65 63 74 65 64 20 63 6f 6d 6d 61 6e 64     Expected command
     9b3:	20 6c 65 74 74 65 72 00                              letter.

000009bb <__c.2309>:
     9bb:	65 72 72 6f 72 3a 20 00                             error: .

000009c3 <__c.2307>:
     9c3:	6f 6b 0d 0a 00                                      ok...

000009c8 <__ctors_end>:
     9c8:	11 24       	eor	r1, r1
     9ca:	1f be       	out	0x3f, r1	; 63
     9cc:	cf ef       	ldi	r28, 0xFF	; 255
     9ce:	d0 e1       	ldi	r29, 0x10	; 16
     9d0:	de bf       	out	0x3e, r29	; 62
     9d2:	cd bf       	out	0x3d, r28	; 61

000009d4 <__do_copy_data>:
     9d4:	11 e0       	ldi	r17, 0x01	; 1
     9d6:	a0 e0       	ldi	r26, 0x00	; 0
     9d8:	b1 e0       	ldi	r27, 0x01	; 1
     9da:	e8 e3       	ldi	r30, 0x38	; 56
     9dc:	f0 e8       	ldi	r31, 0x80	; 128
     9de:	02 c0       	rjmp	.+4      	; 0x9e4 <__do_copy_data+0x10>
     9e0:	05 90       	lpm	r0, Z+
     9e2:	0d 92       	st	X+, r0
     9e4:	a0 30       	cpi	r26, 0x00	; 0
     9e6:	b1 07       	cpc	r27, r17
     9e8:	d9 f7       	brne	.-10     	; 0x9e0 <__do_copy_data+0xc>

000009ea <__do_clear_bss>:
     9ea:	29 e0       	ldi	r18, 0x09	; 9
     9ec:	a0 e0       	ldi	r26, 0x00	; 0
     9ee:	b1 e0       	ldi	r27, 0x01	; 1
     9f0:	01 c0       	rjmp	.+2      	; 0x9f4 <.do_clear_bss_start>

000009f2 <.do_clear_bss_loop>:
     9f2:	1d 92       	st	X+, r1

000009f4 <.do_clear_bss_start>:
     9f4:	a5 35       	cpi	r26, 0x55	; 85
     9f6:	b2 07       	cpc	r27, r18
     9f8:	e1 f7       	brne	.-8      	; 0x9f2 <.do_clear_bss_loop>
     9fa:	0e 94 22 08 	call	0x1044	; 0x1044 <main>
     9fe:	0c 94 1a 40 	jmp	0x8034	; 0x8034 <_exit>

00000a02 <__bad_interrupt>:
     a02:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000a06 <jog_init>:
#define ADMUX_init  0x20  // ADLAR =1 (left adjusted, 8-Bit-Result on ADCH)

void jog_init() {
	// Initialize jog switch port bits and DDR
	#ifdef LED_PRESENT
	LED_DDR |= ((1<<LED_RUN_BIT) | (1<<LED_ERROR_BIT));
     a06:	87 b1       	in	r24, 0x07	; 7
     a08:	80 63       	ori	r24, 0x30	; 48
     a0a:	87 b9       	out	0x07, r24	; 7
	LED_PORT |= ((1<<LED_RUN_BIT) | (1<<LED_ERROR_BIT)); // active low, so set high
     a0c:	88 b1       	in	r24, 0x08	; 8
     a0e:	80 63       	ori	r24, 0x30	; 48
     a10:	88 b9       	out	0x08, r24	; 8
	#endif
	JOGSW_DDR &= ~(JOGSW_MASK); // Set as input pins
     a12:	81 b1       	in	r24, 0x01	; 1
     a14:	80 78       	andi	r24, 0x80	; 128
     a16:	81 b9       	out	0x01, r24	; 1
	JOGSW_PORT |= (JOGSW_MASK); // Enable internal pull-up resistors. Active low operation.
     a18:	82 b1       	in	r24, 0x02	; 2
     a1a:	8f 67       	ori	r24, 0x7F	; 127
     a1c:	82 b9       	out	0x02, r24	; 2

	CONTROL_DDR &= ~(1<<SPIN_TOGGLE);  // Set as input pin
     a1e:	3b 98       	cbi	0x07, 3	; 7
	CONTROL_PORT|= (1<<SPIN_TOGGLE);   // Pullup
     a20:	43 9a       	sbi	0x08, 3	; 8
	
	ADCSRA = ADCSRA_init;
     a22:	83 e8       	ldi	r24, 0x83	; 131
     a24:	80 93 7a 00 	sts	0x007A, r24
	ADMUX = ADMUX_init | JOG_POT;     // Kanal, ADLAR =1 (left adjustet, 8-Bit-Result on ADCH)
     a28:	87 e2       	ldi	r24, 0x27	; 39
     a2a:	80 93 7c 00 	sts	0x007C, r24
     a2e:	08 95       	ret

00000a30 <jog_btn_release>:

}

void jog_btn_release() {
     a30:	cf 93       	push	r28
	uint8_t jog_bits;
	do {
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     a32:	c0 b1       	in	r28, 0x00	; 0
		protocol_process(); // process the serial protocol while waiting
     a34:	0e 94 3b 1a 	call	0x3476	; 0x3476 <protocol_process>
		protocol_execute_realtime();
     a38:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
}

void jog_btn_release() {
	uint8_t jog_bits;
	do {
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     a3c:	c0 95       	com	r28
     a3e:	cf 77       	andi	r28, 0x7F	; 127
		protocol_process(); // process the serial protocol while waiting
		protocol_execute_realtime();
	}
	while (jog_bits); // until released
     a40:	c1 f7       	brne	.-16     	; 0xa32 <jog_btn_release+0x2>
}
     a42:	cf 91       	pop	r28
     a44:	08 95       	ret

00000a46 <spindle_btn_release>:

void spindle_btn_release() {
     a46:	cf 93       	push	r28
	uint8_t spindle_bits;
	do {
		spindle_bits = (~CONTROL_PIN) & (1<<SPIN_TOGGLE); // active low
     a48:	c6 b1       	in	r28, 0x06	; 6
		protocol_process(); // process the serial protocol while waiting
     a4a:	0e 94 3b 1a 	call	0x3476	; 0x3476 <protocol_process>
		protocol_execute_realtime();
     a4e:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
	}
	while (spindle_bits); // until released
     a52:	c3 ff       	sbrs	r28, 3
     a54:	f9 cf       	rjmp	.-14     	; 0xa48 <spindle_btn_release+0x2>
}
     a56:	cf 91       	pop	r28
     a58:	08 95       	ret

00000a5a <jogging>:

void jogging()
// Tests jog port pins and moves steppers
{
     a5a:	2f 92       	push	r2
     a5c:	3f 92       	push	r3
     a5e:	4f 92       	push	r4
     a60:	5f 92       	push	r5
     a62:	6f 92       	push	r6
     a64:	7f 92       	push	r7
     a66:	8f 92       	push	r8
     a68:	9f 92       	push	r9
     a6a:	af 92       	push	r10
     a6c:	bf 92       	push	r11
     a6e:	cf 92       	push	r12
     a70:	df 92       	push	r13
     a72:	ef 92       	push	r14
     a74:	ff 92       	push	r15
     a76:	0f 93       	push	r16
     a78:	1f 93       	push	r17
     a7a:	cf 93       	push	r28
     a7c:	df 93       	push	r29
     a7e:	cd b7       	in	r28, 0x3d	; 61
     a80:	de b7       	in	r29, 0x3e	; 62
     a82:	69 97       	sbiw	r28, 0x19	; 25
     a84:	0f b6       	in	r0, 0x3f	; 63
     a86:	f8 94       	cli
     a88:	de bf       	out	0x3e, r29	; 62
     a8a:	0f be       	out	0x3f, r0	; 63
     a8c:	cd bf       	out	0x3d, r28	; 61
	uint8_t i, spindle_bits;
	
	uint32_t dest_step_rate, step_rate, step_delay; // Step delay after pulse
	float work_position, mm_per_step;

	switch (sys.state) {
     a8e:	80 91 68 07 	lds	r24, 0x0768
     a92:	84 30       	cpi	r24, 0x04	; 4
     a94:	49 f0       	breq	.+18     	; 0xaa8 <jogging+0x4e>
     a96:	18 f4       	brcc	.+6      	; 0xa9e <jogging+0x44>
     a98:	81 30       	cpi	r24, 0x01	; 1
     a9a:	41 f0       	breq	.+16     	; 0xaac <jogging+0x52>
     a9c:	09 c0       	rjmp	.+18     	; 0xab0 <jogging+0x56>
     a9e:	88 30       	cpi	r24, 0x08	; 8
     aa0:	19 f0       	breq	.+6      	; 0xaa8 <jogging+0x4e>
     aa2:	80 32       	cpi	r24, 0x20	; 32
     aa4:	19 f0       	breq	.+6      	; 0xaac <jogging+0x52>
     aa6:	04 c0       	rjmp	.+8      	; 0xab0 <jogging+0x56>
		case STATE_CYCLE: case STATE_HOMING:
		LED_PORT |= (1<<LED_ERROR_BIT);
     aa8:	45 9a       	sbi	0x08, 5	; 8
		return;
     aaa:	b3 c2       	rjmp	.+1382   	; 0x1012 <jogging+0x5b8>
		case STATE_ALARM: case STATE_SAFETY_DOOR:
		LED_PORT &= ~(1<<LED_ERROR_BIT);  break;
     aac:	45 98       	cbi	0x08, 5	; 8
     aae:	01 c0       	rjmp	.+2      	; 0xab2 <jogging+0x58>
		default:
		LED_PORT |= (1<<LED_ERROR_BIT);
     ab0:	45 9a       	sbi	0x08, 5	; 8
	}
	last_sys_state = sys.state;
     ab2:	80 90 68 07 	lds	r8, 0x0768
     ab6:	89 8e       	std	Y+25, r8	; 0x19


	spindle_bits = (~CONTROL_PIN) & (1<<SPIN_TOGGLE); // active low
	if (spindle_bits) {
     ab8:	33 99       	sbic	0x06, 3	; 6
     aba:	15 c0       	rjmp	.+42     	; 0xae6 <jogging+0x8c>
		if (bit_istrue(SPINDLE_ENABLE_PORT,bit(SPINDLE_ENABLE_BIT))) {
     abc:	47 9b       	sbis	0x08, 7	; 8
     abe:	07 c0       	rjmp	.+14     	; 0xace <jogging+0x74>
			//      gc.spindle_direction = 0;
			spindle_run(0, 0.0);
     ac0:	40 e0       	ldi	r20, 0x00	; 0
     ac2:	50 e0       	ldi	r21, 0x00	; 0
     ac4:	ba 01       	movw	r22, r20
     ac6:	80 e0       	ldi	r24, 0x00	; 0
     ac8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <spindle_run>
     acc:	06 c0       	rjmp	.+12     	; 0xada <jogging+0x80>
		}
		else {
			//      gc.spindle_direction = 1;   // also update gcode spindle status
			spindle_run(1, 0.0);
     ace:	40 e0       	ldi	r20, 0x00	; 0
     ad0:	50 e0       	ldi	r21, 0x00	; 0
     ad2:	ba 01       	movw	r22, r20
     ad4:	81 e0       	ldi	r24, 0x01	; 1
     ad6:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <spindle_run>
		}
		spindle_btn_release();
     ada:	0e 94 23 05 	call	0xa46	; 0xa46 <spindle_btn_release>
		delay_ms(20);
     ade:	84 e1       	ldi	r24, 0x14	; 20
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <delay_ms>
	}

	jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     ae6:	80 b1       	in	r24, 0x00	; 0
     ae8:	80 95       	com	r24
     aea:	28 2f       	mov	r18, r24
     aec:	2f 77       	andi	r18, 0x7F	; 127
     aee:	2a 8b       	std	Y+18, r18	; 0x12
	if (!jog_bits) { return; }  // nothing pressed
     af0:	22 23       	and	r18, r18
     af2:	09 f4       	brne	.+2      	; 0xaf6 <jogging+0x9c>
     af4:	8e c2       	rjmp	.+1308   	; 0x1012 <jogging+0x5b8>
	
	// At least one jog/joystick switch is active
	if (jog_bits & (1<<JOG_ZERO)) {     // Zero-Button gedrückt
     af6:	86 ff       	sbrs	r24, 6
     af8:	a1 c0       	rjmp	.+322    	; 0xc3c <jogging+0x1e2>
		jog_btn_release();
     afa:	0e 94 18 05 	call	0xa30	; 0xa30 <jog_btn_release>
		sys.state = last_sys_state;
     afe:	89 8c       	ldd	r8, Y+25	; 0x19
     b00:	80 92 68 07 	sts	0x0768, r8
		if (bit_isfalse(CONTROL_PIN,bit(RESET_BIT))) { // RESET und zusätzlich ZERO gedrückt: Homing
     b04:	30 99       	sbic	0x06, 0	; 6
     b06:	13 c0       	rjmp	.+38     	; 0xb2e <jogging+0xd4>
			if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) {
     b08:	80 91 3c 09 	lds	r24, 0x093C
     b0c:	84 ff       	sbrs	r24, 4
     b0e:	81 c2       	rjmp	.+1282   	; 0x1012 <jogging+0x5b8>
				// Only perform homing if Grbl is idle or lost.
				if ( sys.state==STATE_IDLE || sys.state==STATE_ALARM ) {
     b10:	28 2d       	mov	r18, r8
     b12:	22 30       	cpi	r18, 0x02	; 2
     b14:	08 f0       	brcs	.+2      	; 0xb18 <jogging+0xbe>
     b16:	7d c2       	rjmp	.+1274   	; 0x1012 <jogging+0x5b8>
					mc_homing_cycle();
     b18:	0e 94 17 0c 	call	0x182e	; 0x182e <mc_homing_cycle>
					if (!sys.abort) { 
     b1c:	80 91 67 07 	lds	r24, 0x0767
     b20:	81 11       	cpse	r24, r1
     b22:	77 c2       	rjmp	.+1262   	; 0x1012 <jogging+0x5b8>
						sys.state = STATE_IDLE; // Set to IDLE when complete.
     b24:	10 92 68 07 	sts	0x0768, r1
						st_go_idle(); // Set steppers to the settings idle state before returning.
     b28:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <st_go_idle>
     b2c:	72 c2       	rjmp	.+1252   	; 0x1012 <jogging+0x5b8>
				}
			}
		} 
		else { // Zero current work position

			plan_sync_position();
     b2e:	0e 94 c7 2d 	call	0x5b8e	; 0x5b8e <plan_sync_position>
			gc_sync_position();
     b32:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <gc_sync_position>
     b36:	0e e9       	ldi	r16, 0x9E	; 158
     b38:	17 e0       	ldi	r17, 0x07	; 7
     b3a:	0f 2e       	mov	r0, r31
     b3c:	fa ea       	ldi	r31, 0xAA	; 170
     b3e:	ef 2e       	mov	r14, r31
     b40:	f7 e0       	ldi	r31, 0x07	; 7
     b42:	ff 2e       	mov	r15, r31
     b44:	f0 2d       	mov	r31, r0
			//                            position in mm. Loaded from EEPROM when called.
			//      gc.coord_offset[i]    Retains the G92 coordinate offset (work coordinates) relative to
			//                            machine zero in mm. Non-persistent. Cleared upon reset and boot.

			for (i=0; i<=2; i++) { // Axes indices are consistent, so loop may be used.
				gc_state.coord_offset[i] = gc_state.position[i] - gc_state.coord_system[i];
     b46:	f8 01       	movw	r30, r16
     b48:	61 91       	ld	r22, Z+
     b4a:	71 91       	ld	r23, Z+
     b4c:	81 91       	ld	r24, Z+
     b4e:	91 91       	ld	r25, Z+
     b50:	8f 01       	movw	r16, r30
     b52:	20 85       	ldd	r18, Z+8	; 0x08
     b54:	31 85       	ldd	r19, Z+9	; 0x09
     b56:	42 85       	ldd	r20, Z+10	; 0x0a
     b58:	53 85       	ldd	r21, Z+11	; 0x0b
     b5a:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
     b5e:	f8 01       	movw	r30, r16
     b60:	64 8b       	std	Z+20, r22	; 0x14
     b62:	75 8b       	std	Z+21, r23	; 0x15
     b64:	86 8b       	std	Z+22, r24	; 0x16
     b66:	97 8b       	std	Z+23, r25	; 0x17
			//      gc.coord_system[i]    Current work coordinate system (G54+). Stores offset from absolute machine
			//                            position in mm. Loaded from EEPROM when called.
			//      gc.coord_offset[i]    Retains the G92 coordinate offset (work coordinates) relative to
			//                            machine zero in mm. Non-persistent. Cleared upon reset and boot.

			for (i=0; i<=2; i++) { // Axes indices are consistent, so loop may be used.
     b68:	0e 15       	cp	r16, r14
     b6a:	1f 05       	cpc	r17, r15
     b6c:	61 f7       	brne	.-40     	; 0xb46 <jogging+0xec>
				gc_state.coord_offset[i] = gc_state.position[i] - gc_state.coord_system[i];
			}

			// Z-Achse um bestimmten Betrag zurückziehen
			float xyz[3] = {gc_state.position[X_AXIS], gc_state.position[Y_AXIS], gc_state.position[Z_AXIS] + settings.z_zero_pulloff};
     b6e:	80 91 9e 07 	lds	r24, 0x079E
     b72:	90 91 9f 07 	lds	r25, 0x079F
     b76:	a0 91 a0 07 	lds	r26, 0x07A0
     b7a:	b0 91 a1 07 	lds	r27, 0x07A1
     b7e:	89 83       	std	Y+1, r24	; 0x01
     b80:	9a 83       	std	Y+2, r25	; 0x02
     b82:	ab 83       	std	Y+3, r26	; 0x03
     b84:	bc 83       	std	Y+4, r27	; 0x04
     b86:	80 91 a2 07 	lds	r24, 0x07A2
     b8a:	90 91 a3 07 	lds	r25, 0x07A3
     b8e:	a0 91 a4 07 	lds	r26, 0x07A4
     b92:	b0 91 a5 07 	lds	r27, 0x07A5
     b96:	8d 83       	std	Y+5, r24	; 0x05
     b98:	9e 83       	std	Y+6, r25	; 0x06
     b9a:	af 83       	std	Y+7, r26	; 0x07
     b9c:	b8 87       	std	Y+8, r27	; 0x08
     b9e:	06 ea       	ldi	r16, 0xA6	; 166
     ba0:	17 e0       	ldi	r17, 0x07	; 7
     ba2:	20 91 4c 09 	lds	r18, 0x094C
     ba6:	30 91 4d 09 	lds	r19, 0x094D
     baa:	40 91 4e 09 	lds	r20, 0x094E
     bae:	50 91 4f 09 	lds	r21, 0x094F
     bb2:	f8 01       	movw	r30, r16
     bb4:	60 81       	ld	r22, Z
     bb6:	71 81       	ldd	r23, Z+1	; 0x01
     bb8:	82 81       	ldd	r24, Z+2	; 0x02
     bba:	93 81       	ldd	r25, Z+3	; 0x03
     bbc:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
     bc0:	69 87       	std	Y+9, r22	; 0x09
     bc2:	7a 87       	std	Y+10, r23	; 0x0a
     bc4:	8b 87       	std	Y+11, r24	; 0x0b
     bc6:	9c 87       	std	Y+12, r25	; 0x0c
			mc_line(xyz, settings.homing_seek_rate, false);
     bc8:	40 91 42 09 	lds	r20, 0x0942
     bcc:	50 91 43 09 	lds	r21, 0x0943
     bd0:	60 91 44 09 	lds	r22, 0x0944
     bd4:	70 91 45 09 	lds	r23, 0x0945
     bd8:	20 e0       	ldi	r18, 0x00	; 0
     bda:	ce 01       	movw	r24, r28
     bdc:	01 96       	adiw	r24, 0x01	; 1
     bde:	0e 94 5f 08 	call	0x10be	; 0x10be <mc_line>
			
			protocol_buffer_synchronize(); // Make sure the motion completes
     be2:	0e 94 11 1b 	call	0x3622	; 0x3622 <protocol_buffer_synchronize>
			
			gc_state.position[Z_AXIS] = gc_state.position[Z_AXIS] - (settings.z_zero_gauge);
     be6:	20 91 50 09 	lds	r18, 0x0950
     bea:	30 91 51 09 	lds	r19, 0x0951
     bee:	40 91 52 09 	lds	r20, 0x0952
     bf2:	50 91 53 09 	lds	r21, 0x0953
     bf6:	f8 01       	movw	r30, r16
     bf8:	60 81       	ld	r22, Z
     bfa:	71 81       	ldd	r23, Z+1	; 0x01
     bfc:	82 81       	ldd	r24, Z+2	; 0x02
     bfe:	93 81       	ldd	r25, Z+3	; 0x03
     c00:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
     c04:	f8 01       	movw	r30, r16
     c06:	60 83       	st	Z, r22
     c08:	71 83       	std	Z+1, r23	; 0x01
     c0a:	82 83       	std	Z+2, r24	; 0x02
     c0c:	93 83       	std	Z+3, r25	; 0x03
			gc_state.coord_offset[Z_AXIS] = gc_state.position[Z_AXIS] - gc_state.coord_system[Z_AXIS];
     c0e:	20 91 b2 07 	lds	r18, 0x07B2
     c12:	30 91 b3 07 	lds	r19, 0x07B3
     c16:	40 91 b4 07 	lds	r20, 0x07B4
     c1a:	50 91 b5 07 	lds	r21, 0x07B5
     c1e:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
     c22:	60 93 be 07 	sts	0x07BE, r22
     c26:	70 93 bf 07 	sts	0x07BF, r23
     c2a:	80 93 c0 07 	sts	0x07C0, r24
     c2e:	90 93 c1 07 	sts	0x07C1, r25
			
			// The gcode parser position circumvented by the pull-off maneuver, so sync position vectors.
			// Sets the planner position vector to current steps. Called by the system abort routine.
			// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
			plan_sync_position();
     c32:	0e 94 c7 2d 	call	0x5b8e	; 0x5b8e <plan_sync_position>
			gc_sync_position(); // Syncs all internal position vectors to the current system position.
     c36:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <gc_sync_position>
     c3a:	eb c1       	rjmp	.+982    	; 0x1012 <jogging+0x5b8>

		}
		return;
	}
	
	ADCSRA = ADCSRA_init | (1<<ADIF); //0x93, clear ADIF
     c3c:	ea e7       	ldi	r30, 0x7A	; 122
     c3e:	f0 e0       	ldi	r31, 0x00	; 0
     c40:	93 e9       	ldi	r25, 0x93	; 147
     c42:	90 83       	st	Z, r25
	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
	
	ADCSRA = ADCSRA_init | (1<<ADIF); //0x93, clear ADIF
     c44:	90 83       	st	Z, r25
	ADCSRA = ADCSRA_init | (1<<ADSC); //0xC3; start conversion
     c46:	93 ec       	ldi	r25, 0xC3	; 195
     c48:	90 83       	st	Z, r25
	
	sys.state = STATE_JOG;
     c4a:	90 e8       	ldi	r25, 0x80	; 128
     c4c:	90 93 68 07 	sts	0x0768, r25
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
     c50:	80 fd       	sbrc	r24, 0
     c52:	04 c0       	rjmp	.+8      	; 0xc5c <jogging+0x202>
	}
	
	ADCSRA = ADCSRA_init | (1<<ADIF); //0x93, clear ADIF

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
     c54:	10 e0       	ldi	r17, 0x00	; 0
		return;
	}
	
	ADCSRA = ADCSRA_init | (1<<ADIF); //0x93, clear ADIF

	uint8_t reverse_flag = 0;
     c56:	19 8a       	std	Y+17, r1	; 0x11
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
     c58:	90 e0       	ldi	r25, 0x00	; 0
     c5a:	04 c0       	rjmp	.+8      	; 0xc64 <jogging+0x20a>
	sys.state = STATE_JOG;
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
		out_bits0 ^= (1<<X_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
     c5c:	10 ec       	ldi	r17, 0xC0	; 192
		reverse_flag = 1;
     c5e:	f1 e0       	ldi	r31, 0x01	; 1
     c60:	f9 8b       	std	Y+17, r31	; 0x11
	
	sys.state = STATE_JOG;
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
		out_bits0 ^= (1<<X_DIRECTION_BIT);
     c62:	90 e8       	ldi	r25, 0x80	; 128
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
		reverse_flag = 1;
	}
	if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
     c64:	82 ff       	sbrs	r24, 2
     c66:	09 c0       	rjmp	.+18     	; 0xc7a <jogging+0x220>
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
     c68:	10 e3       	ldi	r17, 0x30	; 48
     c6a:	19 27       	eor	r17, r25
		out_bits0 ^= (1<<X_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
		reverse_flag = 1;
	}
	if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
     c6c:	20 e2       	ldi	r18, 0x20	; 32
     c6e:	92 27       	eor	r25, r18
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
     c70:	21 e0       	ldi	r18, 0x01	; 1
     c72:	28 8f       	std	Y+24, r18	; 0x18
		reverse_flag = 1;
	}
	if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
     c74:	31 e0       	ldi	r19, 0x01	; 1
     c76:	39 8b       	std	Y+17, r19	; 0x11
     c78:	01 c0       	rjmp	.+2      	; 0xc7c <jogging+0x222>
	
	ADCSRA = ADCSRA_init | (1<<ADIF); //0x93, clear ADIF

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
     c7a:	18 8e       	std	Y+24, r1	; 0x18
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
	}
	if (jog_bits & (1<<JOGREV_Z_BIT)) { // Z reverse switch on
     c7c:	84 ff       	sbrs	r24, 4
     c7e:	06 c0       	rjmp	.+12     	; 0xc8c <jogging+0x232>
		out_bits0 ^= (1<<Z_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
     c80:	1c e0       	ldi	r17, 0x0C	; 12
     c82:	19 27       	eor	r17, r25
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
	}
	if (jog_bits & (1<<JOGREV_Z_BIT)) { // Z reverse switch on
		out_bits0 ^= (1<<Z_DIRECTION_BIT);
     c84:	28 e0       	ldi	r18, 0x08	; 8
     c86:	92 27       	eor	r25, r18
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
		// reverse_flag = 1; // positive Z dir!
		jog_select = 2;
     c88:	e2 e0       	ldi	r30, 0x02	; 2
     c8a:	e8 8f       	std	Y+24, r30	; 0x18
	}
	
	// check for forward switches
	if (jog_bits & (1<<JOGFWD_X_BIT)) { // X forward switch on
     c8c:	81 ff       	sbrs	r24, 1
     c8e:	02 c0       	rjmp	.+4      	; 0xc94 <jogging+0x23a>
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
     c90:	10 e4       	ldi	r17, 0x40	; 64
     c92:	19 27       	eor	r17, r25
	}
	if (jog_bits & (1<<JOGFWD_Y_BIT)) { // Y forward switch on
     c94:	83 ff       	sbrs	r24, 3
     c96:	04 c0       	rjmp	.+8      	; 0xca0 <jogging+0x246>
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
     c98:	10 e1       	ldi	r17, 0x10	; 16
     c9a:	19 27       	eor	r17, r25
		jog_select = 1;
     c9c:	f1 e0       	ldi	r31, 0x01	; 1
     c9e:	f8 8f       	std	Y+24, r31	; 0x18
	}
	if (jog_bits & (1<<JOGFWD_Z_BIT)) { // Z forward switch on
     ca0:	85 ff       	sbrs	r24, 5
     ca2:	06 c0       	rjmp	.+12     	; 0xcb0 <jogging+0x256>
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
     ca4:	14 e0       	ldi	r17, 0x04	; 4
     ca6:	19 27       	eor	r17, r25
		reverse_flag = 1; // positive Z dir!
		jog_select = 2;
     ca8:	22 e0       	ldi	r18, 0x02	; 2
     caa:	28 8f       	std	Y+24, r18	; 0x18
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		jog_select = 1;
	}
	if (jog_bits & (1<<JOGFWD_Z_BIT)) { // Z forward switch on
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
		reverse_flag = 1; // positive Z dir!
     cac:	31 e0       	ldi	r19, 0x01	; 1
     cae:	39 8b       	std	Y+17, r19	; 0x11
		jog_select = 2;
	}

	dest_step_rate = ADCH;    // set initial dest_step_rate according to analog input
     cb0:	20 91 79 00 	lds	r18, 0x0079
	dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	a7 e2       	ldi	r26, 0x27	; 39
     cb8:	bf e1       	ldi	r27, 0x1F	; 31
     cba:	0e 94 00 40 	call	0x8000	; 0x8000 <__umulhisi3>
     cbe:	2f ef       	ldi	r18, 0xFF	; 255
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	40 e0       	ldi	r20, 0x00	; 0
     cc4:	50 e0       	ldi	r21, 0x00	; 0
     cc6:	0e 94 d8 3f 	call	0x7fb0	; 0x7fb0 <__udivmodsi4>
     cca:	49 01       	movw	r8, r18
     ccc:	5a 01       	movw	r10, r20
     cce:	89 e1       	ldi	r24, 0x19	; 25
     cd0:	88 0e       	add	r8, r24
     cd2:	91 1c       	adc	r9, r1
     cd4:	a1 1c       	adc	r10, r1
     cd6:	b1 1c       	adc	r11, r1
	step_rate = JOG_MIN_SPEED;   // set initial step rate
	jog_exit = 0;
	while (!(ADCSRA && (1<<ADIF))) {} // wait until ADIF bit is set
     cd8:	ea e7       	ldi	r30, 0x7A	; 122
     cda:	f0 e0       	ldi	r31, 0x00	; 0
     cdc:	80 81       	ld	r24, Z
     cde:	88 23       	and	r24, r24
     ce0:	e9 f3       	breq	.-6      	; 0xcdc <jogging+0x282>
	ADCSRA = ADCSRA_init; // exit conversion
     ce2:	83 e8       	ldi	r24, 0x83	; 131
     ce4:	80 93 7a 00 	sts	0x007A, r24
	
	st_wake_up();
     ce8:	0e 94 2d 1b 	call	0x365a	; 0x365a <st_wake_up>
	
	
	// prepare direction with small delay, direction settle time
	STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits0 & STEP_MASK);
     cec:	8b b1       	in	r24, 0x0b	; 11
     cee:	8b 7a       	andi	r24, 0xAB	; 171
     cf0:	8b b9       	out	0x0b, r24	; 11
	delay_us(10);
     cf2:	6a e0       	ldi	r22, 0x0A	; 10
     cf4:	70 e0       	ldi	r23, 0x00	; 0
     cf6:	80 e0       	ldi	r24, 0x00	; 0
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	0e 94 e4 2e 	call	0x5dc8	; 0x5dc8 <delay_us>
	jog_bits_old = jog_bits;
	i = 0;  // now index for sending position data
	
	// Report machine position;
	if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
     cfe:	80 91 3c 09 	lds	r24, 0x093C
     d02:	80 ff       	sbrs	r24, 0
     d04:	20 c0       	rjmp	.+64     	; 0xd46 <jogging+0x2ec>
		mm_per_step = 1/(settings.steps_per_mm[jog_select] * INCH_PER_MM);
     d06:	98 8d       	ldd	r25, Y+24	; 0x18
     d08:	e9 2f       	mov	r30, r25
     d0a:	f0 e0       	ldi	r31, 0x00	; 0
     d0c:	ee 0f       	add	r30, r30
     d0e:	ff 1f       	adc	r31, r31
     d10:	ee 0f       	add	r30, r30
     d12:	ff 1f       	adc	r31, r31
     d14:	e1 50       	subi	r30, 0x01	; 1
     d16:	f7 4f       	sbci	r31, 0xF7	; 247
     d18:	2b e8       	ldi	r18, 0x8B	; 139
     d1a:	32 e4       	ldi	r19, 0x42	; 66
     d1c:	41 e2       	ldi	r20, 0x21	; 33
     d1e:	5d e3       	ldi	r21, 0x3D	; 61
     d20:	60 81       	ld	r22, Z
     d22:	71 81       	ldd	r23, Z+1	; 0x01
     d24:	82 81       	ldd	r24, Z+2	; 0x02
     d26:	93 81       	ldd	r25, Z+3	; 0x03
     d28:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
     d2c:	9b 01       	movw	r18, r22
     d2e:	ac 01       	movw	r20, r24
     d30:	60 e0       	ldi	r22, 0x00	; 0
     d32:	70 e0       	ldi	r23, 0x00	; 0
     d34:	80 e8       	ldi	r24, 0x80	; 128
     d36:	9f e3       	ldi	r25, 0x3F	; 63
     d38:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
     d3c:	6b 8b       	std	Y+19, r22	; 0x13
     d3e:	7c 8b       	std	Y+20, r23	; 0x14
     d40:	8d 8b       	std	Y+21, r24	; 0x15
     d42:	9e 8b       	std	Y+22, r25	; 0x16
     d44:	17 c0       	rjmp	.+46     	; 0xd74 <jogging+0x31a>
		} else {
		mm_per_step = 1/settings.steps_per_mm[jog_select];
     d46:	28 8d       	ldd	r18, Y+24	; 0x18
     d48:	e2 2f       	mov	r30, r18
     d4a:	f0 e0       	ldi	r31, 0x00	; 0
     d4c:	ee 0f       	add	r30, r30
     d4e:	ff 1f       	adc	r31, r31
     d50:	ee 0f       	add	r30, r30
     d52:	ff 1f       	adc	r31, r31
     d54:	e1 50       	subi	r30, 0x01	; 1
     d56:	f7 4f       	sbci	r31, 0xF7	; 247
     d58:	20 81       	ld	r18, Z
     d5a:	31 81       	ldd	r19, Z+1	; 0x01
     d5c:	42 81       	ldd	r20, Z+2	; 0x02
     d5e:	53 81       	ldd	r21, Z+3	; 0x03
     d60:	60 e0       	ldi	r22, 0x00	; 0
     d62:	70 e0       	ldi	r23, 0x00	; 0
     d64:	80 e8       	ldi	r24, 0x80	; 128
     d66:	9f e3       	ldi	r25, 0x3F	; 63
     d68:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
     d6c:	6b 8b       	std	Y+19, r22	; 0x13
     d6e:	7c 8b       	std	Y+20, r23	; 0x14
     d70:	8d 8b       	std	Y+21, r24	; 0x15
     d72:	9e 8b       	std	Y+22, r25	; 0x16
	}
	
	work_position = sys.position[jog_select] / mm_per_step;
     d74:	98 8d       	ldd	r25, Y+24	; 0x18
     d76:	89 2f       	mov	r24, r25
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	9e 87       	std	Y+14, r25	; 0x0e
     d7c:	8d 87       	std	Y+13, r24	; 0x0d
     d7e:	fc 01       	movw	r30, r24
     d80:	ee 0f       	add	r30, r30
     d82:	ff 1f       	adc	r31, r31
     d84:	ee 0f       	add	r30, r30
     d86:	ff 1f       	adc	r31, r31
     d88:	e9 59       	subi	r30, 0x99	; 153
     d8a:	f8 4f       	sbci	r31, 0xF8	; 248
     d8c:	65 81       	ldd	r22, Z+5	; 0x05
     d8e:	76 81       	ldd	r23, Z+6	; 0x06
     d90:	87 81       	ldd	r24, Z+7	; 0x07
     d92:	90 85       	ldd	r25, Z+8	; 0x08
     d94:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <__floatsisf>
     d98:	2b 89       	ldd	r18, Y+19	; 0x13
     d9a:	3c 89       	ldd	r19, Y+20	; 0x14
     d9c:	4d 89       	ldd	r20, Y+21	; 0x15
     d9e:	5e 89       	ldd	r21, Y+22	; 0x16
     da0:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
     da4:	2b 01       	movw	r4, r22
     da6:	3c 01       	movw	r6, r24
		jog_select = 2;
	}

	dest_step_rate = ADCH;    // set initial dest_step_rate according to analog input
	dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
	step_rate = JOG_MIN_SPEED;   // set initial step rate
     da8:	0f 2e       	mov	r0, r31
     daa:	f9 e1       	ldi	r31, 0x19	; 25
     dac:	cf 2e       	mov	r12, r31
     dae:	d1 2c       	mov	r13, r1
     db0:	e1 2c       	mov	r14, r1
     db2:	f1 2c       	mov	r15, r1
     db4:	f0 2d       	mov	r31, r0
	//work_position = print_position[jog_select];
	
	for(;;) { // repeat until button/joystick released
		//    report_realtime_status(); // benötigt viel Zeit!
		
		ADCSRA = ADCSRA_init | (1<<ADIF); //0x93, clear ADIF
     db6:	0f 2e       	mov	r0, r31
     db8:	fa e7       	ldi	r31, 0x7A	; 122
     dba:	2f 2e       	mov	r2, r31
     dbc:	31 2c       	mov	r3, r1
     dbe:	f0 2d       	mov	r31, r0
		}
		

		ADCSRA = ADCSRA_init | (1<<ADSC); //0xC3; start ADC conversion
		// Both direction and step pins appropriately inverted and set. Perform one step
		STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits & STEP_MASK);
     dc0:	01 2f       	mov	r16, r17
     dc2:	04 75       	andi	r16, 0x54	; 84
		if (reverse_flag) {
			sys.position[jog_select]--;       // sys.position ist in Steps!
			work_position -= mm_per_step;
		}
		else {
			sys.position[jog_select]++;
     dc4:	8d 85       	ldd	r24, Y+13	; 0x0d
     dc6:	9e 85       	ldd	r25, Y+14	; 0x0e
     dc8:	88 0f       	add	r24, r24
     dca:	99 1f       	adc	r25, r25
     dcc:	88 0f       	add	r24, r24
     dce:	99 1f       	adc	r25, r25
     dd0:	fc 01       	movw	r30, r24
     dd2:	e4 59       	subi	r30, 0x94	; 148
     dd4:	f8 4f       	sbci	r31, 0xF8	; 248
     dd6:	fe 87       	std	Y+14, r31	; 0x0e
     dd8:	ed 87       	std	Y+13, r30	; 0x0d
		
		if (sys.rt_exec_state & EXEC_STATUS_REPORT) {
			if (step_delay > 250) {
				// status report requested, print short msg only
				printPgmString(PSTR("Jog"));
				serial_write(88 + jog_select); // 88 = X + 1 = Y etc.
     dda:	f8 8d       	ldd	r31, Y+24	; 0x18
     ddc:	f8 5a       	subi	r31, 0xA8	; 168
     dde:	f8 8f       	std	Y+24, r31	; 0x18
		delay_us(step_delay);
		
		while (!(ADCSRA && (1<<ADIF))) {} // wait until ADIF bit is set
		ADCSRA = ADCSRA_init;     // exit conversion
		dest_step_rate = ADCH;    // set next dest_step_rate according to analog input
		dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     de0:	a5 01       	movw	r20, r10
     de2:	94 01       	movw	r18, r8
     de4:	0f 8b       	std	Y+23, r16	; 0x17
     de6:	0d 85       	ldd	r16, Y+13	; 0x0d
     de8:	1e 85       	ldd	r17, Y+14	; 0x0e
	//work_position = print_position[jog_select];
	
	for(;;) { // repeat until button/joystick released
		//    report_realtime_status(); // benötigt viel Zeit!
		
		ADCSRA = ADCSRA_init | (1<<ADIF); //0x93, clear ADIF
     dea:	83 e9       	ldi	r24, 0x93	; 147
     dec:	f1 01       	movw	r30, r2
     dee:	80 83       	st	Z, r24

		// Get limit pin state
		uint8_t bits = LIMIT_PIN;
     df0:	83 b1       	in	r24, 0x03	; 3
		if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { bits ^= LIMIT_MASK; }
     df2:	ec e3       	ldi	r30, 0x3C	; 60
     df4:	f9 e0       	ldi	r31, 0x09	; 9
     df6:	90 81       	ld	r25, Z
     df8:	96 fd       	sbrc	r25, 6
     dfa:	02 c0       	rjmp	.+4      	; 0xe00 <jogging+0x3a6>
     dfc:	9e e0       	ldi	r25, 0x0E	; 14
     dfe:	89 27       	eor	r24, r25
		if (bit_istrue(bits,LIMIT_MASK) && reverse_flag) { jog_exit = 1; } // immediate stop on any switch
     e00:	8e 70       	andi	r24, 0x0E	; 14
     e02:	39 f0       	breq	.+14     	; 0xe12 <jogging+0x3b8>
     e04:	bb 24       	eor	r11, r11
     e06:	b3 94       	inc	r11
     e08:	89 88       	ldd	r8, Y+17	; 0x11
     e0a:	81 10       	cpse	r8, r1
     e0c:	03 c0       	rjmp	.+6      	; 0xe14 <jogging+0x3ba>
     e0e:	b1 2c       	mov	r11, r1
     e10:	01 c0       	rjmp	.+2      	; 0xe14 <jogging+0x3ba>
     e12:	b1 2c       	mov	r11, r1
		
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     e14:	80 b1       	in	r24, 0x00	; 0
     e16:	80 95       	com	r24
     e18:	8f 77       	andi	r24, 0x7F	; 127
		if (jog_bits == jog_bits_old) { // nothing changed
     e1a:	9a 88       	ldd	r9, Y+18	; 0x12
     e1c:	98 12       	cpse	r9, r24
     e1e:	1f c0       	rjmp	.+62     	; 0xe5e <jogging+0x404>
			if (step_rate < (dest_step_rate - 5)) { // Hysteresis for A/D-conversion
     e20:	da 01       	movw	r26, r20
     e22:	c9 01       	movw	r24, r18
     e24:	05 97       	sbiw	r24, 0x05	; 5
     e26:	a1 09       	sbc	r26, r1
     e28:	b1 09       	sbc	r27, r1
     e2a:	c8 16       	cp	r12, r24
     e2c:	d9 06       	cpc	r13, r25
     e2e:	ea 06       	cpc	r14, r26
     e30:	fb 06       	cpc	r15, r27
     e32:	28 f4       	brcc	.+10     	; 0xe3e <jogging+0x3e4>
				step_rate += JOG_RAMP; // accelerate
     e34:	85 e0       	ldi	r24, 0x05	; 5
     e36:	c8 0e       	add	r12, r24
     e38:	d1 1c       	adc	r13, r1
     e3a:	e1 1c       	adc	r14, r1
     e3c:	f1 1c       	adc	r15, r1
			}
			if (step_rate > (dest_step_rate + 5)) { // Hysteresis for A/D-conversion
     e3e:	da 01       	movw	r26, r20
     e40:	c9 01       	movw	r24, r18
     e42:	05 96       	adiw	r24, 0x05	; 5
     e44:	a1 1d       	adc	r26, r1
     e46:	b1 1d       	adc	r27, r1
     e48:	8c 15       	cp	r24, r12
     e4a:	9d 05       	cpc	r25, r13
     e4c:	ae 05       	cpc	r26, r14
     e4e:	bf 05       	cpc	r27, r15
     e50:	f8 f4       	brcc	.+62     	; 0xe90 <jogging+0x436>
				step_rate -= JOG_RAMP; // brake
     e52:	95 e0       	ldi	r25, 0x05	; 5
     e54:	c9 1a       	sub	r12, r25
     e56:	d1 08       	sbc	r13, r1
     e58:	e1 08       	sbc	r14, r1
     e5a:	f1 08       	sbc	r15, r1
     e5c:	19 c0       	rjmp	.+50     	; 0xe90 <jogging+0x436>
			}
		}
		else {
			if (step_rate > (JOG_MIN_SPEED*2)) {  // switch change happened, fast brake to complete stop
     e5e:	e3 e3       	ldi	r30, 0x33	; 51
     e60:	ce 16       	cp	r12, r30
     e62:	d1 04       	cpc	r13, r1
     e64:	e1 04       	cpc	r14, r1
     e66:	f1 04       	cpc	r15, r1
     e68:	d0 f0       	brcs	.+52     	; 0xe9e <jogging+0x444>
				step_rate = ((step_rate * 99) / 100) - 5;
     e6a:	a3 e6       	ldi	r26, 0x63	; 99
     e6c:	b0 e0       	ldi	r27, 0x00	; 0
     e6e:	a7 01       	movw	r20, r14
     e70:	96 01       	movw	r18, r12
     e72:	0e 94 0f 40 	call	0x801e	; 0x801e <__muluhisi3>
     e76:	24 e6       	ldi	r18, 0x64	; 100
     e78:	30 e0       	ldi	r19, 0x00	; 0
     e7a:	40 e0       	ldi	r20, 0x00	; 0
     e7c:	50 e0       	ldi	r21, 0x00	; 0
     e7e:	0e 94 d8 3f 	call	0x7fb0	; 0x7fb0 <__udivmodsi4>
     e82:	69 01       	movw	r12, r18
     e84:	7a 01       	movw	r14, r20
     e86:	f5 e0       	ldi	r31, 0x05	; 5
     e88:	cf 1a       	sub	r12, r31
     e8a:	d1 08       	sbc	r13, r1
     e8c:	e1 08       	sbc	r14, r1
     e8e:	f1 08       	sbc	r15, r1
			else { jog_exit = 1; } // finished to stop and exit
		}
		
		
		// stop and exit if done
		if (jog_exit || (sys.rt_exec_state & EXEC_RESET)) {
     e90:	b1 10       	cpse	r11, r1
     e92:	05 c0       	rjmp	.+10     	; 0xe9e <jogging+0x444>
     e94:	ea e6       	ldi	r30, 0x6A	; 106
     e96:	f7 e0       	ldi	r31, 0x07	; 7
     e98:	80 81       	ld	r24, Z
     e9a:	84 ff       	sbrs	r24, 4
     e9c:	0e c0       	rjmp	.+28     	; 0xeba <jogging+0x460>
			st_go_idle();
     e9e:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <st_go_idle>
			printPgmString(PSTR("idle from jog"));
     ea2:	8b e8       	ldi	r24, 0x8B	; 139
     ea4:	92 e0       	ldi	r25, 0x02	; 2
     ea6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
			sys.state = last_sys_state;
     eaa:	89 8c       	ldd	r8, Y+25	; 0x19
     eac:	80 92 68 07 	sts	0x0768, r8
			plan_sync_position();
     eb0:	0e 94 c7 2d 	call	0x5b8e	; 0x5b8e <plan_sync_position>
			gc_sync_position(); // Syncs all internal position vectors to the current system position.
     eb4:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <gc_sync_position>
			return;
     eb8:	ac c0       	rjmp	.+344    	; 0x1012 <jogging+0x5b8>
		}
		

		ADCSRA = ADCSRA_init | (1<<ADSC); //0xC3; start ADC conversion
     eba:	83 ec       	ldi	r24, 0xC3	; 195
     ebc:	f1 01       	movw	r30, r2
     ebe:	80 83       	st	Z, r24
		// Both direction and step pins appropriately inverted and set. Perform one step
		STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits & STEP_MASK);
     ec0:	8b b1       	in	r24, 0x0b	; 11
     ec2:	8b 7a       	andi	r24, 0xAB	; 171
     ec4:	8f 88       	ldd	r8, Y+23	; 0x17
     ec6:	88 29       	or	r24, r8
     ec8:	8b b9       	out	0x0b, r24	; 11
		delay_us(settings.pulse_microseconds/2);
     eca:	ef e2       	ldi	r30, 0x2F	; 47
     ecc:	f9 e0       	ldi	r31, 0x09	; 9
     ece:	60 81       	ld	r22, Z
     ed0:	66 95       	lsr	r22
     ed2:	70 e0       	ldi	r23, 0x00	; 0
     ed4:	80 e0       	ldi	r24, 0x00	; 0
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	0e 94 e4 2e 	call	0x5dc8	; 0x5dc8 <delay_us>
		step_delay = (1000000/step_rate) - settings.pulse_microseconds - 100; // 100 = fixed value for loop time
     edc:	60 e4       	ldi	r22, 0x40	; 64
     ede:	72 e4       	ldi	r23, 0x42	; 66
     ee0:	8f e0       	ldi	r24, 0x0F	; 15
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	a7 01       	movw	r20, r14
     ee6:	96 01       	movw	r18, r12
     ee8:	0e 94 d8 3f 	call	0x7fb0	; 0x7fb0 <__udivmodsi4>
     eec:	ef e2       	ldi	r30, 0x2F	; 47
     eee:	f9 e0       	ldi	r31, 0x09	; 9
     ef0:	80 81       	ld	r24, Z
     ef2:	49 01       	movw	r8, r18
     ef4:	5a 01       	movw	r10, r20
     ef6:	88 1a       	sub	r8, r24
     ef8:	91 08       	sbc	r9, r1
     efa:	a1 08       	sbc	r10, r1
     efc:	b1 08       	sbc	r11, r1
     efe:	8d 86       	std	Y+13, r8	; 0x0d
     f00:	9e 86       	std	Y+14, r9	; 0x0e
     f02:	af 86       	std	Y+15, r10	; 0x0f
     f04:	b8 8a       	std	Y+16, r11	; 0x10
     f06:	24 e6       	ldi	r18, 0x64	; 100
     f08:	82 1a       	sub	r8, r18
     f0a:	91 08       	sbc	r9, r1
     f0c:	a1 08       	sbc	r10, r1
     f0e:	b1 08       	sbc	r11, r1
		STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits0 & STEP_MASK);
     f10:	8b b1       	in	r24, 0x0b	; 11
     f12:	8b 7a       	andi	r24, 0xAB	; 171
     f14:	8b b9       	out	0x0b, r24	; 11
		
	
		if (reverse_flag) {
     f16:	39 89       	ldd	r19, Y+17	; 0x11
     f18:	33 23       	and	r19, r19
     f1a:	b9 f0       	breq	.+46     	; 0xf4a <jogging+0x4f0>
			sys.position[jog_select]--;       // sys.position ist in Steps!
     f1c:	f8 01       	movw	r30, r16
     f1e:	80 81       	ld	r24, Z
     f20:	91 81       	ldd	r25, Z+1	; 0x01
     f22:	a2 81       	ldd	r26, Z+2	; 0x02
     f24:	b3 81       	ldd	r27, Z+3	; 0x03
     f26:	01 97       	sbiw	r24, 0x01	; 1
     f28:	a1 09       	sbc	r26, r1
     f2a:	b1 09       	sbc	r27, r1
     f2c:	80 83       	st	Z, r24
     f2e:	91 83       	std	Z+1, r25	; 0x01
     f30:	a2 83       	std	Z+2, r26	; 0x02
     f32:	b3 83       	std	Z+3, r27	; 0x03
			work_position -= mm_per_step;
     f34:	2b 89       	ldd	r18, Y+19	; 0x13
     f36:	3c 89       	ldd	r19, Y+20	; 0x14
     f38:	4d 89       	ldd	r20, Y+21	; 0x15
     f3a:	5e 89       	ldd	r21, Y+22	; 0x16
     f3c:	c3 01       	movw	r24, r6
     f3e:	b2 01       	movw	r22, r4
     f40:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
     f44:	2b 01       	movw	r4, r22
     f46:	3c 01       	movw	r6, r24
     f48:	16 c0       	rjmp	.+44     	; 0xf76 <jogging+0x51c>
		}
		else {
			sys.position[jog_select]++;
     f4a:	f8 01       	movw	r30, r16
     f4c:	80 81       	ld	r24, Z
     f4e:	91 81       	ldd	r25, Z+1	; 0x01
     f50:	a2 81       	ldd	r26, Z+2	; 0x02
     f52:	b3 81       	ldd	r27, Z+3	; 0x03
     f54:	01 96       	adiw	r24, 0x01	; 1
     f56:	a1 1d       	adc	r26, r1
     f58:	b1 1d       	adc	r27, r1
     f5a:	80 83       	st	Z, r24
     f5c:	91 83       	std	Z+1, r25	; 0x01
     f5e:	a2 83       	std	Z+2, r26	; 0x02
     f60:	b3 83       	std	Z+3, r27	; 0x03
			work_position += mm_per_step;    // relative print_position in mm since last report
     f62:	2b 89       	ldd	r18, Y+19	; 0x13
     f64:	3c 89       	ldd	r19, Y+20	; 0x14
     f66:	4d 89       	ldd	r20, Y+21	; 0x15
     f68:	5e 89       	ldd	r21, Y+22	; 0x16
     f6a:	c3 01       	movw	r24, r6
     f6c:	b2 01       	movw	r22, r4
     f6e:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
     f72:	2b 01       	movw	r4, r22
     f74:	3c 01       	movw	r6, r24
		}
		
		if (sys.rt_exec_state & EXEC_STATUS_REPORT) {
     f76:	ea e6       	ldi	r30, 0x6A	; 106
     f78:	f7 e0       	ldi	r31, 0x07	; 7
     f7a:	80 81       	ld	r24, Z
     f7c:	80 ff       	sbrs	r24, 0
     f7e:	2d c0       	rjmp	.+90     	; 0xfda <jogging+0x580>
			if (step_delay > 250) {
     f80:	fb ef       	ldi	r31, 0xFB	; 251
     f82:	8f 16       	cp	r8, r31
     f84:	91 04       	cpc	r9, r1
     f86:	a1 04       	cpc	r10, r1
     f88:	b1 04       	cpc	r11, r1
     f8a:	00 f1       	brcs	.+64     	; 0xfcc <jogging+0x572>
				// status report requested, print short msg only
				printPgmString(PSTR("Jog"));
     f8c:	87 e8       	ldi	r24, 0x87	; 135
     f8e:	92 e0       	ldi	r25, 0x02	; 2
     f90:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
				serial_write(88 + jog_select); // 88 = X + 1 = Y etc.
     f94:	88 8d       	ldd	r24, Y+24	; 0x18
     f96:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
				serial_write(44);
     f9a:	8c e2       	ldi	r24, 0x2C	; 44
     f9c:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
				printFloat(work_position, 3);
     fa0:	43 e0       	ldi	r20, 0x03	; 3
     fa2:	c3 01       	movw	r24, r6
     fa4:	b2 01       	movw	r22, r4
     fa6:	0e 94 49 33 	call	0x6692	; 0x6692 <printFloat>
				serial_write(13);
     faa:	8d e0       	ldi	r24, 0x0D	; 13
     fac:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
				serial_write(10);
     fb0:	8a e0       	ldi	r24, 0x0A	; 10
     fb2:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>

				step_delay -= 250;
     fb6:	8d 84       	ldd	r8, Y+13	; 0x0d
     fb8:	9e 84       	ldd	r9, Y+14	; 0x0e
     fba:	af 84       	ldd	r10, Y+15	; 0x0f
     fbc:	b8 88       	ldd	r11, Y+16	; 0x10
     fbe:	2e e5       	ldi	r18, 0x5E	; 94
     fc0:	82 1a       	sub	r8, r18
     fc2:	21 e0       	ldi	r18, 0x01	; 1
     fc4:	92 0a       	sbc	r9, r18
     fc6:	a1 08       	sbc	r10, r1
     fc8:	b1 08       	sbc	r11, r1
     fca:	04 c0       	rjmp	.+8      	; 0xfd4 <jogging+0x57a>
			}
			else
			{
				printPgmString(PSTR("JogF\r\n"));
     fcc:	80 e8       	ldi	r24, 0x80	; 128
     fce:	92 e0       	ldi	r25, 0x02	; 2
     fd0:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
			}
			sys.rt_exec_state = 0;
     fd4:	ea e6       	ldi	r30, 0x6A	; 106
     fd6:	f7 e0       	ldi	r31, 0x07	; 7
     fd8:	10 82       	st	Z, r1
		}
		
		delay_us(step_delay);
     fda:	c5 01       	movw	r24, r10
     fdc:	b4 01       	movw	r22, r8
     fde:	0e 94 e4 2e 	call	0x5dc8	; 0x5dc8 <delay_us>
		
		while (!(ADCSRA && (1<<ADIF))) {} // wait until ADIF bit is set
     fe2:	f1 01       	movw	r30, r2
     fe4:	80 81       	ld	r24, Z
     fe6:	88 23       	and	r24, r24
     fe8:	e1 f3       	breq	.-8      	; 0xfe2 <jogging+0x588>
		ADCSRA = ADCSRA_init;     // exit conversion
     fea:	83 e8       	ldi	r24, 0x83	; 131
     fec:	80 83       	st	Z, r24
		dest_step_rate = ADCH;    // set next dest_step_rate according to analog input
     fee:	20 91 79 00 	lds	r18, 0x0079
		dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     ff2:	30 e0       	ldi	r19, 0x00	; 0
     ff4:	a7 e2       	ldi	r26, 0x27	; 39
     ff6:	bf e1       	ldi	r27, 0x1F	; 31
     ff8:	0e 94 00 40 	call	0x8000	; 0x8000 <__umulhisi3>
     ffc:	2f ef       	ldi	r18, 0xFF	; 255
     ffe:	30 e0       	ldi	r19, 0x00	; 0
    1000:	40 e0       	ldi	r20, 0x00	; 0
    1002:	50 e0       	ldi	r21, 0x00	; 0
    1004:	0e 94 d8 3f 	call	0x7fb0	; 0x7fb0 <__udivmodsi4>
    1008:	27 5e       	subi	r18, 0xE7	; 231
    100a:	3f 4f       	sbci	r19, 0xFF	; 255
    100c:	4f 4f       	sbci	r20, 0xFF	; 255
    100e:	5f 4f       	sbci	r21, 0xFF	; 255

	}
    1010:	ec ce       	rjmp	.-552    	; 0xdea <jogging+0x390>
    1012:	69 96       	adiw	r28, 0x19	; 25
    1014:	0f b6       	in	r0, 0x3f	; 63
    1016:	f8 94       	cli
    1018:	de bf       	out	0x3e, r29	; 62
    101a:	0f be       	out	0x3f, r0	; 63
    101c:	cd bf       	out	0x3d, r28	; 61
    101e:	df 91       	pop	r29
    1020:	cf 91       	pop	r28
    1022:	1f 91       	pop	r17
    1024:	0f 91       	pop	r16
    1026:	ff 90       	pop	r15
    1028:	ef 90       	pop	r14
    102a:	df 90       	pop	r13
    102c:	cf 90       	pop	r12
    102e:	bf 90       	pop	r11
    1030:	af 90       	pop	r10
    1032:	9f 90       	pop	r9
    1034:	8f 90       	pop	r8
    1036:	7f 90       	pop	r7
    1038:	6f 90       	pop	r6
    103a:	5f 90       	pop	r5
    103c:	4f 90       	pop	r4
    103e:	3f 90       	pop	r3
    1040:	2f 90       	pop	r2
    1042:	08 95       	ret

00001044 <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
    1044:	0e 94 03 18 	call	0x3006	; 0x3006 <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
    1048:	0e 94 d1 28 	call	0x51a2	; 0x51a2 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
    104c:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
    1050:	0e 94 a6 39 	call	0x734c	; 0x734c <system_init>
  
  memset(&sys, 0, sizeof(sys));  // Clear all system variables
    1054:	e7 e6       	ldi	r30, 0x67	; 103
    1056:	f7 e0       	ldi	r31, 0x07	; 7
    1058:	80 e2       	ldi	r24, 0x20	; 32
    105a:	df 01       	movw	r26, r30
    105c:	1d 92       	st	X+, r1
    105e:	8a 95       	dec	r24
    1060:	e9 f7       	brne	.-6      	; 0x105c <main+0x18>
  sys.abort = true;   // Set abort to complete initialization
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	80 83       	st	Z, r24
  sei(); // Enable interrupts
    1066:	78 94       	sei
    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    gc_sync_position();

    // Reset system variables.
    sys.abort = false;
    1068:	6f 01       	movw	r12, r30
    sys.rt_exec_state = 0;
    106a:	0f 2e       	mov	r0, r31
    106c:	fa e6       	ldi	r31, 0x6A	; 106
    106e:	ef 2e       	mov	r14, r31
    1070:	f7 e0       	ldi	r31, 0x07	; 7
    1072:	ff 2e       	mov	r15, r31
    1074:	f0 2d       	mov	r31, r0
    sys.rt_exec_alarm = 0;
    1076:	0b e6       	ldi	r16, 0x6B	; 107
    1078:	17 e0       	ldi	r17, 0x07	; 7
    sys.suspend = false;
    107a:	c9 e6       	ldi	r28, 0x69	; 105
    107c:	d7 e0       	ldi	r29, 0x07	; 7

    // TODO: Separate configure task that require interrupts to be disabled, especially upon
    // a system abort and ensuring any active interrupts are cleanly reset.
  
    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
    107e:	0e 94 df 18 	call	0x31be	; 0x31be <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
    1082:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <gc_init>
    spindle_init();
    1086:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <spindle_init>
    coolant_init();
    108a:	0e 94 e0 17 	call	0x2fc0	; 0x2fc0 <coolant_init>
    limits_init(); 
    108e:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <limits_init>
    probe_init();
    1092:	0e 94 2e 34 	call	0x685c	; 0x685c <probe_init>
    plan_reset(); // Clear block buffer and planner variables
    1096:	0e 94 55 2a 	call	0x54aa	; 0x54aa <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
    109a:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <st_reset>
	jog_init();
    109e:	0e 94 03 05 	call	0xa06	; 0xa06 <jog_init>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    10a2:	0e 94 c7 2d 	call	0x5b8e	; 0x5b8e <plan_sync_position>
    gc_sync_position();
    10a6:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <gc_sync_position>

    // Reset system variables.
    sys.abort = false;
    10aa:	f6 01       	movw	r30, r12
    10ac:	10 82       	st	Z, r1
    sys.rt_exec_state = 0;
    10ae:	d7 01       	movw	r26, r14
    10b0:	1c 92       	st	X, r1
    sys.rt_exec_alarm = 0;
    10b2:	f8 01       	movw	r30, r16
    10b4:	10 82       	st	Z, r1
    sys.suspend = false;
    10b6:	18 82       	st	Y, r1
          
    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
    10b8:	0e 94 e3 1a 	call	0x35c6	; 0x35c6 <protocol_main_loop>
    10bc:	e0 cf       	rjmp	.-64     	; 0x107e <main+0x3a>

000010be <mc_line>:
#ifdef USE_LINE_NUMBERS
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{
    10be:	bf 92       	push	r11
    10c0:	cf 92       	push	r12
    10c2:	df 92       	push	r13
    10c4:	ef 92       	push	r14
    10c6:	ff 92       	push	r15
    10c8:	0f 93       	push	r16
    10ca:	1f 93       	push	r17
    10cc:	cf 93       	push	r28
    10ce:	df 93       	push	r29
    10d0:	8c 01       	movw	r16, r24
    10d2:	6a 01       	movw	r12, r20
    10d4:	7b 01       	movw	r14, r22
    10d6:	b2 2e       	mov	r11, r18
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) { limits_soft_check(target); }    
    10d8:	80 91 3c 09 	lds	r24, 0x093C
    10dc:	85 ff       	sbrs	r24, 5
    10de:	03 c0       	rjmp	.+6      	; 0x10e6 <mc_line+0x28>
    10e0:	c8 01       	movw	r24, r16
    10e2:	0e 94 57 32 	call	0x64ae	; 0x64ae <limits_soft_check>
      
  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
    10e6:	80 91 68 07 	lds	r24, 0x0768
    10ea:	82 30       	cpi	r24, 0x02	; 2
    10ec:	a1 f0       	breq	.+40     	; 0x1116 <__stack+0x17>

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
    10ee:	c7 e6       	ldi	r28, 0x67	; 103
    10f0:	d7 e0       	ldi	r29, 0x07	; 7
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    10f2:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
    10f6:	88 81       	ld	r24, Y
    10f8:	81 11       	cpse	r24, r1
    10fa:	0d c0       	rjmp	.+26     	; 0x1116 <__stack+0x17>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
    10fc:	0e 94 a5 2a 	call	0x554a	; 0x554a <plan_check_full_buffer>
    1100:	88 23       	and	r24, r24
    1102:	19 f0       	breq	.+6      	; 0x110a <__stack+0xb>
    1104:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
    1108:	f4 cf       	rjmp	.-24     	; 0x10f2 <mc_line+0x34>

  // Plan and queue motion into planner buffer
  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    plan_buffer_line(target, feed_rate, invert_feed_rate);
    110a:	2b 2d       	mov	r18, r11
    110c:	b7 01       	movw	r22, r14
    110e:	a6 01       	movw	r20, r12
    1110:	c8 01       	movw	r24, r16
    1112:	0e 94 ad 2a 	call	0x555a	; 0x555a <plan_buffer_line>
  #endif
}
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	ff 90       	pop	r15
    1120:	ef 90       	pop	r14
    1122:	df 90       	pop	r13
    1124:	cf 90       	pop	r12
    1126:	bf 90       	pop	r11
    1128:	08 95       	ret

0000112a <mc_arc>:
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc, int32_t line_number)
#else
  void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate,
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
#endif
{
    112a:	2f 92       	push	r2
    112c:	3f 92       	push	r3
    112e:	4f 92       	push	r4
    1130:	5f 92       	push	r5
    1132:	6f 92       	push	r6
    1134:	7f 92       	push	r7
    1136:	8f 92       	push	r8
    1138:	9f 92       	push	r9
    113a:	af 92       	push	r10
    113c:	bf 92       	push	r11
    113e:	cf 92       	push	r12
    1140:	df 92       	push	r13
    1142:	ef 92       	push	r14
    1144:	ff 92       	push	r15
    1146:	0f 93       	push	r16
    1148:	1f 93       	push	r17
    114a:	cf 93       	push	r28
    114c:	df 93       	push	r29
    114e:	cd b7       	in	r28, 0x3d	; 61
    1150:	de b7       	in	r29, 0x3e	; 62
    1152:	e9 97       	sbiw	r28, 0x39	; 57
    1154:	0f b6       	in	r0, 0x3f	; 63
    1156:	f8 94       	cli
    1158:	de bf       	out	0x3e, r29	; 62
    115a:	0f be       	out	0x3f, r0	; 63
    115c:	cd bf       	out	0x3d, r28	; 61
    115e:	9a 8b       	std	Y+18, r25	; 0x12
    1160:	89 8b       	std	Y+17, r24	; 0x11
    1162:	79 af       	std	Y+57, r23	; 0x39
    1164:	68 af       	std	Y+56, r22	; 0x38
    1166:	3a 01       	movw	r6, r20
    1168:	09 87       	std	Y+9, r16	; 0x09
    116a:	1a 87       	std	Y+10, r17	; 0x0a
    116c:	2b 87       	std	Y+11, r18	; 0x0b
    116e:	3c 87       	std	Y+12, r19	; 0x0c
    1170:	ab 8a       	std	Y+19, r10	; 0x13
  float center_axis0 = position[axis_0] + offset[axis_0];
    1172:	48 2c       	mov	r4, r8
    1174:	51 2c       	mov	r5, r1
    1176:	12 01       	movw	r2, r4
    1178:	22 0c       	add	r2, r2
    117a:	33 1c       	adc	r3, r3
    117c:	22 0c       	add	r2, r2
    117e:	33 1c       	adc	r3, r3
    1180:	82 0d       	add	r24, r2
    1182:	93 1d       	adc	r25, r3
    1184:	9d 8b       	std	Y+21, r25	; 0x15
    1186:	8c 8b       	std	Y+20, r24	; 0x14
    1188:	9a 01       	movw	r18, r20
    118a:	22 0d       	add	r18, r2
    118c:	33 1d       	adc	r19, r3
    118e:	3d ab       	std	Y+53, r19	; 0x35
    1190:	2c ab       	std	Y+52, r18	; 0x34
    1192:	d9 01       	movw	r26, r18
    1194:	8d 90       	ld	r8, X+
    1196:	9d 90       	ld	r9, X+
    1198:	ad 90       	ld	r10, X+
    119a:	bc 90       	ld	r11, X
    119c:	fc 01       	movw	r30, r24
    119e:	20 81       	ld	r18, Z
    11a0:	31 81       	ldd	r19, Z+1	; 0x01
    11a2:	42 81       	ldd	r20, Z+2	; 0x02
    11a4:	53 81       	ldd	r21, Z+3	; 0x03
    11a6:	c5 01       	movw	r24, r10
    11a8:	b4 01       	movw	r22, r8
    11aa:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    11ae:	6e 8b       	std	Y+22, r22	; 0x16
    11b0:	7f 8b       	std	Y+23, r23	; 0x17
    11b2:	88 8f       	std	Y+24, r24	; 0x18
    11b4:	99 8f       	std	Y+25, r25	; 0x19
  float center_axis1 = position[axis_1] + offset[axis_1];
    11b6:	2f 96       	adiw	r28, 0x0f	; 15
    11b8:	0f ad       	ldd	r16, Y+63	; 0x3f
    11ba:	2f 97       	sbiw	r28, 0x0f	; 15
    11bc:	10 e0       	ldi	r17, 0x00	; 0
    11be:	00 0f       	add	r16, r16
    11c0:	11 1f       	adc	r17, r17
    11c2:	00 0f       	add	r16, r16
    11c4:	11 1f       	adc	r17, r17
    11c6:	29 89       	ldd	r18, Y+17	; 0x11
    11c8:	3a 89       	ldd	r19, Y+18	; 0x12
    11ca:	20 0f       	add	r18, r16
    11cc:	31 1f       	adc	r19, r17
    11ce:	3b 8f       	std	Y+27, r19	; 0x1b
    11d0:	2a 8f       	std	Y+26, r18	; 0x1a
    11d2:	a3 01       	movw	r20, r6
    11d4:	40 0f       	add	r20, r16
    11d6:	51 1f       	adc	r21, r17
    11d8:	5f ab       	std	Y+55, r21	; 0x37
    11da:	4e ab       	std	Y+54, r20	; 0x36
    11dc:	da 01       	movw	r26, r20
    11de:	8d 91       	ld	r24, X+
    11e0:	9d 91       	ld	r25, X+
    11e2:	0d 90       	ld	r0, X+
    11e4:	bc 91       	ld	r27, X
    11e6:	a0 2d       	mov	r26, r0
    11e8:	89 83       	std	Y+1, r24	; 0x01
    11ea:	9a 83       	std	Y+2, r25	; 0x02
    11ec:	ab 83       	std	Y+3, r26	; 0x03
    11ee:	bc 83       	std	Y+4, r27	; 0x04
    11f0:	f9 01       	movw	r30, r18
    11f2:	20 81       	ld	r18, Z
    11f4:	31 81       	ldd	r19, Z+1	; 0x01
    11f6:	42 81       	ldd	r20, Z+2	; 0x02
    11f8:	53 81       	ldd	r21, Z+3	; 0x03
    11fa:	bc 01       	movw	r22, r24
    11fc:	cd 01       	movw	r24, r26
    11fe:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    1202:	6c 8f       	std	Y+28, r22	; 0x1c
    1204:	7d 8f       	std	Y+29, r23	; 0x1d
    1206:	8e 8f       	std	Y+30, r24	; 0x1e
    1208:	9f 8f       	std	Y+31, r25	; 0x1f
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
    120a:	24 01       	movw	r4, r8
    120c:	35 01       	movw	r6, r10
    120e:	77 fa       	bst	r7, 7
    1210:	70 94       	com	r7
    1212:	77 f8       	bld	r7, 7
    1214:	70 94       	com	r7
  float r_axis1 = -offset[axis_1];
    1216:	89 80       	ldd	r8, Y+1	; 0x01
    1218:	9a 80       	ldd	r9, Y+2	; 0x02
    121a:	ab 80       	ldd	r10, Y+3	; 0x03
    121c:	bc 80       	ldd	r11, Y+4	; 0x04
    121e:	b7 fa       	bst	r11, 7
    1220:	b0 94       	com	r11
    1222:	b7 f8       	bld	r11, 7
    1224:	b0 94       	com	r11
  float rt_axis0 = target[axis_0] - center_axis0;
    1226:	e8 ad       	ldd	r30, Y+56	; 0x38
    1228:	f9 ad       	ldd	r31, Y+57	; 0x39
    122a:	e2 0d       	add	r30, r2
    122c:	f3 1d       	adc	r31, r3
    122e:	2e 89       	ldd	r18, Y+22	; 0x16
    1230:	3f 89       	ldd	r19, Y+23	; 0x17
    1232:	48 8d       	ldd	r20, Y+24	; 0x18
    1234:	59 8d       	ldd	r21, Y+25	; 0x19
    1236:	60 81       	ld	r22, Z
    1238:	71 81       	ldd	r23, Z+1	; 0x01
    123a:	82 81       	ldd	r24, Z+2	; 0x02
    123c:	93 81       	ldd	r25, Z+3	; 0x03
    123e:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    1242:	69 83       	std	Y+1, r22	; 0x01
    1244:	7a 83       	std	Y+2, r23	; 0x02
    1246:	8b 83       	std	Y+3, r24	; 0x03
    1248:	9c 83       	std	Y+4, r25	; 0x04
  float rt_axis1 = target[axis_1] - center_axis1;
    124a:	e8 ad       	ldd	r30, Y+56	; 0x38
    124c:	f9 ad       	ldd	r31, Y+57	; 0x39
    124e:	e0 0f       	add	r30, r16
    1250:	f1 1f       	adc	r31, r17
    1252:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1254:	3d 8d       	ldd	r19, Y+29	; 0x1d
    1256:	4e 8d       	ldd	r20, Y+30	; 0x1e
    1258:	5f 8d       	ldd	r21, Y+31	; 0x1f
    125a:	60 81       	ld	r22, Z
    125c:	71 81       	ldd	r23, Z+1	; 0x01
    125e:	82 81       	ldd	r24, Z+2	; 0x02
    1260:	93 81       	ldd	r25, Z+3	; 0x03
    1262:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    1266:	6d 83       	std	Y+5, r22	; 0x05
    1268:	7e 83       	std	Y+6, r23	; 0x06
    126a:	8f 83       	std	Y+7, r24	; 0x07
    126c:	98 87       	std	Y+8, r25	; 0x08
  
  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
    126e:	29 81       	ldd	r18, Y+1	; 0x01
    1270:	3a 81       	ldd	r19, Y+2	; 0x02
    1272:	4b 81       	ldd	r20, Y+3	; 0x03
    1274:	5c 81       	ldd	r21, Y+4	; 0x04
    1276:	c3 01       	movw	r24, r6
    1278:	b2 01       	movw	r22, r4
    127a:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    127e:	6d 87       	std	Y+13, r22	; 0x0d
    1280:	7e 87       	std	Y+14, r23	; 0x0e
    1282:	8f 87       	std	Y+15, r24	; 0x0f
    1284:	98 8b       	std	Y+16, r25	; 0x10
    1286:	2d 81       	ldd	r18, Y+5	; 0x05
    1288:	3e 81       	ldd	r19, Y+6	; 0x06
    128a:	4f 81       	ldd	r20, Y+7	; 0x07
    128c:	58 85       	ldd	r21, Y+8	; 0x08
    128e:	c5 01       	movw	r24, r10
    1290:	b4 01       	movw	r22, r8
    1292:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1296:	9b 01       	movw	r18, r22
    1298:	ac 01       	movw	r20, r24
    129a:	6d 85       	ldd	r22, Y+13	; 0x0d
    129c:	7e 85       	ldd	r23, Y+14	; 0x0e
    129e:	8f 85       	ldd	r24, Y+15	; 0x0f
    12a0:	98 89       	ldd	r25, Y+16	; 0x10
    12a2:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    12a6:	6d 87       	std	Y+13, r22	; 0x0d
    12a8:	7e 87       	std	Y+14, r23	; 0x0e
    12aa:	8f 87       	std	Y+15, r24	; 0x0f
    12ac:	98 8b       	std	Y+16, r25	; 0x10
    12ae:	2d 81       	ldd	r18, Y+5	; 0x05
    12b0:	3e 81       	ldd	r19, Y+6	; 0x06
    12b2:	4f 81       	ldd	r20, Y+7	; 0x07
    12b4:	58 85       	ldd	r21, Y+8	; 0x08
    12b6:	c3 01       	movw	r24, r6
    12b8:	b2 01       	movw	r22, r4
    12ba:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    12be:	6d 83       	std	Y+5, r22	; 0x05
    12c0:	7e 83       	std	Y+6, r23	; 0x06
    12c2:	8f 83       	std	Y+7, r24	; 0x07
    12c4:	98 87       	std	Y+8, r25	; 0x08
    12c6:	29 81       	ldd	r18, Y+1	; 0x01
    12c8:	3a 81       	ldd	r19, Y+2	; 0x02
    12ca:	4b 81       	ldd	r20, Y+3	; 0x03
    12cc:	5c 81       	ldd	r21, Y+4	; 0x04
    12ce:	c5 01       	movw	r24, r10
    12d0:	b4 01       	movw	r22, r8
    12d2:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    12d6:	9b 01       	movw	r18, r22
    12d8:	ac 01       	movw	r20, r24
    12da:	6d 81       	ldd	r22, Y+5	; 0x05
    12dc:	7e 81       	ldd	r23, Y+6	; 0x06
    12de:	8f 81       	ldd	r24, Y+7	; 0x07
    12e0:	98 85       	ldd	r25, Y+8	; 0x08
    12e2:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    12e6:	2d 85       	ldd	r18, Y+13	; 0x0d
    12e8:	3e 85       	ldd	r19, Y+14	; 0x0e
    12ea:	4f 85       	ldd	r20, Y+15	; 0x0f
    12ec:	58 89       	ldd	r21, Y+16	; 0x10
    12ee:	0e 94 47 3c 	call	0x788e	; 0x788e <atan2>
    12f2:	69 83       	std	Y+1, r22	; 0x01
    12f4:	7a 83       	std	Y+2, r23	; 0x02
    12f6:	8b 83       	std	Y+3, r24	; 0x03
    12f8:	9c 83       	std	Y+4, r25	; 0x04
  if (is_clockwise_arc) { // Correct atan2 output per direction
    12fa:	61 96       	adiw	r28, 0x11	; 17
    12fc:	8f ad       	ldd	r24, Y+63	; 0x3f
    12fe:	61 97       	sbiw	r28, 0x11	; 17
    1300:	88 23       	and	r24, r24
    1302:	d1 f0       	breq	.+52     	; 0x1338 <mc_arc+0x20e>
    if (angular_travel >= 0) { angular_travel -= 2*M_PI; }
    1304:	20 e0       	ldi	r18, 0x00	; 0
    1306:	30 e0       	ldi	r19, 0x00	; 0
    1308:	a9 01       	movw	r20, r18
    130a:	69 81       	ldd	r22, Y+1	; 0x01
    130c:	7a 81       	ldd	r23, Y+2	; 0x02
    130e:	8b 81       	ldd	r24, Y+3	; 0x03
    1310:	9c 81       	ldd	r25, Y+4	; 0x04
    1312:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    1316:	88 23       	and	r24, r24
    1318:	44 f1       	brlt	.+80     	; 0x136a <mc_arc+0x240>
    131a:	2b ed       	ldi	r18, 0xDB	; 219
    131c:	3f e0       	ldi	r19, 0x0F	; 15
    131e:	49 ec       	ldi	r20, 0xC9	; 201
    1320:	50 e4       	ldi	r21, 0x40	; 64
    1322:	69 81       	ldd	r22, Y+1	; 0x01
    1324:	7a 81       	ldd	r23, Y+2	; 0x02
    1326:	8b 81       	ldd	r24, Y+3	; 0x03
    1328:	9c 81       	ldd	r25, Y+4	; 0x04
    132a:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    132e:	69 83       	std	Y+1, r22	; 0x01
    1330:	7a 83       	std	Y+2, r23	; 0x02
    1332:	8b 83       	std	Y+3, r24	; 0x03
    1334:	9c 83       	std	Y+4, r25	; 0x04
    1336:	19 c0       	rjmp	.+50     	; 0x136a <mc_arc+0x240>
  } else {
    if (angular_travel <= 0) { angular_travel += 2*M_PI; }
    1338:	20 e0       	ldi	r18, 0x00	; 0
    133a:	30 e0       	ldi	r19, 0x00	; 0
    133c:	a9 01       	movw	r20, r18
    133e:	69 81       	ldd	r22, Y+1	; 0x01
    1340:	7a 81       	ldd	r23, Y+2	; 0x02
    1342:	8b 81       	ldd	r24, Y+3	; 0x03
    1344:	9c 81       	ldd	r25, Y+4	; 0x04
    1346:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    134a:	18 16       	cp	r1, r24
    134c:	74 f0       	brlt	.+28     	; 0x136a <mc_arc+0x240>
    134e:	2b ed       	ldi	r18, 0xDB	; 219
    1350:	3f e0       	ldi	r19, 0x0F	; 15
    1352:	49 ec       	ldi	r20, 0xC9	; 201
    1354:	50 e4       	ldi	r21, 0x40	; 64
    1356:	69 81       	ldd	r22, Y+1	; 0x01
    1358:	7a 81       	ldd	r23, Y+2	; 0x02
    135a:	8b 81       	ldd	r24, Y+3	; 0x03
    135c:	9c 81       	ldd	r25, Y+4	; 0x04
    135e:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    1362:	69 83       	std	Y+1, r22	; 0x01
    1364:	7a 83       	std	Y+2, r23	; 0x02
    1366:	8b 83       	std	Y+3, r24	; 0x03
    1368:	9c 83       	std	Y+4, r25	; 0x04
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
    136a:	20 91 38 09 	lds	r18, 0x0938
    136e:	30 91 39 09 	lds	r19, 0x0939
    1372:	40 91 3a 09 	lds	r20, 0x093A
    1376:	50 91 3b 09 	lds	r21, 0x093B
    137a:	2d 83       	std	Y+5, r18	; 0x05
    137c:	3e 83       	std	Y+6, r19	; 0x06
    137e:	4f 83       	std	Y+7, r20	; 0x07
    1380:	58 87       	std	Y+8, r21	; 0x08
    1382:	29 85       	ldd	r18, Y+9	; 0x09
    1384:	3a 85       	ldd	r19, Y+10	; 0x0a
    1386:	4b 85       	ldd	r20, Y+11	; 0x0b
    1388:	5c 85       	ldd	r21, Y+12	; 0x0c
    138a:	ca 01       	movw	r24, r20
    138c:	b9 01       	movw	r22, r18
    138e:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    1392:	2d 81       	ldd	r18, Y+5	; 0x05
    1394:	3e 81       	ldd	r19, Y+6	; 0x06
    1396:	4f 81       	ldd	r20, Y+7	; 0x07
    1398:	58 85       	ldd	r21, Y+8	; 0x08
    139a:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    139e:	9b 01       	movw	r18, r22
    13a0:	ac 01       	movw	r20, r24
    13a2:	6d 81       	ldd	r22, Y+5	; 0x05
    13a4:	7e 81       	ldd	r23, Y+6	; 0x06
    13a6:	8f 81       	ldd	r24, Y+7	; 0x07
    13a8:	98 85       	ldd	r25, Y+8	; 0x08
    13aa:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    13ae:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    13b2:	6d 83       	std	Y+5, r22	; 0x05
    13b4:	7e 83       	std	Y+6, r23	; 0x06
    13b6:	8f 83       	std	Y+7, r24	; 0x07
    13b8:	98 87       	std	Y+8, r25	; 0x08

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
    13ba:	20 e0       	ldi	r18, 0x00	; 0
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	40 e0       	ldi	r20, 0x00	; 0
    13c0:	5f e3       	ldi	r21, 0x3F	; 63
    13c2:	69 81       	ldd	r22, Y+1	; 0x01
    13c4:	7a 81       	ldd	r23, Y+2	; 0x02
    13c6:	8b 81       	ldd	r24, Y+3	; 0x03
    13c8:	9c 81       	ldd	r25, Y+4	; 0x04
    13ca:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    13ce:	29 85       	ldd	r18, Y+9	; 0x09
    13d0:	3a 85       	ldd	r19, Y+10	; 0x0a
    13d2:	4b 85       	ldd	r20, Y+11	; 0x0b
    13d4:	5c 85       	ldd	r21, Y+12	; 0x0c
    13d6:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    13da:	9f 77       	andi	r25, 0x7F	; 127
    13dc:	2d 81       	ldd	r18, Y+5	; 0x05
    13de:	3e 81       	ldd	r19, Y+6	; 0x06
    13e0:	4f 81       	ldd	r20, Y+7	; 0x07
    13e2:	58 85       	ldd	r21, Y+8	; 0x08
    13e4:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    13e8:	0e 94 8a 3d 	call	0x7b14	; 0x7b14 <floor>
    13ec:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
    13f0:	69 87       	std	Y+9, r22	; 0x09
    13f2:	7a 87       	std	Y+10, r23	; 0x0a
    13f4:	8b 87       	std	Y+11, r24	; 0x0b
    13f6:	9c 87       	std	Y+12, r25	; 0x0c
    13f8:	49 85       	ldd	r20, Y+9	; 0x09
    13fa:	5a 85       	ldd	r21, Y+10	; 0x0a
    13fc:	5e 87       	std	Y+14, r21	; 0x0e
    13fe:	4d 87       	std	Y+13, r20	; 0x0d
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
  
  if (segments) { 
    1400:	45 2b       	or	r20, r21
    1402:	09 f4       	brne	.+2      	; 0x1406 <mc_arc+0x2dc>
    1404:	8e c1       	rjmp	.+796    	; 0x1722 <mc_arc+0x5f8>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of 
    // all segments.
    if (invert_feed_rate) { feed_rate *= segments; }
    1406:	5b 89       	ldd	r21, Y+19	; 0x13
    1408:	55 23       	and	r21, r21
    140a:	79 f0       	breq	.+30     	; 0x142a <mc_arc+0x300>
    140c:	a9 85       	ldd	r26, Y+9	; 0x09
    140e:	ba 85       	ldd	r27, Y+10	; 0x0a
    1410:	bd 01       	movw	r22, r26
    1412:	80 e0       	ldi	r24, 0x00	; 0
    1414:	90 e0       	ldi	r25, 0x00	; 0
    1416:	0e 94 4d 3d 	call	0x7a9a	; 0x7a9a <__floatunsisf>
    141a:	9b 01       	movw	r18, r22
    141c:	ac 01       	movw	r20, r24
    141e:	c7 01       	movw	r24, r14
    1420:	b6 01       	movw	r22, r12
    1422:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1426:	6b 01       	movw	r12, r22
    1428:	7c 01       	movw	r14, r24
   
    float theta_per_segment = angular_travel/segments;
    142a:	e9 85       	ldd	r30, Y+9	; 0x09
    142c:	fa 85       	ldd	r31, Y+10	; 0x0a
    142e:	bf 01       	movw	r22, r30
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	90 e0       	ldi	r25, 0x00	; 0
    1434:	0e 94 4d 3d 	call	0x7a9a	; 0x7a9a <__floatunsisf>
    1438:	69 87       	std	Y+9, r22	; 0x09
    143a:	7a 87       	std	Y+10, r23	; 0x0a
    143c:	8b 87       	std	Y+11, r24	; 0x0b
    143e:	9c 87       	std	Y+12, r25	; 0x0c
    1440:	9b 01       	movw	r18, r22
    1442:	ac 01       	movw	r20, r24
    1444:	69 81       	ldd	r22, Y+1	; 0x01
    1446:	7a 81       	ldd	r23, Y+2	; 0x02
    1448:	8b 81       	ldd	r24, Y+3	; 0x03
    144a:	9c 81       	ldd	r25, Y+4	; 0x04
    144c:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    1450:	68 ab       	std	Y+48, r22	; 0x30
    1452:	79 ab       	std	Y+49, r23	; 0x31
    1454:	8a ab       	std	Y+50, r24	; 0x32
    1456:	9b ab       	std	Y+51, r25	; 0x33
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
    1458:	60 96       	adiw	r28, 0x10	; 16
    145a:	8f ad       	ldd	r24, Y+63	; 0x3f
    145c:	60 97       	sbiw	r28, 0x10	; 16
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	88 0f       	add	r24, r24
    1462:	99 1f       	adc	r25, r25
    1464:	88 0f       	add	r24, r24
    1466:	99 1f       	adc	r25, r25
    1468:	29 89       	ldd	r18, Y+17	; 0x11
    146a:	3a 89       	ldd	r19, Y+18	; 0x12
    146c:	28 0f       	add	r18, r24
    146e:	39 1f       	adc	r19, r25
    1470:	3a 83       	std	Y+2, r19	; 0x02
    1472:	29 83       	std	Y+1, r18	; 0x01
    1474:	e8 ad       	ldd	r30, Y+56	; 0x38
    1476:	f9 ad       	ldd	r31, Y+57	; 0x39
    1478:	e8 0f       	add	r30, r24
    147a:	f9 1f       	adc	r31, r25
    147c:	d9 01       	movw	r26, r18
    147e:	2d 91       	ld	r18, X+
    1480:	3d 91       	ld	r19, X+
    1482:	4d 91       	ld	r20, X+
    1484:	5c 91       	ld	r21, X
    1486:	60 81       	ld	r22, Z
    1488:	71 81       	ldd	r23, Z+1	; 0x01
    148a:	82 81       	ldd	r24, Z+2	; 0x02
    148c:	93 81       	ldd	r25, Z+3	; 0x03
    148e:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    1492:	29 85       	ldd	r18, Y+9	; 0x09
    1494:	3a 85       	ldd	r19, Y+10	; 0x0a
    1496:	4b 85       	ldd	r20, Y+11	; 0x0b
    1498:	5c 85       	ldd	r21, Y+12	; 0x0c
    149a:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    149e:	6c a3       	std	Y+36, r22	; 0x24
    14a0:	7d a3       	std	Y+37, r23	; 0x25
    14a2:	8e a3       	std	Y+38, r24	; 0x26
    14a4:	9f a3       	std	Y+39, r25	; 0x27
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. 
       This is important when there are successive arc motions. 
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
    14a6:	28 a9       	ldd	r18, Y+48	; 0x30
    14a8:	39 a9       	ldd	r19, Y+49	; 0x31
    14aa:	4a a9       	ldd	r20, Y+50	; 0x32
    14ac:	5b a9       	ldd	r21, Y+51	; 0x33
    14ae:	ca 01       	movw	r24, r20
    14b0:	b9 01       	movw	r22, r18
    14b2:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    14b6:	9b 01       	movw	r18, r22
    14b8:	ac 01       	movw	r20, r24
    14ba:	60 e0       	ldi	r22, 0x00	; 0
    14bc:	70 e0       	ldi	r23, 0x00	; 0
    14be:	80 e0       	ldi	r24, 0x00	; 0
    14c0:	90 e4       	ldi	r25, 0x40	; 64
    14c2:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    14c6:	69 87       	std	Y+9, r22	; 0x09
    14c8:	7a 87       	std	Y+10, r23	; 0x0a
    14ca:	8b 87       	std	Y+11, r24	; 0x0b
    14cc:	9c 87       	std	Y+12, r25	; 0x0c
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
    14ce:	2b ea       	ldi	r18, 0xAB	; 171
    14d0:	3a ea       	ldi	r19, 0xAA	; 170
    14d2:	4a e2       	ldi	r20, 0x2A	; 42
    14d4:	5e e3       	ldi	r21, 0x3E	; 62
    14d6:	68 a9       	ldd	r22, Y+48	; 0x30
    14d8:	79 a9       	ldd	r23, Y+49	; 0x31
    14da:	8a a9       	ldd	r24, Y+50	; 0x32
    14dc:	9b a9       	ldd	r25, Y+51	; 0x33
    14de:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    14e2:	6d 83       	std	Y+5, r22	; 0x05
    14e4:	7e 83       	std	Y+6, r23	; 0x06
    14e6:	8f 83       	std	Y+7, r24	; 0x07
    14e8:	98 87       	std	Y+8, r25	; 0x08
    14ea:	20 e0       	ldi	r18, 0x00	; 0
    14ec:	30 e0       	ldi	r19, 0x00	; 0
    14ee:	40 e8       	ldi	r20, 0x80	; 128
    14f0:	50 e4       	ldi	r21, 0x40	; 64
    14f2:	69 85       	ldd	r22, Y+9	; 0x09
    14f4:	7a 85       	ldd	r23, Y+10	; 0x0a
    14f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    14f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    14fa:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    14fe:	9b 01       	movw	r18, r22
    1500:	ac 01       	movw	r20, r24
    1502:	6d 81       	ldd	r22, Y+5	; 0x05
    1504:	7e 81       	ldd	r23, Y+6	; 0x06
    1506:	8f 81       	ldd	r24, Y+7	; 0x07
    1508:	98 85       	ldd	r25, Y+8	; 0x08
    150a:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    150e:	68 a7       	std	Y+40, r22	; 0x28
    1510:	79 a7       	std	Y+41, r23	; 0x29
    1512:	8a a7       	std	Y+42, r24	; 0x2a
    1514:	9b a7       	std	Y+43, r25	; 0x2b
    cos_T *= 0.5;
    1516:	20 e0       	ldi	r18, 0x00	; 0
    1518:	30 e0       	ldi	r19, 0x00	; 0
    151a:	40 e0       	ldi	r20, 0x00	; 0
    151c:	5f e3       	ldi	r21, 0x3F	; 63
    151e:	69 85       	ldd	r22, Y+9	; 0x09
    1520:	7a 85       	ldd	r23, Y+10	; 0x0a
    1522:	8b 85       	ldd	r24, Y+11	; 0x0b
    1524:	9c 85       	ldd	r25, Y+12	; 0x0c
    1526:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    152a:	6c a7       	std	Y+44, r22	; 0x2c
    152c:	7d a7       	std	Y+45, r23	; 0x2d
    152e:	8e a7       	std	Y+46, r24	; 0x2e
    1530:	9f a7       	std	Y+47, r25	; 0x2f
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    1532:	ed 85       	ldd	r30, Y+13	; 0x0d
    1534:	fe 85       	ldd	r31, Y+14	; 0x0e
    1536:	32 97       	sbiw	r30, 0x02	; 2
    1538:	08 f4       	brcc	.+2      	; 0x153c <mc_arc+0x412>
    153a:	f3 c0       	rjmp	.+486    	; 0x1722 <mc_arc+0x5f8>

    float sin_Ti;
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
    153c:	10 e0       	ldi	r17, 0x00	; 0
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    153e:	22 24       	eor	r2, r2
    1540:	23 94       	inc	r2
    1542:	31 2c       	mov	r3, r1
      #else
        mc_line(position, feed_rate, invert_feed_rate);
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    1544:	c8 a2       	std	Y+32, r12	; 0x20
    1546:	d9 a2       	std	Y+33, r13	; 0x21
    1548:	ea a2       	std	Y+34, r14	; 0x22
    154a:	fb a2       	std	Y+35, r15	; 0x23
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
      
      if (count < N_ARC_CORRECTION) {
    154c:	1c 30       	cpi	r17, 0x0C	; 12
    154e:	d0 f5       	brcc	.+116    	; 0x15c4 <mc_arc+0x49a>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
    1550:	2c a5       	ldd	r18, Y+44	; 0x2c
    1552:	3d a5       	ldd	r19, Y+45	; 0x2d
    1554:	4e a5       	ldd	r20, Y+46	; 0x2e
    1556:	5f a5       	ldd	r21, Y+47	; 0x2f
    1558:	c5 01       	movw	r24, r10
    155a:	b4 01       	movw	r22, r8
    155c:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1560:	6b 01       	movw	r12, r22
    1562:	7c 01       	movw	r14, r24
    1564:	28 a5       	ldd	r18, Y+40	; 0x28
    1566:	39 a5       	ldd	r19, Y+41	; 0x29
    1568:	4a a5       	ldd	r20, Y+42	; 0x2a
    156a:	5b a5       	ldd	r21, Y+43	; 0x2b
    156c:	c3 01       	movw	r24, r6
    156e:	b2 01       	movw	r22, r4
    1570:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1574:	a7 01       	movw	r20, r14
    1576:	96 01       	movw	r18, r12
    1578:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    157c:	d6 2e       	mov	r13, r22
    157e:	e7 2e       	mov	r14, r23
    1580:	f8 2e       	mov	r15, r24
    1582:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
    1584:	2c a5       	ldd	r18, Y+44	; 0x2c
    1586:	3d a5       	ldd	r19, Y+45	; 0x2d
    1588:	4e a5       	ldd	r20, Y+46	; 0x2e
    158a:	5f a5       	ldd	r21, Y+47	; 0x2f
    158c:	c3 01       	movw	r24, r6
    158e:	b2 01       	movw	r22, r4
    1590:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1594:	2b 01       	movw	r4, r22
    1596:	3c 01       	movw	r6, r24
    1598:	28 a5       	ldd	r18, Y+40	; 0x28
    159a:	39 a5       	ldd	r19, Y+41	; 0x29
    159c:	4a a5       	ldd	r20, Y+42	; 0x2a
    159e:	5b a5       	ldd	r21, Y+43	; 0x2b
    15a0:	c5 01       	movw	r24, r10
    15a2:	b4 01       	movw	r22, r8
    15a4:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    15a8:	9b 01       	movw	r18, r22
    15aa:	ac 01       	movw	r20, r24
    15ac:	c3 01       	movw	r24, r6
    15ae:	b2 01       	movw	r22, r4
    15b0:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    15b4:	2b 01       	movw	r4, r22
    15b6:	3c 01       	movw	r6, r24
        r_axis1 = r_axisi;
        count++;
    15b8:	1f 5f       	subi	r17, 0xFF	; 255
      
      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
    15ba:	8d 2c       	mov	r8, r13
    15bc:	9e 2c       	mov	r9, r14
    15be:	af 2c       	mov	r10, r15
    15c0:	b0 2e       	mov	r11, r16
    15c2:	64 c0       	rjmp	.+200    	; 0x168c <mc_arc+0x562>
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
    15c4:	b1 01       	movw	r22, r2
    15c6:	80 e0       	ldi	r24, 0x00	; 0
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	0e 94 4d 3d 	call	0x7a9a	; 0x7a9a <__floatunsisf>
    15ce:	28 a9       	ldd	r18, Y+48	; 0x30
    15d0:	39 a9       	ldd	r19, Y+49	; 0x31
    15d2:	4a a9       	ldd	r20, Y+50	; 0x32
    15d4:	5b a9       	ldd	r21, Y+51	; 0x33
    15d6:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    15da:	4b 01       	movw	r8, r22
    15dc:	5c 01       	movw	r10, r24
    15de:	0e 94 b1 3c 	call	0x7962	; 0x7962 <cos>
    15e2:	6b 01       	movw	r12, r22
    15e4:	7c 01       	movw	r14, r24
        sin_Ti = sin(i*theta_per_segment);
    15e6:	c5 01       	movw	r24, r10
    15e8:	b4 01       	movw	r22, r8
    15ea:	0e 94 6e 3f 	call	0x7edc	; 0x7edc <sin>
    15ee:	4b 01       	movw	r8, r22
    15f0:	5c 01       	movw	r10, r24
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
    15f2:	ec a9       	ldd	r30, Y+52	; 0x34
    15f4:	fd a9       	ldd	r31, Y+53	; 0x35
    15f6:	80 81       	ld	r24, Z
    15f8:	91 81       	ldd	r25, Z+1	; 0x01
    15fa:	a2 81       	ldd	r26, Z+2	; 0x02
    15fc:	b3 81       	ldd	r27, Z+3	; 0x03
    15fe:	9c 01       	movw	r18, r24
    1600:	ad 01       	movw	r20, r26
    1602:	50 58       	subi	r21, 0x80	; 128
    1604:	29 87       	std	Y+9, r18	; 0x09
    1606:	3a 87       	std	Y+10, r19	; 0x0a
    1608:	4b 87       	std	Y+11, r20	; 0x0b
    160a:	5c 87       	std	Y+12, r21	; 0x0c
    160c:	ae a9       	ldd	r26, Y+54	; 0x36
    160e:	bf a9       	ldd	r27, Y+55	; 0x37
    1610:	8d 91       	ld	r24, X+
    1612:	9d 91       	ld	r25, X+
    1614:	0d 90       	ld	r0, X+
    1616:	bc 91       	ld	r27, X
    1618:	a0 2d       	mov	r26, r0
    161a:	8d 83       	std	Y+5, r24	; 0x05
    161c:	9e 83       	std	Y+6, r25	; 0x06
    161e:	af 83       	std	Y+7, r26	; 0x07
    1620:	b8 87       	std	Y+8, r27	; 0x08
    1622:	a7 01       	movw	r20, r14
    1624:	96 01       	movw	r18, r12
    1626:	69 85       	ldd	r22, Y+9	; 0x09
    1628:	7a 85       	ldd	r23, Y+10	; 0x0a
    162a:	8b 85       	ldd	r24, Y+11	; 0x0b
    162c:	9c 85       	ldd	r25, Y+12	; 0x0c
    162e:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1632:	2b 01       	movw	r4, r22
    1634:	3c 01       	movw	r6, r24
    1636:	a5 01       	movw	r20, r10
    1638:	94 01       	movw	r18, r8
    163a:	6d 81       	ldd	r22, Y+5	; 0x05
    163c:	7e 81       	ldd	r23, Y+6	; 0x06
    163e:	8f 81       	ldd	r24, Y+7	; 0x07
    1640:	98 85       	ldd	r25, Y+8	; 0x08
    1642:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1646:	9b 01       	movw	r18, r22
    1648:	ac 01       	movw	r20, r24
    164a:	c3 01       	movw	r24, r6
    164c:	b2 01       	movw	r22, r4
    164e:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    1652:	2b 01       	movw	r4, r22
    1654:	3c 01       	movw	r6, r24
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
    1656:	29 85       	ldd	r18, Y+9	; 0x09
    1658:	3a 85       	ldd	r19, Y+10	; 0x0a
    165a:	4b 85       	ldd	r20, Y+11	; 0x0b
    165c:	5c 85       	ldd	r21, Y+12	; 0x0c
    165e:	c5 01       	movw	r24, r10
    1660:	b4 01       	movw	r22, r8
    1662:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1666:	4b 01       	movw	r8, r22
    1668:	5c 01       	movw	r10, r24
    166a:	2d 81       	ldd	r18, Y+5	; 0x05
    166c:	3e 81       	ldd	r19, Y+6	; 0x06
    166e:	4f 81       	ldd	r20, Y+7	; 0x07
    1670:	58 85       	ldd	r21, Y+8	; 0x08
    1672:	c7 01       	movw	r24, r14
    1674:	b6 01       	movw	r22, r12
    1676:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    167a:	9b 01       	movw	r18, r22
    167c:	ac 01       	movw	r20, r24
    167e:	c5 01       	movw	r24, r10
    1680:	b4 01       	movw	r22, r8
    1682:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    1686:	4b 01       	movw	r8, r22
    1688:	5c 01       	movw	r10, r24
        count = 0;
    168a:	10 e0       	ldi	r17, 0x00	; 0
      }
  
      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
    168c:	a3 01       	movw	r20, r6
    168e:	92 01       	movw	r18, r4
    1690:	6e 89       	ldd	r22, Y+22	; 0x16
    1692:	7f 89       	ldd	r23, Y+23	; 0x17
    1694:	88 8d       	ldd	r24, Y+24	; 0x18
    1696:	99 8d       	ldd	r25, Y+25	; 0x19
    1698:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    169c:	ec 89       	ldd	r30, Y+20	; 0x14
    169e:	fd 89       	ldd	r31, Y+21	; 0x15
    16a0:	60 83       	st	Z, r22
    16a2:	71 83       	std	Z+1, r23	; 0x01
    16a4:	82 83       	std	Z+2, r24	; 0x02
    16a6:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
    16a8:	a5 01       	movw	r20, r10
    16aa:	94 01       	movw	r18, r8
    16ac:	6c 8d       	ldd	r22, Y+28	; 0x1c
    16ae:	7d 8d       	ldd	r23, Y+29	; 0x1d
    16b0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16b2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    16b4:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    16b8:	aa 8d       	ldd	r26, Y+26	; 0x1a
    16ba:	bb 8d       	ldd	r27, Y+27	; 0x1b
    16bc:	6d 93       	st	X+, r22
    16be:	7d 93       	st	X+, r23
    16c0:	8d 93       	st	X+, r24
    16c2:	9c 93       	st	X, r25
    16c4:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
    16c6:	2c a1       	ldd	r18, Y+36	; 0x24
    16c8:	3d a1       	ldd	r19, Y+37	; 0x25
    16ca:	4e a1       	ldd	r20, Y+38	; 0x26
    16cc:	5f a1       	ldd	r21, Y+39	; 0x27
    16ce:	e9 81       	ldd	r30, Y+1	; 0x01
    16d0:	fa 81       	ldd	r31, Y+2	; 0x02
    16d2:	60 81       	ld	r22, Z
    16d4:	71 81       	ldd	r23, Z+1	; 0x01
    16d6:	82 81       	ldd	r24, Z+2	; 0x02
    16d8:	93 81       	ldd	r25, Z+3	; 0x03
    16da:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    16de:	a9 81       	ldd	r26, Y+1	; 0x01
    16e0:	ba 81       	ldd	r27, Y+2	; 0x02
    16e2:	6d 93       	st	X+, r22
    16e4:	7d 93       	st	X+, r23
    16e6:	8d 93       	st	X+, r24
    16e8:	9c 93       	st	X, r25
    16ea:	13 97       	sbiw	r26, 0x03	; 3
      
      #ifdef USE_LINE_NUMBERS
        mc_line(position, feed_rate, invert_feed_rate, line_number);
      #else
        mc_line(position, feed_rate, invert_feed_rate);
    16ec:	2b 89       	ldd	r18, Y+19	; 0x13
    16ee:	48 a1       	ldd	r20, Y+32	; 0x20
    16f0:	59 a1       	ldd	r21, Y+33	; 0x21
    16f2:	6a a1       	ldd	r22, Y+34	; 0x22
    16f4:	7b a1       	ldd	r23, Y+35	; 0x23
    16f6:	89 89       	ldd	r24, Y+17	; 0x11
    16f8:	9a 89       	ldd	r25, Y+18	; 0x12
    16fa:	0e 94 5f 08 	call	0x10be	; 0x10be <mc_line>
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    16fe:	e7 e6       	ldi	r30, 0x67	; 103
    1700:	f7 e0       	ldi	r31, 0x07	; 7
    1702:	80 81       	ld	r24, Z
    1704:	81 11       	cpse	r24, r1
    1706:	14 c0       	rjmp	.+40     	; 0x1730 <mc_arc+0x606>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    1708:	ff ef       	ldi	r31, 0xFF	; 255
    170a:	2f 1a       	sub	r2, r31
    170c:	3f 0a       	sbc	r3, r31
    170e:	2d 85       	ldd	r18, Y+13	; 0x0d
    1710:	3e 85       	ldd	r19, Y+14	; 0x0e
    1712:	22 16       	cp	r2, r18
    1714:	33 06       	cpc	r3, r19
    1716:	09 f0       	breq	.+2      	; 0x171a <mc_arc+0x5f0>
    1718:	19 cf       	rjmp	.-462    	; 0x154c <mc_arc+0x422>
    171a:	c8 a0       	ldd	r12, Y+32	; 0x20
    171c:	d9 a0       	ldd	r13, Y+33	; 0x21
    171e:	ea a0       	ldd	r14, Y+34	; 0x22
    1720:	fb a0       	ldd	r15, Y+35	; 0x23
  }
  // Ensure last segment arrives at target location.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    1722:	2b 89       	ldd	r18, Y+19	; 0x13
    1724:	b7 01       	movw	r22, r14
    1726:	a6 01       	movw	r20, r12
    1728:	88 ad       	ldd	r24, Y+56	; 0x38
    172a:	99 ad       	ldd	r25, Y+57	; 0x39
    172c:	0e 94 5f 08 	call	0x10be	; 0x10be <mc_line>
  #endif
}
    1730:	e9 96       	adiw	r28, 0x39	; 57
    1732:	0f b6       	in	r0, 0x3f	; 63
    1734:	f8 94       	cli
    1736:	de bf       	out	0x3e, r29	; 62
    1738:	0f be       	out	0x3f, r0	; 63
    173a:	cd bf       	out	0x3d, r28	; 61
    173c:	df 91       	pop	r29
    173e:	cf 91       	pop	r28
    1740:	1f 91       	pop	r17
    1742:	0f 91       	pop	r16
    1744:	ff 90       	pop	r15
    1746:	ef 90       	pop	r14
    1748:	df 90       	pop	r13
    174a:	cf 90       	pop	r12
    174c:	bf 90       	pop	r11
    174e:	af 90       	pop	r10
    1750:	9f 90       	pop	r9
    1752:	8f 90       	pop	r8
    1754:	7f 90       	pop	r7
    1756:	6f 90       	pop	r6
    1758:	5f 90       	pop	r5
    175a:	4f 90       	pop	r4
    175c:	3f 90       	pop	r3
    175e:	2f 90       	pop	r2
    1760:	08 95       	ret

00001762 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
    1762:	8f 92       	push	r8
    1764:	9f 92       	push	r9
    1766:	af 92       	push	r10
    1768:	bf 92       	push	r11
    176a:	cf 92       	push	r12
    176c:	df 92       	push	r13
    176e:	ef 92       	push	r14
    1770:	ff 92       	push	r15
    1772:	cf 93       	push	r28
    1774:	df 93       	push	r29
    1776:	4b 01       	movw	r8, r22
    1778:	5c 01       	movw	r10, r24
   if (sys.state == STATE_CHECK_MODE) { return; }
    177a:	80 91 68 07 	lds	r24, 0x0768
    177e:	82 30       	cpi	r24, 0x02	; 2
    1780:	09 f4       	brne	.+2      	; 0x1784 <mc_dwell+0x22>
    1782:	4a c0       	rjmp	.+148    	; 0x1818 <mc_dwell+0xb6>
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
    1784:	20 e0       	ldi	r18, 0x00	; 0
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	40 ea       	ldi	r20, 0xA0	; 160
    178a:	51 e4       	ldi	r21, 0x41	; 65
    178c:	c5 01       	movw	r24, r10
    178e:	b4 01       	movw	r22, r8
    1790:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1794:	0e 94 8a 3d 	call	0x7b14	; 0x7b14 <floor>
    1798:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
    179c:	6b 01       	movw	r12, r22
    179e:	7c 01       	movw	r14, r24
    17a0:	eb 01       	movw	r28, r22
   protocol_buffer_synchronize();
    17a2:	0e 94 11 1b 	call	0x3622	; 0x3622 <protocol_buffer_synchronize>
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
    17a6:	20 e0       	ldi	r18, 0x00	; 0
    17a8:	30 e0       	ldi	r19, 0x00	; 0
    17aa:	4a e7       	ldi	r20, 0x7A	; 122
    17ac:	54 e4       	ldi	r21, 0x44	; 68
    17ae:	c5 01       	movw	r24, r10
    17b0:	b4 01       	movw	r22, r8
    17b2:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    17b6:	4b 01       	movw	r8, r22
    17b8:	5c 01       	movw	r10, r24
    17ba:	82 e3       	ldi	r24, 0x32	; 50
    17bc:	8c 9d       	mul	r24, r12
    17be:	b0 01       	movw	r22, r0
    17c0:	8d 9d       	mul	r24, r13
    17c2:	70 0d       	add	r23, r0
    17c4:	11 24       	eor	r1, r1
    17c6:	80 e0       	ldi	r24, 0x00	; 0
    17c8:	90 e0       	ldi	r25, 0x00	; 0
    17ca:	0e 94 4d 3d 	call	0x7a9a	; 0x7a9a <__floatunsisf>
    17ce:	9b 01       	movw	r18, r22
    17d0:	ac 01       	movw	r20, r24
    17d2:	c5 01       	movw	r24, r10
    17d4:	b4 01       	movw	r22, r8
    17d6:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    17da:	0e 94 8a 3d 	call	0x7b14	; 0x7b14 <floor>
    17de:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
    17e2:	cb 01       	movw	r24, r22
    17e4:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <delay_ms>
   while (i-- > 0) {
    17e8:	cd 2b       	or	r28, r29
    17ea:	b1 f0       	breq	.+44     	; 0x1818 <mc_dwell+0xb6>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
    17ec:	c7 e6       	ldi	r28, 0x67	; 103
    17ee:	d7 e0       	ldi	r29, 0x07	; 7
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
    17f0:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
     if (sys.abort) { return; }
    17f4:	88 81       	ld	r24, Y
    17f6:	81 11       	cpse	r24, r1
    17f8:	0f c0       	rjmp	.+30     	; 0x1818 <mc_dwell+0xb6>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17fa:	2f ef       	ldi	r18, 0xFF	; 255
    17fc:	8f ec       	ldi	r24, 0xCF	; 207
    17fe:	92 e0       	ldi	r25, 0x02	; 2
    1800:	21 50       	subi	r18, 0x01	; 1
    1802:	80 40       	sbci	r24, 0x00	; 0
    1804:	90 40       	sbci	r25, 0x00	; 0
    1806:	e1 f7       	brne	.-8      	; 0x1800 <mc_dwell+0x9e>
    1808:	00 c0       	rjmp	.+0      	; 0x180a <mc_dwell+0xa8>
    180a:	00 00       	nop
    180c:	21 e0       	ldi	r18, 0x01	; 1
    180e:	c2 1a       	sub	r12, r18
    1810:	d1 08       	sbc	r13, r1
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
    1812:	c1 14       	cp	r12, r1
    1814:	d1 04       	cpc	r13, r1
    1816:	61 f7       	brne	.-40     	; 0x17f0 <mc_dwell+0x8e>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   }
}
    1818:	df 91       	pop	r29
    181a:	cf 91       	pop	r28
    181c:	ff 90       	pop	r15
    181e:	ef 90       	pop	r14
    1820:	df 90       	pop	r13
    1822:	cf 90       	pop	r12
    1824:	bf 90       	pop	r11
    1826:	af 90       	pop	r10
    1828:	9f 90       	pop	r9
    182a:	8f 90       	pop	r8
    182c:	08 95       	ret

0000182e <mc_homing_cycle>:
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT));
      return;
    }
  #endif
   
  limits_disable(); // Disable hard limits pin change register for cycle duration
    182e:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <limits_disable>
    
  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  // Search to engage all axes limit switches at faster homing seek rate.
  limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    1832:	84 e0       	ldi	r24, 0x04	; 4
    1834:	0e 94 a4 2f 	call	0x5f48	; 0x5f48 <limits_go_home>
  #ifdef HOMING_CYCLE_1
    limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
    1838:	83 e0       	ldi	r24, 0x03	; 3
    183a:	0e 94 a4 2f 	call	0x5f48	; 0x5f48 <limits_go_home>
  #endif
  #ifdef HOMING_CYCLE_2
    limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
  #endif
    
  protocol_execute_realtime(); // Check for reset and set system abort.
    183e:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
    1842:	80 91 67 07 	lds	r24, 0x0767
    1846:	81 11       	cpse	r24, r1
    1848:	04 c0       	rjmp	.+8      	; 0x1852 <mc_homing_cycle+0x24>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Gcode parser position was circumvented by the limits_go_home() routine, so sync position now.
  gc_sync_position();
    184a:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <gc_sync_position>
  
  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
    184e:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <limits_init>
    1852:	08 95       	ret

00001854 <mc_probe_cycle>:
    uint8_t is_no_error, int32_t line_number)
#else
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate, uint8_t is_probe_away,
    uint8_t is_no_error)
#endif
{ 
    1854:	8f 92       	push	r8
    1856:	9f 92       	push	r9
    1858:	af 92       	push	r10
    185a:	bf 92       	push	r11
    185c:	cf 92       	push	r12
    185e:	df 92       	push	r13
    1860:	ef 92       	push	r14
    1862:	0f 93       	push	r16
    1864:	1f 93       	push	r17
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	6c 01       	movw	r12, r24
    186c:	4a 01       	movw	r8, r20
    186e:	5b 01       	movw	r10, r22
    1870:	c2 2f       	mov	r28, r18
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return; }
    1872:	90 91 68 07 	lds	r25, 0x0768
    1876:	92 30       	cpi	r25, 0x02	; 2
    1878:	09 f4       	brne	.+2      	; 0x187c <mc_probe_cycle+0x28>
    187a:	68 c0       	rjmp	.+208    	; 0x194c <mc_probe_cycle+0xf8>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
    187c:	0e 94 11 1b 	call	0x3622	; 0x3622 <protocol_buffer_synchronize>

  // Initialize probing control variables
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.  
    1880:	10 92 86 07 	sts	0x0786, r1
  probe_configure_invert_mask(is_probe_away);
    1884:	80 2f       	mov	r24, r16
    1886:	0e 94 31 34 	call	0x6862	; 0x6862 <probe_configure_invert_mask>
  
  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
    188a:	0e 94 43 34 	call	0x6886	; 0x6886 <probe_get_state>
    188e:	88 23       	and	r24, r24
    1890:	51 f0       	breq	.+20     	; 0x18a6 <mc_probe_cycle+0x52>
    bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_PROBE_FAIL);
    1892:	8f b7       	in	r24, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	eb e6       	ldi	r30, 0x6B	; 107
    1898:	f7 e0       	ldi	r31, 0x07	; 7
    189a:	90 81       	ld	r25, Z
    189c:	90 61       	ori	r25, 0x10	; 16
    189e:	90 83       	st	Z, r25
    18a0:	8f bf       	out	0x3f, r24	; 63
    protocol_execute_realtime();
    18a2:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
  }
  if (sys.abort) { return; } // Return if system reset has been issued.
    18a6:	80 91 67 07 	lds	r24, 0x0767
    18aa:	81 11       	cpse	r24, r1
    18ac:	4f c0       	rjmp	.+158    	; 0x194c <mc_probe_cycle+0xf8>

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    18ae:	2c 2f       	mov	r18, r28
    18b0:	b5 01       	movw	r22, r10
    18b2:	a4 01       	movw	r20, r8
    18b4:	c6 01       	movw	r24, r12
    18b6:	0e 94 5f 08 	call	0x10be	; 0x10be <mc_line>
  #endif
  
  // Activate the probing state monitor in the stepper module.
  sys.probe_state = PROBE_ACTIVE;
    18ba:	81 e0       	ldi	r24, 0x01	; 1
    18bc:	80 93 79 07 	sts	0x0779, r24

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
    18c0:	8f b7       	in	r24, 0x3f	; 63
    18c2:	f8 94       	cli
    18c4:	ea e6       	ldi	r30, 0x6A	; 106
    18c6:	f7 e0       	ldi	r31, 0x07	; 7
    18c8:	90 81       	ld	r25, Z
    18ca:	92 60       	ori	r25, 0x02	; 2
    18cc:	90 83       	st	Z, r25
    18ce:	8f bf       	out	0x3f, r24	; 63
  do {
    protocol_execute_realtime(); 
    if (sys.abort) { return; } // Check for system abort
    18d0:	c7 e6       	ldi	r28, 0x67	; 103
    18d2:	d7 e0       	ldi	r29, 0x07	; 7
  } while (sys.state != STATE_IDLE);
    18d4:	08 e6       	ldi	r16, 0x68	; 104
    18d6:	17 e0       	ldi	r17, 0x07	; 7
  sys.probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
  do {
    protocol_execute_realtime(); 
    18d8:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    18dc:	88 81       	ld	r24, Y
    18de:	81 11       	cpse	r24, r1
    18e0:	35 c0       	rjmp	.+106    	; 0x194c <mc_probe_cycle+0xf8>
  } while (sys.state != STATE_IDLE);
    18e2:	f8 01       	movw	r30, r16
    18e4:	80 81       	ld	r24, Z
    18e6:	81 11       	cpse	r24, r1
    18e8:	f7 cf       	rjmp	.-18     	; 0x18d8 <mc_probe_cycle+0x84>
  
  // Probing cycle complete!
  
  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys.probe_state == PROBE_ACTIVE) {
    18ea:	80 91 79 07 	lds	r24, 0x0779
    18ee:	81 30       	cpi	r24, 0x01	; 1
    18f0:	a9 f4       	brne	.+42     	; 0x191c <mc_probe_cycle+0xc8>
    if (is_no_error) { memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS); }
    18f2:	ee 20       	and	r14, r14
    18f4:	51 f0       	breq	.+20     	; 0x190a <mc_probe_cycle+0xb6>
    18f6:	8c e0       	ldi	r24, 0x0C	; 12
    18f8:	ec e6       	ldi	r30, 0x6C	; 108
    18fa:	f7 e0       	ldi	r31, 0x07	; 7
    18fc:	aa e7       	ldi	r26, 0x7A	; 122
    18fe:	b7 e0       	ldi	r27, 0x07	; 7
    1900:	01 90       	ld	r0, Z+
    1902:	0d 92       	st	X+, r0
    1904:	8a 95       	dec	r24
    1906:	e1 f7       	brne	.-8      	; 0x1900 <mc_probe_cycle+0xac>
    1908:	0c c0       	rjmp	.+24     	; 0x1922 <mc_probe_cycle+0xce>
    else { bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_PROBE_FAIL); }
    190a:	8f b7       	in	r24, 0x3f	; 63
    190c:	f8 94       	cli
    190e:	eb e6       	ldi	r30, 0x6B	; 107
    1910:	f7 e0       	ldi	r31, 0x07	; 7
    1912:	90 81       	ld	r25, Z
    1914:	90 61       	ori	r25, 0x10	; 16
    1916:	90 83       	st	Z, r25
    1918:	8f bf       	out	0x3f, r24	; 63
    191a:	03 c0       	rjmp	.+6      	; 0x1922 <mc_probe_cycle+0xce>
  } else { 
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
    191c:	81 e0       	ldi	r24, 0x01	; 1
    191e:	80 93 86 07 	sts	0x0786, r24
  }
  sys.probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
    1922:	10 92 79 07 	sts	0x0779, r1
  protocol_execute_realtime();   // Check and execute run-time commands
    1926:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
  if (sys.abort) { return; } // Check for system abort
    192a:	80 91 67 07 	lds	r24, 0x0767
    192e:	81 11       	cpse	r24, r1
    1930:	0d c0       	rjmp	.+26     	; 0x194c <mc_probe_cycle+0xf8>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reest step segment buffer.
    1932:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
    1936:	0e 94 55 2a 	call	0x54aa	; 0x54aa <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    193a:	0e 94 c7 2d 	call	0x5b8e	; 0x5b8e <plan_sync_position>

  // TODO: Update the g-code parser code to not require this target calculation but uses a gc_sync_position() call.
  // NOTE: The target[] variable updated here will be sent back and synced with the g-code parser.
  system_convert_array_steps_to_mpos(target, sys.position);
    193e:	6c e6       	ldi	r22, 0x6C	; 108
    1940:	77 e0       	ldi	r23, 0x07	; 7
    1942:	c6 01       	movw	r24, r12
    1944:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_convert_array_steps_to_mpos>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
    1948:	0e 94 e1 36 	call	0x6dc2	; 0x6dc2 <report_probe_parameters>
  #endif
}
    194c:	df 91       	pop	r29
    194e:	cf 91       	pop	r28
    1950:	1f 91       	pop	r17
    1952:	0f 91       	pop	r16
    1954:	ef 90       	pop	r14
    1956:	df 90       	pop	r13
    1958:	cf 90       	pop	r12
    195a:	bf 90       	pop	r11
    195c:	af 90       	pop	r10
    195e:	9f 90       	pop	r9
    1960:	8f 90       	pop	r8
    1962:	08 95       	ret

00001964 <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
    1964:	80 91 6a 07 	lds	r24, 0x076A
    1968:	84 fd       	sbrc	r24, 4
    196a:	1e c0       	rjmp	.+60     	; 0x19a8 <mc_reset+0x44>
    bit_true_atomic(sys.rt_exec_state, EXEC_RESET);
    196c:	8f b7       	in	r24, 0x3f	; 63
    196e:	f8 94       	cli
    1970:	ea e6       	ldi	r30, 0x6A	; 106
    1972:	f7 e0       	ldi	r31, 0x07	; 7
    1974:	90 81       	ld	r25, Z
    1976:	90 61       	ori	r25, 0x10	; 16
    1978:	90 83       	st	Z, r25
    197a:	8f bf       	out	0x3f, r24	; 63

    // Kill spindle and coolant.   
    spindle_stop();
    197c:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <spindle_stop>
    coolant_stop();
    1980:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING)) || (sys.suspend == SUSPEND_ENABLE_HOLD)) {
    1984:	80 91 68 07 	lds	r24, 0x0768
    1988:	8c 70       	andi	r24, 0x0C	; 12
    198a:	21 f4       	brne	.+8      	; 0x1994 <mc_reset+0x30>
    198c:	80 91 69 07 	lds	r24, 0x0769
    1990:	81 30       	cpi	r24, 0x01	; 1
    1992:	51 f4       	brne	.+20     	; 0x19a8 <mc_reset+0x44>
      bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_ABORT_CYCLE);
    1994:	8f b7       	in	r24, 0x3f	; 63
    1996:	f8 94       	cli
    1998:	eb e6       	ldi	r30, 0x6B	; 107
    199a:	f7 e0       	ldi	r31, 0x07	; 7
    199c:	90 81       	ld	r25, Z
    199e:	98 60       	ori	r25, 0x08	; 8
    19a0:	90 83       	st	Z, r25
    19a2:	8f bf       	out	0x3f, r24	; 63
      st_go_idle(); // Force kill steppers. Position has likely been lost.
    19a4:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <st_go_idle>
    19a8:	08 95       	ret

000019aa <gc_init>:
#define FAIL(status) return(status);


void gc_init() 
{
  memset(&gc_state, 0, sizeof(gc_state));
    19aa:	8f e3       	ldi	r24, 0x3F	; 63
    19ac:	e7 e8       	ldi	r30, 0x87	; 135
    19ae:	f7 e0       	ldi	r31, 0x07	; 7
    19b0:	df 01       	movw	r26, r30
    19b2:	1d 92       	st	X+, r1
    19b4:	8a 95       	dec	r24
    19b6:	e9 f7       	brne	.-6      	; 0x19b2 <gc_init+0x8>
  
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
    19b8:	6a ea       	ldi	r22, 0xAA	; 170
    19ba:	77 e0       	ldi	r23, 0x07	; 7
    19bc:	80 e0       	ldi	r24, 0x00	; 0
    19be:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <settings_read_coord_data>
    19c2:	81 11       	cpse	r24, r1
    19c4:	03 c0       	rjmp	.+6      	; 0x19cc <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL); 
    19c6:	87 e0       	ldi	r24, 0x07	; 7
    19c8:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
    19cc:	08 95       	ret

000019ce <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
    19ce:	6c e6       	ldi	r22, 0x6C	; 108
    19d0:	77 e0       	ldi	r23, 0x07	; 7
    19d2:	8e e9       	ldi	r24, 0x9E	; 158
    19d4:	97 e0       	ldi	r25, 0x07	; 7
    19d6:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_convert_array_steps_to_mpos>
    19da:	08 95       	ret

000019dc <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and 
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine 
// coordinates, respectively.
uint8_t gc_execute_line(char *line) 
{
    19dc:	2f 92       	push	r2
    19de:	3f 92       	push	r3
    19e0:	4f 92       	push	r4
    19e2:	5f 92       	push	r5
    19e4:	6f 92       	push	r6
    19e6:	7f 92       	push	r7
    19e8:	8f 92       	push	r8
    19ea:	9f 92       	push	r9
    19ec:	af 92       	push	r10
    19ee:	bf 92       	push	r11
    19f0:	cf 92       	push	r12
    19f2:	df 92       	push	r13
    19f4:	ef 92       	push	r14
    19f6:	ff 92       	push	r15
    19f8:	0f 93       	push	r16
    19fa:	1f 93       	push	r17
    19fc:	cf 93       	push	r28
    19fe:	df 93       	push	r29
    1a00:	cd b7       	in	r28, 0x3d	; 61
    1a02:	de b7       	in	r29, 0x3e	; 62
    1a04:	ab 97       	sbiw	r28, 0x2b	; 43
    1a06:	0f b6       	in	r0, 0x3f	; 63
    1a08:	f8 94       	cli
    1a0a:	de bf       	out	0x3e, r29	; 62
    1a0c:	0f be       	out	0x3f, r0	; 63
    1a0e:	cd bf       	out	0x3d, r28	; 61
    1a10:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
    1a12:	89 e3       	ldi	r24, 0x39	; 57
    1a14:	e6 ec       	ldi	r30, 0xC6	; 198
    1a16:	f7 e0       	ldi	r31, 0x07	; 7
    1a18:	df 01       	movw	r26, r30
    1a1a:	1d 92       	st	X+, r1
    1a1c:	8a 95       	dec	r24
    1a1e:	e9 f7       	brne	.-6      	; 0x1a1a <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
    1a20:	8a e0       	ldi	r24, 0x0A	; 10
    1a22:	e7 e8       	ldi	r30, 0x87	; 135
    1a24:	f7 e0       	ldi	r31, 0x07	; 7
    1a26:	a7 ec       	ldi	r26, 0xC7	; 199
    1a28:	b7 e0       	ldi	r27, 0x07	; 7
    1a2a:	01 90       	ld	r0, Z+
    1a2c:	0d 92       	st	X+, r0
    1a2e:	8a 95       	dec	r24
    1a30:	e1 f7       	brne	.-8      	; 0x1a2a <gc_execute_line+0x4e>
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also, 
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */
     
  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter = 0;  
    1a32:	19 8e       	std	Y+25, r1	; 0x19
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Value words. 
    1a34:	21 2c       	mov	r2, r1
    1a36:	31 2c       	mov	r3, r1
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
    1a38:	e1 2c       	mov	r14, r1
    1a3a:	f1 2c       	mov	r15, r1
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 
    1a3c:	1b a2       	std	Y+35, r1	; 0x23
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
    1a3e:	1f 8e       	std	Y+31, r1	; 0x1f
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
    1a40:	1e 8e       	std	Y+30, r1	; 0x1e
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1a42:	cc 24       	eor	r12, r12
    1a44:	c3 94       	inc	r12
    1a46:	d1 2c       	mov	r13, r1
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1a48:	0f 2e       	mov	r0, r31
    1a4a:	f1 e6       	ldi	r31, 0x61	; 97
    1a4c:	8f 2e       	mov	r8, r31
    1a4e:	f3 e0       	ldi	r31, 0x03	; 3
    1a50:	9f 2e       	mov	r9, r31
    1a52:	f0 2d       	mov	r31, r0
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1a54:	ad c2       	rjmp	.+1370   	; 0x1fb0 <gc_execute_line+0x5d4>
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    1a56:	9f eb       	ldi	r25, 0xBF	; 191
    1a58:	9b 0d       	add	r25, r11
    1a5a:	9a 31       	cpi	r25, 0x1A	; 26
    1a5c:	10 f0       	brcs	.+4      	; 0x1a62 <gc_execute_line+0x86>
    1a5e:	0c 94 30 17 	jmp	0x2e60	; 0x2e60 <gc_execute_line+0x1484>
    char_counter++;
    1a62:	8f 5f       	subi	r24, 0xFF	; 255
    1a64:	89 8f       	std	Y+25, r24	; 0x19
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    1a66:	ae 01       	movw	r20, r28
    1a68:	46 5e       	subi	r20, 0xE6	; 230
    1a6a:	5f 4f       	sbci	r21, 0xFF	; 255
    1a6c:	be 01       	movw	r22, r28
    1a6e:	67 5e       	subi	r22, 0xE7	; 231
    1a70:	7f 4f       	sbci	r23, 0xFF	; 255
    1a72:	c8 01       	movw	r24, r16
    1a74:	0e 94 0c 2e 	call	0x5c18	; 0x5c18 <read_float>
    1a78:	88 23       	and	r24, r24
    1a7a:	11 f4       	brne	.+4      	; 0x1a80 <gc_execute_line+0xa4>
    1a7c:	0c 94 32 17 	jmp	0x2e64	; 0x2e64 <gc_execute_line+0x1488>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant, 
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later. 
    int_value = trunc(value);
    1a80:	4a 8c       	ldd	r4, Y+26	; 0x1a
    1a82:	5b 8c       	ldd	r5, Y+27	; 0x1b
    1a84:	6c 8c       	ldd	r6, Y+28	; 0x1c
    1a86:	7d 8c       	ldd	r7, Y+29	; 0x1d
    1a88:	c3 01       	movw	r24, r6
    1a8a:	b2 01       	movw	r22, r4
    1a8c:	0e 94 b9 3f 	call	0x7f72	; 0x7f72 <trunc>
    1a90:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
    1a94:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
    1a96:	70 e0       	ldi	r23, 0x00	; 0
    1a98:	80 e0       	ldi	r24, 0x00	; 0
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <__floatsisf>
    1aa0:	9b 01       	movw	r18, r22
    1aa2:	ac 01       	movw	r20, r24
    1aa4:	c3 01       	movw	r24, r6
    1aa6:	b2 01       	movw	r22, r4
    1aa8:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    1aac:	20 e0       	ldi	r18, 0x00	; 0
    1aae:	30 e0       	ldi	r19, 0x00	; 0
    1ab0:	48 ec       	ldi	r20, 0xC8	; 200
    1ab2:	52 e4       	ldi	r21, 0x42	; 66
    1ab4:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    1ab8:	0e 94 4e 3f 	call	0x7e9c	; 0x7e9c <round>
    1abc:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
        // NOTE: Rounding must be used to catch small floating point errors. 

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
    1ac0:	b7 e4       	ldi	r27, 0x47	; 71
    1ac2:	bb 16       	cp	r11, r27
    1ac4:	29 f0       	breq	.+10     	; 0x1ad0 <gc_execute_line+0xf4>
    1ac6:	ed e4       	ldi	r30, 0x4D	; 77
    1ac8:	be 16       	cp	r11, r30
    1aca:	09 f4       	brne	.+2      	; 0x1ace <gc_execute_line+0xf2>
    1acc:	5c c1       	rjmp	.+696    	; 0x1d86 <gc_execute_line+0x3aa>
    1ace:	b9 c1       	rjmp	.+882    	; 0x1e42 <gc_execute_line+0x466>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
         
      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
    1ad0:	8a 2d       	mov	r24, r10
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
    1ad4:	8f 35       	cpi	r24, 0x5F	; 95
    1ad6:	91 05       	cpc	r25, r1
    1ad8:	10 f0       	brcs	.+4      	; 0x1ade <gc_execute_line+0x102>
    1ada:	0c 94 34 17 	jmp	0x2e68	; 0x2e68 <gc_execute_line+0x148c>
    1ade:	fc 01       	movw	r30, r24
    1ae0:	e8 5c       	subi	r30, 0xC8	; 200
    1ae2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ae4:	0c 94 fa 3f 	jmp	0x7ff4	; 0x7ff4 <__tablejump2__>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
    1ae8:	61 15       	cp	r22, r1
    1aea:	71 05       	cpc	r23, r1
    1aec:	31 f4       	brne	.+12     	; 0x1afa <gc_execute_line+0x11e>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1aee:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1af0:	f1 11       	cpse	r31, r1
    1af2:	0c 94 36 17 	jmp	0x2e6c	; 0x2e6c <gc_execute_line+0x1490>
              axis_command = AXIS_COMMAND_NON_MODAL;
    1af6:	21 e0       	ldi	r18, 0x01	; 1
    1af8:	2e 8f       	std	Y+30, r18	; 0x1e
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
    1afa:	3c e1       	ldi	r19, 0x1C	; 28
    1afc:	a3 16       	cp	r10, r19
    1afe:	01 f1       	breq	.+64     	; 0x1b40 <gc_execute_line+0x164>
    1b00:	3a 15       	cp	r19, r10
    1b02:	38 f0       	brcs	.+14     	; 0x1b12 <gc_execute_line+0x136>
    1b04:	84 e0       	ldi	r24, 0x04	; 4
    1b06:	a8 16       	cp	r10, r24
    1b08:	79 f0       	breq	.+30     	; 0x1b28 <gc_execute_line+0x14c>
    1b0a:	9a e0       	ldi	r25, 0x0A	; 10
    1b0c:	a9 16       	cp	r10, r25
    1b0e:	91 f0       	breq	.+36     	; 0x1b34 <gc_execute_line+0x158>
    1b10:	21 c1       	rjmp	.+578    	; 0x1d54 <gc_execute_line+0x378>
    1b12:	a5 e3       	ldi	r26, 0x35	; 53
    1b14:	aa 16       	cp	r10, r26
    1b16:	e1 f1       	breq	.+120    	; 0x1b90 <gc_execute_line+0x1b4>
    1b18:	bc e5       	ldi	r27, 0x5C	; 92
    1b1a:	ab 16       	cp	r10, r27
    1b1c:	09 f4       	brne	.+2      	; 0x1b20 <gc_execute_line+0x144>
    1b1e:	3e c0       	rjmp	.+124    	; 0x1b9c <gc_execute_line+0x1c0>
    1b20:	ee e1       	ldi	r30, 0x1E	; 30
    1b22:	ae 12       	cpse	r10, r30
    1b24:	17 c1       	rjmp	.+558    	; 0x1d54 <gc_execute_line+0x378>
    1b26:	20 c0       	rjmp	.+64     	; 0x1b68 <gc_execute_line+0x18c>
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
    1b28:	81 e0       	ldi	r24, 0x01	; 1
    1b2a:	a6 ec       	ldi	r26, 0xC6	; 198
    1b2c:	b7 e0       	ldi	r27, 0x07	; 7
    1b2e:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b30:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
    1b32:	15 c1       	rjmp	.+554    	; 0x1d5e <gc_execute_line+0x382>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
    1b34:	82 e0       	ldi	r24, 0x02	; 2
    1b36:	e6 ec       	ldi	r30, 0xC6	; 198
    1b38:	f7 e0       	ldi	r31, 0x07	; 7
    1b3a:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b3c:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
    1b3e:	0f c1       	rjmp	.+542    	; 0x1d5e <gc_execute_line+0x382>
              case 28:
                switch(mantissa) {
    1b40:	61 15       	cp	r22, r1
    1b42:	71 05       	cpc	r23, r1
    1b44:	29 f0       	breq	.+10     	; 0x1b50 <gc_execute_line+0x174>
    1b46:	6a 30       	cpi	r22, 0x0A	; 10
    1b48:	71 05       	cpc	r23, r1
    1b4a:	41 f0       	breq	.+16     	; 0x1b5c <gc_execute_line+0x180>
    1b4c:	0c 94 38 17 	jmp	0x2e70	; 0x2e70 <gc_execute_line+0x1494>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
    1b50:	83 e0       	ldi	r24, 0x03	; 3
    1b52:	a6 ec       	ldi	r26, 0xC6	; 198
    1b54:	b7 e0       	ldi	r27, 0x07	; 7
    1b56:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b58:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
    1b5a:	05 c1       	rjmp	.+522    	; 0x1d66 <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
    1b5c:	84 e0       	ldi	r24, 0x04	; 4
    1b5e:	e6 ec       	ldi	r30, 0xC6	; 198
    1b60:	f7 e0       	ldi	r31, 0x07	; 7
    1b62:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b64:	80 e0       	ldi	r24, 0x00	; 0
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
    1b66:	ff c0       	rjmp	.+510    	; 0x1d66 <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
    1b68:	61 15       	cp	r22, r1
    1b6a:	71 05       	cpc	r23, r1
    1b6c:	29 f0       	breq	.+10     	; 0x1b78 <gc_execute_line+0x19c>
    1b6e:	6a 30       	cpi	r22, 0x0A	; 10
    1b70:	71 05       	cpc	r23, r1
    1b72:	41 f0       	breq	.+16     	; 0x1b84 <gc_execute_line+0x1a8>
    1b74:	0c 94 3a 17 	jmp	0x2e74	; 0x2e74 <gc_execute_line+0x1498>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
    1b78:	85 e0       	ldi	r24, 0x05	; 5
    1b7a:	a6 ec       	ldi	r26, 0xC6	; 198
    1b7c:	b7 e0       	ldi	r27, 0x07	; 7
    1b7e:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b80:	80 e0       	ldi	r24, 0x00	; 0
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
    1b82:	f1 c0       	rjmp	.+482    	; 0x1d66 <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
    1b84:	86 e0       	ldi	r24, 0x06	; 6
    1b86:	e6 ec       	ldi	r30, 0xC6	; 198
    1b88:	f7 e0       	ldi	r31, 0x07	; 7
    1b8a:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b8c:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
    1b8e:	eb c0       	rjmp	.+470    	; 0x1d66 <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
    1b90:	87 e0       	ldi	r24, 0x07	; 7
    1b92:	a6 ec       	ldi	r26, 0xC6	; 198
    1b94:	b7 e0       	ldi	r27, 0x07	; 7
    1b96:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b98:	80 e0       	ldi	r24, 0x00	; 0
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
    1b9a:	e1 c0       	rjmp	.+450    	; 0x1d5e <gc_execute_line+0x382>
              case 92: 
                switch(mantissa) {
    1b9c:	61 15       	cp	r22, r1
    1b9e:	71 05       	cpc	r23, r1
    1ba0:	29 f0       	breq	.+10     	; 0x1bac <gc_execute_line+0x1d0>
    1ba2:	6a 30       	cpi	r22, 0x0A	; 10
    1ba4:	71 05       	cpc	r23, r1
    1ba6:	41 f0       	breq	.+16     	; 0x1bb8 <gc_execute_line+0x1dc>
    1ba8:	0c 94 3c 17 	jmp	0x2e78	; 0x2e78 <gc_execute_line+0x149c>
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
    1bac:	88 e0       	ldi	r24, 0x08	; 8
    1bae:	e6 ec       	ldi	r30, 0xC6	; 198
    1bb0:	f7 e0       	ldi	r31, 0x07	; 7
    1bb2:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1bb4:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
    1bb6:	d7 c0       	rjmp	.+430    	; 0x1d66 <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
    1bb8:	89 e0       	ldi	r24, 0x09	; 9
    1bba:	a6 ec       	ldi	r26, 0xC6	; 198
    1bbc:	b7 e0       	ldi	r27, 0x07	; 7
    1bbe:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1bc0:	80 e0       	ldi	r24, 0x00	; 0
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
    1bc2:	d1 c0       	rjmp	.+418    	; 0x1d66 <gc_execute_line+0x38a>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1bc4:	be 8d       	ldd	r27, Y+30	; 0x1e
    1bc6:	b1 11       	cpse	r27, r1
    1bc8:	0c 94 3e 17 	jmp	0x2e7c	; 0x2e7c <gc_execute_line+0x14a0>
            axis_command = AXIS_COMMAND_MOTION_MODE; 
    1bcc:	e2 e0       	ldi	r30, 0x02	; 2
    1bce:	ee 8f       	std	Y+30, r30	; 0x1e
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
            switch(int_value) {
    1bd0:	f2 e0       	ldi	r31, 0x02	; 2
    1bd2:	af 16       	cp	r10, r31
    1bd4:	e9 f0       	breq	.+58     	; 0x1c10 <gc_execute_line+0x234>
    1bd6:	fa 15       	cp	r31, r10
    1bd8:	30 f0       	brcs	.+12     	; 0x1be6 <gc_execute_line+0x20a>
    1bda:	aa 20       	and	r10, r10
    1bdc:	79 f0       	breq	.+30     	; 0x1bfc <gc_execute_line+0x220>
    1bde:	21 e0       	ldi	r18, 0x01	; 1
    1be0:	a2 16       	cp	r10, r18
    1be2:	89 f0       	breq	.+34     	; 0x1c06 <gc_execute_line+0x22a>
    1be4:	b9 c0       	rjmp	.+370    	; 0x1d58 <gc_execute_line+0x37c>
    1be6:	36 e2       	ldi	r19, 0x26	; 38
    1be8:	a3 16       	cp	r10, r19
    1bea:	f1 f0       	breq	.+60     	; 0x1c28 <gc_execute_line+0x24c>
    1bec:	80 e5       	ldi	r24, 0x50	; 80
    1bee:	a8 16       	cp	r10, r24
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <gc_execute_line+0x218>
    1bf2:	43 c0       	rjmp	.+134    	; 0x1c7a <gc_execute_line+0x29e>
    1bf4:	93 e0       	ldi	r25, 0x03	; 3
    1bf6:	a9 12       	cpse	r10, r25
    1bf8:	af c0       	rjmp	.+350    	; 0x1d58 <gc_execute_line+0x37c>
    1bfa:	10 c0       	rjmp	.+32     	; 0x1c1c <gc_execute_line+0x240>
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
    1bfc:	a7 ec       	ldi	r26, 0xC7	; 199
    1bfe:	b7 e0       	ldi	r27, 0x07	; 7
    1c00:	1c 92       	st	X, r1
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c02:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
    1c04:	ac c0       	rjmp	.+344    	; 0x1d5e <gc_execute_line+0x382>
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
    1c06:	81 e0       	ldi	r24, 0x01	; 1
    1c08:	e7 ec       	ldi	r30, 0xC7	; 199
    1c0a:	f7 e0       	ldi	r31, 0x07	; 7
    1c0c:	80 83       	st	Z, r24
    1c0e:	a7 c0       	rjmp	.+334    	; 0x1d5e <gc_execute_line+0x382>
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
    1c10:	82 e0       	ldi	r24, 0x02	; 2
    1c12:	a7 ec       	ldi	r26, 0xC7	; 199
    1c14:	b7 e0       	ldi	r27, 0x07	; 7
    1c16:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c18:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
    1c1a:	a1 c0       	rjmp	.+322    	; 0x1d5e <gc_execute_line+0x382>
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
    1c1c:	83 e0       	ldi	r24, 0x03	; 3
    1c1e:	e7 ec       	ldi	r30, 0xC7	; 199
    1c20:	f7 e0       	ldi	r31, 0x07	; 7
    1c22:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c24:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
    1c26:	9b c0       	rjmp	.+310    	; 0x1d5e <gc_execute_line+0x382>
              case 38: 
                switch(mantissa) {
    1c28:	6e 31       	cpi	r22, 0x1E	; 30
    1c2a:	71 05       	cpc	r23, r1
    1c2c:	a1 f0       	breq	.+40     	; 0x1c56 <gc_execute_line+0x27a>
    1c2e:	28 f4       	brcc	.+10     	; 0x1c3a <gc_execute_line+0x25e>
    1c30:	64 31       	cpi	r22, 0x14	; 20
    1c32:	71 05       	cpc	r23, r1
    1c34:	51 f0       	breq	.+20     	; 0x1c4a <gc_execute_line+0x26e>
    1c36:	0c 94 40 17 	jmp	0x2e80	; 0x2e80 <gc_execute_line+0x14a4>
    1c3a:	68 32       	cpi	r22, 0x28	; 40
    1c3c:	71 05       	cpc	r23, r1
    1c3e:	89 f0       	breq	.+34     	; 0x1c62 <gc_execute_line+0x286>
    1c40:	62 33       	cpi	r22, 0x32	; 50
    1c42:	71 05       	cpc	r23, r1
    1c44:	a1 f0       	breq	.+40     	; 0x1c6e <gc_execute_line+0x292>
    1c46:	0c 94 40 17 	jmp	0x2e80	; 0x2e80 <gc_execute_line+0x14a4>
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
    1c4a:	84 e0       	ldi	r24, 0x04	; 4
    1c4c:	a7 ec       	ldi	r26, 0xC7	; 199
    1c4e:	b7 e0       	ldi	r27, 0x07	; 7
    1c50:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c52:	81 e0       	ldi	r24, 0x01	; 1
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
    1c54:	88 c0       	rjmp	.+272    	; 0x1d66 <gc_execute_line+0x38a>
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
    1c56:	85 e0       	ldi	r24, 0x05	; 5
    1c58:	e7 ec       	ldi	r30, 0xC7	; 199
    1c5a:	f7 e0       	ldi	r31, 0x07	; 7
    1c5c:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c5e:	81 e0       	ldi	r24, 0x01	; 1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
    1c60:	82 c0       	rjmp	.+260    	; 0x1d66 <gc_execute_line+0x38a>
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
    1c62:	86 e0       	ldi	r24, 0x06	; 6
    1c64:	a7 ec       	ldi	r26, 0xC7	; 199
    1c66:	b7 e0       	ldi	r27, 0x07	; 7
    1c68:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
    1c6c:	7c c0       	rjmp	.+248    	; 0x1d66 <gc_execute_line+0x38a>
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
    1c6e:	87 e0       	ldi	r24, 0x07	; 7
    1c70:	e7 ec       	ldi	r30, 0xC7	; 199
    1c72:	f7 e0       	ldi	r31, 0x07	; 7
    1c74:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c76:	81 e0       	ldi	r24, 0x01	; 1
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
    1c78:	76 c0       	rjmp	.+236    	; 0x1d66 <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
    1c7a:	88 e0       	ldi	r24, 0x08	; 8
    1c7c:	a7 ec       	ldi	r26, 0xC7	; 199
    1c7e:	b7 e0       	ldi	r27, 0x07	; 7
    1c80:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c82:	81 e0       	ldi	r24, 0x01	; 1
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
    1c84:	6c c0       	rjmp	.+216    	; 0x1d5e <gc_execute_line+0x382>
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
            switch(int_value) {
    1c86:	b2 e1       	ldi	r27, 0x12	; 18
    1c88:	ab 16       	cp	r10, r27
    1c8a:	59 f0       	breq	.+22     	; 0x1ca2 <gc_execute_line+0x2c6>
    1c8c:	e3 e1       	ldi	r30, 0x13	; 19
    1c8e:	ae 16       	cp	r10, r30
    1c90:	71 f0       	breq	.+28     	; 0x1cae <gc_execute_line+0x2d2>
    1c92:	f1 e1       	ldi	r31, 0x11	; 17
    1c94:	af 12       	cpse	r10, r31
    1c96:	62 c0       	rjmp	.+196    	; 0x1d5c <gc_execute_line+0x380>
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
    1c98:	ab ec       	ldi	r26, 0xCB	; 203
    1c9a:	b7 e0       	ldi	r27, 0x07	; 7
    1c9c:	1c 92       	st	X, r1
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1c9e:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
    1ca0:	5e c0       	rjmp	.+188    	; 0x1d5e <gc_execute_line+0x382>
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	eb ec       	ldi	r30, 0xCB	; 203
    1ca6:	f7 e0       	ldi	r31, 0x07	; 7
    1ca8:	80 83       	st	Z, r24
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1caa:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
    1cac:	58 c0       	rjmp	.+176    	; 0x1d5e <gc_execute_line+0x382>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
    1cae:	82 e0       	ldi	r24, 0x02	; 2
    1cb0:	ab ec       	ldi	r26, 0xCB	; 203
    1cb2:	b7 e0       	ldi	r27, 0x07	; 7
    1cb4:	8c 93       	st	X, r24
    1cb6:	53 c0       	rjmp	.+166    	; 0x1d5e <gc_execute_line+0x382>
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
    1cb8:	ba e5       	ldi	r27, 0x5A	; 90
    1cba:	ab 12       	cpse	r10, r27
    1cbc:	05 c0       	rjmp	.+10     	; 0x1cc8 <gc_execute_line+0x2ec>
    1cbe:	ea ec       	ldi	r30, 0xCA	; 202
    1cc0:	f7 e0       	ldi	r31, 0x07	; 7
    1cc2:	10 82       	st	Z, r1
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
    1cc4:	83 e0       	ldi	r24, 0x03	; 3
    1cc6:	4b c0       	rjmp	.+150    	; 0x1d5e <gc_execute_line+0x382>
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
    1cc8:	81 e0       	ldi	r24, 0x01	; 1
    1cca:	aa ec       	ldi	r26, 0xCA	; 202
    1ccc:	b7 e0       	ldi	r27, 0x07	; 7
    1cce:	8c 93       	st	X, r24
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
    1cd0:	83 e0       	ldi	r24, 0x03	; 3
    1cd2:	45 c0       	rjmp	.+138    	; 0x1d5e <gc_execute_line+0x382>
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
    1cd4:	bd e5       	ldi	r27, 0x5D	; 93
    1cd6:	ab 12       	cpse	r10, r27
    1cd8:	06 c0       	rjmp	.+12     	; 0x1ce6 <gc_execute_line+0x30a>
    1cda:	81 e0       	ldi	r24, 0x01	; 1
    1cdc:	e8 ec       	ldi	r30, 0xC8	; 200
    1cde:	f7 e0       	ldi	r31, 0x07	; 7
    1ce0:	80 83       	st	Z, r24
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
    1ce2:	84 e0       	ldi	r24, 0x04	; 4
    1ce4:	3c c0       	rjmp	.+120    	; 0x1d5e <gc_execute_line+0x382>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
    1ce6:	a8 ec       	ldi	r26, 0xC8	; 200
    1ce8:	b7 e0       	ldi	r27, 0x07	; 7
    1cea:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
    1cec:	84 e0       	ldi	r24, 0x04	; 4
    1cee:	37 c0       	rjmp	.+110    	; 0x1d5e <gc_execute_line+0x382>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
    1cf0:	b4 e1       	ldi	r27, 0x14	; 20
    1cf2:	ab 12       	cpse	r10, r27
    1cf4:	06 c0       	rjmp	.+12     	; 0x1d02 <gc_execute_line+0x326>
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	e9 ec       	ldi	r30, 0xC9	; 201
    1cfa:	f7 e0       	ldi	r31, 0x07	; 7
    1cfc:	80 83       	st	Z, r24
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
    1cfe:	85 e0       	ldi	r24, 0x05	; 5
    1d00:	2e c0       	rjmp	.+92     	; 0x1d5e <gc_execute_line+0x382>
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
    1d02:	a9 ec       	ldi	r26, 0xC9	; 201
    1d04:	b7 e0       	ldi	r27, 0x07	; 7
    1d06:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
    1d08:	85 e0       	ldi	r24, 0x05	; 5
    1d0a:	29 c0       	rjmp	.+82     	; 0x1d5e <gc_execute_line+0x382>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    1d0c:	be 8d       	ldd	r27, Y+30	; 0x1e
    1d0e:	b1 11       	cpse	r27, r1
    1d10:	0c 94 42 17 	jmp	0x2e84	; 0x2e84 <gc_execute_line+0x14a8>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
    1d14:	e1 e3       	ldi	r30, 0x31	; 49
    1d16:	ae 12       	cpse	r10, r30
    1d18:	07 c0       	rjmp	.+14     	; 0x1d28 <gc_execute_line+0x34c>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
    1d1a:	ac ec       	ldi	r26, 0xCC	; 204
    1d1c:	b7 e0       	ldi	r27, 0x07	; 7
    1d1e:	1c 92       	st	X, r1
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1d20:	87 e0       	ldi	r24, 0x07	; 7
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1d22:	b3 e0       	ldi	r27, 0x03	; 3
    1d24:	be 8f       	std	Y+30, r27	; 0x1e
    1d26:	1f c0       	rjmp	.+62     	; 0x1d66 <gc_execute_line+0x38a>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
    1d28:	6a 30       	cpi	r22, 0x0A	; 10
    1d2a:	71 05       	cpc	r23, r1
    1d2c:	11 f0       	breq	.+4      	; 0x1d32 <gc_execute_line+0x356>
    1d2e:	0c 94 44 17 	jmp	0x2e88	; 0x2e88 <gc_execute_line+0x14ac>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    1d32:	81 e0       	ldi	r24, 0x01	; 1
    1d34:	ec ec       	ldi	r30, 0xCC	; 204
    1d36:	f7 e0       	ldi	r31, 0x07	; 7
    1d38:	80 83       	st	Z, r24
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1d3a:	87 e0       	ldi	r24, 0x07	; 7
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1d3c:	f3 e0       	ldi	r31, 0x03	; 3
    1d3e:	fe 8f       	std	Y+30, r31	; 0x1e
    1d40:	12 c0       	rjmp	.+36     	; 0x1d66 <gc_execute_line+0x38a>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
    1d42:	8a ec       	ldi	r24, 0xCA	; 202
    1d44:	8a 0d       	add	r24, r10
    1d46:	ad ec       	ldi	r26, 0xCD	; 205
    1d48:	b7 e0       	ldi	r27, 0x07	; 7
    1d4a:	8c 93       	st	X, r24
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    1d4c:	88 e0       	ldi	r24, 0x08	; 8
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
    1d4e:	07 c0       	rjmp	.+14     	; 0x1d5e <gc_execute_line+0x382>
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
    1d50:	86 e0       	ldi	r24, 0x06	; 6
    1d52:	05 c0       	rjmp	.+10     	; 0x1d5e <gc_execute_line+0x382>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1d54:	80 e0       	ldi	r24, 0x00	; 0
    1d56:	03 c0       	rjmp	.+6      	; 0x1d5e <gc_execute_line+0x382>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1d58:	81 e0       	ldi	r24, 0x01	; 1
    1d5a:	01 c0       	rjmp	.+2      	; 0x1d5e <gc_execute_line+0x382>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1d5c:	82 e0       	ldi	r24, 0x02	; 2
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1d5e:	67 2b       	or	r22, r23
    1d60:	11 f0       	breq	.+4      	; 0x1d66 <gc_execute_line+0x38a>
    1d62:	0c 94 46 17 	jmp	0x2e8c	; 0x2e8c <gc_execute_line+0x14b0>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1d66:	f6 01       	movw	r30, r12
    1d68:	02 c0       	rjmp	.+4      	; 0x1d6e <gc_execute_line+0x392>
    1d6a:	ee 0f       	add	r30, r30
    1d6c:	ff 1f       	adc	r31, r31
    1d6e:	8a 95       	dec	r24
    1d70:	e2 f7       	brpl	.-8      	; 0x1d6a <gc_execute_line+0x38e>
    1d72:	9f 01       	movw	r18, r30
    1d74:	2e 21       	and	r18, r14
    1d76:	3f 21       	and	r19, r15
    1d78:	23 2b       	or	r18, r19
    1d7a:	11 f0       	breq	.+4      	; 0x1d80 <gc_execute_line+0x3a4>
    1d7c:	0c 94 48 17 	jmp	0x2e90	; 0x2e90 <gc_execute_line+0x14b4>
        command_words |= bit(word_bit);
    1d80:	ee 2a       	or	r14, r30
    1d82:	ff 2a       	or	r15, r31
        break;
    1d84:	15 c1       	rjmp	.+554    	; 0x1fb0 <gc_execute_line+0x5d4>
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    1d86:	67 2b       	or	r22, r23
    1d88:	11 f0       	breq	.+4      	; 0x1d8e <gc_execute_line+0x3b2>
    1d8a:	0c 94 4a 17 	jmp	0x2e94	; 0x2e94 <gc_execute_line+0x14b8>
        switch(int_value) {
    1d8e:	8a 2d       	mov	r24, r10
    1d90:	90 e0       	ldi	r25, 0x00	; 0
    1d92:	8f 31       	cpi	r24, 0x1F	; 31
    1d94:	91 05       	cpc	r25, r1
    1d96:	10 f0       	brcs	.+4      	; 0x1d9c <gc_execute_line+0x3c0>
    1d98:	0c 94 4c 17 	jmp	0x2e98	; 0x2e98 <gc_execute_line+0x14bc>
    1d9c:	fc 01       	movw	r30, r24
    1d9e:	e9 56       	subi	r30, 0x69	; 105
    1da0:	ff 4f       	sbci	r31, 0xFF	; 255
    1da2:	0c 94 fa 3f 	jmp	0x7ff4	; 0x7ff4 <__tablejump2__>
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
            switch(int_value) {
    1da6:	f2 e0       	ldi	r31, 0x02	; 2
    1da8:	af 16       	cp	r10, r31
    1daa:	51 f0       	breq	.+20     	; 0x1dc0 <gc_execute_line+0x3e4>
    1dac:	2e e1       	ldi	r18, 0x1E	; 30
    1dae:	a2 16       	cp	r10, r18
    1db0:	39 f0       	breq	.+14     	; 0x1dc0 <gc_execute_line+0x3e4>
    1db2:	a1 10       	cpse	r10, r1
    1db4:	31 c0       	rjmp	.+98     	; 0x1e18 <gc_execute_line+0x43c>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1db6:	81 e0       	ldi	r24, 0x01	; 1
    1db8:	80 93 ce 07 	sts	0x07CE, r24
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1dbc:	89 e0       	ldi	r24, 0x09	; 9
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1dbe:	31 c0       	rjmp	.+98     	; 0x1e22 <gc_execute_line+0x446>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1dc0:	82 e0       	ldi	r24, 0x02	; 2
    1dc2:	80 93 ce 07 	sts	0x07CE, r24
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1dc6:	89 e0       	ldi	r24, 0x09	; 9
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1dc8:	2c c0       	rjmp	.+88     	; 0x1e22 <gc_execute_line+0x446>
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
            switch(int_value) {
    1dca:	34 e0       	ldi	r19, 0x04	; 4
    1dcc:	a3 16       	cp	r10, r19
    1dce:	59 f0       	breq	.+22     	; 0x1de6 <gc_execute_line+0x40a>
    1dd0:	85 e0       	ldi	r24, 0x05	; 5
    1dd2:	a8 16       	cp	r10, r24
    1dd4:	69 f0       	breq	.+26     	; 0x1df0 <gc_execute_line+0x414>
    1dd6:	93 e0       	ldi	r25, 0x03	; 3
    1dd8:	a9 12       	cpse	r10, r25
    1dda:	20 c0       	rjmp	.+64     	; 0x1e1c <gc_execute_line+0x440>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	80 93 d0 07 	sts	0x07D0, r24
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1de2:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1de4:	1e c0       	rjmp	.+60     	; 0x1e22 <gc_execute_line+0x446>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1de6:	82 e0       	ldi	r24, 0x02	; 2
    1de8:	80 93 d0 07 	sts	0x07D0, r24
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1dec:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1dee:	19 c0       	rjmp	.+50     	; 0x1e22 <gc_execute_line+0x446>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1df0:	10 92 d0 07 	sts	0x07D0, r1
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1df4:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1df6:	15 c0       	rjmp	.+42     	; 0x1e22 <gc_execute_line+0x446>
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    1df8:	a8 e0       	ldi	r26, 0x08	; 8
    1dfa:	aa 16       	cp	r10, r26
    1dfc:	21 f0       	breq	.+8      	; 0x1e06 <gc_execute_line+0x42a>
    1dfe:	b9 e0       	ldi	r27, 0x09	; 9
    1e00:	ab 16       	cp	r10, r27
    1e02:	31 f0       	breq	.+12     	; 0x1e10 <gc_execute_line+0x434>
    1e04:	0d c0       	rjmp	.+26     	; 0x1e20 <gc_execute_line+0x444>
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1e06:	82 e0       	ldi	r24, 0x02	; 2
    1e08:	80 93 cf 07 	sts	0x07CF, r24
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1e0c:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1e0e:	09 c0       	rjmp	.+18     	; 0x1e22 <gc_execute_line+0x446>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1e10:	10 92 cf 07 	sts	0x07CF, r1
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1e14:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1e16:	05 c0       	rjmp	.+10     	; 0x1e22 <gc_execute_line+0x446>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1e18:	89 e0       	ldi	r24, 0x09	; 9
    1e1a:	03 c0       	rjmp	.+6      	; 0x1e22 <gc_execute_line+0x446>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1e1c:	8a e0       	ldi	r24, 0x0A	; 10
    1e1e:	01 c0       	rjmp	.+2      	; 0x1e22 <gc_execute_line+0x446>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1e20:	8b e0       	ldi	r24, 0x0B	; 11
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1e22:	f6 01       	movw	r30, r12
    1e24:	02 c0       	rjmp	.+4      	; 0x1e2a <gc_execute_line+0x44e>
    1e26:	ee 0f       	add	r30, r30
    1e28:	ff 1f       	adc	r31, r31
    1e2a:	8a 95       	dec	r24
    1e2c:	e2 f7       	brpl	.-8      	; 0x1e26 <gc_execute_line+0x44a>
    1e2e:	9f 01       	movw	r18, r30
    1e30:	2e 21       	and	r18, r14
    1e32:	3f 21       	and	r19, r15
    1e34:	23 2b       	or	r18, r19
    1e36:	11 f0       	breq	.+4      	; 0x1e3c <gc_execute_line+0x460>
    1e38:	0c 94 4e 17 	jmp	0x2e9c	; 0x2e9c <gc_execute_line+0x14c0>
        command_words |= bit(word_bit);
    1e3c:	ee 2a       	or	r14, r30
    1e3e:	ff 2a       	or	r15, r31
        break;
    1e40:	b7 c0       	rjmp	.+366    	; 0x1fb0 <gc_execute_line+0x5d4>
      default: 
  
        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    1e42:	8b 2d       	mov	r24, r11
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	fc 01       	movw	r30, r24
    1e48:	e6 54       	subi	r30, 0x46	; 70
    1e4a:	f1 09       	sbc	r31, r1
    1e4c:	e5 31       	cpi	r30, 0x15	; 21
    1e4e:	f1 05       	cpc	r31, r1
    1e50:	10 f0       	brcs	.+4      	; 0x1e56 <gc_execute_line+0x47a>
    1e52:	0c 94 50 17 	jmp	0x2ea0	; 0x2ea0 <gc_execute_line+0x14c4>
    1e56:	ea 54       	subi	r30, 0x4A	; 74
    1e58:	ff 4f       	sbci	r31, 0xFF	; 255
    1e5a:	0c 94 fa 3f 	jmp	0x7ff4	; 0x7ff4 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    1e5e:	40 92 d1 07 	sts	0x07D1, r4
    1e62:	50 92 d2 07 	sts	0x07D2, r5
    1e66:	60 92 d3 07 	sts	0x07D3, r6
    1e6a:	70 92 d4 07 	sts	0x07D4, r7
    1e6e:	20 e0       	ldi	r18, 0x00	; 0
    1e70:	7e c0       	rjmp	.+252    	; 0x1f6e <gc_execute_line+0x592>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    1e72:	40 92 d5 07 	sts	0x07D5, r4
    1e76:	50 92 d6 07 	sts	0x07D6, r5
    1e7a:	60 92 d7 07 	sts	0x07D7, r6
    1e7e:	70 92 d8 07 	sts	0x07D8, r7
    1e82:	fb a1       	ldd	r31, Y+35	; 0x23
    1e84:	f1 60       	ori	r31, 0x01	; 1
    1e86:	fb a3       	std	Y+35, r31	; 0x23
    1e88:	21 e0       	ldi	r18, 0x01	; 1
    1e8a:	71 c0       	rjmp	.+226    	; 0x1f6e <gc_execute_line+0x592>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    1e8c:	40 92 d9 07 	sts	0x07D9, r4
    1e90:	50 92 da 07 	sts	0x07DA, r5
    1e94:	60 92 db 07 	sts	0x07DB, r6
    1e98:	70 92 dc 07 	sts	0x07DC, r7
    1e9c:	2b a1       	ldd	r18, Y+35	; 0x23
    1e9e:	22 60       	ori	r18, 0x02	; 2
    1ea0:	2b a3       	std	Y+35, r18	; 0x23
    1ea2:	22 e0       	ldi	r18, 0x02	; 2
    1ea4:	64 c0       	rjmp	.+200    	; 0x1f6e <gc_execute_line+0x592>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    1ea6:	40 92 dd 07 	sts	0x07DD, r4
    1eaa:	50 92 de 07 	sts	0x07DE, r5
    1eae:	60 92 df 07 	sts	0x07DF, r6
    1eb2:	70 92 e0 07 	sts	0x07E0, r7
    1eb6:	3b a1       	ldd	r19, Y+35	; 0x23
    1eb8:	34 60       	ori	r19, 0x04	; 4
    1eba:	3b a3       	std	Y+35, r19	; 0x23
    1ebc:	23 e0       	ldi	r18, 0x03	; 3
    1ebe:	57 c0       	rjmp	.+174    	; 0x1f6e <gc_execute_line+0x592>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    1ec0:	a0 92 e1 07 	sts	0x07E1, r10
    1ec4:	24 e0       	ldi	r18, 0x04	; 4
    1ec6:	53 c0       	rjmp	.+166    	; 0x1f6e <gc_execute_line+0x592>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    1ec8:	c3 01       	movw	r24, r6
    1eca:	b2 01       	movw	r22, r4
    1ecc:	0e 94 1c 3d 	call	0x7a38	; 0x7a38 <__fixsfsi>
    1ed0:	60 93 e2 07 	sts	0x07E2, r22
    1ed4:	70 93 e3 07 	sts	0x07E3, r23
    1ed8:	80 93 e4 07 	sts	0x07E4, r24
    1edc:	90 93 e5 07 	sts	0x07E5, r25
    1ee0:	25 e0       	ldi	r18, 0x05	; 5
    1ee2:	45 c0       	rjmp	.+138    	; 0x1f6e <gc_execute_line+0x592>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    1ee4:	40 92 e6 07 	sts	0x07E6, r4
    1ee8:	50 92 e7 07 	sts	0x07E7, r5
    1eec:	60 92 e8 07 	sts	0x07E8, r6
    1ef0:	70 92 e9 07 	sts	0x07E9, r7
    1ef4:	26 e0       	ldi	r18, 0x06	; 6
    1ef6:	3b c0       	rjmp	.+118    	; 0x1f6e <gc_execute_line+0x592>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1ef8:	40 92 ea 07 	sts	0x07EA, r4
    1efc:	50 92 eb 07 	sts	0x07EB, r5
    1f00:	60 92 ec 07 	sts	0x07EC, r6
    1f04:	70 92 ed 07 	sts	0x07ED, r7
    1f08:	27 e0       	ldi	r18, 0x07	; 7
    1f0a:	31 c0       	rjmp	.+98     	; 0x1f6e <gc_execute_line+0x592>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    1f0c:	40 92 ee 07 	sts	0x07EE, r4
    1f10:	50 92 ef 07 	sts	0x07EF, r5
    1f14:	60 92 f0 07 	sts	0x07F0, r6
    1f18:	70 92 f1 07 	sts	0x07F1, r7
    1f1c:	28 e0       	ldi	r18, 0x08	; 8
    1f1e:	27 c0       	rjmp	.+78     	; 0x1f6e <gc_execute_line+0x592>
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    1f20:	40 92 f3 07 	sts	0x07F3, r4
    1f24:	50 92 f4 07 	sts	0x07F4, r5
    1f28:	60 92 f5 07 	sts	0x07F5, r6
    1f2c:	70 92 f6 07 	sts	0x07F6, r7
    1f30:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1f32:	81 60       	ori	r24, 0x01	; 1
    1f34:	8f 8f       	std	Y+31, r24	; 0x1f
    1f36:	2a e0       	ldi	r18, 0x0A	; 10
    1f38:	1a c0       	rjmp	.+52     	; 0x1f6e <gc_execute_line+0x592>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    1f3a:	40 92 f7 07 	sts	0x07F7, r4
    1f3e:	50 92 f8 07 	sts	0x07F8, r5
    1f42:	60 92 f9 07 	sts	0x07F9, r6
    1f46:	70 92 fa 07 	sts	0x07FA, r7
    1f4a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1f4c:	92 60       	ori	r25, 0x02	; 2
    1f4e:	9f 8f       	std	Y+31, r25	; 0x1f
    1f50:	2b e0       	ldi	r18, 0x0B	; 11
    1f52:	0d c0       	rjmp	.+26     	; 0x1f6e <gc_execute_line+0x592>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    1f54:	ab ef       	ldi	r26, 0xFB	; 251
    1f56:	b7 e0       	ldi	r27, 0x07	; 7
    1f58:	4d 92       	st	X+, r4
    1f5a:	5d 92       	st	X+, r5
    1f5c:	6d 92       	st	X+, r6
    1f5e:	7c 92       	st	X, r7
    1f60:	13 97       	sbiw	r26, 0x03	; 3
    1f62:	bf 8d       	ldd	r27, Y+31	; 0x1f
    1f64:	b4 60       	ori	r27, 0x04	; 4
    1f66:	bf 8f       	std	Y+31, r27	; 0x1f
    1f68:	2c e0       	ldi	r18, 0x0C	; 12
    1f6a:	01 c0       	rjmp	.+2      	; 0x1f6e <gc_execute_line+0x592>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
    1f6c:	29 e0       	ldi	r18, 0x09	; 9
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1f6e:	56 01       	movw	r10, r12
    1f70:	02 2e       	mov	r0, r18
    1f72:	02 c0       	rjmp	.+4      	; 0x1f78 <gc_execute_line+0x59c>
    1f74:	aa 0c       	add	r10, r10
    1f76:	bb 1c       	adc	r11, r11
    1f78:	0a 94       	dec	r0
    1f7a:	e2 f7       	brpl	.-8      	; 0x1f74 <gc_execute_line+0x598>
    1f7c:	c5 01       	movw	r24, r10
    1f7e:	82 21       	and	r24, r2
    1f80:	93 21       	and	r25, r3
    1f82:	89 2b       	or	r24, r25
    1f84:	09 f0       	breq	.+2      	; 0x1f88 <gc_execute_line+0x5ac>
    1f86:	8e c7       	rjmp	.+3868   	; 0x2ea4 <gc_execute_line+0x14c8>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1f88:	c4 01       	movw	r24, r8
    1f8a:	02 c0       	rjmp	.+4      	; 0x1f90 <gc_execute_line+0x5b4>
    1f8c:	95 95       	asr	r25
    1f8e:	87 95       	ror	r24
    1f90:	2a 95       	dec	r18
    1f92:	e2 f7       	brpl	.-8      	; 0x1f8c <gc_execute_line+0x5b0>
    1f94:	80 ff       	sbrs	r24, 0
    1f96:	0a c0       	rjmp	.+20     	; 0x1fac <gc_execute_line+0x5d0>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    1f98:	20 e0       	ldi	r18, 0x00	; 0
    1f9a:	30 e0       	ldi	r19, 0x00	; 0
    1f9c:	a9 01       	movw	r20, r18
    1f9e:	c3 01       	movw	r24, r6
    1fa0:	b2 01       	movw	r22, r4
    1fa2:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    1fa6:	88 23       	and	r24, r24
    1fa8:	0c f4       	brge	.+2      	; 0x1fac <gc_execute_line+0x5d0>
    1faa:	7e c7       	rjmp	.+3836   	; 0x2ea8 <gc_execute_line+0x14cc>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    1fac:	2a 28       	or	r2, r10
    1fae:	3b 28       	or	r3, r11
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1fb0:	89 8d       	ldd	r24, Y+25	; 0x19
    1fb2:	f8 01       	movw	r30, r16
    1fb4:	e8 0f       	add	r30, r24
    1fb6:	f1 1d       	adc	r31, r1
    1fb8:	b0 80       	ld	r11, Z
    1fba:	b1 10       	cpse	r11, r1
    1fbc:	4c cd       	rjmp	.-1384   	; 0x1a56 <gc_execute_line+0x7a>
    1fbe:	81 01       	movw	r16, r2
    1fc0:	8e 8d       	ldd	r24, Y+30	; 0x1e
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  
  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    1fc2:	ef 8d       	ldd	r30, Y+31	; 0x1f
    1fc4:	ee 23       	and	r30, r30
    1fc6:	21 f0       	breq	.+8      	; 0x1fd0 <gc_execute_line+0x5f4>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    1fc8:	81 11       	cpse	r24, r1
    1fca:	02 c0       	rjmp	.+4      	; 0x1fd0 <gc_execute_line+0x5f4>
    1fcc:	f2 e0       	ldi	r31, 0x02	; 2
    1fce:	fe 8f       	std	Y+30, r31	; 0x1e
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1fd0:	05 ff       	sbrs	r16, 5
    1fd2:	0e c0       	rjmp	.+28     	; 0x1ff0 <gc_execute_line+0x614>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1fd4:	80 91 e2 07 	lds	r24, 0x07E2
    1fd8:	90 91 e3 07 	lds	r25, 0x07E3
    1fdc:	a0 91 e4 07 	lds	r26, 0x07E4
    1fe0:	b0 91 e5 07 	lds	r27, 0x07E5
    1fe4:	80 38       	cpi	r24, 0x80	; 128
    1fe6:	96 49       	sbci	r25, 0x96	; 150
    1fe8:	a8 49       	sbci	r26, 0x98	; 152
    1fea:	b1 05       	cpc	r27, r1
    1fec:	0c f0       	brlt	.+2      	; 0x1ff0 <gc_execute_line+0x614>
    1fee:	5e c7       	rjmp	.+3772   	; 0x2eac <gc_execute_line+0x14d0>
  
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
  
  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1ff0:	80 91 c8 07 	lds	r24, 0x07C8
    1ff4:	81 30       	cpi	r24, 0x01	; 1
    1ff6:	31 f4       	brne	.+12     	; 0x2004 <gc_execute_line+0x628>
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
    1ff8:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1ffa:	32 30       	cpi	r19, 0x02	; 2
    1ffc:	a1 f5       	brne	.+104    	; 0x2066 <gc_execute_line+0x68a>
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1ffe:	00 ff       	sbrs	r16, 0
    2000:	57 c7       	rjmp	.+3758   	; 0x2eb0 <gc_execute_line+0x14d4>
    2002:	31 c0       	rjmp	.+98     	; 0x2066 <gc_execute_line+0x68a>
    // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error 
    // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
  } else { // = G94
    // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    2004:	80 91 88 07 	lds	r24, 0x0788
    2008:	81 11       	cpse	r24, r1
    200a:	2d c0       	rjmp	.+90     	; 0x2066 <gc_execute_line+0x68a>
      if (bit_istrue(value_words,bit(WORD_F))) {
    200c:	00 ff       	sbrs	r16, 0
    200e:	1b c0       	rjmp	.+54     	; 0x2046 <gc_execute_line+0x66a>
        if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    2010:	80 91 c9 07 	lds	r24, 0x07C9
    2014:	81 30       	cpi	r24, 0x01	; 1
    2016:	39 f5       	brne	.+78     	; 0x2066 <gc_execute_line+0x68a>
    2018:	0f 2e       	mov	r0, r31
    201a:	f1 ed       	ldi	r31, 0xD1	; 209
    201c:	cf 2e       	mov	r12, r31
    201e:	f7 e0       	ldi	r31, 0x07	; 7
    2020:	df 2e       	mov	r13, r31
    2022:	f0 2d       	mov	r31, r0
    2024:	23 e3       	ldi	r18, 0x33	; 51
    2026:	33 e3       	ldi	r19, 0x33	; 51
    2028:	4b ec       	ldi	r20, 0xCB	; 203
    202a:	51 e4       	ldi	r21, 0x41	; 65
    202c:	d6 01       	movw	r26, r12
    202e:	6d 91       	ld	r22, X+
    2030:	7d 91       	ld	r23, X+
    2032:	8d 91       	ld	r24, X+
    2034:	9c 91       	ld	r25, X
    2036:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    203a:	f6 01       	movw	r30, r12
    203c:	60 83       	st	Z, r22
    203e:	71 83       	std	Z+1, r23	; 0x01
    2040:	82 83       	std	Z+2, r24	; 0x02
    2042:	93 83       	std	Z+3, r25	; 0x03
    2044:	10 c0       	rjmp	.+32     	; 0x2066 <gc_execute_line+0x68a>
      } else {
        gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    2046:	80 91 95 07 	lds	r24, 0x0795
    204a:	90 91 96 07 	lds	r25, 0x0796
    204e:	a0 91 97 07 	lds	r26, 0x0797
    2052:	b0 91 98 07 	lds	r27, 0x0798
    2056:	80 93 d1 07 	sts	0x07D1, r24
    205a:	90 93 d2 07 	sts	0x07D2, r25
    205e:	a0 93 d3 07 	sts	0x07D3, r26
    2062:	b0 93 d4 07 	sts	0x07D4, r27
    } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
  } 
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
  
  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    2066:	10 fd       	sbrc	r17, 0
    2068:	10 c0       	rjmp	.+32     	; 0x208a <gc_execute_line+0x6ae>
    206a:	80 91 91 07 	lds	r24, 0x0791
    206e:	90 91 92 07 	lds	r25, 0x0792
    2072:	a0 91 93 07 	lds	r26, 0x0793
    2076:	b0 91 94 07 	lds	r27, 0x0794
    207a:	80 93 ee 07 	sts	0x07EE, r24
    207e:	90 93 ef 07 	sts	0x07EF, r25
    2082:	a0 93 f0 07 	sts	0x07F0, r26
    2086:	b0 93 f1 07 	sts	0x07F1, r27
  // [7. Spindle control ]: N/A
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    208a:	80 91 c6 07 	lds	r24, 0x07C6
    208e:	81 30       	cpi	r24, 0x01	; 1
    2090:	29 f4       	brne	.+10     	; 0x209c <gc_execute_line+0x6c0>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2092:	06 ff       	sbrs	r16, 6
    2094:	0f c7       	rjmp	.+3614   	; 0x2eb4 <gc_execute_line+0x14d8>
    bit_false(value_words,bit(WORD_P));
    2096:	18 01       	movw	r2, r16
    2098:	e8 94       	clt
    209a:	26 f8       	bld	r2, 6
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    209c:	80 91 cb 07 	lds	r24, 0x07CB
    20a0:	88 23       	and	r24, r24
    20a2:	19 f0       	breq	.+6      	; 0x20aa <gc_execute_line+0x6ce>
    20a4:	81 30       	cpi	r24, 0x01	; 1
    20a6:	69 f0       	breq	.+26     	; 0x20c2 <gc_execute_line+0x6e6>
    20a8:	06 c0       	rjmp	.+12     	; 0x20b6 <gc_execute_line+0x6da>
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    20aa:	f2 e0       	ldi	r31, 0x02	; 2
    20ac:	fe a3       	std	Y+38, r31	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    20ae:	21 e0       	ldi	r18, 0x01	; 1
    20b0:	2d a3       	std	Y+37, r18	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    20b2:	1c a2       	std	Y+36, r1	; 0x24
    20b4:	0b c0       	rjmp	.+22     	; 0x20cc <gc_execute_line+0x6f0>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    20b6:	1e a2       	std	Y+38, r1	; 0x26
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    20b8:	32 e0       	ldi	r19, 0x02	; 2
    20ba:	3d a3       	std	Y+37, r19	; 0x25
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	8c a3       	std	Y+36, r24	; 0x24
    20c0:	05 c0       	rjmp	.+10     	; 0x20cc <gc_execute_line+0x6f0>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    20c2:	91 e0       	ldi	r25, 0x01	; 1
    20c4:	9e a3       	std	Y+38, r25	; 0x26
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    20c6:	1d a2       	std	Y+37, r1	; 0x25
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    20c8:	a2 e0       	ldi	r26, 0x02	; 2
    20ca:	ac a3       	std	Y+36, r26	; 0x24
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    20cc:	80 91 c9 07 	lds	r24, 0x07C9
    20d0:	81 30       	cpi	r24, 0x01	; 1
    20d2:	69 f5       	brne	.+90     	; 0x212e <gc_execute_line+0x752>
    20d4:	0f 2e       	mov	r0, r31
    20d6:	f3 ef       	ldi	r31, 0xF3	; 243
    20d8:	af 2e       	mov	r10, r31
    20da:	f7 e0       	ldi	r31, 0x07	; 7
    20dc:	bf 2e       	mov	r11, r31
    20de:	f0 2d       	mov	r31, r0
    20e0:	00 e0       	ldi	r16, 0x00	; 0
    20e2:	10 e0       	ldi	r17, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    20e4:	bf 8d       	ldd	r27, Y+31	; 0x1f
    20e6:	cb 2e       	mov	r12, r27
    20e8:	d1 2c       	mov	r13, r1
    20ea:	c6 01       	movw	r24, r12
    20ec:	00 2e       	mov	r0, r16
    20ee:	02 c0       	rjmp	.+4      	; 0x20f4 <gc_execute_line+0x718>
    20f0:	95 95       	asr	r25
    20f2:	87 95       	ror	r24
    20f4:	0a 94       	dec	r0
    20f6:	e2 f7       	brpl	.-8      	; 0x20f0 <gc_execute_line+0x714>
    20f8:	80 ff       	sbrs	r24, 0
    20fa:	11 c0       	rjmp	.+34     	; 0x211e <gc_execute_line+0x742>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    20fc:	23 e3       	ldi	r18, 0x33	; 51
    20fe:	33 e3       	ldi	r19, 0x33	; 51
    2100:	4b ec       	ldi	r20, 0xCB	; 203
    2102:	51 e4       	ldi	r21, 0x41	; 65
    2104:	f5 01       	movw	r30, r10
    2106:	60 81       	ld	r22, Z
    2108:	71 81       	ldd	r23, Z+1	; 0x01
    210a:	82 81       	ldd	r24, Z+2	; 0x02
    210c:	93 81       	ldd	r25, Z+3	; 0x03
    210e:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    2112:	d5 01       	movw	r26, r10
    2114:	6d 93       	st	X+, r22
    2116:	7d 93       	st	X+, r23
    2118:	8d 93       	st	X+, r24
    211a:	9c 93       	st	X, r25
    211c:	13 97       	sbiw	r26, 0x03	; 3
    211e:	0f 5f       	subi	r16, 0xFF	; 255
    2120:	1f 4f       	sbci	r17, 0xFF	; 255
    2122:	b4 e0       	ldi	r27, 0x04	; 4
    2124:	ab 0e       	add	r10, r27
    2126:	b1 1c       	adc	r11, r1
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    2128:	03 30       	cpi	r16, 0x03	; 3
    212a:	11 05       	cpc	r17, r1
    212c:	f1 f6       	brne	.-68     	; 0x20ea <gc_execute_line+0x70e>
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are. 
  // [G43.1 Errors]: Motion command in same line. 
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    212e:	ee 8d       	ldd	r30, Y+30	; 0x1e
    2130:	e3 30       	cpi	r30, 0x03	; 3
    2132:	41 f4       	brne	.+16     	; 0x2144 <gc_execute_line+0x768>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    2134:	80 91 cc 07 	lds	r24, 0x07CC
    2138:	81 30       	cpi	r24, 0x01	; 1
    213a:	21 f4       	brne	.+8      	; 0x2144 <gc_execute_line+0x768>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    213c:	ff 8d       	ldd	r31, Y+31	; 0x1f
    213e:	f4 30       	cpi	r31, 0x04	; 4
    2140:	09 f0       	breq	.+2      	; 0x2144 <gc_execute_line+0x768>
    2142:	ba c6       	rjmp	.+3444   	; 0x2eb8 <gc_execute_line+0x14dc>
  // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
    2144:	8c e0       	ldi	r24, 0x0C	; 12
    2146:	ea ea       	ldi	r30, 0xAA	; 170
    2148:	f7 e0       	ldi	r31, 0x07	; 7
    214a:	de 01       	movw	r26, r28
    214c:	11 96       	adiw	r26, 0x01	; 1
    214e:	01 90       	ld	r0, Z+
    2150:	0d 92       	st	X+, r0
    2152:	8a 95       	dec	r24
    2154:	e1 f7       	brne	.-8      	; 0x214e <gc_execute_line+0x772>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    2156:	f0 fe       	sbrs	r15, 0
    2158:	11 c0       	rjmp	.+34     	; 0x217c <gc_execute_line+0x7a0>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    215a:	80 91 cd 07 	lds	r24, 0x07CD
    215e:	87 30       	cpi	r24, 0x07	; 7
    2160:	08 f0       	brcs	.+2      	; 0x2164 <gc_execute_line+0x788>
    2162:	ac c6       	rjmp	.+3416   	; 0x2ebc <gc_execute_line+0x14e0>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    2164:	90 91 8d 07 	lds	r25, 0x078D
    2168:	89 17       	cp	r24, r25
    216a:	41 f0       	breq	.+16     	; 0x217c <gc_execute_line+0x7a0>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    216c:	be 01       	movw	r22, r28
    216e:	6f 5f       	subi	r22, 0xFF	; 255
    2170:	7f 4f       	sbci	r23, 0xFF	; 255
    2172:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <settings_read_coord_data>
    2176:	88 23       	and	r24, r24
    2178:	09 f4       	brne	.+2      	; 0x217c <gc_execute_line+0x7a0>
    217a:	a2 c6       	rjmp	.+3396   	; 0x2ec0 <gc_execute_line+0x14e4>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets. 
  switch (gc_block.non_modal_command) {
    217c:	50 90 c6 07 	lds	r5, 0x07C6
    2180:	22 e0       	ldi	r18, 0x02	; 2
    2182:	52 16       	cp	r5, r18
    2184:	29 f0       	breq	.+10     	; 0x2190 <gc_execute_line+0x7b4>
    2186:	38 e0       	ldi	r19, 0x08	; 8
    2188:	53 16       	cp	r5, r19
    218a:	09 f4       	brne	.+2      	; 0x218e <gc_execute_line+0x7b2>
    218c:	a2 c0       	rjmp	.+324    	; 0x22d2 <gc_execute_line+0x8f6>
    218e:	0d c1       	rjmp	.+538    	; 0x23aa <gc_execute_line+0x9ce>
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2190:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2192:	88 23       	and	r24, r24
    2194:	09 f4       	brne	.+2      	; 0x2198 <gc_execute_line+0x7bc>
    2196:	96 c6       	rjmp	.+3372   	; 0x2ec4 <gc_execute_line+0x14e8>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    2198:	c1 01       	movw	r24, r2
    219a:	80 75       	andi	r24, 0x50	; 80
    219c:	99 27       	eor	r25, r25
    219e:	89 2b       	or	r24, r25
    21a0:	09 f4       	brne	.+2      	; 0x21a4 <gc_execute_line+0x7c8>
    21a2:	92 c6       	rjmp	.+3364   	; 0x2ec8 <gc_execute_line+0x14ec>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    21a4:	60 91 e6 07 	lds	r22, 0x07E6
    21a8:	70 91 e7 07 	lds	r23, 0x07E7
    21ac:	80 91 e8 07 	lds	r24, 0x07E8
    21b0:	90 91 e9 07 	lds	r25, 0x07E9
    21b4:	0e 94 b9 3f 	call	0x7f72	; 0x7f72 <trunc>
    21b8:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    21bc:	67 30       	cpi	r22, 0x07	; 7
    21be:	08 f0       	brcs	.+2      	; 0x21c2 <gc_execute_line+0x7e6>
    21c0:	85 c6       	rjmp	.+3338   	; 0x2ecc <gc_execute_line+0x14f0>
      if (gc_block.values.l != 20) {
    21c2:	80 91 e1 07 	lds	r24, 0x07E1
    21c6:	84 31       	cpi	r24, 0x14	; 20
    21c8:	29 f0       	breq	.+10     	; 0x21d4 <gc_execute_line+0x7f8>
        if (gc_block.values.l == 2) {
    21ca:	82 30       	cpi	r24, 0x02	; 2
    21cc:	09 f0       	breq	.+2      	; 0x21d0 <gc_execute_line+0x7f4>
    21ce:	80 c6       	rjmp	.+3328   	; 0x2ed0 <gc_execute_line+0x14f4>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    21d0:	27 fc       	sbrc	r2, 7
    21d2:	80 c6       	rjmp	.+3328   	; 0x2ed4 <gc_execute_line+0x14f8>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    21d4:	9f ea       	ldi	r25, 0xAF	; 175
    21d6:	29 22       	and	r2, r25
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    21d8:	66 23       	and	r22, r22
    21da:	19 f0       	breq	.+6      	; 0x21e2 <gc_execute_line+0x806>
    21dc:	61 50       	subi	r22, 0x01	; 1
    21de:	6f a3       	std	Y+39, r22	; 0x27
    21e0:	03 c0       	rjmp	.+6      	; 0x21e8 <gc_execute_line+0x80c>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    21e2:	a0 91 cd 07 	lds	r26, 0x07CD
    21e6:	af a3       	std	Y+39, r26	; 0x27
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    21e8:	be 01       	movw	r22, r28
    21ea:	63 5f       	subi	r22, 0xF3	; 243
    21ec:	7f 4f       	sbci	r23, 0xFF	; 255
    21ee:	8f a1       	ldd	r24, Y+39	; 0x27
    21f0:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <settings_read_coord_data>
    21f4:	88 23       	and	r24, r24
    21f6:	09 f4       	brne	.+2      	; 0x21fa <gc_execute_line+0x81e>
    21f8:	6f c6       	rjmp	.+3294   	; 0x2ed8 <gc_execute_line+0x14fc>
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    21fa:	b0 91 e1 07 	lds	r27, 0x07E1
    21fe:	b8 a7       	std	Y+40, r27	; 0x28
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    2200:	c0 90 c2 07 	lds	r12, 0x07C2
    2204:	d0 90 c3 07 	lds	r13, 0x07C3
    2208:	e0 90 c4 07 	lds	r14, 0x07C4
    220c:	f0 90 c5 07 	lds	r15, 0x07C5
    2210:	5e 01       	movw	r10, r28
    2212:	ed e0       	ldi	r30, 0x0D	; 13
    2214:	ae 0e       	add	r10, r30
    2216:	b1 1c       	adc	r11, r1
    2218:	0f 2e       	mov	r0, r31
    221a:	f3 ef       	ldi	r31, 0xF3	; 243
    221c:	8f 2e       	mov	r8, r31
    221e:	f7 e0       	ldi	r31, 0x07	; 7
    2220:	9f 2e       	mov	r9, r31
    2222:	f0 2d       	mov	r31, r0
    2224:	0f 2e       	mov	r0, r31
    2226:	fe e9       	ldi	r31, 0x9E	; 158
    2228:	6f 2e       	mov	r6, r31
    222a:	f7 e0       	ldi	r31, 0x07	; 7
    222c:	7f 2e       	mov	r7, r31
    222e:	f0 2d       	mov	r31, r0
    2230:	00 e0       	ldi	r16, 0x00	; 0
    2232:	10 e0       	ldi	r17, 0x00	; 0
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    2234:	ff 8d       	ldd	r31, Y+31	; 0x1f
    2236:	4f 2e       	mov	r4, r31
    2238:	51 2c       	mov	r5, r1
    223a:	c2 01       	movw	r24, r4
    223c:	00 2e       	mov	r0, r16
    223e:	02 c0       	rjmp	.+4      	; 0x2244 <gc_execute_line+0x868>
    2240:	95 95       	asr	r25
    2242:	87 95       	ror	r24
    2244:	0a 94       	dec	r0
    2246:	e2 f7       	brpl	.-8      	; 0x2240 <gc_execute_line+0x864>
    2248:	80 ff       	sbrs	r24, 0
    224a:	33 c0       	rjmp	.+102    	; 0x22b2 <gc_execute_line+0x8d6>
          if (gc_block.values.l == 20) {
    224c:	28 a5       	ldd	r18, Y+40	; 0x28
    224e:	24 31       	cpi	r18, 0x14	; 20
    2250:	31 f5       	brne	.+76     	; 0x229e <gc_execute_line+0x8c2>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    2252:	d3 01       	movw	r26, r6
    2254:	58 96       	adiw	r26, 0x18	; 24
    2256:	2d 91       	ld	r18, X+
    2258:	3d 91       	ld	r19, X+
    225a:	4d 91       	ld	r20, X+
    225c:	5c 91       	ld	r21, X
    225e:	5b 97       	sbiw	r26, 0x1b	; 27
    2260:	6d 91       	ld	r22, X+
    2262:	7d 91       	ld	r23, X+
    2264:	8d 91       	ld	r24, X+
    2266:	9c 91       	ld	r25, X
    2268:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    226c:	f4 01       	movw	r30, r8
    226e:	20 81       	ld	r18, Z
    2270:	31 81       	ldd	r19, Z+1	; 0x01
    2272:	42 81       	ldd	r20, Z+2	; 0x02
    2274:	53 81       	ldd	r21, Z+3	; 0x03
    2276:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    227a:	d5 01       	movw	r26, r10
    227c:	6d 93       	st	X+, r22
    227e:	7d 93       	st	X+, r23
    2280:	8d 93       	st	X+, r24
    2282:	9c 93       	st	X, r25
    2284:	13 97       	sbiw	r26, 0x03	; 3
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    2286:	02 30       	cpi	r16, 0x02	; 2
    2288:	a1 f4       	brne	.+40     	; 0x22b2 <gc_execute_line+0x8d6>
    228a:	a7 01       	movw	r20, r14
    228c:	96 01       	movw	r18, r12
    228e:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    2292:	f5 01       	movw	r30, r10
    2294:	60 83       	st	Z, r22
    2296:	71 83       	std	Z+1, r23	; 0x01
    2298:	82 83       	std	Z+2, r24	; 0x02
    229a:	93 83       	std	Z+3, r25	; 0x03
    229c:	0a c0       	rjmp	.+20     	; 0x22b2 <gc_execute_line+0x8d6>
          } else {
            // L2: Update coordinate system axis to programmed value.
            parameter_data[idx] = gc_block.values.xyz[idx]; 
    229e:	f4 01       	movw	r30, r8
    22a0:	80 81       	ld	r24, Z
    22a2:	91 81       	ldd	r25, Z+1	; 0x01
    22a4:	a2 81       	ldd	r26, Z+2	; 0x02
    22a6:	b3 81       	ldd	r27, Z+3	; 0x03
    22a8:	f5 01       	movw	r30, r10
    22aa:	80 83       	st	Z, r24
    22ac:	91 83       	std	Z+1, r25	; 0x01
    22ae:	a2 83       	std	Z+2, r26	; 0x02
    22b0:	b3 83       	std	Z+3, r27	; 0x03
    22b2:	0f 5f       	subi	r16, 0xFF	; 255
    22b4:	1f 4f       	sbci	r17, 0xFF	; 255
    22b6:	f4 e0       	ldi	r31, 0x04	; 4
    22b8:	af 0e       	add	r10, r31
    22ba:	b1 1c       	adc	r11, r1
    22bc:	24 e0       	ldi	r18, 0x04	; 4
    22be:	82 0e       	add	r8, r18
    22c0:	91 1c       	adc	r9, r1
    22c2:	34 e0       	ldi	r19, 0x04	; 4
    22c4:	63 0e       	add	r6, r19
    22c6:	71 1c       	adc	r7, r1
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    22c8:	03 30       	cpi	r16, 0x03	; 3
    22ca:	11 05       	cpc	r17, r1
    22cc:	09 f0       	breq	.+2      	; 0x22d0 <gc_execute_line+0x8f4>
    22ce:	b5 cf       	rjmp	.-150    	; 0x223a <gc_execute_line+0x85e>
    22d0:	24 c6       	rjmp	.+3144   	; 0x2f1a <gc_execute_line+0x153e>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    22d2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    22d4:	88 23       	and	r24, r24
    22d6:	09 f4       	brne	.+2      	; 0x22da <gc_execute_line+0x8fe>
    22d8:	01 c6       	rjmp	.+3074   	; 0x2edc <gc_execute_line+0x1500>
    22da:	0f 2e       	mov	r0, r31
    22dc:	fe e9       	ldi	r31, 0x9E	; 158
    22de:	cf 2e       	mov	r12, r31
    22e0:	f7 e0       	ldi	r31, 0x07	; 7
    22e2:	df 2e       	mov	r13, r31
    22e4:	f0 2d       	mov	r31, r0
    22e6:	de 01       	movw	r26, r28
    22e8:	11 96       	adiw	r26, 0x01	; 1
    22ea:	5d 01       	movw	r10, r26
    22ec:	0f 2e       	mov	r0, r31
    22ee:	f3 ef       	ldi	r31, 0xF3	; 243
    22f0:	ef 2e       	mov	r14, r31
    22f2:	f7 e0       	ldi	r31, 0x07	; 7
    22f4:	ff 2e       	mov	r15, r31
    22f6:	f0 2d       	mov	r31, r0
    22f8:	00 e0       	ldi	r16, 0x00	; 0
    22fa:	10 e0       	ldi	r17, 0x00	; 0
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    22fc:	88 2e       	mov	r8, r24
    22fe:	91 2c       	mov	r9, r1
    2300:	c4 01       	movw	r24, r8
    2302:	00 2e       	mov	r0, r16
    2304:	02 c0       	rjmp	.+4      	; 0x230a <gc_execute_line+0x92e>
    2306:	95 95       	asr	r25
    2308:	87 95       	ror	r24
    230a:	0a 94       	dec	r0
    230c:	e2 f7       	brpl	.-8      	; 0x2306 <gc_execute_line+0x92a>
    230e:	80 ff       	sbrs	r24, 0
    2310:	32 c0       	rjmp	.+100    	; 0x2376 <gc_execute_line+0x99a>
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
    2312:	f5 01       	movw	r30, r10
    2314:	20 81       	ld	r18, Z
    2316:	31 81       	ldd	r19, Z+1	; 0x01
    2318:	42 81       	ldd	r20, Z+2	; 0x02
    231a:	53 81       	ldd	r21, Z+3	; 0x03
    231c:	d6 01       	movw	r26, r12
    231e:	6d 91       	ld	r22, X+
    2320:	7d 91       	ld	r23, X+
    2322:	8d 91       	ld	r24, X+
    2324:	9c 91       	ld	r25, X
    2326:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    232a:	f7 01       	movw	r30, r14
    232c:	20 81       	ld	r18, Z
    232e:	31 81       	ldd	r19, Z+1	; 0x01
    2330:	42 81       	ldd	r20, Z+2	; 0x02
    2332:	53 81       	ldd	r21, Z+3	; 0x03
    2334:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    2338:	d7 01       	movw	r26, r14
    233a:	6d 93       	st	X+, r22
    233c:	7d 93       	st	X+, r23
    233e:	8d 93       	st	X+, r24
    2340:	9c 93       	st	X, r25
    2342:	13 97       	sbiw	r26, 0x03	; 3
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    2344:	02 30       	cpi	r16, 0x02	; 2
    2346:	09 f5       	brne	.+66     	; 0x238a <gc_execute_line+0x9ae>
    2348:	00 0f       	add	r16, r16
    234a:	11 1f       	adc	r17, r17
    234c:	00 0f       	add	r16, r16
    234e:	11 1f       	adc	r17, r17
    2350:	0a 53       	subi	r16, 0x3A	; 58
    2352:	18 4f       	sbci	r17, 0xF8	; 248
    2354:	20 91 c2 07 	lds	r18, 0x07C2
    2358:	30 91 c3 07 	lds	r19, 0x07C3
    235c:	40 91 c4 07 	lds	r20, 0x07C4
    2360:	50 91 c5 07 	lds	r21, 0x07C5
    2364:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    2368:	f8 01       	movw	r30, r16
    236a:	65 a7       	std	Z+45, r22	; 0x2d
    236c:	76 a7       	std	Z+46, r23	; 0x2e
    236e:	87 a7       	std	Z+47, r24	; 0x2f
    2370:	90 ab       	std	Z+48, r25	; 0x30
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    2372:	1f a2       	std	Y+39, r1	; 0x27
    2374:	d2 c5       	rjmp	.+2980   	; 0x2f1a <gc_execute_line+0x153e>
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    2376:	f6 01       	movw	r30, r12
    2378:	80 8d       	ldd	r24, Z+24	; 0x18
    237a:	91 8d       	ldd	r25, Z+25	; 0x19
    237c:	a2 8d       	ldd	r26, Z+26	; 0x1a
    237e:	b3 8d       	ldd	r27, Z+27	; 0x1b
    2380:	f7 01       	movw	r30, r14
    2382:	80 83       	st	Z, r24
    2384:	91 83       	std	Z+1, r25	; 0x01
    2386:	a2 83       	std	Z+2, r26	; 0x02
    2388:	b3 83       	std	Z+3, r27	; 0x03
    238a:	0f 5f       	subi	r16, 0xFF	; 255
    238c:	1f 4f       	sbci	r17, 0xFF	; 255
    238e:	f4 e0       	ldi	r31, 0x04	; 4
    2390:	cf 0e       	add	r12, r31
    2392:	d1 1c       	adc	r13, r1
    2394:	24 e0       	ldi	r18, 0x04	; 4
    2396:	a2 0e       	add	r10, r18
    2398:	b1 1c       	adc	r11, r1
    239a:	34 e0       	ldi	r19, 0x04	; 4
    239c:	e3 0e       	add	r14, r19
    239e:	f1 1c       	adc	r15, r1
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    23a0:	03 30       	cpi	r16, 0x03	; 3
    23a2:	11 05       	cpc	r17, r1
    23a4:	09 f0       	breq	.+2      	; 0x23a8 <gc_execute_line+0x9cc>
    23a6:	ac cf       	rjmp	.-168    	; 0x2300 <gc_execute_line+0x924>
    23a8:	b7 c5       	rjmp	.+2926   	; 0x2f18 <gc_execute_line+0x153c>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    23aa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23ac:	83 30       	cpi	r24, 0x03	; 3
    23ae:	09 f4       	brne	.+2      	; 0x23b2 <gc_execute_line+0x9d6>
    23b0:	87 c0       	rjmp	.+270    	; 0x24c0 <gc_execute_line+0xae4>
        if (axis_words) {
    23b2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    23b4:	99 23       	and	r25, r25
    23b6:	09 f4       	brne	.+2      	; 0x23ba <gc_execute_line+0x9de>
    23b8:	83 c0       	rjmp	.+262    	; 0x24c0 <gc_execute_line+0xae4>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    23ba:	40 90 ca 07 	lds	r4, 0x07CA
    23be:	0f 2e       	mov	r0, r31
    23c0:	fe e9       	ldi	r31, 0x9E	; 158
    23c2:	cf 2e       	mov	r12, r31
    23c4:	f7 e0       	ldi	r31, 0x07	; 7
    23c6:	df 2e       	mov	r13, r31
    23c8:	f0 2d       	mov	r31, r0
    23ca:	0f 2e       	mov	r0, r31
    23cc:	f3 ef       	ldi	r31, 0xF3	; 243
    23ce:	ef 2e       	mov	r14, r31
    23d0:	f7 e0       	ldi	r31, 0x07	; 7
    23d2:	ff 2e       	mov	r15, r31
    23d4:	f0 2d       	mov	r31, r0
    23d6:	de 01       	movw	r26, r28
    23d8:	11 96       	adiw	r26, 0x01	; 1
    23da:	5d 01       	movw	r10, r26
    23dc:	00 e0       	ldi	r16, 0x00	; 0
    23de:	10 e0       	ldi	r17, 0x00	; 0
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    23e0:	89 2e       	mov	r8, r25
    23e2:	91 2c       	mov	r9, r1
    23e4:	c4 01       	movw	r24, r8
    23e6:	00 2e       	mov	r0, r16
    23e8:	02 c0       	rjmp	.+4      	; 0x23ee <gc_execute_line+0xa12>
    23ea:	95 95       	asr	r25
    23ec:	87 95       	ror	r24
    23ee:	0a 94       	dec	r0
    23f0:	e2 f7       	brpl	.-8      	; 0x23ea <gc_execute_line+0xa0e>
    23f2:	80 fd       	sbrc	r24, 0
    23f4:	0b c0       	rjmp	.+22     	; 0x240c <gc_execute_line+0xa30>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    23f6:	f6 01       	movw	r30, r12
    23f8:	80 81       	ld	r24, Z
    23fa:	91 81       	ldd	r25, Z+1	; 0x01
    23fc:	a2 81       	ldd	r26, Z+2	; 0x02
    23fe:	b3 81       	ldd	r27, Z+3	; 0x03
    2400:	f7 01       	movw	r30, r14
    2402:	80 83       	st	Z, r24
    2404:	91 83       	std	Z+1, r25	; 0x01
    2406:	a2 83       	std	Z+2, r26	; 0x02
    2408:	b3 83       	std	Z+3, r27	; 0x03
    240a:	4b c0       	rjmp	.+150    	; 0x24a2 <gc_execute_line+0xac6>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    240c:	f7 e0       	ldi	r31, 0x07	; 7
    240e:	5f 16       	cp	r5, r31
    2410:	09 f4       	brne	.+2      	; 0x2414 <gc_execute_line+0xa38>
    2412:	47 c0       	rjmp	.+142    	; 0x24a2 <gc_execute_line+0xac6>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    2414:	41 10       	cpse	r4, r1
    2416:	34 c0       	rjmp	.+104    	; 0x2480 <gc_execute_line+0xaa4>
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
    2418:	d6 01       	movw	r26, r12
    241a:	58 96       	adiw	r26, 0x18	; 24
    241c:	2d 91       	ld	r18, X+
    241e:	3d 91       	ld	r19, X+
    2420:	4d 91       	ld	r20, X+
    2422:	5c 91       	ld	r21, X
    2424:	5b 97       	sbiw	r26, 0x1b	; 27
    2426:	f5 01       	movw	r30, r10
    2428:	60 81       	ld	r22, Z
    242a:	71 81       	ldd	r23, Z+1	; 0x01
    242c:	82 81       	ldd	r24, Z+2	; 0x02
    242e:	93 81       	ldd	r25, Z+3	; 0x03
    2430:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    2434:	d7 01       	movw	r26, r14
    2436:	2d 91       	ld	r18, X+
    2438:	3d 91       	ld	r19, X+
    243a:	4d 91       	ld	r20, X+
    243c:	5c 91       	ld	r21, X
    243e:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    2442:	f7 01       	movw	r30, r14
    2444:	60 83       	st	Z, r22
    2446:	71 83       	std	Z+1, r23	; 0x01
    2448:	82 83       	std	Z+2, r24	; 0x02
    244a:	93 83       	std	Z+3, r25	; 0x03
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    244c:	02 30       	cpi	r16, 0x02	; 2
    244e:	49 f5       	brne	.+82     	; 0x24a2 <gc_execute_line+0xac6>
    2450:	00 0f       	add	r16, r16
    2452:	11 1f       	adc	r17, r17
    2454:	00 0f       	add	r16, r16
    2456:	11 1f       	adc	r17, r17
    2458:	0a 53       	subi	r16, 0x3A	; 58
    245a:	18 4f       	sbci	r17, 0xF8	; 248
    245c:	20 91 c2 07 	lds	r18, 0x07C2
    2460:	30 91 c3 07 	lds	r19, 0x07C3
    2464:	40 91 c4 07 	lds	r20, 0x07C4
    2468:	50 91 c5 07 	lds	r21, 0x07C5
    246c:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    2470:	d8 01       	movw	r26, r16
    2472:	9d 96       	adiw	r26, 0x2d	; 45
    2474:	6d 93       	st	X+, r22
    2476:	7d 93       	st	X+, r23
    2478:	8d 93       	st	X+, r24
    247a:	9c 93       	st	X, r25
    247c:	d0 97       	sbiw	r26, 0x30	; 48
    247e:	20 c0       	rjmp	.+64     	; 0x24c0 <gc_execute_line+0xae4>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    2480:	f6 01       	movw	r30, r12
    2482:	20 81       	ld	r18, Z
    2484:	31 81       	ldd	r19, Z+1	; 0x01
    2486:	42 81       	ldd	r20, Z+2	; 0x02
    2488:	53 81       	ldd	r21, Z+3	; 0x03
    248a:	d7 01       	movw	r26, r14
    248c:	6d 91       	ld	r22, X+
    248e:	7d 91       	ld	r23, X+
    2490:	8d 91       	ld	r24, X+
    2492:	9c 91       	ld	r25, X
    2494:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    2498:	f7 01       	movw	r30, r14
    249a:	60 83       	st	Z, r22
    249c:	71 83       	std	Z+1, r23	; 0x01
    249e:	82 83       	std	Z+2, r24	; 0x02
    24a0:	93 83       	std	Z+3, r25	; 0x03
    24a2:	0f 5f       	subi	r16, 0xFF	; 255
    24a4:	1f 4f       	sbci	r17, 0xFF	; 255
    24a6:	f4 e0       	ldi	r31, 0x04	; 4
    24a8:	cf 0e       	add	r12, r31
    24aa:	d1 1c       	adc	r13, r1
    24ac:	24 e0       	ldi	r18, 0x04	; 4
    24ae:	e2 0e       	add	r14, r18
    24b0:	f1 1c       	adc	r15, r1
    24b2:	34 e0       	ldi	r19, 0x04	; 4
    24b4:	a3 0e       	add	r10, r19
    24b6:	b1 1c       	adc	r11, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    24b8:	03 30       	cpi	r16, 0x03	; 3
    24ba:	11 05       	cpc	r17, r1
    24bc:	09 f0       	breq	.+2      	; 0x24c0 <gc_execute_line+0xae4>
    24be:	92 cf       	rjmp	.-220    	; 0x23e4 <gc_execute_line+0xa08>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    24c0:	85 e0       	ldi	r24, 0x05	; 5
    24c2:	58 16       	cp	r5, r24
    24c4:	a1 f0       	breq	.+40     	; 0x24ee <gc_execute_line+0xb12>
    24c6:	97 e0       	ldi	r25, 0x07	; 7
    24c8:	59 16       	cp	r5, r25
    24ca:	f9 f0       	breq	.+62     	; 0x250a <gc_execute_line+0xb2e>
    24cc:	a3 e0       	ldi	r26, 0x03	; 3
    24ce:	5a 12       	cpse	r5, r26
    24d0:	21 c0       	rjmp	.+66     	; 0x2514 <gc_execute_line+0xb38>
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    24d2:	bf 8d       	ldd	r27, Y+31	; 0x1f
    24d4:	b1 11       	cpse	r27, r1
    24d6:	01 c0       	rjmp	.+2      	; 0x24da <gc_execute_line+0xafe>
    24d8:	1e 8e       	std	Y+30, r1	; 0x1e
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    24da:	be 01       	movw	r22, r28
    24dc:	63 5f       	subi	r22, 0xF3	; 243
    24de:	7f 4f       	sbci	r23, 0xFF	; 255
    24e0:	86 e0       	ldi	r24, 0x06	; 6
    24e2:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <settings_read_coord_data>
    24e6:	88 23       	and	r24, r24
    24e8:	09 f4       	brne	.+2      	; 0x24ec <gc_execute_line+0xb10>
    24ea:	fa c4       	rjmp	.+2548   	; 0x2ee0 <gc_execute_line+0x1504>
    24ec:	13 c0       	rjmp	.+38     	; 0x2514 <gc_execute_line+0xb38>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    24ee:	ef 8d       	ldd	r30, Y+31	; 0x1f
    24f0:	e1 11       	cpse	r30, r1
    24f2:	01 c0       	rjmp	.+2      	; 0x24f6 <gc_execute_line+0xb1a>
    24f4:	1e 8e       	std	Y+30, r1	; 0x1e
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    24f6:	be 01       	movw	r22, r28
    24f8:	63 5f       	subi	r22, 0xF3	; 243
    24fa:	7f 4f       	sbci	r23, 0xFF	; 255
    24fc:	87 e0       	ldi	r24, 0x07	; 7
    24fe:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <settings_read_coord_data>
    2502:	88 23       	and	r24, r24
    2504:	09 f4       	brne	.+2      	; 0x2508 <gc_execute_line+0xb2c>
    2506:	ee c4       	rjmp	.+2524   	; 0x2ee4 <gc_execute_line+0x1508>
    2508:	05 c0       	rjmp	.+10     	; 0x2514 <gc_execute_line+0xb38>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    250a:	80 91 c7 07 	lds	r24, 0x07C7
    250e:	82 30       	cpi	r24, 0x02	; 2
    2510:	08 f0       	brcs	.+2      	; 0x2514 <gc_execute_line+0xb38>
    2512:	ea c4       	rjmp	.+2516   	; 0x2ee8 <gc_execute_line+0x150c>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    2514:	10 91 c7 07 	lds	r17, 0x07C7
    2518:	18 30       	cpi	r17, 0x08	; 8
    251a:	51 f4       	brne	.+20     	; 0x2530 <gc_execute_line+0xb54>
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    251c:	ff 8d       	ldd	r31, Y+31	; 0x1f
    251e:	ff 23       	and	r31, r31
    2520:	09 f4       	brne	.+2      	; 0x2524 <gc_execute_line+0xb48>
    2522:	8e c2       	rjmp	.+1308   	; 0x2a40 <gc_execute_line+0x1064>
    2524:	1f a2       	std	Y+39, r1	; 0x27
    2526:	2e 8d       	ldd	r18, Y+30	; 0x1e
    2528:	21 30       	cpi	r18, 0x01	; 1
    252a:	09 f0       	breq	.+2      	; 0x252e <gc_execute_line+0xb52>
    252c:	df c4       	rjmp	.+2494   	; 0x2eec <gc_execute_line+0x1510>
    252e:	91 c2       	rjmp	.+1314   	; 0x2a52 <gc_execute_line+0x1076>
    2530:	1f a2       	std	Y+39, r1	; 0x27
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    }

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or 
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    2532:	3e 8d       	ldd	r19, Y+30	; 0x1e
    2534:	32 30       	cpi	r19, 0x02	; 2
    2536:	09 f0       	breq	.+2      	; 0x253a <gc_execute_line+0xb5e>
    2538:	84 c2       	rjmp	.+1288   	; 0x2a42 <gc_execute_line+0x1066>
  
    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    253a:	11 11       	cpse	r17, r1
    253c:	05 c0       	rjmp	.+10     	; 0x2548 <gc_execute_line+0xb6c>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    253e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2540:	88 23       	and	r24, r24
    2542:	09 f4       	brne	.+2      	; 0x2546 <gc_execute_line+0xb6a>
    2544:	f6 c4       	rjmp	.+2540   	; 0x2f32 <gc_execute_line+0x1556>
    2546:	85 c2       	rjmp	.+1290   	; 0x2a52 <gc_execute_line+0x1076>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2548:	20 e0       	ldi	r18, 0x00	; 0
    254a:	30 e0       	ldi	r19, 0x00	; 0
    254c:	a9 01       	movw	r20, r18
    254e:	60 91 d1 07 	lds	r22, 0x07D1
    2552:	70 91 d2 07 	lds	r23, 0x07D2
    2556:	80 91 d3 07 	lds	r24, 0x07D3
    255a:	90 91 d4 07 	lds	r25, 0x07D4
    255e:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    2562:	88 23       	and	r24, r24
    2564:	09 f4       	brne	.+2      	; 0x2568 <gc_execute_line+0xb8c>
    2566:	c4 c4       	rjmp	.+2440   	; 0x2ef0 <gc_execute_line+0x1514>
     
      switch (gc_block.modal.motion) {
    2568:	14 30       	cpi	r17, 0x04	; 4
    256a:	28 f4       	brcc	.+10     	; 0x2576 <gc_execute_line+0xb9a>
    256c:	12 30       	cpi	r17, 0x02	; 2
    256e:	60 f4       	brcc	.+24     	; 0x2588 <gc_execute_line+0xbac>
    2570:	11 30       	cpi	r17, 0x01	; 1
    2572:	29 f0       	breq	.+10     	; 0x257e <gc_execute_line+0xba2>
    2574:	66 c2       	rjmp	.+1228   	; 0x2a42 <gc_execute_line+0x1066>
    2576:	18 30       	cpi	r17, 0x08	; 8
    2578:	08 f4       	brcc	.+2      	; 0x257c <gc_execute_line+0xba0>
    257a:	20 c2       	rjmp	.+1088   	; 0x29bc <gc_execute_line+0xfe0>
    257c:	62 c2       	rjmp	.+1220   	; 0x2a42 <gc_execute_line+0x1066>
        case MOTION_MODE_LINEAR: 
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    257e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2580:	99 23       	and	r25, r25
    2582:	09 f4       	brne	.+2      	; 0x2586 <gc_execute_line+0xbaa>
    2584:	d6 c4       	rjmp	.+2476   	; 0x2f32 <gc_execute_line+0x1556>
    2586:	65 c2       	rjmp	.+1226   	; 0x2a52 <gc_execute_line+0x1076>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2588:	af 8d       	ldd	r26, Y+31	; 0x1f
    258a:	aa 23       	and	r26, r26
    258c:	09 f4       	brne	.+2      	; 0x2590 <gc_execute_line+0xbb4>
    258e:	b2 c4       	rjmp	.+2404   	; 0x2ef4 <gc_execute_line+0x1518>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    2590:	fc a1       	ldd	r31, Y+36	; 0x24
    2592:	ef 2f       	mov	r30, r31
    2594:	f0 e0       	ldi	r31, 0x00	; 0
    2596:	f9 a7       	std	Y+41, r31	; 0x29
    2598:	e8 a7       	std	Y+40, r30	; 0x28
    259a:	3d a1       	ldd	r19, Y+37	; 0x25
    259c:	23 2f       	mov	r18, r19
    259e:	30 e0       	ldi	r19, 0x00	; 0
    25a0:	3b a7       	std	Y+43, r19	; 0x2b
    25a2:	2a a7       	std	Y+42, r18	; 0x2a
    25a4:	81 e0       	ldi	r24, 0x01	; 1
    25a6:	90 e0       	ldi	r25, 0x00	; 0
    25a8:	9c 01       	movw	r18, r24
    25aa:	0d a0       	ldd	r0, Y+37	; 0x25
    25ac:	02 c0       	rjmp	.+4      	; 0x25b2 <gc_execute_line+0xbd6>
    25ae:	22 0f       	add	r18, r18
    25b0:	33 1f       	adc	r19, r19
    25b2:	0a 94       	dec	r0
    25b4:	e2 f7       	brpl	.-8      	; 0x25ae <gc_execute_line+0xbd2>
    25b6:	0c a0       	ldd	r0, Y+36	; 0x24
    25b8:	02 c0       	rjmp	.+4      	; 0x25be <gc_execute_line+0xbe2>
    25ba:	88 0f       	add	r24, r24
    25bc:	99 1f       	adc	r25, r25
    25be:	0a 94       	dec	r0
    25c0:	e2 f7       	brpl	.-8      	; 0x25ba <gc_execute_line+0xbde>
    25c2:	89 01       	movw	r16, r18
    25c4:	08 2b       	or	r16, r24
    25c6:	19 2b       	or	r17, r25
    25c8:	8a 2f       	mov	r24, r26
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	80 23       	and	r24, r16
    25ce:	91 23       	and	r25, r17
    25d0:	89 2b       	or	r24, r25
    25d2:	09 f4       	brne	.+2      	; 0x25d6 <gc_execute_line+0xbfa>
    25d4:	91 c4       	rjmp	.+2338   	; 0x2ef8 <gc_execute_line+0x151c>
        
          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    25d6:	cf 01       	movw	r24, r30
    25d8:	88 0f       	add	r24, r24
    25da:	99 1f       	adc	r25, r25
    25dc:	88 0f       	add	r24, r24
    25de:	99 1f       	adc	r25, r25
    25e0:	fc 01       	movw	r30, r24
    25e2:	ea 53       	subi	r30, 0x3A	; 58
    25e4:	f8 4f       	sbci	r31, 0xF8	; 248
    25e6:	dc 01       	movw	r26, r24
    25e8:	a9 57       	subi	r26, 0x79	; 121
    25ea:	b8 4f       	sbci	r27, 0xF8	; 248
    25ec:	57 96       	adiw	r26, 0x17	; 23
    25ee:	2d 91       	ld	r18, X+
    25f0:	3d 91       	ld	r19, X+
    25f2:	4d 91       	ld	r20, X+
    25f4:	5c 91       	ld	r21, X
    25f6:	5a 97       	sbiw	r26, 0x1a	; 26
    25f8:	65 a5       	ldd	r22, Z+45	; 0x2d
    25fa:	76 a5       	ldd	r23, Z+46	; 0x2e
    25fc:	87 a5       	ldd	r24, Z+47	; 0x2f
    25fe:	90 a9       	ldd	r25, Z+48	; 0x30
    2600:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    2604:	6b 01       	movw	r12, r22
    2606:	7c 01       	movw	r14, r24
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    2608:	8a a5       	ldd	r24, Y+42	; 0x2a
    260a:	9b a5       	ldd	r25, Y+43	; 0x2b
    260c:	88 0f       	add	r24, r24
    260e:	99 1f       	adc	r25, r25
    2610:	88 0f       	add	r24, r24
    2612:	99 1f       	adc	r25, r25
    2614:	fc 01       	movw	r30, r24
    2616:	ea 53       	subi	r30, 0x3A	; 58
    2618:	f8 4f       	sbci	r31, 0xF8	; 248
    261a:	dc 01       	movw	r26, r24
    261c:	a9 57       	subi	r26, 0x79	; 121
    261e:	b8 4f       	sbci	r27, 0xF8	; 248
    2620:	57 96       	adiw	r26, 0x17	; 23
    2622:	2d 91       	ld	r18, X+
    2624:	3d 91       	ld	r19, X+
    2626:	4d 91       	ld	r20, X+
    2628:	5c 91       	ld	r21, X
    262a:	5a 97       	sbiw	r26, 0x1a	; 26
    262c:	65 a5       	ldd	r22, Z+45	; 0x2d
    262e:	76 a5       	ldd	r23, Z+46	; 0x2e
    2630:	87 a5       	ldd	r24, Z+47	; 0x2f
    2632:	90 a9       	ldd	r25, Z+48	; 0x30
    2634:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    2638:	4b 01       	movw	r8, r22
    263a:	5c 01       	movw	r10, r24

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
    263c:	27 fe       	sbrs	r2, 7
    263e:	10 c1       	rjmp	.+544    	; 0x2860 <gc_execute_line+0xe84>
            bit_false(value_words,bit(WORD_R));
    2640:	e8 94       	clt
    2642:	27 f8       	bld	r2, 7

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
    2644:	20 91 f3 07 	lds	r18, 0x07F3
    2648:	30 91 f4 07 	lds	r19, 0x07F4
    264c:	40 91 f5 07 	lds	r20, 0x07F5
    2650:	50 91 f6 07 	lds	r21, 0x07F6
    2654:	60 91 9e 07 	lds	r22, 0x079E
    2658:	70 91 9f 07 	lds	r23, 0x079F
    265c:	80 91 a0 07 	lds	r24, 0x07A0
    2660:	90 91 a1 07 	lds	r25, 0x07A1
    2664:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    2668:	81 11       	cpse	r24, r1
    266a:	5d c4       	rjmp	.+2234   	; 0x2f26 <gc_execute_line+0x154a>
    266c:	20 91 f7 07 	lds	r18, 0x07F7
    2670:	30 91 f8 07 	lds	r19, 0x07F8
    2674:	40 91 f9 07 	lds	r20, 0x07F9
    2678:	50 91 fa 07 	lds	r21, 0x07FA
    267c:	60 91 a2 07 	lds	r22, 0x07A2
    2680:	70 91 a3 07 	lds	r23, 0x07A3
    2684:	80 91 a4 07 	lds	r24, 0x07A4
    2688:	90 91 a5 07 	lds	r25, 0x07A5
    268c:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    2690:	81 11       	cpse	r24, r1
    2692:	49 c4       	rjmp	.+2194   	; 0x2f26 <gc_execute_line+0x154a>
    2694:	20 91 fb 07 	lds	r18, 0x07FB
    2698:	30 91 fc 07 	lds	r19, 0x07FC
    269c:	40 91 fd 07 	lds	r20, 0x07FD
    26a0:	50 91 fe 07 	lds	r21, 0x07FE
    26a4:	60 91 a6 07 	lds	r22, 0x07A6
    26a8:	70 91 a7 07 	lds	r23, 0x07A7
    26ac:	80 91 a8 07 	lds	r24, 0x07A8
    26b0:	90 91 a9 07 	lds	r25, 0x07A9
    26b4:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    26b8:	81 11       	cpse	r24, r1
    26ba:	35 c4       	rjmp	.+2154   	; 0x2f26 <gc_execute_line+0x154a>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    26bc:	81 e2       	ldi	r24, 0x21	; 33
    26be:	3f c4       	rjmp	.+2174   	; 0x2f3e <gc_execute_line+0x1562>
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    26c0:	0a ee       	ldi	r16, 0xEA	; 234
    26c2:	17 e0       	ldi	r17, 0x07	; 7
    26c4:	23 e3       	ldi	r18, 0x33	; 51
    26c6:	33 e3       	ldi	r19, 0x33	; 51
    26c8:	4b ec       	ldi	r20, 0xCB	; 203
    26ca:	51 e4       	ldi	r21, 0x41	; 65
    26cc:	d8 01       	movw	r26, r16
    26ce:	6d 91       	ld	r22, X+
    26d0:	7d 91       	ld	r23, X+
    26d2:	8d 91       	ld	r24, X+
    26d4:	9c 91       	ld	r25, X
    26d6:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    26da:	f8 01       	movw	r30, r16
    26dc:	60 83       	st	Z, r22
    26de:	71 83       	std	Z+1, r23	; 0x01
    26e0:	82 83       	std	Z+2, r24	; 0x02
    26e2:	93 83       	std	Z+3, r25	; 0x03
                j = (y + (x * h_x2_div_d))/2       
            */      

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    26e4:	40 90 ea 07 	lds	r4, 0x07EA
    26e8:	50 90 eb 07 	lds	r5, 0x07EB
    26ec:	60 90 ec 07 	lds	r6, 0x07EC
    26f0:	70 90 ed 07 	lds	r7, 0x07ED
    26f4:	20 e0       	ldi	r18, 0x00	; 0
    26f6:	30 e0       	ldi	r19, 0x00	; 0
    26f8:	40 e8       	ldi	r20, 0x80	; 128
    26fa:	50 e4       	ldi	r21, 0x40	; 64
    26fc:	c3 01       	movw	r24, r6
    26fe:	b2 01       	movw	r22, r4
    2700:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    2704:	9b 01       	movw	r18, r22
    2706:	ac 01       	movw	r20, r24
    2708:	c3 01       	movw	r24, r6
    270a:	b2 01       	movw	r22, r4
    270c:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    2710:	2b 01       	movw	r4, r22
    2712:	3c 01       	movw	r6, r24
    2714:	a7 01       	movw	r20, r14
    2716:	96 01       	movw	r18, r12
    2718:	c7 01       	movw	r24, r14
    271a:	b6 01       	movw	r22, r12
    271c:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    2720:	9b 01       	movw	r18, r22
    2722:	ac 01       	movw	r20, r24
    2724:	c3 01       	movw	r24, r6
    2726:	b2 01       	movw	r22, r4
    2728:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    272c:	2b 01       	movw	r4, r22
    272e:	3c 01       	movw	r6, r24
    2730:	a5 01       	movw	r20, r10
    2732:	94 01       	movw	r18, r8
    2734:	c5 01       	movw	r24, r10
    2736:	b4 01       	movw	r22, r8
    2738:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    273c:	9b 01       	movw	r18, r22
    273e:	ac 01       	movw	r20, r24
    2740:	c3 01       	movw	r24, r6
    2742:	b2 01       	movw	r22, r4
    2744:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    2748:	2b 01       	movw	r4, r22
    274a:	3c 01       	movw	r6, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    274c:	20 e0       	ldi	r18, 0x00	; 0
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	a9 01       	movw	r20, r18
    2752:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    2756:	88 23       	and	r24, r24
    2758:	0c f4       	brge	.+2      	; 0x275c <gc_execute_line+0xd80>
    275a:	d0 c3       	rjmp	.+1952   	; 0x2efc <gc_execute_line+0x1520>
    
            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    275c:	c3 01       	movw	r24, r6
    275e:	b2 01       	movw	r22, r4
    2760:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    2764:	2b 01       	movw	r4, r22
    2766:	3c 01       	movw	r6, r24
    2768:	a5 01       	movw	r20, r10
    276a:	94 01       	movw	r18, r8
    276c:	c7 01       	movw	r24, r14
    276e:	b6 01       	movw	r22, r12
    2770:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <hypot_f>
    2774:	9b 01       	movw	r18, r22
    2776:	ac 01       	movw	r20, r24
    2778:	c3 01       	movw	r24, r6
    277a:	b2 01       	movw	r22, r4
    277c:	90 58       	subi	r25, 0x80	; 128
    277e:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    2782:	2b 01       	movw	r4, r22
    2784:	3c 01       	movw	r6, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }  
    2786:	80 91 c7 07 	lds	r24, 0x07C7
    278a:	83 30       	cpi	r24, 0x03	; 3
    278c:	21 f4       	brne	.+8      	; 0x2796 <gc_execute_line+0xdba>
    278e:	77 fa       	bst	r7, 7
    2790:	70 94       	com	r7
    2792:	77 f8       	bld	r7, 7
    2794:	70 94       	com	r7
            */  
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
            // even though it is advised against ever generating such circles in a single line of g-code. By 
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) { 
    2796:	80 91 ea 07 	lds	r24, 0x07EA
    279a:	90 91 eb 07 	lds	r25, 0x07EB
    279e:	a0 91 ec 07 	lds	r26, 0x07EC
    27a2:	b0 91 ed 07 	lds	r27, 0x07ED
    27a6:	8f 8f       	std	Y+31, r24	; 0x1f
    27a8:	98 a3       	std	Y+32, r25	; 0x20
    27aa:	a9 a3       	std	Y+33, r26	; 0x21
    27ac:	ba a3       	std	Y+34, r27	; 0x22
    27ae:	20 e0       	ldi	r18, 0x00	; 0
    27b0:	30 e0       	ldi	r19, 0x00	; 0
    27b2:	a9 01       	movw	r20, r18
    27b4:	bc 01       	movw	r22, r24
    27b6:	cd 01       	movw	r24, r26
    27b8:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    27bc:	88 23       	and	r24, r24
    27be:	8c f4       	brge	.+34     	; 0x27e2 <gc_execute_line+0xe06>
                h_x2_div_d = -h_x2_div_d; 
    27c0:	77 fa       	bst	r7, 7
    27c2:	70 94       	com	r7
    27c4:	77 f8       	bld	r7, 7
    27c6:	70 94       	com	r7
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    27c8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    27ca:	98 a1       	ldd	r25, Y+32	; 0x20
    27cc:	a9 a1       	ldd	r26, Y+33	; 0x21
    27ce:	ba a1       	ldd	r27, Y+34	; 0x22
    27d0:	b0 58       	subi	r27, 0x80	; 128
    27d2:	80 93 ea 07 	sts	0x07EA, r24
    27d6:	90 93 eb 07 	sts	0x07EB, r25
    27da:	a0 93 ec 07 	sts	0x07EC, r26
    27de:	b0 93 ed 07 	sts	0x07ED, r27
            }        
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    27e2:	08 a5       	ldd	r16, Y+40	; 0x28
    27e4:	19 a5       	ldd	r17, Y+41	; 0x29
    27e6:	00 0f       	add	r16, r16
    27e8:	11 1f       	adc	r17, r17
    27ea:	00 0f       	add	r16, r16
    27ec:	11 1f       	adc	r17, r17
    27ee:	06 53       	subi	r16, 0x36	; 54
    27f0:	18 4f       	sbci	r17, 0xF8	; 248
    27f2:	a3 01       	movw	r20, r6
    27f4:	92 01       	movw	r18, r4
    27f6:	c5 01       	movw	r24, r10
    27f8:	b4 01       	movw	r22, r8
    27fa:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    27fe:	9b 01       	movw	r18, r22
    2800:	ac 01       	movw	r20, r24
    2802:	c7 01       	movw	r24, r14
    2804:	b6 01       	movw	r22, r12
    2806:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    280a:	20 e0       	ldi	r18, 0x00	; 0
    280c:	30 e0       	ldi	r19, 0x00	; 0
    280e:	40 e0       	ldi	r20, 0x00	; 0
    2810:	5f e3       	ldi	r21, 0x3F	; 63
    2812:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    2816:	d8 01       	movw	r26, r16
    2818:	1b 96       	adiw	r26, 0x0b	; 11
    281a:	6d 93       	st	X+, r22
    281c:	7d 93       	st	X+, r23
    281e:	8d 93       	st	X+, r24
    2820:	9c 93       	st	X, r25
    2822:	1e 97       	sbiw	r26, 0x0e	; 14
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    2824:	0a a5       	ldd	r16, Y+42	; 0x2a
    2826:	1b a5       	ldd	r17, Y+43	; 0x2b
    2828:	00 0f       	add	r16, r16
    282a:	11 1f       	adc	r17, r17
    282c:	00 0f       	add	r16, r16
    282e:	11 1f       	adc	r17, r17
    2830:	06 53       	subi	r16, 0x36	; 54
    2832:	18 4f       	sbci	r17, 0xF8	; 248
    2834:	a3 01       	movw	r20, r6
    2836:	92 01       	movw	r18, r4
    2838:	c7 01       	movw	r24, r14
    283a:	b6 01       	movw	r22, r12
    283c:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    2840:	a5 01       	movw	r20, r10
    2842:	94 01       	movw	r18, r8
    2844:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    2848:	20 e0       	ldi	r18, 0x00	; 0
    284a:	30 e0       	ldi	r19, 0x00	; 0
    284c:	40 e0       	ldi	r20, 0x00	; 0
    284e:	5f e3       	ldi	r21, 0x3F	; 63
    2850:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    2854:	f8 01       	movw	r30, r16
    2856:	63 87       	std	Z+11, r22	; 0x0b
    2858:	74 87       	std	Z+12, r23	; 0x0c
    285a:	85 87       	std	Z+13, r24	; 0x0d
    285c:	96 87       	std	Z+14, r25	; 0x0e
    285e:	f9 c0       	rjmp	.+498    	; 0x2a52 <gc_execute_line+0x1076>
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2860:	fb a1       	ldd	r31, Y+35	; 0x23
    2862:	4f 2e       	mov	r4, r31
    2864:	51 2c       	mov	r5, r1
    2866:	04 21       	and	r16, r4
    2868:	15 21       	and	r17, r5
    286a:	01 2b       	or	r16, r17
    286c:	09 f4       	brne	.+2      	; 0x2870 <gc_execute_line+0xe94>
    286e:	48 c3       	rjmp	.+1680   	; 0x2f00 <gc_execute_line+0x1524>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
    2870:	21 ef       	ldi	r18, 0xF1	; 241
    2872:	22 22       	and	r2, r18
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2874:	80 91 c9 07 	lds	r24, 0x07C9
    2878:	81 30       	cpi	r24, 0x01	; 1
    287a:	49 f5       	brne	.+82     	; 0x28ce <gc_execute_line+0xef2>
    287c:	0f 2e       	mov	r0, r31
    287e:	f5 ed       	ldi	r31, 0xD5	; 213
    2880:	6f 2e       	mov	r6, r31
    2882:	f7 e0       	ldi	r31, 0x07	; 7
    2884:	7f 2e       	mov	r7, r31
    2886:	f0 2d       	mov	r31, r0
    2888:	00 e0       	ldi	r16, 0x00	; 0
    288a:	10 e0       	ldi	r17, 0x00	; 0
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    288c:	c2 01       	movw	r24, r4
    288e:	00 2e       	mov	r0, r16
    2890:	02 c0       	rjmp	.+4      	; 0x2896 <gc_execute_line+0xeba>
    2892:	95 95       	asr	r25
    2894:	87 95       	ror	r24
    2896:	0a 94       	dec	r0
    2898:	e2 f7       	brpl	.-8      	; 0x2892 <gc_execute_line+0xeb6>
    289a:	80 ff       	sbrs	r24, 0
    289c:	10 c0       	rjmp	.+32     	; 0x28be <gc_execute_line+0xee2>
    289e:	23 e3       	ldi	r18, 0x33	; 51
    28a0:	33 e3       	ldi	r19, 0x33	; 51
    28a2:	4b ec       	ldi	r20, 0xCB	; 203
    28a4:	51 e4       	ldi	r21, 0x41	; 65
    28a6:	d3 01       	movw	r26, r6
    28a8:	6d 91       	ld	r22, X+
    28aa:	7d 91       	ld	r23, X+
    28ac:	8d 91       	ld	r24, X+
    28ae:	9c 91       	ld	r25, X
    28b0:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    28b4:	f3 01       	movw	r30, r6
    28b6:	60 83       	st	Z, r22
    28b8:	71 83       	std	Z+1, r23	; 0x01
    28ba:	82 83       	std	Z+2, r24	; 0x02
    28bc:	93 83       	std	Z+3, r25	; 0x03
    28be:	0f 5f       	subi	r16, 0xFF	; 255
    28c0:	1f 4f       	sbci	r17, 0xFF	; 255
    28c2:	f4 e0       	ldi	r31, 0x04	; 4
    28c4:	6f 0e       	add	r6, r31
    28c6:	71 1c       	adc	r7, r1
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    28c8:	03 30       	cpi	r16, 0x03	; 3
    28ca:	11 05       	cpc	r17, r1
    28cc:	f9 f6       	brne	.-66     	; 0x288c <gc_execute_line+0xeb0>
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    28ce:	0a a5       	ldd	r16, Y+42	; 0x2a
    28d0:	1b a5       	ldd	r17, Y+43	; 0x2b
    28d2:	00 0f       	add	r16, r16
    28d4:	11 1f       	adc	r17, r17
    28d6:	00 0f       	add	r16, r16
    28d8:	11 1f       	adc	r17, r17
    28da:	06 53       	subi	r16, 0x36	; 54
    28dc:	18 4f       	sbci	r17, 0xF8	; 248
    28de:	d8 01       	movw	r26, r16
    28e0:	1b 96       	adiw	r26, 0x0b	; 11
    28e2:	2d 91       	ld	r18, X+
    28e4:	3d 91       	ld	r19, X+
    28e6:	4d 91       	ld	r20, X+
    28e8:	5c 91       	ld	r21, X
    28ea:	1e 97       	sbiw	r26, 0x0e	; 14
    28ec:	c5 01       	movw	r24, r10
    28ee:	b4 01       	movw	r22, r8
    28f0:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    28f4:	2b 01       	movw	r4, r22
    28f6:	3c 01       	movw	r6, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    28f8:	88 a5       	ldd	r24, Y+40	; 0x28
    28fa:	99 a5       	ldd	r25, Y+41	; 0x29
    28fc:	88 0f       	add	r24, r24
    28fe:	99 1f       	adc	r25, r25
    2900:	88 0f       	add	r24, r24
    2902:	99 1f       	adc	r25, r25
    2904:	fc 01       	movw	r30, r24
    2906:	e6 53       	subi	r30, 0x36	; 54
    2908:	f8 4f       	sbci	r31, 0xF8	; 248
    290a:	5f 01       	movw	r10, r30
    290c:	23 85       	ldd	r18, Z+11	; 0x0b
    290e:	34 85       	ldd	r19, Z+12	; 0x0c
    2910:	45 85       	ldd	r20, Z+13	; 0x0d
    2912:	56 85       	ldd	r21, Z+14	; 0x0e
    2914:	c7 01       	movw	r24, r14
    2916:	b6 01       	movw	r22, r12
    2918:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y); 
    291c:	a3 01       	movw	r20, r6
    291e:	92 01       	movw	r18, r4
    2920:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <hypot_f>
    2924:	6b 01       	movw	r12, r22
    2926:	7c 01       	movw	r14, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
    2928:	d8 01       	movw	r26, r16
    292a:	1b 96       	adiw	r26, 0x0b	; 11
    292c:	2d 91       	ld	r18, X+
    292e:	3d 91       	ld	r19, X+
    2930:	4d 91       	ld	r20, X+
    2932:	5c 91       	ld	r21, X
    2934:	1e 97       	sbiw	r26, 0x0e	; 14
    2936:	f5 01       	movw	r30, r10
    2938:	63 85       	ldd	r22, Z+11	; 0x0b
    293a:	74 85       	ldd	r23, Z+12	; 0x0c
    293c:	85 85       	ldd	r24, Z+13	; 0x0d
    293e:	96 85       	ldd	r25, Z+14	; 0x0e
    2940:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <hypot_f>
    2944:	4b 01       	movw	r8, r22
    2946:	5c 01       	movw	r10, r24
    2948:	60 93 ea 07 	sts	0x07EA, r22
    294c:	70 93 eb 07 	sts	0x07EB, r23
    2950:	80 93 ec 07 	sts	0x07EC, r24
    2954:	90 93 ed 07 	sts	0x07ED, r25
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    2958:	9b 01       	movw	r18, r22
    295a:	ac 01       	movw	r20, r24
    295c:	c7 01       	movw	r24, r14
    295e:	b6 01       	movw	r22, r12
    2960:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    2964:	6b 01       	movw	r12, r22
    2966:	7c 01       	movw	r14, r24
    2968:	e8 94       	clt
    296a:	f7 f8       	bld	r15, 7
            if (delta_r > 0.005) { 
    296c:	2a e0       	ldi	r18, 0x0A	; 10
    296e:	37 ed       	ldi	r19, 0xD7	; 215
    2970:	43 ea       	ldi	r20, 0xA3	; 163
    2972:	5b e3       	ldi	r21, 0x3B	; 59
    2974:	c7 01       	movw	r24, r14
    2976:	b6 01       	movw	r22, r12
    2978:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    297c:	18 16       	cp	r1, r24
    297e:	0c f0       	brlt	.+2      	; 0x2982 <gc_execute_line+0xfa6>
    2980:	68 c0       	rjmp	.+208    	; 0x2a52 <gc_execute_line+0x1076>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    2982:	20 e0       	ldi	r18, 0x00	; 0
    2984:	30 e0       	ldi	r19, 0x00	; 0
    2986:	40 e0       	ldi	r20, 0x00	; 0
    2988:	5f e3       	ldi	r21, 0x3F	; 63
    298a:	c7 01       	movw	r24, r14
    298c:	b6 01       	movw	r22, r12
    298e:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    2992:	18 16       	cp	r1, r24
    2994:	0c f4       	brge	.+2      	; 0x2998 <gc_execute_line+0xfbc>
    2996:	b6 c2       	rjmp	.+1388   	; 0x2f04 <gc_execute_line+0x1528>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    2998:	2f e6       	ldi	r18, 0x6F	; 111
    299a:	32 e1       	ldi	r19, 0x12	; 18
    299c:	43 e8       	ldi	r20, 0x83	; 131
    299e:	5a e3       	ldi	r21, 0x3A	; 58
    29a0:	c5 01       	movw	r24, r10
    29a2:	b4 01       	movw	r22, r8
    29a4:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    29a8:	9b 01       	movw	r18, r22
    29aa:	ac 01       	movw	r20, r24
    29ac:	c7 01       	movw	r24, r14
    29ae:	b6 01       	movw	r22, r12
    29b0:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    29b4:	18 16       	cp	r1, r24
    29b6:	0c f4       	brge	.+2      	; 0x29ba <gc_execute_line+0xfde>
    29b8:	a7 c2       	rjmp	.+1358   	; 0x2f08 <gc_execute_line+0x152c>
    29ba:	4b c0       	rjmp	.+150    	; 0x2a52 <gc_execute_line+0x1076>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    29bc:	ff 8d       	ldd	r31, Y+31	; 0x1f
    29be:	ff 23       	and	r31, r31
    29c0:	09 f4       	brne	.+2      	; 0x29c4 <gc_execute_line+0xfe8>
    29c2:	a4 c2       	rjmp	.+1352   	; 0x2f0c <gc_execute_line+0x1530>

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
    29c4:	20 91 f3 07 	lds	r18, 0x07F3
    29c8:	30 91 f4 07 	lds	r19, 0x07F4
    29cc:	40 91 f5 07 	lds	r20, 0x07F5
    29d0:	50 91 f6 07 	lds	r21, 0x07F6
    29d4:	60 91 9e 07 	lds	r22, 0x079E
    29d8:	70 91 9f 07 	lds	r23, 0x079F
    29dc:	80 91 a0 07 	lds	r24, 0x07A0
    29e0:	90 91 a1 07 	lds	r25, 0x07A1
    29e4:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    29e8:	81 11       	cpse	r24, r1
    29ea:	33 c0       	rjmp	.+102    	; 0x2a52 <gc_execute_line+0x1076>
    29ec:	20 91 f7 07 	lds	r18, 0x07F7
    29f0:	30 91 f8 07 	lds	r19, 0x07F8
    29f4:	40 91 f9 07 	lds	r20, 0x07F9
    29f8:	50 91 fa 07 	lds	r21, 0x07FA
    29fc:	60 91 a2 07 	lds	r22, 0x07A2
    2a00:	70 91 a3 07 	lds	r23, 0x07A3
    2a04:	80 91 a4 07 	lds	r24, 0x07A4
    2a08:	90 91 a5 07 	lds	r25, 0x07A5
    2a0c:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    2a10:	81 11       	cpse	r24, r1
    2a12:	1f c0       	rjmp	.+62     	; 0x2a52 <gc_execute_line+0x1076>
    2a14:	20 91 fb 07 	lds	r18, 0x07FB
    2a18:	30 91 fc 07 	lds	r19, 0x07FC
    2a1c:	40 91 fd 07 	lds	r20, 0x07FD
    2a20:	50 91 fe 07 	lds	r21, 0x07FE
    2a24:	60 91 a6 07 	lds	r22, 0x07A6
    2a28:	70 91 a7 07 	lds	r23, 0x07A7
    2a2c:	80 91 a8 07 	lds	r24, 0x07A8
    2a30:	90 91 a9 07 	lds	r25, 0x07A9
    2a34:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    2a38:	81 11       	cpse	r24, r1
    2a3a:	0b c0       	rjmp	.+22     	; 0x2a52 <gc_execute_line+0x1076>
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2a3c:	81 e2       	ldi	r24, 0x21	; 33
    2a3e:	7f c2       	rjmp	.+1278   	; 0x2f3e <gc_execute_line+0x1562>
    2a40:	1f a2       	std	Y+39, r1	; 0x27
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    2a42:	2e 8d       	ldd	r18, Y+30	; 0x1e
    2a44:	21 11       	cpse	r18, r1
    2a46:	05 c0       	rjmp	.+10     	; 0x2a52 <gc_execute_line+0x1076>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    2a48:	3e ed       	ldi	r19, 0xDE	; 222
    2a4a:	23 22       	and	r2, r19
    2a4c:	3c ef       	ldi	r19, 0xFC	; 252
    2a4e:	33 22       	and	r3, r19
    2a50:	04 c0       	rjmp	.+8      	; 0x2a5a <gc_execute_line+0x107e>
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    2a52:	8e ed       	ldi	r24, 0xDE	; 222
    2a54:	28 22       	and	r2, r24
    2a56:	80 ee       	ldi	r24, 0xE0	; 224
    2a58:	38 22       	and	r3, r24
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2a5a:	23 28       	or	r2, r3
    2a5c:	09 f0       	breq	.+2      	; 0x2a60 <gc_execute_line+0x1084>
    2a5e:	58 c2       	rjmp	.+1200   	; 0x2f10 <gc_execute_line+0x1534>
     Assumes that all error-checking has been completed and no failure modes exist. We just
     need to update the state and execute the block according to the order-of-execution.
  */ 
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  gc_state.line_number = gc_block.values.n;
    2a60:	80 91 e2 07 	lds	r24, 0x07E2
    2a64:	90 91 e3 07 	lds	r25, 0x07E3
    2a68:	a0 91 e4 07 	lds	r26, 0x07E4
    2a6c:	b0 91 e5 07 	lds	r27, 0x07E5
    2a70:	80 93 9a 07 	sts	0x079A, r24
    2a74:	90 93 9b 07 	sts	0x079B, r25
    2a78:	a0 93 9c 07 	sts	0x079C, r26
    2a7c:	b0 93 9d 07 	sts	0x079D, r27
  
  // [1. Comments feedback ]:  NOT SUPPORTED
  
  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    2a80:	80 91 c8 07 	lds	r24, 0x07C8
    2a84:	80 93 88 07 	sts	0x0788, r24
  
  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    2a88:	80 91 d1 07 	lds	r24, 0x07D1
    2a8c:	90 91 d2 07 	lds	r25, 0x07D2
    2a90:	a0 91 d3 07 	lds	r26, 0x07D3
    2a94:	b0 91 d4 07 	lds	r27, 0x07D4
    2a98:	80 93 95 07 	sts	0x0795, r24
    2a9c:	90 93 96 07 	sts	0x0796, r25
    2aa0:	a0 93 97 07 	sts	0x0797, r26
    2aa4:	b0 93 98 07 	sts	0x0798, r27

  // [4. Set spindle speed ]:
  if (gc_state.spindle_speed != gc_block.values.s) { 
    2aa8:	c0 90 ee 07 	lds	r12, 0x07EE
    2aac:	d0 90 ef 07 	lds	r13, 0x07EF
    2ab0:	e0 90 f0 07 	lds	r14, 0x07F0
    2ab4:	f0 90 f1 07 	lds	r15, 0x07F1
    2ab8:	a7 01       	movw	r20, r14
    2aba:	96 01       	movw	r18, r12
    2abc:	60 91 91 07 	lds	r22, 0x0791
    2ac0:	70 91 92 07 	lds	r23, 0x0792
    2ac4:	80 91 93 07 	lds	r24, 0x0793
    2ac8:	90 91 94 07 	lds	r25, 0x0794
    2acc:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    2ad0:	88 23       	and	r24, r24
    2ad2:	c1 f0       	breq	.+48     	; 0x2b04 <gc_execute_line+0x1128>
    // Update running spindle only if not in check mode and not already enabled.
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { spindle_run(gc_state.modal.spindle, gc_block.values.s); }
    2ad4:	80 91 90 07 	lds	r24, 0x0790
    2ad8:	88 23       	and	r24, r24
    2ada:	21 f0       	breq	.+8      	; 0x2ae4 <gc_execute_line+0x1108>
    2adc:	b7 01       	movw	r22, r14
    2ade:	a6 01       	movw	r20, r12
    2ae0:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <spindle_run>
    gc_state.spindle_speed = gc_block.values.s; 
    2ae4:	80 91 ee 07 	lds	r24, 0x07EE
    2ae8:	90 91 ef 07 	lds	r25, 0x07EF
    2aec:	a0 91 f0 07 	lds	r26, 0x07F0
    2af0:	b0 91 f1 07 	lds	r27, 0x07F1
    2af4:	80 93 91 07 	sts	0x0791, r24
    2af8:	90 93 92 07 	sts	0x0792, r25
    2afc:	a0 93 93 07 	sts	0x0793, r26
    2b00:	b0 93 94 07 	sts	0x0794, r27
  }
    
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    2b04:	80 91 f2 07 	lds	r24, 0x07F2
    2b08:	80 93 99 07 	sts	0x0799, r24

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    2b0c:	80 91 d0 07 	lds	r24, 0x07D0
    2b10:	90 91 90 07 	lds	r25, 0x0790
    2b14:	98 17       	cp	r25, r24
    2b16:	71 f0       	breq	.+28     	; 0x2b34 <gc_execute_line+0x1158>
    // Update spindle control and apply spindle speed when enabling it in this block.    
    spindle_run(gc_block.modal.spindle, gc_state.spindle_speed);
    2b18:	40 91 91 07 	lds	r20, 0x0791
    2b1c:	50 91 92 07 	lds	r21, 0x0792
    2b20:	60 91 93 07 	lds	r22, 0x0793
    2b24:	70 91 94 07 	lds	r23, 0x0794
    2b28:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <spindle_run>
    gc_state.modal.spindle = gc_block.modal.spindle;    
    2b2c:	80 91 d0 07 	lds	r24, 0x07D0
    2b30:	80 93 90 07 	sts	0x0790, r24
  }

  // [8. Coolant control ]:  
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    2b34:	80 91 cf 07 	lds	r24, 0x07CF
    2b38:	90 91 8f 07 	lds	r25, 0x078F
    2b3c:	98 17       	cp	r25, r24
    2b3e:	31 f0       	breq	.+12     	; 0x2b4c <gc_execute_line+0x1170>
    coolant_run(gc_block.modal.coolant);
    2b40:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <coolant_run>
    gc_state.modal.coolant = gc_block.modal.coolant;
    2b44:	80 91 cf 07 	lds	r24, 0x07CF
    2b48:	80 93 8f 07 	sts	0x078F, r24
  }
  
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    2b4c:	80 91 c6 07 	lds	r24, 0x07C6
    2b50:	81 30       	cpi	r24, 0x01	; 1
    2b52:	51 f4       	brne	.+20     	; 0x2b68 <gc_execute_line+0x118c>
    2b54:	60 91 e6 07 	lds	r22, 0x07E6
    2b58:	70 91 e7 07 	lds	r23, 0x07E7
    2b5c:	80 91 e8 07 	lds	r24, 0x07E8
    2b60:	90 91 e9 07 	lds	r25, 0x07E9
    2b64:	0e 94 b1 0b 	call	0x1762	; 0x1762 <mc_dwell>
  
  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;  
    2b68:	80 91 cb 07 	lds	r24, 0x07CB
    2b6c:	80 93 8b 07 	sts	0x078B, r24

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    2b70:	80 91 c9 07 	lds	r24, 0x07C9
    2b74:	80 93 89 07 	sts	0x0789, r24

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array. 
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    2b78:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2b7a:	93 30       	cpi	r25, 0x03	; 3
    2b7c:	f9 f4       	brne	.+62     	; 0x2bbc <gc_execute_line+0x11e0>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    2b7e:	80 91 cc 07 	lds	r24, 0x07CC
    2b82:	80 93 8c 07 	sts	0x078C, r24
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) { // G43.1
    2b86:	81 30       	cpi	r24, 0x01	; 1
    2b88:	89 f4       	brne	.+34     	; 0x2bac <gc_execute_line+0x11d0>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    2b8a:	80 91 fb 07 	lds	r24, 0x07FB
    2b8e:	90 91 fc 07 	lds	r25, 0x07FC
    2b92:	a0 91 fd 07 	lds	r26, 0x07FD
    2b96:	b0 91 fe 07 	lds	r27, 0x07FE
    2b9a:	80 93 c2 07 	sts	0x07C2, r24
    2b9e:	90 93 c3 07 	sts	0x07C3, r25
    2ba2:	a0 93 c4 07 	sts	0x07C4, r26
    2ba6:	b0 93 c5 07 	sts	0x07C5, r27
    2baa:	08 c0       	rjmp	.+16     	; 0x2bbc <gc_execute_line+0x11e0>
    } else { // G49
      gc_state.tool_length_offset = 0.0;
    2bac:	10 92 c2 07 	sts	0x07C2, r1
    2bb0:	10 92 c3 07 	sts	0x07C3, r1
    2bb4:	10 92 c4 07 	sts	0x07C4, r1
    2bb8:	10 92 c5 07 	sts	0x07C5, r1
    }
  }
  
  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    2bbc:	80 91 cd 07 	lds	r24, 0x07CD
    2bc0:	90 91 8d 07 	lds	r25, 0x078D
    2bc4:	98 17       	cp	r25, r24
    2bc6:	59 f0       	breq	.+22     	; 0x2bde <gc_execute_line+0x1202>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    2bc8:	80 93 8d 07 	sts	0x078D, r24
    memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    2bcc:	8c e0       	ldi	r24, 0x0C	; 12
    2bce:	fe 01       	movw	r30, r28
    2bd0:	31 96       	adiw	r30, 0x01	; 1
    2bd2:	aa ea       	ldi	r26, 0xAA	; 170
    2bd4:	b7 e0       	ldi	r27, 0x07	; 7
    2bd6:	01 90       	ld	r0, Z+
    2bd8:	0d 92       	st	X+, r0
    2bda:	8a 95       	dec	r24
    2bdc:	e1 f7       	brne	.-8      	; 0x2bd6 <gc_execute_line+0x11fa>
  }
  
  // [16. Set path control mode ]: NOT SUPPORTED
  
  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    2bde:	80 91 ca 07 	lds	r24, 0x07CA
    2be2:	80 93 8a 07 	sts	0x078A, r24
  
  // [18. Set retract mode ]: NOT SUPPORTED
    
  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    2be6:	80 91 c6 07 	lds	r24, 0x07C6
    2bea:	90 e0       	ldi	r25, 0x00	; 0
    2bec:	fc 01       	movw	r30, r24
    2bee:	32 97       	sbiw	r30, 0x02	; 2
    2bf0:	e8 30       	cpi	r30, 0x08	; 8
    2bf2:	f1 05       	cpc	r31, r1
    2bf4:	08 f0       	brcs	.+2      	; 0x2bf8 <gc_execute_line+0x121c>
    2bf6:	55 c0       	rjmp	.+170    	; 0x2ca2 <gc_execute_line+0x12c6>
    2bf8:	e5 53       	subi	r30, 0x35	; 53
    2bfa:	ff 4f       	sbci	r31, 0xFF	; 255
    2bfc:	0c 94 fa 3f 	jmp	0x7ff4	; 0x7ff4 <__tablejump2__>
    case NON_MODAL_SET_COORDINATE_DATA:    
      settings_write_coord_data(coord_select,parameter_data);
    2c00:	be 01       	movw	r22, r28
    2c02:	63 5f       	subi	r22, 0xF3	; 243
    2c04:	7f 4f       	sbci	r23, 0xFF	; 255
    2c06:	8f a1       	ldd	r24, Y+39	; 0x27
    2c08:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) { memcpy(gc_state.coord_system,parameter_data,sizeof(parameter_data)); }
    2c0c:	80 91 8d 07 	lds	r24, 0x078D
    2c10:	af a1       	ldd	r26, Y+39	; 0x27
    2c12:	8a 13       	cpse	r24, r26
    2c14:	46 c0       	rjmp	.+140    	; 0x2ca2 <gc_execute_line+0x12c6>
    2c16:	8c e0       	ldi	r24, 0x0C	; 12
    2c18:	fe 01       	movw	r30, r28
    2c1a:	3d 96       	adiw	r30, 0x0d	; 13
    2c1c:	aa ea       	ldi	r26, 0xAA	; 170
    2c1e:	b7 e0       	ldi	r27, 0x07	; 7
    2c20:	01 90       	ld	r0, Z+
    2c22:	0d 92       	st	X+, r0
    2c24:	8a 95       	dec	r24
    2c26:	e1 f7       	brne	.-8      	; 0x2c20 <gc_execute_line+0x1244>
    2c28:	3c c0       	rjmp	.+120    	; 0x2ca2 <gc_execute_line+0x12c6>
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1: 
      // Move to intermediate position before going home. Obeys current coordinate system and offsets 
      // and absolute and incremental modes.
      if (axis_command) {
    2c2a:	be 8d       	ldd	r27, Y+30	; 0x1e
    2c2c:	bb 23       	and	r27, r27
    2c2e:	49 f0       	breq	.+18     	; 0x2c42 <gc_execute_line+0x1266>
        #ifdef USE_LINE_NUMBERS
          mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
        #else
          mc_line(gc_block.values.xyz, -1.0, false);
    2c30:	20 e0       	ldi	r18, 0x00	; 0
    2c32:	40 e0       	ldi	r20, 0x00	; 0
    2c34:	50 e0       	ldi	r21, 0x00	; 0
    2c36:	60 e8       	ldi	r22, 0x80	; 128
    2c38:	7f eb       	ldi	r23, 0xBF	; 191
    2c3a:	83 ef       	ldi	r24, 0xF3	; 243
    2c3c:	97 e0       	ldi	r25, 0x07	; 7
    2c3e:	0e 94 5f 08 	call	0x10be	; 0x10be <mc_line>
        #endif
      }
      #ifdef USE_LINE_NUMBERS
        mc_line(parameter_data, -1.0, false, gc_state.line_number); 
      #else
        mc_line(parameter_data, -1.0, false); 
    2c42:	20 e0       	ldi	r18, 0x00	; 0
    2c44:	40 e0       	ldi	r20, 0x00	; 0
    2c46:	50 e0       	ldi	r21, 0x00	; 0
    2c48:	60 e8       	ldi	r22, 0x80	; 128
    2c4a:	7f eb       	ldi	r23, 0xBF	; 191
    2c4c:	ce 01       	movw	r24, r28
    2c4e:	0d 96       	adiw	r24, 0x0d	; 13
    2c50:	0e 94 5f 08 	call	0x10be	; 0x10be <mc_line>
      #endif
      memcpy(gc_state.position, parameter_data, sizeof(parameter_data));
    2c54:	8c e0       	ldi	r24, 0x0C	; 12
    2c56:	fe 01       	movw	r30, r28
    2c58:	3d 96       	adiw	r30, 0x0d	; 13
    2c5a:	ae e9       	ldi	r26, 0x9E	; 158
    2c5c:	b7 e0       	ldi	r27, 0x07	; 7
    2c5e:	01 90       	ld	r0, Z+
    2c60:	0d 92       	st	X+, r0
    2c62:	8a 95       	dec	r24
    2c64:	e1 f7       	brne	.-8      	; 0x2c5e <gc_execute_line+0x1282>
      break;
    2c66:	1d c0       	rjmp	.+58     	; 0x2ca2 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_HOME_0: 
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    2c68:	6e e9       	ldi	r22, 0x9E	; 158
    2c6a:	77 e0       	ldi	r23, 0x07	; 7
    2c6c:	86 e0       	ldi	r24, 0x06	; 6
    2c6e:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <settings_write_coord_data>
      break;
    2c72:	17 c0       	rjmp	.+46     	; 0x2ca2 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    2c74:	6e e9       	ldi	r22, 0x9E	; 158
    2c76:	77 e0       	ldi	r23, 0x07	; 7
    2c78:	87 e0       	ldi	r24, 0x07	; 7
    2c7a:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <settings_write_coord_data>
      break;
    2c7e:	11 c0       	rjmp	.+34     	; 0x2ca2 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    2c80:	8c e0       	ldi	r24, 0x0C	; 12
    2c82:	e3 ef       	ldi	r30, 0xF3	; 243
    2c84:	f7 e0       	ldi	r31, 0x07	; 7
    2c86:	a6 eb       	ldi	r26, 0xB6	; 182
    2c88:	b7 e0       	ldi	r27, 0x07	; 7
    2c8a:	01 90       	ld	r0, Z+
    2c8c:	0d 92       	st	X+, r0
    2c8e:	8a 95       	dec	r24
    2c90:	e1 f7       	brne	.-8      	; 0x2c8a <gc_execute_line+0x12ae>
      break;
    2c92:	07 c0       	rjmp	.+14     	; 0x2ca2 <gc_execute_line+0x12c6>
    case NON_MODAL_RESET_COORDINATE_OFFSET: 
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    2c94:	8c e0       	ldi	r24, 0x0C	; 12
    2c96:	e6 eb       	ldi	r30, 0xB6	; 182
    2c98:	f7 e0       	ldi	r31, 0x07	; 7
    2c9a:	df 01       	movw	r26, r30
    2c9c:	1d 92       	st	X+, r1
    2c9e:	8a 95       	dec	r24
    2ca0:	e9 f7       	brne	.-6      	; 0x2c9c <gc_execute_line+0x12c0>

  
  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes. 
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    2ca2:	80 91 c7 07 	lds	r24, 0x07C7
    2ca6:	80 93 87 07 	sts	0x0787, r24
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    2caa:	88 30       	cpi	r24, 0x08	; 8
    2cac:	09 f4       	brne	.+2      	; 0x2cb0 <gc_execute_line+0x12d4>
    2cae:	be c0       	rjmp	.+380    	; 0x2e2c <gc_execute_line+0x1450>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    2cb0:	be 8d       	ldd	r27, Y+30	; 0x1e
    2cb2:	b2 30       	cpi	r27, 0x02	; 2
    2cb4:	09 f0       	breq	.+2      	; 0x2cb8 <gc_execute_line+0x12dc>
    2cb6:	ba c0       	rjmp	.+372    	; 0x2e2c <gc_execute_line+0x1450>
      switch (gc_state.modal.motion) {
    2cb8:	90 e0       	ldi	r25, 0x00	; 0
    2cba:	88 30       	cpi	r24, 0x08	; 8
    2cbc:	91 05       	cpc	r25, r1
    2cbe:	08 f0       	brcs	.+2      	; 0x2cc2 <gc_execute_line+0x12e6>
    2cc0:	ac c0       	rjmp	.+344    	; 0x2e1a <gc_execute_line+0x143e>
    2cc2:	fc 01       	movw	r30, r24
    2cc4:	ed 52       	subi	r30, 0x2D	; 45
    2cc6:	ff 4f       	sbci	r31, 0xFF	; 255
    2cc8:	0c 94 fa 3f 	jmp	0x7ff4	; 0x7ff4 <__tablejump2__>
        case MOTION_MODE_SEEK:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, -1.0, false);
    2ccc:	20 e0       	ldi	r18, 0x00	; 0
    2cce:	40 e0       	ldi	r20, 0x00	; 0
    2cd0:	50 e0       	ldi	r21, 0x00	; 0
    2cd2:	60 e8       	ldi	r22, 0x80	; 128
    2cd4:	7f eb       	ldi	r23, 0xBF	; 191
    2cd6:	83 ef       	ldi	r24, 0xF3	; 243
    2cd8:	97 e0       	ldi	r25, 0x07	; 7
    2cda:	0e 94 5f 08 	call	0x10be	; 0x10be <mc_line>
          #endif
          break;
    2cde:	9d c0       	rjmp	.+314    	; 0x2e1a <gc_execute_line+0x143e>
        case MOTION_MODE_LINEAR:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
    2ce0:	40 91 95 07 	lds	r20, 0x0795
    2ce4:	50 91 96 07 	lds	r21, 0x0796
    2ce8:	60 91 97 07 	lds	r22, 0x0797
    2cec:	70 91 98 07 	lds	r23, 0x0798
    2cf0:	20 91 88 07 	lds	r18, 0x0788
    2cf4:	83 ef       	ldi	r24, 0xF3	; 243
    2cf6:	97 e0       	ldi	r25, 0x07	; 7
    2cf8:	0e 94 5f 08 	call	0x10be	; 0x10be <mc_line>
          #endif
          break;
    2cfc:	8e c0       	rjmp	.+284    	; 0x2e1a <gc_execute_line+0x143e>
        case MOTION_MODE_CW_ARC: 
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    2cfe:	c0 90 95 07 	lds	r12, 0x0795
    2d02:	d0 90 96 07 	lds	r13, 0x0796
    2d06:	e0 90 97 07 	lds	r14, 0x0797
    2d0a:	f0 90 98 07 	lds	r15, 0x0798
    2d0e:	00 91 ea 07 	lds	r16, 0x07EA
    2d12:	10 91 eb 07 	lds	r17, 0x07EB
    2d16:	20 91 ec 07 	lds	r18, 0x07EC
    2d1a:	30 91 ed 07 	lds	r19, 0x07ED
    2d1e:	81 e0       	ldi	r24, 0x01	; 1
    2d20:	8f 93       	push	r24
    2d22:	ee a1       	ldd	r30, Y+38	; 0x26
    2d24:	ef 93       	push	r30
    2d26:	fd a1       	ldd	r31, Y+37	; 0x25
    2d28:	ff 93       	push	r31
    2d2a:	8c a0       	ldd	r8, Y+36	; 0x24
    2d2c:	a0 90 88 07 	lds	r10, 0x0788
    2d30:	45 ed       	ldi	r20, 0xD5	; 213
    2d32:	57 e0       	ldi	r21, 0x07	; 7
    2d34:	63 ef       	ldi	r22, 0xF3	; 243
    2d36:	77 e0       	ldi	r23, 0x07	; 7
    2d38:	8e e9       	ldi	r24, 0x9E	; 158
    2d3a:	97 e0       	ldi	r25, 0x07	; 7
    2d3c:	0e 94 95 08 	call	0x112a	; 0x112a <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true); 
          #endif
          break;        
    2d40:	0f 90       	pop	r0
    2d42:	0f 90       	pop	r0
    2d44:	0f 90       	pop	r0
    2d46:	69 c0       	rjmp	.+210    	; 0x2e1a <gc_execute_line+0x143e>
        case MOTION_MODE_CCW_ARC:
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    2d48:	c0 90 95 07 	lds	r12, 0x0795
    2d4c:	d0 90 96 07 	lds	r13, 0x0796
    2d50:	e0 90 97 07 	lds	r14, 0x0797
    2d54:	f0 90 98 07 	lds	r15, 0x0798
    2d58:	00 91 ea 07 	lds	r16, 0x07EA
    2d5c:	10 91 eb 07 	lds	r17, 0x07EB
    2d60:	20 91 ec 07 	lds	r18, 0x07EC
    2d64:	30 91 ed 07 	lds	r19, 0x07ED
    2d68:	1f 92       	push	r1
    2d6a:	8e a1       	ldd	r24, Y+38	; 0x26
    2d6c:	8f 93       	push	r24
    2d6e:	9d a1       	ldd	r25, Y+37	; 0x25
    2d70:	9f 93       	push	r25
    2d72:	8c a0       	ldd	r8, Y+36	; 0x24
    2d74:	a0 90 88 07 	lds	r10, 0x0788
    2d78:	45 ed       	ldi	r20, 0xD5	; 213
    2d7a:	57 e0       	ldi	r21, 0x07	; 7
    2d7c:	63 ef       	ldi	r22, 0xF3	; 243
    2d7e:	77 e0       	ldi	r23, 0x07	; 7
    2d80:	8e e9       	ldi	r24, 0x9E	; 158
    2d82:	97 e0       	ldi	r25, 0x07	; 7
    2d84:	0e 94 95 08 	call	0x112a	; 0x112a <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false); 
          #endif
          break;
    2d88:	0f 90       	pop	r0
    2d8a:	0f 90       	pop	r0
    2d8c:	0f 90       	pop	r0
    2d8e:	45 c0       	rjmp	.+138    	; 0x2e1a <gc_execute_line+0x143e>
          // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
          // upon a successful probing cycle, the machine position and the returned value should be the same.
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false);
    2d90:	40 91 95 07 	lds	r20, 0x0795
    2d94:	50 91 96 07 	lds	r21, 0x0796
    2d98:	60 91 97 07 	lds	r22, 0x0797
    2d9c:	70 91 98 07 	lds	r23, 0x0798
    2da0:	e1 2c       	mov	r14, r1
    2da2:	00 e0       	ldi	r16, 0x00	; 0
    2da4:	20 91 88 07 	lds	r18, 0x0788
    2da8:	83 ef       	ldi	r24, 0xF3	; 243
    2daa:	97 e0       	ldi	r25, 0x07	; 7
    2dac:	0e 94 2a 0c 	call	0x1854	; 0x1854 <mc_probe_cycle>
          #endif
          break;
    2db0:	34 c0       	rjmp	.+104    	; 0x2e1a <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true);
    2db2:	40 91 95 07 	lds	r20, 0x0795
    2db6:	50 91 96 07 	lds	r21, 0x0796
    2dba:	60 91 97 07 	lds	r22, 0x0797
    2dbe:	70 91 98 07 	lds	r23, 0x0798
    2dc2:	ee 24       	eor	r14, r14
    2dc4:	e3 94       	inc	r14
    2dc6:	00 e0       	ldi	r16, 0x00	; 0
    2dc8:	20 91 88 07 	lds	r18, 0x0788
    2dcc:	83 ef       	ldi	r24, 0xF3	; 243
    2dce:	97 e0       	ldi	r25, 0x07	; 7
    2dd0:	0e 94 2a 0c 	call	0x1854	; 0x1854 <mc_probe_cycle>
          #endif
          break;
    2dd4:	22 c0       	rjmp	.+68     	; 0x2e1a <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_AWAY:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false);
    2dd6:	40 91 95 07 	lds	r20, 0x0795
    2dda:	50 91 96 07 	lds	r21, 0x0796
    2dde:	60 91 97 07 	lds	r22, 0x0797
    2de2:	70 91 98 07 	lds	r23, 0x0798
    2de6:	e1 2c       	mov	r14, r1
    2de8:	01 e0       	ldi	r16, 0x01	; 1
    2dea:	20 91 88 07 	lds	r18, 0x0788
    2dee:	83 ef       	ldi	r24, 0xF3	; 243
    2df0:	97 e0       	ldi	r25, 0x07	; 7
    2df2:	0e 94 2a 0c 	call	0x1854	; 0x1854 <mc_probe_cycle>
          #endif
          break;
    2df6:	11 c0       	rjmp	.+34     	; 0x2e1a <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true, gc_state.line_number);
          #else        
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true);
    2df8:	40 91 95 07 	lds	r20, 0x0795
    2dfc:	50 91 96 07 	lds	r21, 0x0796
    2e00:	60 91 97 07 	lds	r22, 0x0797
    2e04:	70 91 98 07 	lds	r23, 0x0798
    2e08:	ee 24       	eor	r14, r14
    2e0a:	e3 94       	inc	r14
    2e0c:	01 e0       	ldi	r16, 0x01	; 1
    2e0e:	20 91 88 07 	lds	r18, 0x0788
    2e12:	83 ef       	ldi	r24, 0xF3	; 243
    2e14:	97 e0       	ldi	r25, 0x07	; 7
    2e16:	0e 94 2a 0c 	call	0x1854	; 0x1854 <mc_probe_cycle>
      }
    
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    2e1a:	8c e0       	ldi	r24, 0x0C	; 12
    2e1c:	e3 ef       	ldi	r30, 0xF3	; 243
    2e1e:	f7 e0       	ldi	r31, 0x07	; 7
    2e20:	ae e9       	ldi	r26, 0x9E	; 158
    2e22:	b7 e0       	ldi	r27, 0x07	; 7
    2e24:	01 90       	ld	r0, Z+
    2e26:	0d 92       	st	X+, r0
    2e28:	8a 95       	dec	r24
    2e2a:	e1 f7       	brne	.-8      	; 0x2e24 <gc_execute_line+0x1448>
  }
  
  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may 
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    2e2c:	80 91 ce 07 	lds	r24, 0x07CE
    2e30:	80 93 8e 07 	sts	0x078E, r24
  if (gc_state.modal.program_flow) { 
    2e34:	88 23       	and	r24, r24
    2e36:	09 f4       	brne	.+2      	; 0x2e3a <gc_execute_line+0x145e>
    2e38:	6d c0       	rjmp	.+218    	; 0x2f14 <gc_execute_line+0x1538>
    protocol_buffer_synchronize(); // Finish all remaining buffered motions. Program paused when complete.
    2e3a:	0e 94 11 1b 	call	0x3622	; 0x3622 <protocol_buffer_synchronize>

    sys.suspend = true;
    2e3e:	81 e0       	ldi	r24, 0x01	; 1
    2e40:	80 93 69 07 	sts	0x0769, r24
    protocol_execute_realtime(); // Suspend execution. For both program pause or program end.
    2e44:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
  
    // If complete, reset to reload defaults (G92.2,G54,G17,G90,G94,M48,G40,M5,M9). Otherwise,
    // re-enable program flow after pause complete, where cycle start will resume the program.
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    2e48:	80 91 8e 07 	lds	r24, 0x078E
    2e4c:	82 30       	cpi	r24, 0x02	; 2
    2e4e:	21 f4       	brne	.+8      	; 0x2e58 <gc_execute_line+0x147c>
    2e50:	0e 94 b2 0c 	call	0x1964	; 0x1964 <mc_reset>
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2e54:	80 e0       	ldi	r24, 0x00	; 0
    2e56:	73 c0       	rjmp	.+230    	; 0x2f3e <gc_execute_line+0x1562>
    protocol_execute_realtime(); // Suspend execution. For both program pause or program end.
  
    // If complete, reset to reload defaults (G92.2,G54,G17,G90,G94,M48,G40,M5,M9). Otherwise,
    // re-enable program flow after pause complete, where cycle start will resume the program.
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
    2e58:	10 92 8e 07 	sts	0x078E, r1
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2e5c:	80 e0       	ldi	r24, 0x00	; 0
    2e5e:	6f c0       	rjmp	.+222    	; 0x2f3e <gc_execute_line+0x1562>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2e60:	81 e0       	ldi	r24, 0x01	; 1
    2e62:	6d c0       	rjmp	.+218    	; 0x2f3e <gc_execute_line+0x1562>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2e64:	82 e0       	ldi	r24, 0x02	; 2
    2e66:	6b c0       	rjmp	.+214    	; 0x2f3e <gc_execute_line+0x1562>
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    2e68:	84 e1       	ldi	r24, 0x14	; 20
    2e6a:	69 c0       	rjmp	.+210    	; 0x2f3e <gc_execute_line+0x1562>
        switch(int_value) {
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2e6c:	88 e1       	ldi	r24, 0x18	; 24
    2e6e:	67 c0       	rjmp	.+206    	; 0x2f3e <gc_execute_line+0x1562>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
    2e70:	84 e1       	ldi	r24, 0x14	; 20
    2e72:	65 c0       	rjmp	.+202    	; 0x2f3e <gc_execute_line+0x1562>
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
    2e74:	84 e1       	ldi	r24, 0x14	; 20
    2e76:	63 c0       	rjmp	.+198    	; 0x2f3e <gc_execute_line+0x1562>
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G92.x command]
    2e78:	84 e1       	ldi	r24, 0x14	; 20
    2e7a:	61 c0       	rjmp	.+194    	; 0x2f3e <gc_execute_line+0x1562>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2e7c:	88 e1       	ldi	r24, 0x18	; 24
    2e7e:	5f c0       	rjmp	.+190    	; 0x2f3e <gc_execute_line+0x1562>
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    2e80:	84 e1       	ldi	r24, 0x14	; 20
    2e82:	5d c0       	rjmp	.+186    	; 0x2f3e <gc_execute_line+0x1562>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    2e84:	88 e1       	ldi	r24, 0x18	; 24
    2e86:	5b c0       	rjmp	.+182    	; 0x2f3e <gc_execute_line+0x1562>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    2e88:	84 e1       	ldi	r24, 0x14	; 20
    2e8a:	59 c0       	rjmp	.+178    	; 0x2f3e <gc_execute_line+0x1562>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2e8c:	87 e1       	ldi	r24, 0x17	; 23
    2e8e:	57 c0       	rjmp	.+174    	; 0x2f3e <gc_execute_line+0x1562>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2e90:	85 e1       	ldi	r24, 0x15	; 21
    2e92:	55 c0       	rjmp	.+170    	; 0x2f3e <gc_execute_line+0x1562>
        break;
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    2e94:	87 e1       	ldi	r24, 0x17	; 23
    2e96:	53 c0       	rjmp	.+166    	; 0x2f3e <gc_execute_line+0x1562>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    2e98:	84 e1       	ldi	r24, 0x14	; 20
    2e9a:	51 c0       	rjmp	.+162    	; 0x2f3e <gc_execute_line+0x1562>
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2e9c:	85 e1       	ldi	r24, 0x15	; 21
    2e9e:	4f c0       	rjmp	.+158    	; 0x2f3e <gc_execute_line+0x1562>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2ea0:	84 e1       	ldi	r24, 0x14	; 20
    2ea2:	4d c0       	rjmp	.+154    	; 0x2f3e <gc_execute_line+0x1562>
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    2ea4:	89 e1       	ldi	r24, 0x19	; 25
    2ea6:	4b c0       	rjmp	.+150    	; 0x2f3e <gc_execute_line+0x1562>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    2ea8:	84 e0       	ldi	r24, 0x04	; 4
    2eaa:	49 c0       	rjmp	.+146    	; 0x2f3e <gc_execute_line+0x1562>
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    2eac:	8b e1       	ldi	r24, 0x1B	; 27
    2eae:	47 c0       	rjmp	.+142    	; 0x2f3e <gc_execute_line+0x1562>
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    2eb0:	86 e1       	ldi	r24, 0x16	; 22
    2eb2:	45 c0       	rjmp	.+138    	; 0x2f3e <gc_execute_line+0x1562>
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2eb4:	8c e1       	ldi	r24, 0x1C	; 28
    2eb6:	43 c0       	rjmp	.+134    	; 0x2f3e <gc_execute_line+0x1562>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    2eb8:	85 e2       	ldi	r24, 0x25	; 37
    2eba:	41 c0       	rjmp	.+130    	; 0x2f3e <gc_execute_line+0x1562>
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2ebc:	8d e1       	ldi	r24, 0x1D	; 29
    2ebe:	3f c0       	rjmp	.+126    	; 0x2f3e <gc_execute_line+0x1562>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2ec0:	87 e0       	ldi	r24, 0x07	; 7
    2ec2:	3d c0       	rjmp	.+122    	; 0x2f3e <gc_execute_line+0x1562>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2ec4:	8a e1       	ldi	r24, 0x1A	; 26
    2ec6:	3b c0       	rjmp	.+118    	; 0x2f3e <gc_execute_line+0x1562>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    2ec8:	8c e1       	ldi	r24, 0x1C	; 28
    2eca:	39 c0       	rjmp	.+114    	; 0x2f3e <gc_execute_line+0x1562>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2ecc:	8d e1       	ldi	r24, 0x1D	; 29
    2ece:	37 c0       	rjmp	.+110    	; 0x2f3e <gc_execute_line+0x1562>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    2ed0:	84 e1       	ldi	r24, 0x14	; 20
    2ed2:	35 c0       	rjmp	.+106    	; 0x2f3e <gc_execute_line+0x1562>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    2ed4:	84 e1       	ldi	r24, 0x14	; 20
    2ed6:	33 c0       	rjmp	.+102    	; 0x2f3e <gc_execute_line+0x1562>
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    2ed8:	87 e0       	ldi	r24, 0x07	; 7
    2eda:	31 c0       	rjmp	.+98     	; 0x2f3e <gc_execute_line+0x1562>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2edc:	8a e1       	ldi	r24, 0x1A	; 26
    2ede:	2f c0       	rjmp	.+94     	; 0x2f3e <gc_execute_line+0x1562>
      switch (gc_block.non_modal_command) {        
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2ee0:	87 e0       	ldi	r24, 0x07	; 7
    2ee2:	2d c0       	rjmp	.+90     	; 0x2f3e <gc_execute_line+0x1562>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2ee4:	87 e0       	ldi	r24, 0x07	; 7
    2ee6:	2b c0       	rjmp	.+86     	; 0x2f3e <gc_execute_line+0x1562>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    2ee8:	8e e1       	ldi	r24, 0x1E	; 30
    2eea:	29 c0       	rjmp	.+82     	; 0x2f3e <gc_execute_line+0x1562>
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    2eec:	8f e1       	ldi	r24, 0x1F	; 31
    2eee:	27 c0       	rjmp	.+78     	; 0x2f3e <gc_execute_line+0x1562>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2ef0:	86 e1       	ldi	r24, 0x16	; 22
    2ef2:	25 c0       	rjmp	.+74     	; 0x2f3e <gc_execute_line+0x1562>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2ef4:	8a e1       	ldi	r24, 0x1A	; 26
    2ef6:	23 c0       	rjmp	.+70     	; 0x2f3e <gc_execute_line+0x1562>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    2ef8:	80 e2       	ldi	r24, 0x20	; 32
    2efa:	21 c0       	rjmp	.+66     	; 0x2f3e <gc_execute_line+0x1562>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2efc:	82 e2       	ldi	r24, 0x22	; 34
    2efe:	1f c0       	rjmp	.+62     	; 0x2f3e <gc_execute_line+0x1562>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2f00:	83 e2       	ldi	r24, 0x23	; 35
    2f02:	1d c0       	rjmp	.+58     	; 0x2f3e <gc_execute_line+0x1562>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) { 
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    2f04:	81 e2       	ldi	r24, 0x21	; 33
    2f06:	1b c0       	rjmp	.+54     	; 0x2f3e <gc_execute_line+0x1562>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    2f08:	81 e2       	ldi	r24, 0x21	; 33
    2f0a:	19 c0       	rjmp	.+50     	; 0x2f3e <gc_execute_line+0x1562>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2f0c:	8a e1       	ldi	r24, 0x1A	; 26
    2f0e:	17 c0       	rjmp	.+46     	; 0x2f3e <gc_execute_line+0x1562>

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2f10:	84 e2       	ldi	r24, 0x24	; 36
    2f12:	15 c0       	rjmp	.+42     	; 0x2f3e <gc_execute_line+0x1562>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2f14:	80 e0       	ldi	r24, 0x00	; 0
    2f16:	13 c0       	rjmp	.+38     	; 0x2f3e <gc_execute_line+0x1562>
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    2f18:	1f a2       	std	Y+39, r1	; 0x27
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    2f1a:	10 91 c7 07 	lds	r17, 0x07C7
    2f1e:	18 30       	cpi	r17, 0x08	; 8
    2f20:	09 f0       	breq	.+2      	; 0x2f24 <gc_execute_line+0x1548>
    2f22:	07 cb       	rjmp	.-2546   	; 0x2532 <gc_execute_line+0xb56>
    2f24:	00 cb       	rjmp	.-2560   	; 0x2526 <gc_execute_line+0xb4a>
          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    2f26:	80 91 c9 07 	lds	r24, 0x07C9
    2f2a:	81 30       	cpi	r24, 0x01	; 1
    2f2c:	09 f0       	breq	.+2      	; 0x2f30 <gc_execute_line+0x1554>
    2f2e:	da cb       	rjmp	.-2124   	; 0x26e4 <gc_execute_line+0xd08>
    2f30:	c7 cb       	rjmp	.-2162   	; 0x26c0 <gc_execute_line+0xce4>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    2f32:	ae ed       	ldi	r26, 0xDE	; 222
    2f34:	2a 22       	and	r2, r26
    2f36:	ac ef       	ldi	r26, 0xFC	; 252
    2f38:	3a 22       	and	r3, r26
    2f3a:	1e 8e       	std	Y+30, r1	; 0x1e
    2f3c:	8e cd       	rjmp	.-1252   	; 0x2a5a <gc_execute_line+0x107e>
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
}
    2f3e:	ab 96       	adiw	r28, 0x2b	; 43
    2f40:	0f b6       	in	r0, 0x3f	; 63
    2f42:	f8 94       	cli
    2f44:	de bf       	out	0x3e, r29	; 62
    2f46:	0f be       	out	0x3f, r0	; 63
    2f48:	cd bf       	out	0x3d, r28	; 61
    2f4a:	df 91       	pop	r29
    2f4c:	cf 91       	pop	r28
    2f4e:	1f 91       	pop	r17
    2f50:	0f 91       	pop	r16
    2f52:	ff 90       	pop	r15
    2f54:	ef 90       	pop	r14
    2f56:	df 90       	pop	r13
    2f58:	cf 90       	pop	r12
    2f5a:	bf 90       	pop	r11
    2f5c:	af 90       	pop	r10
    2f5e:	9f 90       	pop	r9
    2f60:	8f 90       	pop	r8
    2f62:	7f 90       	pop	r7
    2f64:	6f 90       	pop	r6
    2f66:	5f 90       	pop	r5
    2f68:	4f 90       	pop	r4
    2f6a:	3f 90       	pop	r3
    2f6c:	2f 90       	pop	r2
    2f6e:	08 95       	ret

00002f70 <spindle_stop>:
    TCCRA_REGISTER &= ~(1<<COMB_BIT); // Disable PWM. Output voltage is zero.
    #ifndef CPU_MAP_ATMEGA328P 
      SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low.
    #endif
  #else
    SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low.
    2f70:	47 98       	cbi	0x08, 7	; 8
    2f72:	08 95       	ret

00002f74 <spindle_init>:
    SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    #ifndef CPU_MAP_ATMEGA328P 
      SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    #endif     
  #else
    SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    2f74:	3f 9a       	sbi	0x07, 7	; 7
  #endif
  #ifdef SPINDLE_DIRECTION_PRESENT
  SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
  #endif
  spindle_stop();
    2f76:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <spindle_stop>
    2f7a:	08 95       	ret

00002f7c <spindle_set_state>:


void spindle_set_state(uint8_t state, float rpm)
{
  // Halt or set spindle direction and rpm. 
  if (state == SPINDLE_DISABLE) {
    2f7c:	81 11       	cpse	r24, r1
    2f7e:	03 c0       	rjmp	.+6      	; 0x2f86 <spindle_set_state+0xa>

    spindle_stop();
    2f80:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <spindle_stop>
    2f84:	08 95       	ret
    
      #ifdef CPU_MAP_ATMEGA2560 // On the Uno, spindle enable and PWM are shared.
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    #else   
      SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
    2f86:	47 9a       	sbi	0x08, 7	; 8
    2f88:	08 95       	ret

00002f8a <spindle_run>:
  }
}


void spindle_run(uint8_t state, float rpm)
{
    2f8a:	cf 92       	push	r12
    2f8c:	df 92       	push	r13
    2f8e:	ef 92       	push	r14
    2f90:	ff 92       	push	r15
    2f92:	cf 93       	push	r28
    2f94:	c8 2f       	mov	r28, r24
    2f96:	6a 01       	movw	r12, r20
    2f98:	7b 01       	movw	r14, r22
  if (sys.state == STATE_CHECK_MODE) { return; }
    2f9a:	90 91 68 07 	lds	r25, 0x0768
    2f9e:	92 30       	cpi	r25, 0x02	; 2
    2fa0:	39 f0       	breq	.+14     	; 0x2fb0 <spindle_run+0x26>
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.  
    2fa2:	0e 94 11 1b 	call	0x3622	; 0x3622 <protocol_buffer_synchronize>
  spindle_set_state(state, rpm);
    2fa6:	b7 01       	movw	r22, r14
    2fa8:	a6 01       	movw	r20, r12
    2faa:	8c 2f       	mov	r24, r28
    2fac:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <spindle_set_state>
}
    2fb0:	cf 91       	pop	r28
    2fb2:	ff 90       	pop	r15
    2fb4:	ef 90       	pop	r14
    2fb6:	df 90       	pop	r13
    2fb8:	cf 90       	pop	r12
    2fba:	08 95       	ret

00002fbc <coolant_stop>:
}


void coolant_stop()
{
  COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2fbc:	46 98       	cbi	0x08, 6	; 8
    2fbe:	08 95       	ret

00002fc0 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT);
    2fc0:	3e 9a       	sbi	0x07, 6	; 7
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
    2fc2:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <coolant_stop>
    2fc6:	08 95       	ret

00002fc8 <coolant_set_state>:
}


void coolant_set_state(uint8_t mode)
{
  if (mode == COOLANT_FLOOD_ENABLE) {
    2fc8:	82 30       	cpi	r24, 0x02	; 2
    2fca:	11 f4       	brne	.+4      	; 0x2fd0 <coolant_set_state+0x8>
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    2fcc:	46 9a       	sbi	0x08, 6	; 8
    2fce:	08 95       	ret
    } else if (mode == COOLANT_MIST_ENABLE) {
      COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #endif

  } else {
    coolant_stop();
    2fd0:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <coolant_stop>
    2fd4:	08 95       	ret

00002fd6 <coolant_run>:
  }
}


void coolant_run(uint8_t mode)
{
    2fd6:	cf 93       	push	r28
    2fd8:	c8 2f       	mov	r28, r24
  if (sys.state == STATE_CHECK_MODE) { return; }
    2fda:	90 91 68 07 	lds	r25, 0x0768
    2fde:	92 30       	cpi	r25, 0x02	; 2
    2fe0:	29 f0       	breq	.+10     	; 0x2fec <coolant_run+0x16>
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.  
    2fe2:	0e 94 11 1b 	call	0x3622	; 0x3622 <protocol_buffer_synchronize>
  coolant_set_state(mode);
    2fe6:	8c 2f       	mov	r24, r28
    2fe8:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <coolant_set_state>
}
    2fec:	cf 91       	pop	r28
    2fee:	08 95       	ret

00002ff0 <serial_get_rx_buffer_count>:
  

// Returns the number of bytes used in the RX serial buffer.
uint8_t serial_get_rx_buffer_count()
{
  uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
    2ff0:	90 91 02 01 	lds	r25, 0x0102
  if (serial_rx_buffer_head >= rtail) { return(serial_rx_buffer_head-rtail); }
    2ff4:	80 91 03 01 	lds	r24, 0x0103
    2ff8:	89 17       	cp	r24, r25
    2ffa:	10 f0       	brcs	.+4      	; 0x3000 <serial_get_rx_buffer_count+0x10>
    2ffc:	89 1b       	sub	r24, r25
    2ffe:	08 95       	ret
  return (RX_BUFFER_SIZE - (rtail-serial_rx_buffer_head));
    3000:	80 58       	subi	r24, 0x80	; 128
    3002:	89 1b       	sub	r24, r25
}
    3004:	08 95       	ret

00003006 <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    3006:	e0 ec       	ldi	r30, 0xC0	; 192
    3008:	f0 e0       	ldi	r31, 0x00	; 0
    300a:	80 81       	ld	r24, Z
    300c:	82 60       	ori	r24, 0x02	; 2
    300e:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    3010:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = UBRR0_value;
    3014:	83 e1       	ldi	r24, 0x13	; 19
    3016:	80 93 c4 00 	sts	0x00C4, r24
            
  // enable rx and tx
  UCSR0B |= 1<<RXEN0;
    301a:	e1 ec       	ldi	r30, 0xC1	; 193
    301c:	f0 e0       	ldi	r31, 0x00	; 0
    301e:	80 81       	ld	r24, Z
    3020:	80 61       	ori	r24, 0x10	; 16
    3022:	80 83       	st	Z, r24
  UCSR0B |= 1<<TXEN0;
    3024:	80 81       	ld	r24, Z
    3026:	88 60       	ori	r24, 0x08	; 8
    3028:	80 83       	st	Z, r24
	
  // enable interrupt on complete reception of a byte
  UCSR0B |= 1<<RXCIE0;
    302a:	80 81       	ld	r24, Z
    302c:	80 68       	ori	r24, 0x80	; 128
    302e:	80 83       	st	Z, r24
    3030:	08 95       	ret

00003032 <serial_write>:

// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    3032:	30 91 01 01 	lds	r19, 0x0101
    3036:	21 e0       	ldi	r18, 0x01	; 1
    3038:	23 0f       	add	r18, r19
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    303a:	20 38       	cpi	r18, 0x80	; 128
    303c:	31 f4       	brne	.+12     	; 0x304a <serial_write+0x18>
    303e:	04 c0       	rjmp	.+8      	; 0x3048 <serial_write+0x16>

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    3040:	90 81       	ld	r25, Z
    3042:	94 ff       	sbrs	r25, 4
    3044:	04 c0       	rjmp	.+8      	; 0x304e <serial_write+0x1c>
    3046:	08 95       	ret
// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    3048:	20 e0       	ldi	r18, 0x00	; 0

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    304a:	ea e6       	ldi	r30, 0x6A	; 106
    304c:	f7 e0       	ldi	r31, 0x07	; 7
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    304e:	90 91 00 01 	lds	r25, 0x0100
    3052:	92 17       	cp	r25, r18
    3054:	a9 f3       	breq	.-22     	; 0x3040 <serial_write+0xe>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    3056:	e3 2f       	mov	r30, r19
    3058:	f0 e0       	ldi	r31, 0x00	; 0
    305a:	e1 50       	subi	r30, 0x01	; 1
    305c:	f8 4f       	sbci	r31, 0xF8	; 248
    305e:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    3060:	20 93 01 01 	sts	0x0101, r18
  
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0); 
    3064:	e1 ec       	ldi	r30, 0xC1	; 193
    3066:	f0 e0       	ldi	r31, 0x00	; 0
    3068:	80 81       	ld	r24, Z
    306a:	80 62       	ori	r24, 0x20	; 32
    306c:	80 83       	st	Z, r24
    306e:	08 95       	ret

00003070 <__vector_21>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    3070:	1f 92       	push	r1
    3072:	0f 92       	push	r0
    3074:	0f b6       	in	r0, 0x3f	; 63
    3076:	0f 92       	push	r0
    3078:	11 24       	eor	r1, r1
    307a:	8f 93       	push	r24
    307c:	9f 93       	push	r25
    307e:	ef 93       	push	r30
    3080:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    3082:	80 91 00 01 	lds	r24, 0x0100
      flow_ctrl = XON_SENT; 
    } else
  #endif
  { 
    // Send a byte from the buffer	
    UDR0 = serial_tx_buffer[tail];
    3086:	e8 2f       	mov	r30, r24
    3088:	f0 e0       	ldi	r31, 0x00	; 0
    308a:	e1 50       	subi	r30, 0x01	; 1
    308c:	f8 4f       	sbci	r31, 0xF8	; 248
    308e:	90 81       	ld	r25, Z
    3090:	90 93 c6 00 	sts	0x00C6, r25
  
    // Update tail position
    tail++;
    3094:	8f 5f       	subi	r24, 0xFF	; 255
    if (tail == TX_BUFFER_SIZE) { tail = 0; }
    3096:	80 38       	cpi	r24, 0x80	; 128
    3098:	09 f4       	brne	.+2      	; 0x309c <__vector_21+0x2c>
    309a:	80 e0       	ldi	r24, 0x00	; 0
  
    serial_tx_buffer_tail = tail;
    309c:	80 93 00 01 	sts	0x0100, r24
  }
  
  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    30a0:	90 91 01 01 	lds	r25, 0x0101
    30a4:	89 13       	cpse	r24, r25
    30a6:	05 c0       	rjmp	.+10     	; 0x30b2 <__vector_21+0x42>
    30a8:	e1 ec       	ldi	r30, 0xC1	; 193
    30aa:	f0 e0       	ldi	r31, 0x00	; 0
    30ac:	80 81       	ld	r24, Z
    30ae:	8f 7d       	andi	r24, 0xDF	; 223
    30b0:	80 83       	st	Z, r24
}
    30b2:	ff 91       	pop	r31
    30b4:	ef 91       	pop	r30
    30b6:	9f 91       	pop	r25
    30b8:	8f 91       	pop	r24
    30ba:	0f 90       	pop	r0
    30bc:	0f be       	out	0x3f, r0	; 63
    30be:	0f 90       	pop	r0
    30c0:	1f 90       	pop	r1
    30c2:	18 95       	reti

000030c4 <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    30c4:	90 91 02 01 	lds	r25, 0x0102
  if (serial_rx_buffer_head == tail) {
    30c8:	80 91 03 01 	lds	r24, 0x0103
    30cc:	89 17       	cp	r24, r25
    30ce:	61 f0       	breq	.+24     	; 0x30e8 <serial_read+0x24>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    30d0:	e9 2f       	mov	r30, r25
    30d2:	f0 e0       	ldi	r31, 0x00	; 0
    30d4:	e1 58       	subi	r30, 0x81	; 129
    30d6:	f7 4f       	sbci	r31, 0xF7	; 247
    30d8:	80 81       	ld	r24, Z
    
    tail++;
    30da:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_BUFFER_SIZE) { tail = 0; }
    30dc:	90 38       	cpi	r25, 0x80	; 128
    30de:	09 f4       	brne	.+2      	; 0x30e2 <serial_read+0x1e>
    30e0:	90 e0       	ldi	r25, 0x00	; 0
    serial_rx_buffer_tail = tail;
    30e2:	90 93 02 01 	sts	0x0102, r25
        flow_ctrl = SEND_XON;
        UCSR0B |=  (1 << UDRIE0); // Force TX
      }
    #endif
    
    return data;
    30e6:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    30e8:	8f ef       	ldi	r24, 0xFF	; 255
      }
    #endif
    
    return data;
  }
}
    30ea:	08 95       	ret

000030ec <__vector_20>:


ISR(SERIAL_RX)
{
    30ec:	1f 92       	push	r1
    30ee:	0f 92       	push	r0
    30f0:	0f b6       	in	r0, 0x3f	; 63
    30f2:	0f 92       	push	r0
    30f4:	11 24       	eor	r1, r1
    30f6:	2f 93       	push	r18
    30f8:	3f 93       	push	r19
    30fa:	4f 93       	push	r20
    30fc:	5f 93       	push	r21
    30fe:	6f 93       	push	r22
    3100:	7f 93       	push	r23
    3102:	8f 93       	push	r24
    3104:	9f 93       	push	r25
    3106:	af 93       	push	r26
    3108:	bf 93       	push	r27
    310a:	ef 93       	push	r30
    310c:	ff 93       	push	r31
  uint8_t data = UDR0;
    310e:	80 91 c6 00 	lds	r24, 0x00C6
  uint8_t next_head;
  
  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    3112:	8f 33       	cpi	r24, 0x3F	; 63
    3114:	59 f0       	breq	.+22     	; 0x312c <__vector_20+0x40>
    3116:	28 f4       	brcc	.+10     	; 0x3122 <__vector_20+0x36>
    3118:	88 31       	cpi	r24, 0x18	; 24
    311a:	61 f1       	breq	.+88     	; 0x3174 <__vector_20+0x88>
    311c:	81 32       	cpi	r24, 0x21	; 33
    311e:	c1 f0       	breq	.+48     	; 0x3150 <__vector_20+0x64>
    3120:	2c c0       	rjmp	.+88     	; 0x317a <__vector_20+0x8e>
    3122:	80 34       	cpi	r24, 0x40	; 64
    3124:	f1 f0       	breq	.+60     	; 0x3162 <__vector_20+0x76>
    3126:	8e 37       	cpi	r24, 0x7E	; 126
    3128:	51 f0       	breq	.+20     	; 0x313e <__vector_20+0x52>
    312a:	27 c0       	rjmp	.+78     	; 0x317a <__vector_20+0x8e>
    case CMD_STATUS_REPORT: bit_true_atomic(sys.rt_exec_state, EXEC_STATUS_REPORT); break; // Set as true
    312c:	8f b7       	in	r24, 0x3f	; 63
    312e:	f8 94       	cli
    3130:	ea e6       	ldi	r30, 0x6A	; 106
    3132:	f7 e0       	ldi	r31, 0x07	; 7
    3134:	90 81       	ld	r25, Z
    3136:	91 60       	ori	r25, 0x01	; 1
    3138:	90 83       	st	Z, r25
    313a:	8f bf       	out	0x3f, r24	; 63
    313c:	2f c0       	rjmp	.+94     	; 0x319c <__vector_20+0xb0>
    case CMD_CYCLE_START:   bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START); break; // Set as true
    313e:	8f b7       	in	r24, 0x3f	; 63
    3140:	f8 94       	cli
    3142:	ea e6       	ldi	r30, 0x6A	; 106
    3144:	f7 e0       	ldi	r31, 0x07	; 7
    3146:	90 81       	ld	r25, Z
    3148:	92 60       	ori	r25, 0x02	; 2
    314a:	90 83       	st	Z, r25
    314c:	8f bf       	out	0x3f, r24	; 63
    314e:	26 c0       	rjmp	.+76     	; 0x319c <__vector_20+0xb0>
    case CMD_FEED_HOLD:     bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD); break; // Set as true
    3150:	8f b7       	in	r24, 0x3f	; 63
    3152:	f8 94       	cli
    3154:	ea e6       	ldi	r30, 0x6A	; 106
    3156:	f7 e0       	ldi	r31, 0x07	; 7
    3158:	90 81       	ld	r25, Z
    315a:	98 60       	ori	r25, 0x08	; 8
    315c:	90 83       	st	Z, r25
    315e:	8f bf       	out	0x3f, r24	; 63
    3160:	1d c0       	rjmp	.+58     	; 0x319c <__vector_20+0xb0>
    case CMD_SAFETY_DOOR:   bit_true_atomic(sys.rt_exec_state, EXEC_SAFETY_DOOR); break; // Set as true
    3162:	8f b7       	in	r24, 0x3f	; 63
    3164:	f8 94       	cli
    3166:	ea e6       	ldi	r30, 0x6A	; 106
    3168:	f7 e0       	ldi	r31, 0x07	; 7
    316a:	90 81       	ld	r25, Z
    316c:	90 62       	ori	r25, 0x20	; 32
    316e:	90 83       	st	Z, r25
    3170:	8f bf       	out	0x3f, r24	; 63
    3172:	14 c0       	rjmp	.+40     	; 0x319c <__vector_20+0xb0>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    3174:	0e 94 b2 0c 	call	0x1964	; 0x1964 <mc_reset>
    3178:	11 c0       	rjmp	.+34     	; 0x319c <__vector_20+0xb0>
    default: // Write character to buffer    
      next_head = serial_rx_buffer_head + 1;
    317a:	e0 91 03 01 	lds	r30, 0x0103
    317e:	91 e0       	ldi	r25, 0x01	; 1
    3180:	9e 0f       	add	r25, r30
      if (next_head == RX_BUFFER_SIZE) { next_head = 0; }
    3182:	90 38       	cpi	r25, 0x80	; 128
    3184:	09 f4       	brne	.+2      	; 0x3188 <__vector_20+0x9c>
    3186:	90 e0       	ldi	r25, 0x00	; 0
    
      // Write data to buffer unless it is full.
      if (next_head != serial_rx_buffer_tail) {
    3188:	20 91 02 01 	lds	r18, 0x0102
    318c:	92 17       	cp	r25, r18
    318e:	31 f0       	breq	.+12     	; 0x319c <__vector_20+0xb0>
        serial_rx_buffer[serial_rx_buffer_head] = data;
    3190:	f0 e0       	ldi	r31, 0x00	; 0
    3192:	e1 58       	subi	r30, 0x81	; 129
    3194:	f7 4f       	sbci	r31, 0xF7	; 247
    3196:	80 83       	st	Z, r24
        serial_rx_buffer_head = next_head;    
    3198:	90 93 03 01 	sts	0x0103, r25
        #endif
        
      }
      //TODO: else alarm on overflow?
  }
}
    319c:	ff 91       	pop	r31
    319e:	ef 91       	pop	r30
    31a0:	bf 91       	pop	r27
    31a2:	af 91       	pop	r26
    31a4:	9f 91       	pop	r25
    31a6:	8f 91       	pop	r24
    31a8:	7f 91       	pop	r23
    31aa:	6f 91       	pop	r22
    31ac:	5f 91       	pop	r21
    31ae:	4f 91       	pop	r20
    31b0:	3f 91       	pop	r19
    31b2:	2f 91       	pop	r18
    31b4:	0f 90       	pop	r0
    31b6:	0f be       	out	0x3f, r0	; 63
    31b8:	0f 90       	pop	r0
    31ba:	1f 90       	pop	r1
    31bc:	18 95       	reti

000031be <serial_reset_read_buffer>:


void serial_reset_read_buffer() 
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    31be:	80 91 03 01 	lds	r24, 0x0103
    31c2:	80 93 02 01 	sts	0x0102, r24
    31c6:	08 95       	ret

000031c8 <protocol_execute_realtime>:
// execute certain tasks without having two or more instances of the same task, such as the planner
// recalculating the buffer upon a feedhold or override.
// NOTE: The sys.rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    31c8:	2f 92       	push	r2
    31ca:	3f 92       	push	r3
    31cc:	4f 92       	push	r4
    31ce:	5f 92       	push	r5
    31d0:	6f 92       	push	r6
    31d2:	7f 92       	push	r7
    31d4:	8f 92       	push	r8
    31d6:	9f 92       	push	r9
    31d8:	af 92       	push	r10
    31da:	bf 92       	push	r11
    31dc:	cf 92       	push	r12
    31de:	df 92       	push	r13
    31e0:	ef 92       	push	r14
    31e2:	ff 92       	push	r15
    31e4:	0f 93       	push	r16
    31e6:	1f 93       	push	r17
    31e8:	cf 93       	push	r28
    31ea:	df 93       	push	r29
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys.rt_exec_alarm; // Copy volatile sys.rt_exec_alarm.
    31ec:	0f 2e       	mov	r0, r31
    31ee:	fb e6       	ldi	r31, 0x6B	; 107
    31f0:	ef 2e       	mov	r14, r31
    31f2:	f7 e0       	ldi	r31, 0x07	; 7
    31f4:	ff 2e       	mov	r15, r31
    31f6:	f0 2d       	mov	r31, r0
  if (rt_exec) { // Enter only if any bit flag is true
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    31f8:	0f 2e       	mov	r0, r31
    31fa:	f8 e6       	ldi	r31, 0x68	; 104
    31fc:	8f 2e       	mov	r8, r31
    31fe:	f7 e0       	ldi	r31, 0x07	; 7
    3200:	9f 2e       	mov	r9, r31
    3202:	f0 2d       	mov	r31, r0
    3204:	44 24       	eor	r4, r4
    3206:	43 94       	inc	r4
      report_alarm_message(ALARM_PROBE_FAIL);
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
      bit_false_atomic(sys.rt_exec_state,EXEC_RESET); // Disable any existing reset
    3208:	ca e6       	ldi	r28, 0x6A	; 106
    320a:	d7 e0       	ldi	r29, 0x07	; 7
          coolant_stop();
          // TODO: Install parking motion here.
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY); //Problem in Bezug auf Jogging?
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    320c:	09 e6       	ldi	r16, 0x69	; 105
    320e:	17 e0       	ldi	r17, 0x07	; 7
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    3210:	0f 2e       	mov	r0, r31
    3212:	f0 e9       	ldi	r31, 0x90	; 144
    3214:	af 2e       	mov	r10, r31
    3216:	f7 e0       	ldi	r31, 0x07	; 7
    3218:	bf 2e       	mov	r11, r31
    321a:	f0 2d       	mov	r31, r0
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    321c:	0f 2e       	mov	r0, r31
    321e:	ff e8       	ldi	r31, 0x8F	; 143
    3220:	cf 2e       	mov	r12, r31
    3222:	f7 e0       	ldi	r31, 0x07	; 7
    3224:	df 2e       	mov	r13, r31
    3226:	f0 2d       	mov	r31, r0
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    3228:	0f 2e       	mov	r0, r31
    322a:	f1 e9       	ldi	r31, 0x91	; 145
    322c:	6f 2e       	mov	r6, r31
    322e:	f7 e0       	ldi	r31, 0x07	; 7
    3230:	7f 2e       	mov	r7, r31
    3232:	f0 2d       	mov	r31, r0
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    3234:	68 94       	set
    3236:	22 24       	eor	r2, r2
    3238:	24 f8       	bld	r2, 4
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    323a:	68 94       	set
    323c:	33 24       	eor	r3, r3
    323e:	31 f8       	bld	r3, 1
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys.rt_exec_alarm; // Copy volatile sys.rt_exec_alarm.
    3240:	f7 01       	movw	r30, r14
    3242:	50 80       	ld	r5, Z
  if (rt_exec) { // Enter only if any bit flag is true
    3244:	55 20       	and	r5, r5
    3246:	69 f1       	breq	.+90     	; 0x32a2 <protocol_execute_realtime+0xda>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    3248:	f4 01       	movw	r30, r8
    324a:	40 82       	st	Z, r4
    if (rt_exec & EXEC_ALARM_HARD_LIMIT) {
    324c:	51 fe       	sbrs	r5, 1
    324e:	04 c0       	rjmp	.+8      	; 0x3258 <protocol_execute_realtime+0x90>
      report_alarm_message(ALARM_HARD_LIMIT_ERROR); 
    3250:	8f ef       	ldi	r24, 0xFF	; 255
    3252:	0e 94 d3 34 	call	0x69a6	; 0x69a6 <report_alarm_message>
    3256:	11 c0       	rjmp	.+34     	; 0x327a <protocol_execute_realtime+0xb2>
    } else if (rt_exec & EXEC_ALARM_SOFT_LIMIT) {
    3258:	52 fe       	sbrs	r5, 2
    325a:	04 c0       	rjmp	.+8      	; 0x3264 <protocol_execute_realtime+0x9c>
      report_alarm_message(ALARM_SOFT_LIMIT_ERROR);
    325c:	8e ef       	ldi	r24, 0xFE	; 254
    325e:	0e 94 d3 34 	call	0x69a6	; 0x69a6 <report_alarm_message>
    3262:	0b c0       	rjmp	.+22     	; 0x327a <protocol_execute_realtime+0xb2>
    } else if (rt_exec & EXEC_ALARM_ABORT_CYCLE) {      
    3264:	53 fe       	sbrs	r5, 3
    3266:	04 c0       	rjmp	.+8      	; 0x3270 <protocol_execute_realtime+0xa8>
      report_alarm_message(ALARM_ABORT_CYCLE);
    3268:	8d ef       	ldi	r24, 0xFD	; 253
    326a:	0e 94 d3 34 	call	0x69a6	; 0x69a6 <report_alarm_message>
    326e:	05 c0       	rjmp	.+10     	; 0x327a <protocol_execute_realtime+0xb2>
    } else if (rt_exec & EXEC_ALARM_PROBE_FAIL) {
    3270:	54 fe       	sbrs	r5, 4
    3272:	03 c0       	rjmp	.+6      	; 0x327a <protocol_execute_realtime+0xb2>
      report_alarm_message(ALARM_PROBE_FAIL);
    3274:	8c ef       	ldi	r24, 0xFC	; 252
    3276:	0e 94 d3 34 	call	0x69a6	; 0x69a6 <report_alarm_message>
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
    327a:	50 fe       	sbrs	r5, 0
    327c:	0c c0       	rjmp	.+24     	; 0x3296 <protocol_execute_realtime+0xce>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    327e:	84 2d       	mov	r24, r4
    3280:	0e 94 00 35 	call	0x6a00	; 0x6a00 <report_feedback_message>
      bit_false_atomic(sys.rt_exec_state,EXEC_RESET); // Disable any existing reset
    3284:	8f b7       	in	r24, 0x3f	; 63
    3286:	f8 94       	cli
    3288:	98 81       	ld	r25, Y
    328a:	9f 7e       	andi	r25, 0xEF	; 239
    328c:	98 83       	st	Y, r25
    328e:	8f bf       	out	0x3f, r24	; 63
        // Nothing. Block EVERYTHING until user issues reset or power cycles. Hard limits
        // typically occur while unattended or not paying attention. Gives the user time
        // to do what is needed before resetting, like killing the incoming stream. The 
        // same could be said about soft limits. While the position is not lost, the incoming
        // stream could be still engaged and cause a serious crash if it continues afterwards.
      } while (bit_isfalse(sys.rt_exec_state,EXEC_RESET));
    3290:	88 81       	ld	r24, Y
    3292:	84 ff       	sbrs	r24, 4
    3294:	fd cf       	rjmp	.-6      	; 0x3290 <protocol_execute_realtime+0xc8>
    }
    bit_false_atomic(sys.rt_exec_alarm,0xFF); // Clear all alarm flags
    3296:	8f b7       	in	r24, 0x3f	; 63
    3298:	f8 94       	cli
    329a:	f7 01       	movw	r30, r14
    329c:	90 81       	ld	r25, Z
    329e:	10 82       	st	Z, r1
    32a0:	8f bf       	out	0x3f, r24	; 63
  }
  
  // Check amd execute realtime commands
  rt_exec = sys.rt_exec_state; // Copy volatile sys.rt_exec_state.
    32a2:	58 80       	ld	r5, Y
  if (rt_exec) { // Enter only if any bit flag is true
    32a4:	55 20       	and	r5, r5
    32a6:	09 f4       	brne	.+2      	; 0x32aa <protocol_execute_realtime+0xe2>
    32a8:	b7 c0       	rjmp	.+366    	; 0x3418 <protocol_execute_realtime+0x250>
  
    // Execute system abort. 
    if (rt_exec & EXEC_RESET) {
    32aa:	54 fe       	sbrs	r5, 4
    32ac:	04 c0       	rjmp	.+8      	; 0x32b6 <protocol_execute_realtime+0xee>
      sys.abort = true;  // Only place this is set true.
    32ae:	81 e0       	ldi	r24, 0x01	; 1
    32b0:	80 93 67 07 	sts	0x0767, r24
      return; // Nothing else to do but exit.
    32b4:	cd c0       	rjmp	.+410    	; 0x3450 <protocol_execute_realtime+0x288>
    }
    
    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) { 
    32b6:	50 fe       	sbrs	r5, 0
    32b8:	08 c0       	rjmp	.+16     	; 0x32ca <protocol_execute_realtime+0x102>
      report_realtime_status();
    32ba:	0e 94 a4 38 	call	0x7148	; 0x7148 <report_realtime_status>
      bit_false_atomic(sys.rt_exec_state,EXEC_STATUS_REPORT);
    32be:	8f b7       	in	r24, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	98 81       	ld	r25, Y
    32c4:	9e 7f       	andi	r25, 0xFE	; 254
    32c6:	98 83       	st	Y, r25
    32c8:	8f bf       	out	0x3f, r24	; 63
  
    // Execute hold states.
    // NOTE: The math involved to calculate the hold should be low enough for most, if not all, 
    // operational scenarios. Once hold is initiated, the system enters a suspend state to block
    // all main program processes until either reset or resumed.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR)) {
    32ca:	85 2d       	mov	r24, r5
    32cc:	88 76       	andi	r24, 0x68	; 104
    32ce:	09 f4       	brne	.+2      	; 0x32d2 <protocol_execute_realtime+0x10a>
    32d0:	40 c0       	rjmp	.+128    	; 0x3352 <protocol_execute_realtime+0x18a>
      
      // TODO: CHECK MODE? How to handle this? Likely nothing, since it only works when IDLE and then resets Grbl.
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {
    32d2:	f4 01       	movw	r30, r8
    32d4:	80 81       	ld	r24, Z
    32d6:	88 23       	and	r24, r24
    32d8:	71 f0       	breq	.+28     	; 0x32f6 <protocol_execute_realtime+0x12e>
    32da:	98 2f       	mov	r25, r24
    32dc:	9c 77       	andi	r25, 0x7C	; 124
    32de:	99 f1       	breq	.+102    	; 0x3346 <protocol_execute_realtime+0x17e>

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
    32e0:	88 30       	cpi	r24, 0x08	; 8
    32e2:	09 f0       	breq	.+2      	; 0x32e6 <protocol_execute_realtime+0x11e>
    32e4:	b2 c0       	rjmp	.+356    	; 0x344a <protocol_execute_realtime+0x282>
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    32e6:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <st_update_plan_block_parameters>
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
    32ea:	f8 01       	movw	r30, r16
    32ec:	40 82       	st	Z, r4
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    32ee:	f4 01       	movw	r30, r8
    32f0:	80 81       	ld	r24, Z
    32f2:	81 11       	cpse	r24, r1
    32f4:	05 c0       	rjmp	.+10     	; 0x3300 <protocol_execute_realtime+0x138>
    32f6:	f8 01       	movw	r30, r16
    32f8:	30 82       	st	Z, r3
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    32fa:	56 fc       	sbrc	r5, 6
    32fc:	08 c0       	rjmp	.+16     	; 0x330e <protocol_execute_realtime+0x146>
    32fe:	0b c0       	rjmp	.+22     	; 0x3316 <protocol_execute_realtime+0x14e>
    3300:	56 fe       	sbrs	r5, 6
    3302:	09 c0       	rjmp	.+18     	; 0x3316 <protocol_execute_realtime+0x14e>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    3304:	88 30       	cpi	r24, 0x08	; 8
    3306:	19 f4       	brne	.+6      	; 0x330e <protocol_execute_realtime+0x146>
    3308:	80 e4       	ldi	r24, 0x40	; 64
    330a:	f4 01       	movw	r30, r8
    330c:	80 83       	st	Z, r24
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
    330e:	f8 01       	movw	r30, r16
    3310:	80 81       	ld	r24, Z
    3312:	88 60       	ori	r24, 0x08	; 8
    3314:	80 83       	st	Z, r24
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    3316:	53 fe       	sbrs	r5, 3
    3318:	04 c0       	rjmp	.+8      	; 0x3322 <protocol_execute_realtime+0x15a>
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    331a:	f4 01       	movw	r30, r8
    331c:	80 81       	ld	r24, Z
    331e:	85 ff       	sbrs	r24, 5
    3320:	20 82       	st	Z, r2
  
        // Execute a safety door stop with a feed hold, only during a cycle, and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged. The power-down is 
        // executed here, if IDLE, or when the CYCLE completes via the EXEC_CYCLE_STOP flag.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    3322:	55 fe       	sbrs	r5, 5
    3324:	10 c0       	rjmp	.+32     	; 0x3346 <protocol_execute_realtime+0x17e>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
    3326:	86 e0       	ldi	r24, 0x06	; 6
    3328:	0e 94 00 35 	call	0x6a00	; 0x6a00 <report_feedback_message>
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
    332c:	f8 01       	movw	r30, r16
    332e:	80 81       	ld	r24, Z
    3330:	81 ff       	sbrs	r24, 1
    3332:	03 c0       	rjmp	.+6      	; 0x333a <protocol_execute_realtime+0x172>
    3334:	f5 2d       	mov	r31, r5
    3336:	f4 60       	ori	r31, 0x04	; 4
    3338:	5f 2e       	mov	r5, r31
          sys.suspend |= SUSPEND_ENERGIZE;
    333a:	84 60       	ori	r24, 0x04	; 4
    333c:	f8 01       	movw	r30, r16
    333e:	80 83       	st	Z, r24
          sys.state = STATE_SAFETY_DOOR;
    3340:	80 e2       	ldi	r24, 0x20	; 32
    3342:	f4 01       	movw	r30, r8
    3344:	80 83       	st	Z, r24
        }
         
      }
      bit_false_atomic(sys.rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    3346:	8f b7       	in	r24, 0x3f	; 63
    3348:	f8 94       	cli
    334a:	98 81       	ld	r25, Y
    334c:	97 79       	andi	r25, 0x97	; 151
    334e:	98 83       	st	Y, r25
    3350:	8f bf       	out	0x3f, r24	; 63
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    3352:	51 fe       	sbrs	r5, 1
    3354:	44 c0       	rjmp	.+136    	; 0x33de <protocol_execute_realtime+0x216>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) { 
    3356:	85 2d       	mov	r24, r5
    3358:	88 76       	andi	r24, 0x68	; 104
    335a:	d9 f5       	brne	.+118    	; 0x33d2 <protocol_execute_realtime+0x20a>
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
    335c:	f4 01       	movw	r30, r8
    335e:	80 81       	ld	r24, Z
    3360:	88 23       	and	r24, r24
    3362:	31 f0       	breq	.+12     	; 0x3370 <protocol_execute_realtime+0x1a8>
    3364:	80 75       	andi	r24, 0x50	; 80
    3366:	a9 f1       	breq	.+106    	; 0x33d2 <protocol_execute_realtime+0x20a>
    3368:	f8 01       	movw	r30, r16
    336a:	80 81       	ld	r24, Z
    336c:	81 ff       	sbrs	r24, 1
    336e:	31 c0       	rjmp	.+98     	; 0x33d2 <protocol_execute_realtime+0x20a>
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
    3370:	f8 01       	movw	r30, r16
    3372:	80 81       	ld	r24, Z
    3374:	82 ff       	sbrs	r24, 2
    3376:	19 c0       	rjmp	.+50     	; 0x33aa <protocol_execute_realtime+0x1e2>
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    3378:	f5 01       	movw	r30, r10
    337a:	80 81       	ld	r24, Z
    337c:	88 23       	and	r24, r24
    337e:	59 f0       	breq	.+22     	; 0x3396 <protocol_execute_realtime+0x1ce>
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    3380:	f3 01       	movw	r30, r6
    3382:	40 81       	ld	r20, Z
    3384:	51 81       	ldd	r21, Z+1	; 0x01
    3386:	62 81       	ldd	r22, Z+2	; 0x02
    3388:	73 81       	ldd	r23, Z+3	; 0x03
    338a:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <spindle_set_state>
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    338e:	80 ea       	ldi	r24, 0xA0	; 160
    3390:	9f e0       	ldi	r25, 0x0F	; 15
    3392:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <delay_ms>
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    3396:	f6 01       	movw	r30, r12
    3398:	80 81       	ld	r24, Z
    339a:	88 23       	and	r24, r24
    339c:	31 f0       	breq	.+12     	; 0x33aa <protocol_execute_realtime+0x1e2>
              coolant_set_state(gc_state.modal.coolant); 
    339e:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <coolant_set_state>
              delay_ms(SAFETY_DOOR_COOLANT_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    33a2:	88 ee       	ldi	r24, 0xE8	; 232
    33a4:	93 e0       	ldi	r25, 0x03	; 3
    33a6:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <delay_ms>
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    33aa:	0e 94 7a 2a 	call	0x54f4	; 0x54f4 <plan_get_current_block>
    33ae:	89 2b       	or	r24, r25
    33b0:	61 f0       	breq	.+24     	; 0x33ca <protocol_execute_realtime+0x202>
    33b2:	f8 01       	movw	r30, r16
    33b4:	80 81       	ld	r24, Z
    33b6:	83 fd       	sbrc	r24, 3
    33b8:	08 c0       	rjmp	.+16     	; 0x33ca <protocol_execute_realtime+0x202>
            sys.state = STATE_CYCLE;
    33ba:	88 e0       	ldi	r24, 0x08	; 8
    33bc:	f4 01       	movw	r30, r8
    33be:	80 83       	st	Z, r24
            st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    33c0:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <st_prep_buffer>
            st_wake_up();
    33c4:	0e 94 2d 1b 	call	0x365a	; 0x365a <st_wake_up>
    33c8:	02 c0       	rjmp	.+4      	; 0x33ce <protocol_execute_realtime+0x206>
          } else { // Otherwise, do nothing. Set and resume IDLE state.
            sys.state = STATE_IDLE;
    33ca:	f4 01       	movw	r30, r8
    33cc:	10 82       	st	Z, r1
          }
          sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    33ce:	f8 01       	movw	r30, r16
    33d0:	10 82       	st	Z, r1
        }
      }    
      bit_false_atomic(sys.rt_exec_state,EXEC_CYCLE_START);
    33d2:	8f b7       	in	r24, 0x3f	; 63
    33d4:	f8 94       	cli
    33d6:	98 81       	ld	r25, Y
    33d8:	9d 7f       	andi	r25, 0xFD	; 253
    33da:	98 83       	st	Y, r25
    33dc:	8f bf       	out	0x3f, r24	; 63
    // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by 
    // realtime command execution in the main program, ensuring that the planner re-plans safely.
    // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
    // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.   
    // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
    if (rt_exec & EXEC_CYCLE_STOP) {
    33de:	52 fe       	sbrs	r5, 2
    33e0:	1b c0       	rjmp	.+54     	; 0x3418 <protocol_execute_realtime+0x250>
      if (sys.state & (STATE_HOLD | STATE_SAFETY_DOOR)) {
    33e2:	f4 01       	movw	r30, r8
    33e4:	80 81       	ld	r24, Z
    33e6:	80 73       	andi	r24, 0x30	; 48
    33e8:	69 f0       	breq	.+26     	; 0x3404 <protocol_execute_realtime+0x23c>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        if (sys.suspend & SUSPEND_ENERGIZE) { // De-energize system if safety door has been opened.
    33ea:	f8 01       	movw	r30, r16
    33ec:	80 81       	ld	r24, Z
    33ee:	82 ff       	sbrs	r24, 2
    33f0:	04 c0       	rjmp	.+8      	; 0x33fa <protocol_execute_realtime+0x232>
          spindle_stop();
    33f2:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <spindle_stop>
          coolant_stop();
    33f6:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <coolant_stop>
          // TODO: Install parking motion here.
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY); //Problem in Bezug auf Jogging?
    33fa:	f8 01       	movw	r30, r16
    33fc:	80 81       	ld	r24, Z
    33fe:	82 60       	ori	r24, 0x02	; 2
    3400:	80 83       	st	Z, r24
    3402:	04 c0       	rjmp	.+8      	; 0x340c <protocol_execute_realtime+0x244>
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    3404:	f8 01       	movw	r30, r16
    3406:	10 82       	st	Z, r1
        sys.state = STATE_IDLE;
    3408:	f4 01       	movw	r30, r8
    340a:	10 82       	st	Z, r1
      }
      bit_false_atomic(sys.rt_exec_state,EXEC_CYCLE_STOP);
    340c:	8f b7       	in	r24, 0x3f	; 63
    340e:	f8 94       	cli
    3410:	98 81       	ld	r25, Y
    3412:	9b 7f       	andi	r25, 0xFB	; 251
    3414:	98 83       	st	Y, r25
    3416:	8f bf       	out	0x3f, r24	; 63

  // Overrides flag byte (sys.override) and execution should be installed here, since they 
  // are realtime and require a direct and controlled interface to the main stepper program.

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_MOTION_CANCEL | STATE_SAFETY_DOOR | STATE_HOMING)) { st_prep_buffer(); }  
    3418:	f4 01       	movw	r30, r8
    341a:	80 81       	ld	r24, Z
    341c:	8c 77       	andi	r24, 0x7C	; 124
    341e:	11 f0       	breq	.+4      	; 0x3424 <protocol_execute_realtime+0x25c>
    3420:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <st_prep_buffer>
  
  // If safety door was opened, actively check when safety door is closed and ready to resume.
  // NOTE: This unlocks the SAFETY_DOOR state to a HOLD state, such that CYCLE_START can activate a resume.
  if (sys.state == STATE_SAFETY_DOOR) { 
    3424:	f4 01       	movw	r30, r8
    3426:	80 81       	ld	r24, Z
    3428:	80 32       	cpi	r24, 0x20	; 32
    342a:	51 f4       	brne	.+20     	; 0x3440 <protocol_execute_realtime+0x278>
    if (bit_istrue(sys.suspend,SUSPEND_ENABLE_READY)) { 
    342c:	f8 01       	movw	r30, r16
    342e:	80 81       	ld	r24, Z
    3430:	81 ff       	sbrs	r24, 1
    3432:	06 c0       	rjmp	.+12     	; 0x3440 <protocol_execute_realtime+0x278>
      if (!(system_check_safety_door_ajar())) {
    3434:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <system_check_safety_door_ajar>
    3438:	81 11       	cpse	r24, r1
    343a:	02 c0       	rjmp	.+4      	; 0x3440 <protocol_execute_realtime+0x278>
        sys.state = STATE_HOLD; // Update to HOLD state to indicate door is closed and ready to resume.
    343c:	f4 01       	movw	r30, r8
    343e:	20 82       	st	Z, r2
      }
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
    3440:	f8 01       	movw	r30, r16
    3442:	80 81       	ld	r24, Z
    3444:	81 11       	cpse	r24, r1
    3446:	fc ce       	rjmp	.-520    	; 0x3240 <protocol_execute_realtime+0x78>
    3448:	03 c0       	rjmp	.+6      	; 0x3450 <protocol_execute_realtime+0x288>
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    344a:	f4 01       	movw	r30, r8
    344c:	80 81       	ld	r24, Z
    344e:	58 cf       	rjmp	.-336    	; 0x3300 <protocol_execute_realtime+0x138>
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
  
}  
    3450:	df 91       	pop	r29
    3452:	cf 91       	pop	r28
    3454:	1f 91       	pop	r17
    3456:	0f 91       	pop	r16
    3458:	ff 90       	pop	r15
    345a:	ef 90       	pop	r14
    345c:	df 90       	pop	r13
    345e:	cf 90       	pop	r12
    3460:	bf 90       	pop	r11
    3462:	af 90       	pop	r10
    3464:	9f 90       	pop	r9
    3466:	8f 90       	pop	r8
    3468:	7f 90       	pop	r7
    346a:	6f 90       	pop	r6
    346c:	5f 90       	pop	r5
    346e:	4f 90       	pop	r4
    3470:	3f 90       	pop	r3
    3472:	2f 90       	pop	r2
    3474:	08 95       	ret

00003476 <protocol_process>:
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
  }
}

void protocol_process() { //Extracted from main_loop function to use it while in Jogging State
    3476:	df 92       	push	r13
    3478:	ef 92       	push	r14
    347a:	ff 92       	push	r15
    347c:	0f 93       	push	r16
    347e:	1f 93       	push	r17
    3480:	cf 93       	push	r28
    3482:	df 93       	push	r29
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
		if ((c == '\n') || (c == '\r')) { // End of line reached
			serial_write(LIMIT_PIN & LIMIT_MASK);
			printPgmString(PSTR(" "));
			serial_write(bit_istrue(LIMIT_PIN, LIMIT_MASK));
    3484:	dd 24       	eor	r13, r13
    3486:	d3 94       	inc	r13
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    3488:	c7 e6       	ldi	r28, 0x67	; 103
    348a:	d7 e0       	ldi	r29, 0x07	; 7

  if (line[0] == 0) {
    348c:	06 e0       	ldi	r16, 0x06	; 6
    348e:	11 e0       	ldi	r17, 0x01	; 1
  else if (line[0] == '$') {
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    
  }
  else if (sys.state == STATE_ALARM) {
    3490:	0f 2e       	mov	r0, r31
    3492:	f8 e6       	ldi	r31, 0x68	; 104
    3494:	ef 2e       	mov	r14, r31
    3496:	f7 e0       	ldi	r31, 0x07	; 7
    3498:	ff 2e       	mov	r15, r31
    349a:	f0 2d       	mov	r31, r0
	// line buffer, which is limited in size. The g-code standard actually states a line can't
	// exceed 256 characters, but the Arduino Uno does not have the memory space for this.
	// With a better processor, it would be very easy to pull this initial parsing out as a
	// seperate task to be shared by the g-code parser and Grbl's system commands.
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
    349c:	7e c0       	rjmp	.+252    	; 0x359a <protocol_process+0x124>
		if ((c == '\n') || (c == '\r')) { // End of line reached
    349e:	8a 30       	cpi	r24, 0x0A	; 10
    34a0:	19 f0       	breq	.+6      	; 0x34a8 <protocol_process+0x32>
    34a2:	8d 30       	cpi	r24, 0x0D	; 13
    34a4:	09 f0       	breq	.+2      	; 0x34a8 <protocol_process+0x32>
    34a6:	45 c0       	rjmp	.+138    	; 0x3532 <protocol_process+0xbc>
			serial_write(LIMIT_PIN & LIMIT_MASK);
    34a8:	83 b1       	in	r24, 0x03	; 3
    34aa:	8e 70       	andi	r24, 0x0E	; 14
    34ac:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
			printPgmString(PSTR(" "));
    34b0:	8c e9       	ldi	r24, 0x9C	; 156
    34b2:	92 e0       	ldi	r25, 0x02	; 2
    34b4:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
			serial_write(bit_istrue(LIMIT_PIN, LIMIT_MASK));
    34b8:	93 b1       	in	r25, 0x03	; 3
    34ba:	9e 70       	andi	r25, 0x0E	; 14
    34bc:	8d 2d       	mov	r24, r13
    34be:	09 f4       	brne	.+2      	; 0x34c2 <protocol_process+0x4c>
    34c0:	80 e0       	ldi	r24, 0x00	; 0
    34c2:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
			printPgmString(PSTR("\r\n"));
    34c6:	89 e9       	ldi	r24, 0x99	; 153
    34c8:	92 e0       	ldi	r25, 0x02	; 2
    34ca:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
			line[char_counter] = 0; // Set string termination character.
    34ce:	e0 91 05 01 	lds	r30, 0x0105
    34d2:	f0 e0       	ldi	r31, 0x00	; 0
    34d4:	ea 5f       	subi	r30, 0xFA	; 250
    34d6:	fe 4f       	sbci	r31, 0xFE	; 254
    34d8:	10 82       	st	Z, r1
// Directs and executes one line of formatted input from protocol_process. While mostly
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
    34da:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    34de:	88 81       	ld	r24, Y
    34e0:	81 11       	cpse	r24, r1
    34e2:	22 c0       	rjmp	.+68     	; 0x3528 <protocol_process+0xb2>

  if (line[0] == 0) {
    34e4:	f8 01       	movw	r30, r16
    34e6:	80 81       	ld	r24, Z
    34e8:	81 11       	cpse	r24, r1
    34ea:	03 c0       	rjmp	.+6      	; 0x34f2 <protocol_process+0x7c>
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);
    34ec:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
    34f0:	1b c0       	rjmp	.+54     	; 0x3528 <protocol_process+0xb2>

  }
  else if (line[0] == '$') {
    34f2:	84 32       	cpi	r24, 0x24	; 36
    34f4:	31 f4       	brne	.+12     	; 0x3502 <protocol_process+0x8c>
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    34f6:	c8 01       	movw	r24, r16
    34f8:	0e 94 15 3a 	call	0x742a	; 0x742a <system_execute_line>
    34fc:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
    3500:	13 c0       	rjmp	.+38     	; 0x3528 <protocol_process+0xb2>
    
  }
  else if (sys.state == STATE_ALARM) {
    3502:	f7 01       	movw	r30, r14
    3504:	80 81       	ld	r24, Z
    3506:	81 30       	cpi	r24, 0x01	; 1
    3508:	21 f4       	brne	.+8      	; 0x3512 <protocol_process+0x9c>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);
    350a:	89 e0       	ldi	r24, 0x09	; 9
    350c:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
    3510:	0b c0       	rjmp	.+22     	; 0x3528 <protocol_process+0xb2>

  } 
  else if (sys.state == STATE_JOG) {
    3512:	80 38       	cpi	r24, 0x80	; 128
    3514:	21 f4       	brne	.+8      	; 0x351e <protocol_process+0xa8>
	// GCode shall be ignored as long as jogging is ongoing
	report_status_message(STATUS_JOG_ONGOING_LOCK);
    3516:	8d e0       	ldi	r24, 0x0D	; 13
    3518:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
    351c:	05 c0       	rjmp	.+10     	; 0x3528 <protocol_process+0xb2>
  }
  else {
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
    351e:	c8 01       	movw	r24, r16
    3520:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <gc_execute_line>
    3524:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
			printPgmString(PSTR(" "));
			serial_write(bit_istrue(LIMIT_PIN, LIMIT_MASK));
			printPgmString(PSTR("\r\n"));
			line[char_counter] = 0; // Set string termination character.
			protocol_execute_line(line); // Line is complete. Execute it!
			iscomment = false;
    3528:	10 92 04 01 	sts	0x0104, r1
			char_counter = 0;
    352c:	10 92 05 01 	sts	0x0105, r1
    3530:	34 c0       	rjmp	.+104    	; 0x359a <protocol_process+0x124>
		} 
		else {
			if (iscomment) {
    3532:	90 91 04 01 	lds	r25, 0x0104
    3536:	99 23       	and	r25, r25
    3538:	29 f0       	breq	.+10     	; 0x3544 <protocol_process+0xce>
				// Throw away all comment characters
				if (c == ')') {
    353a:	89 32       	cpi	r24, 0x29	; 41
    353c:	71 f5       	brne	.+92     	; 0x359a <protocol_process+0x124>
					// End of comment. Resume line.
					iscomment = false;
    353e:	10 92 04 01 	sts	0x0104, r1
    3542:	2b c0       	rjmp	.+86     	; 0x359a <protocol_process+0x124>
				}
			}
			else {
				if (c <= ' ') {
    3544:	81 32       	cpi	r24, 0x21	; 33
    3546:	48 f1       	brcs	.+82     	; 0x359a <protocol_process+0x124>
					// Throw away whitepace and control characters
				}
				else if (c == '/') {
    3548:	8f 32       	cpi	r24, 0x2F	; 47
    354a:	39 f1       	breq	.+78     	; 0x359a <protocol_process+0x124>
					// Block delete NOT SUPPORTED. Ignore character.
					// NOTE: If supported, would simply need to check the system if block delete is enabled.
				}
				else if (c == '(') {
    354c:	88 32       	cpi	r24, 0x28	; 40
    354e:	19 f4       	brne	.+6      	; 0x3556 <protocol_process+0xe0>
					// Enable comments flag and ignore all characters until ')' or EOL.
					// NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
					// In the future, we could simply remove the items within the comments, but retain the
					// comment control characters, so that the g-code parser can error-check it.
					iscomment = true;
    3550:	d0 92 04 01 	sts	0x0104, r13
    3554:	22 c0       	rjmp	.+68     	; 0x359a <protocol_process+0x124>
					// where, during a program, the system auto-cycle start will continue to execute
					// everything until the next '%' sign. This will help fix resuming issues with certain
					// functions that empty the planner buffer to execute its task on-time.

				}
				else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    3556:	e0 91 05 01 	lds	r30, 0x0105
    355a:	ef 34       	cpi	r30, 0x4F	; 79
    355c:	40 f0       	brcs	.+16     	; 0x356e <protocol_process+0xf8>
					// Detect line buffer overflow. Report error and reset line buffer.
					report_status_message(STATUS_OVERFLOW);
    355e:	8b e0       	ldi	r24, 0x0B	; 11
    3560:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
					iscomment = false;
    3564:	10 92 04 01 	sts	0x0104, r1
					char_counter = 0;
    3568:	10 92 05 01 	sts	0x0105, r1
    356c:	16 c0       	rjmp	.+44     	; 0x359a <protocol_process+0x124>
				}
				else if (c >= 'a' && c <= 'z') { // Uppercase lowercase
    356e:	9f e9       	ldi	r25, 0x9F	; 159
    3570:	98 0f       	add	r25, r24
    3572:	9a 31       	cpi	r25, 0x1A	; 26
    3574:	50 f4       	brcc	.+20     	; 0x358a <protocol_process+0x114>
					line[char_counter++] = c-'a'+'A';
    3576:	91 e0       	ldi	r25, 0x01	; 1
    3578:	9e 0f       	add	r25, r30
    357a:	90 93 05 01 	sts	0x0105, r25
    357e:	f0 e0       	ldi	r31, 0x00	; 0
    3580:	ea 5f       	subi	r30, 0xFA	; 250
    3582:	fe 4f       	sbci	r31, 0xFE	; 254
    3584:	80 52       	subi	r24, 0x20	; 32
    3586:	80 83       	st	Z, r24
    3588:	08 c0       	rjmp	.+16     	; 0x359a <protocol_process+0x124>
				}
				else {
					line[char_counter++] = c;
    358a:	91 e0       	ldi	r25, 0x01	; 1
    358c:	9e 0f       	add	r25, r30
    358e:	90 93 05 01 	sts	0x0105, r25
    3592:	f0 e0       	ldi	r31, 0x00	; 0
    3594:	ea 5f       	subi	r30, 0xFA	; 250
    3596:	fe 4f       	sbci	r31, 0xFE	; 254
    3598:	80 83       	st	Z, r24
	// line buffer, which is limited in size. The g-code standard actually states a line can't
	// exceed 256 characters, but the Arduino Uno does not have the memory space for this.
	// With a better processor, it would be very easy to pull this initial parsing out as a
	// seperate task to be shared by the g-code parser and Grbl's system commands.
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
    359a:	0e 94 62 18 	call	0x30c4	; 0x30c4 <serial_read>
    359e:	8f 3f       	cpi	r24, 0xFF	; 255
    35a0:	09 f0       	breq	.+2      	; 0x35a4 <protocol_process+0x12e>
    35a2:	7d cf       	rjmp	.-262    	; 0x349e <protocol_process+0x28>
					line[char_counter++] = c;
				}
			}
		}
	}	
}
    35a4:	df 91       	pop	r29
    35a6:	cf 91       	pop	r28
    35a8:	1f 91       	pop	r17
    35aa:	0f 91       	pop	r16
    35ac:	ff 90       	pop	r15
    35ae:	ef 90       	pop	r14
    35b0:	df 90       	pop	r13
    35b2:	08 95       	ret

000035b4 <protocol_auto_cycle_start>:
// command in the planner queue.
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes 
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming 
// is finished, single commands), a command that needs to wait for the motions in the buffer to 
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start() { bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START); } 
    35b4:	8f b7       	in	r24, 0x3f	; 63
    35b6:	f8 94       	cli
    35b8:	ea e6       	ldi	r30, 0x6A	; 106
    35ba:	f7 e0       	ldi	r31, 0x07	; 7
    35bc:	90 81       	ld	r25, Z
    35be:	92 60       	ori	r25, 0x02	; 2
    35c0:	90 83       	st	Z, r25
    35c2:	8f bf       	out	0x3f, r24	; 63
    35c4:	08 95       	ret

000035c6 <protocol_main_loop>:

/* 
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    35c6:	cf 93       	push	r28
    35c8:	df 93       	push	r29
  // ------------------------------------------------------------
  // Complete initialization procedures upon a power-up or reset.
  // ------------------------------------------------------------
  
  // Print welcome message   
  report_init_message();
    35ca:	0e 94 37 35 	call	0x6a6e	; 0x6a6e <report_init_message>

  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    35ce:	80 91 68 07 	lds	r24, 0x0768
    35d2:	81 30       	cpi	r24, 0x01	; 1
    35d4:	21 f4       	brne	.+8      	; 0x35de <protocol_main_loop+0x18>
    report_feedback_message(MESSAGE_ALARM_LOCK); 
    35d6:	82 e0       	ldi	r24, 0x02	; 2
    35d8:	0e 94 00 35 	call	0x6a00	; 0x6a00 <report_feedback_message>
    35dc:	12 c0       	rjmp	.+36     	; 0x3602 <protocol_main_loop+0x3c>
  } else {
    // All systems go! But first check for safety door.
    if (system_check_safety_door_ajar()) {
    35de:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <system_check_safety_door_ajar>
    35e2:	88 23       	and	r24, r24
    35e4:	41 f0       	breq	.+16     	; 0x35f6 <protocol_main_loop+0x30>
      bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
    35e6:	ea e6       	ldi	r30, 0x6A	; 106
    35e8:	f7 e0       	ldi	r31, 0x07	; 7
    35ea:	80 81       	ld	r24, Z
    35ec:	80 62       	ori	r24, 0x20	; 32
    35ee:	80 83       	st	Z, r24
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    35f0:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
    35f4:	02 c0       	rjmp	.+4      	; 0x35fa <protocol_main_loop+0x34>
    } else {
      sys.state = STATE_IDLE; // Set system to ready. Clear all state flags.
    35f6:	10 92 68 07 	sts	0x0768, r1
    } 
    system_execute_startup(line); // Execute startup script.
    35fa:	86 e0       	ldi	r24, 0x06	; 6
    35fc:	91 e0       	ldi	r25, 0x01	; 1
    35fe:	0e 94 f4 39 	call	0x73e8	; 0x73e8 <system_execute_startup>
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
	jogging();
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    3602:	c7 e6       	ldi	r28, 0x67	; 103
    3604:	d7 e0       	ldi	r29, 0x07	; 7
  

  for (;;) {

    
    protocol_process();
    3606:	0e 94 3b 1a 	call	0x3476	; 0x3476 <protocol_process>
    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    360a:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
    360e:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
	jogging();
    3612:	0e 94 2d 05 	call	0xa5a	; 0xa5a <jogging>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    3616:	88 81       	ld	r24, Y
    3618:	88 23       	and	r24, r24
    361a:	a9 f3       	breq	.-22     	; 0x3606 <protocol_main_loop+0x40>
              
  }
  
  return; /* Never reached */
}
    361c:	df 91       	pop	r29
    361e:	cf 91       	pop	r28
    3620:	08 95       	ret

00003622 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    3622:	0f 93       	push	r16
    3624:	1f 93       	push	r17
    3626:	cf 93       	push	r28
    3628:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    362a:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    362e:	c7 e6       	ldi	r28, 0x67	; 103
    3630:	d7 e0       	ldi	r29, 0x07	; 7
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    3632:	08 e6       	ldi	r16, 0x68	; 104
    3634:	17 e0       	ldi	r17, 0x07	; 7
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    3636:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    363a:	88 81       	ld	r24, Y
    363c:	81 11       	cpse	r24, r1
    363e:	08 c0       	rjmp	.+16     	; 0x3650 <protocol_buffer_synchronize+0x2e>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    3640:	0e 94 7a 2a 	call	0x54f4	; 0x54f4 <plan_get_current_block>
    3644:	89 2b       	or	r24, r25
    3646:	b9 f7       	brne	.-18     	; 0x3636 <protocol_buffer_synchronize+0x14>
    3648:	f8 01       	movw	r30, r16
    364a:	80 81       	ld	r24, Z
    364c:	88 30       	cpi	r24, 0x08	; 8
    364e:	99 f3       	breq	.-26     	; 0x3636 <protocol_buffer_synchronize+0x14>
}
    3650:	df 91       	pop	r29
    3652:	cf 91       	pop	r28
    3654:	1f 91       	pop	r17
    3656:	0f 91       	pop	r16
    3658:	08 95       	ret

0000365a <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up() 
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    365a:	80 91 3c 09 	lds	r24, 0x093C
    365e:	82 ff       	sbrs	r24, 2
    3660:	02 c0       	rjmp	.+4      	; 0x3666 <st_wake_up+0xc>
    3662:	28 9a       	sbi	0x05, 0	; 5
    3664:	01 c0       	rjmp	.+2      	; 0x3668 <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    3666:	28 98       	cbi	0x05, 0	; 5

  if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)){
    3668:	80 91 68 07 	lds	r24, 0x0768
    366c:	8c 78       	andi	r24, 0x8C	; 140
    366e:	99 f1       	breq	.+102    	; 0x36d6 <st_wake_up+0x7c>
    // Initialize stepper output bits
    st.dir_outbits = dir_port_invert_mask; 
    3670:	80 91 86 01 	lds	r24, 0x0186
    3674:	80 93 9a 01 	sts	0x019A, r24
    st.step_outbits = step_port_invert_mask;
    3678:	80 91 87 01 	lds	r24, 0x0187
    367c:	80 93 99 01 	sts	0x0199, r24
      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
      // Set delay between direction pin write and step command.
      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    #else // Normal operation
      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    3680:	80 91 2f 09 	lds	r24, 0x092F
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	02 97       	sbiw	r24, 0x02	; 2
    3688:	aa 27       	eor	r26, r26
    368a:	97 fd       	sbrc	r25, 7
    368c:	a0 95       	com	r26
    368e:	ba 2f       	mov	r27, r26
    3690:	ac 01       	movw	r20, r24
    3692:	bd 01       	movw	r22, r26
    3694:	44 0f       	add	r20, r20
    3696:	55 1f       	adc	r21, r21
    3698:	66 1f       	adc	r22, r22
    369a:	77 1f       	adc	r23, r23
    369c:	44 0f       	add	r20, r20
    369e:	55 1f       	adc	r21, r21
    36a0:	66 1f       	adc	r22, r22
    36a2:	77 1f       	adc	r23, r23
    36a4:	44 0f       	add	r20, r20
    36a6:	55 1f       	adc	r21, r21
    36a8:	66 1f       	adc	r22, r22
    36aa:	77 1f       	adc	r23, r23
    36ac:	84 0f       	add	r24, r20
    36ae:	95 1f       	adc	r25, r21
    36b0:	a6 1f       	adc	r26, r22
    36b2:	b7 1f       	adc	r27, r23
    36b4:	b5 95       	asr	r27
    36b6:	a7 95       	ror	r26
    36b8:	97 95       	ror	r25
    36ba:	87 95       	ror	r24
    36bc:	b5 95       	asr	r27
    36be:	a7 95       	ror	r26
    36c0:	97 95       	ror	r25
    36c2:	87 95       	ror	r24
    36c4:	81 95       	neg	r24
    36c6:	80 93 98 01 	sts	0x0198, r24
    #endif

    // Enable Stepper Driver Interrupt
    TIMSK1 |= (1<<OCIE1A);
    36ca:	ef e6       	ldi	r30, 0x6F	; 111
    36cc:	f0 e0       	ldi	r31, 0x00	; 0
    36ce:	80 81       	ld	r24, Z
    36d0:	82 60       	ori	r24, 0x02	; 2
    36d2:	80 83       	st	Z, r24
	
	#ifdef LED_PRESENT
	LED_PORT &= ~(1<<LED_RUN_BIT); // active low
    36d4:	44 98       	cbi	0x08, 4	; 8
    36d6:	08 95       	ret

000036d8 <st_go_idle>:

// Stepper shutdown
void st_go_idle() 
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    36d8:	ef e6       	ldi	r30, 0x6F	; 111
    36da:	f0 e0       	ldi	r31, 0x00	; 0
    36dc:	80 81       	ld	r24, Z
    36de:	8d 7f       	andi	r24, 0xFD	; 253
    36e0:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    36e2:	e1 e8       	ldi	r30, 0x81	; 129
    36e4:	f0 e0       	ldi	r31, 0x00	; 0
    36e6:	80 81       	ld	r24, Z
    36e8:	88 7f       	andi	r24, 0xF8	; 248
    36ea:	81 60       	ori	r24, 0x01	; 1
    36ec:	80 83       	st	Z, r24
  busy = false;
    36ee:	10 92 85 01 	sts	0x0185, r1
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys.rt_exec_alarm) && sys.state != STATE_HOMING) {
    36f2:	80 91 32 09 	lds	r24, 0x0932
    36f6:	8f 3f       	cpi	r24, 0xFF	; 255
    36f8:	21 f4       	brne	.+8      	; 0x3702 <st_go_idle+0x2a>
    36fa:	90 91 6b 07 	lds	r25, 0x076B
    36fe:	99 23       	and	r25, r25
    3700:	49 f0       	breq	.+18     	; 0x3714 <st_go_idle+0x3c>
    3702:	90 91 68 07 	lds	r25, 0x0768
    3706:	94 30       	cpi	r25, 0x04	; 4
    3708:	39 f0       	breq	.+14     	; 0x3718 <st_go_idle+0x40>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    370a:	90 e0       	ldi	r25, 0x00	; 0
    370c:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <delay_ms>
    pin_state = true; // Override. Disable steppers.
    3710:	81 e0       	ldi	r24, 0x01	; 1
    3712:	03 c0       	rjmp	.+6      	; 0x371a <st_go_idle+0x42>
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
  busy = false;
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
    3714:	80 e0       	ldi	r24, 0x00	; 0
    3716:	01 c0       	rjmp	.+2      	; 0x371a <st_go_idle+0x42>
    3718:	80 e0       	ldi	r24, 0x00	; 0
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    371a:	90 91 3c 09 	lds	r25, 0x093C
    371e:	92 ff       	sbrs	r25, 2
    3720:	02 c0       	rjmp	.+4      	; 0x3726 <st_go_idle+0x4e>
    3722:	91 e0       	ldi	r25, 0x01	; 1
    3724:	89 27       	eor	r24, r25
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    3726:	88 23       	and	r24, r24
    3728:	11 f0       	breq	.+4      	; 0x372e <st_go_idle+0x56>
    372a:	28 9a       	sbi	0x05, 0	; 5
    372c:	01 c0       	rjmp	.+2      	; 0x3730 <st_go_idle+0x58>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    372e:	28 98       	cbi	0x05, 0	; 5
	  
  #ifdef LED_PRESENT
  LED_PORT |= (1<<LED_RUN_BIT); // active low, so set high
    3730:	44 9a       	sbi	0x08, 4	; 8
    3732:	08 95       	ret

00003734 <__vector_13>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated 
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{        
    3734:	1f 92       	push	r1
    3736:	0f 92       	push	r0
    3738:	0f b6       	in	r0, 0x3f	; 63
    373a:	0f 92       	push	r0
    373c:	11 24       	eor	r1, r1
    373e:	2f 93       	push	r18
    3740:	3f 93       	push	r19
    3742:	4f 93       	push	r20
    3744:	5f 93       	push	r21
    3746:	6f 93       	push	r22
    3748:	7f 93       	push	r23
    374a:	8f 93       	push	r24
    374c:	9f 93       	push	r25
    374e:	af 93       	push	r26
    3750:	bf 93       	push	r27
    3752:	cf 93       	push	r28
    3754:	df 93       	push	r29
    3756:	ef 93       	push	r30
    3758:	ff 93       	push	r31
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    375a:	80 91 85 01 	lds	r24, 0x0185
    375e:	81 11       	cpse	r24, r1
    3760:	ec c1       	rjmp	.+984    	; 0x3b3a <__vector_13+0x406>
  
  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    3762:	8b b1       	in	r24, 0x0b	; 11
    3764:	90 91 9a 01 	lds	r25, 0x019A
    3768:	98 7a       	andi	r25, 0xA8	; 168
    376a:	87 75       	andi	r24, 0x57	; 87
    376c:	89 2b       	or	r24, r25
    376e:	8b b9       	out	0x0b, r24	; 11

  // Then pulse the stepping pins
  #ifdef STEP_PULSE_DELAY
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    3770:	8b b1       	in	r24, 0x0b	; 11
    3772:	8b 7a       	andi	r24, 0xAB	; 171
    3774:	90 91 99 01 	lds	r25, 0x0199
    3778:	89 2b       	or	r24, r25
    377a:	8b b9       	out	0x0b, r24	; 11
  #endif  

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    377c:	80 91 98 01 	lds	r24, 0x0198
    3780:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    3782:	82 e0       	ldi	r24, 0x02	; 2
    3784:	85 bd       	out	0x25, r24	; 37

  busy = true;
    3786:	81 e0       	ldi	r24, 0x01	; 1
    3788:	80 93 85 01 	sts	0x0185, r24
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. 
    378c:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.
    
  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    378e:	80 91 ac 01 	lds	r24, 0x01AC
    3792:	90 91 ad 01 	lds	r25, 0x01AD
    3796:	89 2b       	or	r24, r25
    3798:	09 f0       	breq	.+2      	; 0x379c <__vector_13+0x68>
    379a:	a9 c0       	rjmp	.+338    	; 0x38ee <__vector_13+0x1ba>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    379c:	80 91 8a 01 	lds	r24, 0x018A
    37a0:	90 91 89 01 	lds	r25, 0x0189
    37a4:	98 17       	cp	r25, r24
    37a6:	09 f4       	brne	.+2      	; 0x37aa <__vector_13+0x76>
    37a8:	97 c0       	rjmp	.+302    	; 0x38d8 <__vector_13+0x1a4>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    37aa:	80 91 8a 01 	lds	r24, 0x018A
    37ae:	90 e0       	ldi	r25, 0x00	; 0
    37b0:	fc 01       	movw	r30, r24
    37b2:	ee 0f       	add	r30, r30
    37b4:	ff 1f       	adc	r31, r31
    37b6:	8e 0f       	add	r24, r30
    37b8:	9f 1f       	adc	r25, r31
    37ba:	fc 01       	movw	r30, r24
    37bc:	ee 0f       	add	r30, r30
    37be:	ff 1f       	adc	r31, r31
    37c0:	e2 55       	subi	r30, 0x52	; 82
    37c2:	fe 4f       	sbci	r31, 0xFE	; 254
    37c4:	f0 93 ad 01 	sts	0x01AD, r31
    37c8:	e0 93 ac 01 	sts	0x01AC, r30
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    37cc:	83 81       	ldd	r24, Z+3	; 0x03
    37ce:	94 81       	ldd	r25, Z+4	; 0x04
    37d0:	90 93 89 00 	sts	0x0089, r25
    37d4:	80 93 88 00 	sts	0x0088, r24
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    37d8:	80 81       	ld	r24, Z
    37da:	91 81       	ldd	r25, Z+1	; 0x01
    37dc:	90 93 a8 01 	sts	0x01A8, r25
    37e0:	80 93 a7 01 	sts	0x01A7, r24
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    37e4:	a2 81       	ldd	r26, Z+2	; 0x02
    37e6:	80 91 a9 01 	lds	r24, 0x01A9
    37ea:	8a 17       	cp	r24, r26
    37ec:	71 f1       	breq	.+92     	; 0x384a <__vector_13+0x116>
        st.exec_block_index = st.exec_segment->st_block_index;
    37ee:	a0 93 a9 01 	sts	0x01A9, r26
        st.exec_block = &st_block_buffer[st.exec_block_index];
    37f2:	81 e1       	ldi	r24, 0x11	; 17
    37f4:	a8 9f       	mul	r26, r24
    37f6:	d0 01       	movw	r26, r0
    37f8:	11 24       	eor	r1, r1
    37fa:	ae 52       	subi	r26, 0x2E	; 46
    37fc:	be 4f       	sbci	r27, 0xFE	; 254
    37fe:	b0 93 ab 01 	sts	0x01AB, r27
    3802:	a0 93 aa 01 	sts	0x01AA, r26
        
        // Initialize Bresenham line and distance counters
        st.counter_x = (st.exec_block->step_event_count >> 1);
    3806:	1d 96       	adiw	r26, 0x0d	; 13
    3808:	8d 91       	ld	r24, X+
    380a:	9d 91       	ld	r25, X+
    380c:	0d 90       	ld	r0, X+
    380e:	bc 91       	ld	r27, X
    3810:	a0 2d       	mov	r26, r0
    3812:	b6 95       	lsr	r27
    3814:	a7 95       	ror	r26
    3816:	97 95       	ror	r25
    3818:	87 95       	ror	r24
    381a:	80 93 8b 01 	sts	0x018B, r24
    381e:	90 93 8c 01 	sts	0x018C, r25
    3822:	a0 93 8d 01 	sts	0x018D, r26
    3826:	b0 93 8e 01 	sts	0x018E, r27
        st.counter_y = st.counter_x;
    382a:	80 93 8f 01 	sts	0x018F, r24
    382e:	90 93 90 01 	sts	0x0190, r25
    3832:	a0 93 91 01 	sts	0x0191, r26
    3836:	b0 93 92 01 	sts	0x0192, r27
        st.counter_z = st.counter_x;        
    383a:	80 93 93 01 	sts	0x0193, r24
    383e:	90 93 94 01 	sts	0x0194, r25
    3842:	a0 93 95 01 	sts	0x0195, r26
    3846:	b0 93 96 01 	sts	0x0196, r27
      }

      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask; 
    384a:	c0 91 aa 01 	lds	r28, 0x01AA
    384e:	d0 91 ab 01 	lds	r29, 0x01AB
    3852:	90 91 86 01 	lds	r25, 0x0186
    3856:	88 81       	ld	r24, Y
    3858:	89 27       	eor	r24, r25
    385a:	80 93 9a 01 	sts	0x019A, r24

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    385e:	89 81       	ldd	r24, Y+1	; 0x01
    3860:	9a 81       	ldd	r25, Y+2	; 0x02
    3862:	ab 81       	ldd	r26, Y+3	; 0x03
    3864:	bc 81       	ldd	r27, Y+4	; 0x04
    3866:	05 80       	ldd	r0, Z+5	; 0x05
    3868:	04 c0       	rjmp	.+8      	; 0x3872 <__vector_13+0x13e>
    386a:	b6 95       	lsr	r27
    386c:	a7 95       	ror	r26
    386e:	97 95       	ror	r25
    3870:	87 95       	ror	r24
    3872:	0a 94       	dec	r0
    3874:	d2 f7       	brpl	.-12     	; 0x386a <__vector_13+0x136>
    3876:	80 93 9b 01 	sts	0x019B, r24
    387a:	90 93 9c 01 	sts	0x019C, r25
    387e:	a0 93 9d 01 	sts	0x019D, r26
    3882:	b0 93 9e 01 	sts	0x019E, r27
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    3886:	8d 81       	ldd	r24, Y+5	; 0x05
    3888:	9e 81       	ldd	r25, Y+6	; 0x06
    388a:	af 81       	ldd	r26, Y+7	; 0x07
    388c:	b8 85       	ldd	r27, Y+8	; 0x08
    388e:	05 80       	ldd	r0, Z+5	; 0x05
    3890:	04 c0       	rjmp	.+8      	; 0x389a <__vector_13+0x166>
    3892:	b6 95       	lsr	r27
    3894:	a7 95       	ror	r26
    3896:	97 95       	ror	r25
    3898:	87 95       	ror	r24
    389a:	0a 94       	dec	r0
    389c:	d2 f7       	brpl	.-12     	; 0x3892 <__vector_13+0x15e>
    389e:	80 93 9f 01 	sts	0x019F, r24
    38a2:	90 93 a0 01 	sts	0x01A0, r25
    38a6:	a0 93 a1 01 	sts	0x01A1, r26
    38aa:	b0 93 a2 01 	sts	0x01A2, r27
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    38ae:	89 85       	ldd	r24, Y+9	; 0x09
    38b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    38b2:	ab 85       	ldd	r26, Y+11	; 0x0b
    38b4:	bc 85       	ldd	r27, Y+12	; 0x0c
    38b6:	05 80       	ldd	r0, Z+5	; 0x05
    38b8:	04 c0       	rjmp	.+8      	; 0x38c2 <__vector_13+0x18e>
    38ba:	b6 95       	lsr	r27
    38bc:	a7 95       	ror	r26
    38be:	97 95       	ror	r25
    38c0:	87 95       	ror	r24
    38c2:	0a 94       	dec	r0
    38c4:	d2 f7       	brpl	.-12     	; 0x38ba <__vector_13+0x186>
    38c6:	80 93 a3 01 	sts	0x01A3, r24
    38ca:	90 93 a4 01 	sts	0x01A4, r25
    38ce:	a0 93 a5 01 	sts	0x01A5, r26
    38d2:	b0 93 a6 01 	sts	0x01A6, r27
    38d6:	0b c0       	rjmp	.+22     	; 0x38ee <__vector_13+0x1ba>
      #endif
      
    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    38d8:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <st_go_idle>
      bit_true_atomic(sys.rt_exec_state,EXEC_CYCLE_STOP); // Flag main program for cycle end
    38dc:	8f b7       	in	r24, 0x3f	; 63
    38de:	f8 94       	cli
    38e0:	ea e6       	ldi	r30, 0x6A	; 106
    38e2:	f7 e0       	ldi	r31, 0x07	; 7
    38e4:	90 81       	ld	r25, Z
    38e6:	94 60       	ori	r25, 0x04	; 4
    38e8:	90 83       	st	Z, r25
    38ea:	8f bf       	out	0x3f, r24	; 63
      return; // Nothing to do but exit.
    38ec:	26 c1       	rjmp	.+588    	; 0x3b3a <__vector_13+0x406>
    }  
  }
  
  
  // Check probing state.
  probe_state_monitor();
    38ee:	0e 94 49 34 	call	0x6892	; 0x6892 <probe_state_monitor>
   
  // Reset step out bits.
  st.step_outbits = 0; 
    38f2:	10 92 99 01 	sts	0x0199, r1

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    38f6:	eb e8       	ldi	r30, 0x8B	; 139
    38f8:	f1 e0       	ldi	r31, 0x01	; 1
    38fa:	40 91 9b 01 	lds	r20, 0x019B
    38fe:	50 91 9c 01 	lds	r21, 0x019C
    3902:	60 91 9d 01 	lds	r22, 0x019D
    3906:	70 91 9e 01 	lds	r23, 0x019E
    390a:	80 81       	ld	r24, Z
    390c:	91 81       	ldd	r25, Z+1	; 0x01
    390e:	a2 81       	ldd	r26, Z+2	; 0x02
    3910:	b3 81       	ldd	r27, Z+3	; 0x03
    3912:	84 0f       	add	r24, r20
    3914:	95 1f       	adc	r25, r21
    3916:	a6 1f       	adc	r26, r22
    3918:	b7 1f       	adc	r27, r23
    391a:	80 83       	st	Z, r24
    391c:	91 83       	std	Z+1, r25	; 0x01
    391e:	a2 83       	std	Z+2, r26	; 0x02
    3920:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif  
  if (st.counter_x > st.exec_block->step_event_count) {
    3922:	e0 91 aa 01 	lds	r30, 0x01AA
    3926:	f0 91 ab 01 	lds	r31, 0x01AB
    392a:	45 85       	ldd	r20, Z+13	; 0x0d
    392c:	56 85       	ldd	r21, Z+14	; 0x0e
    392e:	67 85       	ldd	r22, Z+15	; 0x0f
    3930:	70 89       	ldd	r23, Z+16	; 0x10
    3932:	48 17       	cp	r20, r24
    3934:	59 07       	cpc	r21, r25
    3936:	6a 07       	cpc	r22, r26
    3938:	7b 07       	cpc	r23, r27
    393a:	88 f5       	brcc	.+98     	; 0x399e <__vector_13+0x26a>
    st.step_outbits |= (1<<X_STEP_BIT);
    393c:	20 e4       	ldi	r18, 0x40	; 64
    393e:	20 93 99 01 	sts	0x0199, r18
    st.counter_x -= st.exec_block->step_event_count;
    3942:	45 85       	ldd	r20, Z+13	; 0x0d
    3944:	56 85       	ldd	r21, Z+14	; 0x0e
    3946:	67 85       	ldd	r22, Z+15	; 0x0f
    3948:	70 89       	ldd	r23, Z+16	; 0x10
    394a:	84 1b       	sub	r24, r20
    394c:	95 0b       	sbc	r25, r21
    394e:	a6 0b       	sbc	r26, r22
    3950:	b7 0b       	sbc	r27, r23
    3952:	80 93 8b 01 	sts	0x018B, r24
    3956:	90 93 8c 01 	sts	0x018C, r25
    395a:	a0 93 8d 01 	sts	0x018D, r26
    395e:	b0 93 8e 01 	sts	0x018E, r27
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys.position[X_AXIS]--; }
    3962:	80 81       	ld	r24, Z
    3964:	88 23       	and	r24, r24
    3966:	74 f4       	brge	.+28     	; 0x3984 <__vector_13+0x250>
    3968:	cc e6       	ldi	r28, 0x6C	; 108
    396a:	d7 e0       	ldi	r29, 0x07	; 7
    396c:	88 81       	ld	r24, Y
    396e:	99 81       	ldd	r25, Y+1	; 0x01
    3970:	aa 81       	ldd	r26, Y+2	; 0x02
    3972:	bb 81       	ldd	r27, Y+3	; 0x03
    3974:	01 97       	sbiw	r24, 0x01	; 1
    3976:	a1 09       	sbc	r26, r1
    3978:	b1 09       	sbc	r27, r1
    397a:	88 83       	st	Y, r24
    397c:	99 83       	std	Y+1, r25	; 0x01
    397e:	aa 83       	std	Y+2, r26	; 0x02
    3980:	bb 83       	std	Y+3, r27	; 0x03
    3982:	0d c0       	rjmp	.+26     	; 0x399e <__vector_13+0x26a>
    else { sys.position[X_AXIS]++; }
    3984:	cc e6       	ldi	r28, 0x6C	; 108
    3986:	d7 e0       	ldi	r29, 0x07	; 7
    3988:	88 81       	ld	r24, Y
    398a:	99 81       	ldd	r25, Y+1	; 0x01
    398c:	aa 81       	ldd	r26, Y+2	; 0x02
    398e:	bb 81       	ldd	r27, Y+3	; 0x03
    3990:	01 96       	adiw	r24, 0x01	; 1
    3992:	a1 1d       	adc	r26, r1
    3994:	b1 1d       	adc	r27, r1
    3996:	88 83       	st	Y, r24
    3998:	99 83       	std	Y+1, r25	; 0x01
    399a:	aa 83       	std	Y+2, r26	; 0x02
    399c:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    399e:	cf e8       	ldi	r28, 0x8F	; 143
    39a0:	d1 e0       	ldi	r29, 0x01	; 1
    39a2:	40 91 9f 01 	lds	r20, 0x019F
    39a6:	50 91 a0 01 	lds	r21, 0x01A0
    39aa:	60 91 a1 01 	lds	r22, 0x01A1
    39ae:	70 91 a2 01 	lds	r23, 0x01A2
    39b2:	88 81       	ld	r24, Y
    39b4:	99 81       	ldd	r25, Y+1	; 0x01
    39b6:	aa 81       	ldd	r26, Y+2	; 0x02
    39b8:	bb 81       	ldd	r27, Y+3	; 0x03
    39ba:	84 0f       	add	r24, r20
    39bc:	95 1f       	adc	r25, r21
    39be:	a6 1f       	adc	r26, r22
    39c0:	b7 1f       	adc	r27, r23
    39c2:	88 83       	st	Y, r24
    39c4:	99 83       	std	Y+1, r25	; 0x01
    39c6:	aa 83       	std	Y+2, r26	; 0x02
    39c8:	bb 83       	std	Y+3, r27	; 0x03
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif    
  if (st.counter_y > st.exec_block->step_event_count) {
    39ca:	45 85       	ldd	r20, Z+13	; 0x0d
    39cc:	56 85       	ldd	r21, Z+14	; 0x0e
    39ce:	67 85       	ldd	r22, Z+15	; 0x0f
    39d0:	70 89       	ldd	r23, Z+16	; 0x10
    39d2:	48 17       	cp	r20, r24
    39d4:	59 07       	cpc	r21, r25
    39d6:	6a 07       	cpc	r22, r26
    39d8:	7b 07       	cpc	r23, r27
    39da:	98 f5       	brcc	.+102    	; 0x3a42 <__vector_13+0x30e>
    st.step_outbits |= (1<<Y_STEP_BIT);
    39dc:	c9 e9       	ldi	r28, 0x99	; 153
    39de:	d1 e0       	ldi	r29, 0x01	; 1
    39e0:	28 81       	ld	r18, Y
    39e2:	20 61       	ori	r18, 0x10	; 16
    39e4:	28 83       	st	Y, r18
    st.counter_y -= st.exec_block->step_event_count;
    39e6:	45 85       	ldd	r20, Z+13	; 0x0d
    39e8:	56 85       	ldd	r21, Z+14	; 0x0e
    39ea:	67 85       	ldd	r22, Z+15	; 0x0f
    39ec:	70 89       	ldd	r23, Z+16	; 0x10
    39ee:	84 1b       	sub	r24, r20
    39f0:	95 0b       	sbc	r25, r21
    39f2:	a6 0b       	sbc	r26, r22
    39f4:	b7 0b       	sbc	r27, r23
    39f6:	80 93 8f 01 	sts	0x018F, r24
    39fa:	90 93 90 01 	sts	0x0190, r25
    39fe:	a0 93 91 01 	sts	0x0191, r26
    3a02:	b0 93 92 01 	sts	0x0192, r27
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys.position[Y_AXIS]--; }
    3a06:	80 81       	ld	r24, Z
    3a08:	85 ff       	sbrs	r24, 5
    3a0a:	0e c0       	rjmp	.+28     	; 0x3a28 <__vector_13+0x2f4>
    3a0c:	c0 e7       	ldi	r28, 0x70	; 112
    3a0e:	d7 e0       	ldi	r29, 0x07	; 7
    3a10:	88 81       	ld	r24, Y
    3a12:	99 81       	ldd	r25, Y+1	; 0x01
    3a14:	aa 81       	ldd	r26, Y+2	; 0x02
    3a16:	bb 81       	ldd	r27, Y+3	; 0x03
    3a18:	01 97       	sbiw	r24, 0x01	; 1
    3a1a:	a1 09       	sbc	r26, r1
    3a1c:	b1 09       	sbc	r27, r1
    3a1e:	88 83       	st	Y, r24
    3a20:	99 83       	std	Y+1, r25	; 0x01
    3a22:	aa 83       	std	Y+2, r26	; 0x02
    3a24:	bb 83       	std	Y+3, r27	; 0x03
    3a26:	0d c0       	rjmp	.+26     	; 0x3a42 <__vector_13+0x30e>
    else { sys.position[Y_AXIS]++; }
    3a28:	c0 e7       	ldi	r28, 0x70	; 112
    3a2a:	d7 e0       	ldi	r29, 0x07	; 7
    3a2c:	88 81       	ld	r24, Y
    3a2e:	99 81       	ldd	r25, Y+1	; 0x01
    3a30:	aa 81       	ldd	r26, Y+2	; 0x02
    3a32:	bb 81       	ldd	r27, Y+3	; 0x03
    3a34:	01 96       	adiw	r24, 0x01	; 1
    3a36:	a1 1d       	adc	r26, r1
    3a38:	b1 1d       	adc	r27, r1
    3a3a:	88 83       	st	Y, r24
    3a3c:	99 83       	std	Y+1, r25	; 0x01
    3a3e:	aa 83       	std	Y+2, r26	; 0x02
    3a40:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    3a42:	c3 e9       	ldi	r28, 0x93	; 147
    3a44:	d1 e0       	ldi	r29, 0x01	; 1
    3a46:	40 91 a3 01 	lds	r20, 0x01A3
    3a4a:	50 91 a4 01 	lds	r21, 0x01A4
    3a4e:	60 91 a5 01 	lds	r22, 0x01A5
    3a52:	70 91 a6 01 	lds	r23, 0x01A6
    3a56:	88 81       	ld	r24, Y
    3a58:	99 81       	ldd	r25, Y+1	; 0x01
    3a5a:	aa 81       	ldd	r26, Y+2	; 0x02
    3a5c:	bb 81       	ldd	r27, Y+3	; 0x03
    3a5e:	84 0f       	add	r24, r20
    3a60:	95 1f       	adc	r25, r21
    3a62:	a6 1f       	adc	r26, r22
    3a64:	b7 1f       	adc	r27, r23
    3a66:	88 83       	st	Y, r24
    3a68:	99 83       	std	Y+1, r25	; 0x01
    3a6a:	aa 83       	std	Y+2, r26	; 0x02
    3a6c:	bb 83       	std	Y+3, r27	; 0x03
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif  
  if (st.counter_z > st.exec_block->step_event_count) {
    3a6e:	45 85       	ldd	r20, Z+13	; 0x0d
    3a70:	56 85       	ldd	r21, Z+14	; 0x0e
    3a72:	67 85       	ldd	r22, Z+15	; 0x0f
    3a74:	70 89       	ldd	r23, Z+16	; 0x10
    3a76:	48 17       	cp	r20, r24
    3a78:	59 07       	cpc	r21, r25
    3a7a:	6a 07       	cpc	r22, r26
    3a7c:	7b 07       	cpc	r23, r27
    3a7e:	98 f5       	brcc	.+102    	; 0x3ae6 <__vector_13+0x3b2>
    st.step_outbits |= (1<<Z_STEP_BIT);
    3a80:	c9 e9       	ldi	r28, 0x99	; 153
    3a82:	d1 e0       	ldi	r29, 0x01	; 1
    3a84:	28 81       	ld	r18, Y
    3a86:	24 60       	ori	r18, 0x04	; 4
    3a88:	28 83       	st	Y, r18
    st.counter_z -= st.exec_block->step_event_count;
    3a8a:	45 85       	ldd	r20, Z+13	; 0x0d
    3a8c:	56 85       	ldd	r21, Z+14	; 0x0e
    3a8e:	67 85       	ldd	r22, Z+15	; 0x0f
    3a90:	70 89       	ldd	r23, Z+16	; 0x10
    3a92:	84 1b       	sub	r24, r20
    3a94:	95 0b       	sbc	r25, r21
    3a96:	a6 0b       	sbc	r26, r22
    3a98:	b7 0b       	sbc	r27, r23
    3a9a:	80 93 93 01 	sts	0x0193, r24
    3a9e:	90 93 94 01 	sts	0x0194, r25
    3aa2:	a0 93 95 01 	sts	0x0195, r26
    3aa6:	b0 93 96 01 	sts	0x0196, r27
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys.position[Z_AXIS]--; }
    3aaa:	80 81       	ld	r24, Z
    3aac:	83 ff       	sbrs	r24, 3
    3aae:	0e c0       	rjmp	.+28     	; 0x3acc <__vector_13+0x398>
    3ab0:	e4 e7       	ldi	r30, 0x74	; 116
    3ab2:	f7 e0       	ldi	r31, 0x07	; 7
    3ab4:	80 81       	ld	r24, Z
    3ab6:	91 81       	ldd	r25, Z+1	; 0x01
    3ab8:	a2 81       	ldd	r26, Z+2	; 0x02
    3aba:	b3 81       	ldd	r27, Z+3	; 0x03
    3abc:	01 97       	sbiw	r24, 0x01	; 1
    3abe:	a1 09       	sbc	r26, r1
    3ac0:	b1 09       	sbc	r27, r1
    3ac2:	80 83       	st	Z, r24
    3ac4:	91 83       	std	Z+1, r25	; 0x01
    3ac6:	a2 83       	std	Z+2, r26	; 0x02
    3ac8:	b3 83       	std	Z+3, r27	; 0x03
    3aca:	0d c0       	rjmp	.+26     	; 0x3ae6 <__vector_13+0x3b2>
    else { sys.position[Z_AXIS]++; }
    3acc:	e4 e7       	ldi	r30, 0x74	; 116
    3ace:	f7 e0       	ldi	r31, 0x07	; 7
    3ad0:	80 81       	ld	r24, Z
    3ad2:	91 81       	ldd	r25, Z+1	; 0x01
    3ad4:	a2 81       	ldd	r26, Z+2	; 0x02
    3ad6:	b3 81       	ldd	r27, Z+3	; 0x03
    3ad8:	01 96       	adiw	r24, 0x01	; 1
    3ada:	a1 1d       	adc	r26, r1
    3adc:	b1 1d       	adc	r27, r1
    3ade:	80 83       	st	Z, r24
    3ae0:	91 83       	std	Z+1, r25	; 0x01
    3ae2:	a2 83       	std	Z+2, r26	; 0x02
    3ae4:	b3 83       	std	Z+3, r27	; 0x03
  }  

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }   
    3ae6:	80 91 68 07 	lds	r24, 0x0768
    3aea:	84 30       	cpi	r24, 0x04	; 4
    3aec:	39 f4       	brne	.+14     	; 0x3afc <__vector_13+0x3c8>
    3aee:	e9 e9       	ldi	r30, 0x99	; 153
    3af0:	f1 e0       	ldi	r31, 0x01	; 1
    3af2:	90 91 78 07 	lds	r25, 0x0778
    3af6:	80 81       	ld	r24, Z
    3af8:	89 23       	and	r24, r25
    3afa:	80 83       	st	Z, r24

  st.step_count--; // Decrement step events count 
    3afc:	e7 ea       	ldi	r30, 0xA7	; 167
    3afe:	f1 e0       	ldi	r31, 0x01	; 1
    3b00:	80 81       	ld	r24, Z
    3b02:	91 81       	ldd	r25, Z+1	; 0x01
    3b04:	01 97       	sbiw	r24, 0x01	; 1
    3b06:	91 83       	std	Z+1, r25	; 0x01
    3b08:	80 83       	st	Z, r24
  if (st.step_count == 0) {
    3b0a:	89 2b       	or	r24, r25
    3b0c:	69 f4       	brne	.+26     	; 0x3b28 <__vector_13+0x3f4>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    3b0e:	10 92 ad 01 	sts	0x01AD, r1
    3b12:	10 92 ac 01 	sts	0x01AC, r1
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    3b16:	80 91 8a 01 	lds	r24, 0x018A
    3b1a:	8f 5f       	subi	r24, 0xFF	; 255
    3b1c:	80 93 8a 01 	sts	0x018A, r24
    3b20:	86 30       	cpi	r24, 0x06	; 6
    3b22:	11 f4       	brne	.+4      	; 0x3b28 <__vector_13+0x3f4>
    3b24:	10 92 8a 01 	sts	0x018A, r1
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask    
    3b28:	e9 e9       	ldi	r30, 0x99	; 153
    3b2a:	f1 e0       	ldi	r31, 0x01	; 1
    3b2c:	90 91 87 01 	lds	r25, 0x0187
    3b30:	80 81       	ld	r24, Z
    3b32:	89 27       	eor	r24, r25
    3b34:	80 83       	st	Z, r24
  busy = false;
    3b36:	10 92 85 01 	sts	0x0185, r1
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
}
    3b3a:	ff 91       	pop	r31
    3b3c:	ef 91       	pop	r30
    3b3e:	df 91       	pop	r29
    3b40:	cf 91       	pop	r28
    3b42:	bf 91       	pop	r27
    3b44:	af 91       	pop	r26
    3b46:	9f 91       	pop	r25
    3b48:	8f 91       	pop	r24
    3b4a:	7f 91       	pop	r23
    3b4c:	6f 91       	pop	r22
    3b4e:	5f 91       	pop	r21
    3b50:	4f 91       	pop	r20
    3b52:	3f 91       	pop	r19
    3b54:	2f 91       	pop	r18
    3b56:	0f 90       	pop	r0
    3b58:	0f be       	out	0x3f, r0	; 63
    3b5a:	0f 90       	pop	r0
    3b5c:	1f 90       	pop	r1
    3b5e:	18 95       	reti

00003b60 <__vector_18>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) 
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    3b60:	1f 92       	push	r1
    3b62:	0f 92       	push	r0
    3b64:	0f b6       	in	r0, 0x3f	; 63
    3b66:	0f 92       	push	r0
    3b68:	11 24       	eor	r1, r1
    3b6a:	8f 93       	push	r24
    3b6c:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK); 
    3b6e:	8b b1       	in	r24, 0x0b	; 11
    3b70:	90 91 87 01 	lds	r25, 0x0187
    3b74:	94 75       	andi	r25, 0x54	; 84
    3b76:	8b 7a       	andi	r24, 0xAB	; 171
    3b78:	89 2b       	or	r24, r25
    3b7a:	8b b9       	out	0x0b, r24	; 11
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed. 
    3b7c:	15 bc       	out	0x25, r1	; 37
}
    3b7e:	9f 91       	pop	r25
    3b80:	8f 91       	pop	r24
    3b82:	0f 90       	pop	r0
    3b84:	0f be       	out	0x3f, r0	; 63
    3b86:	0f 90       	pop	r0
    3b88:	1f 90       	pop	r1
    3b8a:	18 95       	reti

00003b8c <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{  
    3b8c:	cf 92       	push	r12
    3b8e:	df 92       	push	r13
    3b90:	ef 92       	push	r14
    3b92:	ff 92       	push	r15
    3b94:	0f 93       	push	r16
    3b96:	1f 93       	push	r17
    3b98:	cf 93       	push	r28
    3b9a:	df 93       	push	r29
  uint8_t idx;
  step_port_invert_mask = 0;
    3b9c:	10 92 87 01 	sts	0x0187, r1
  dir_port_invert_mask = 0;
    3ba0:	10 92 86 01 	sts	0x0186, r1
    3ba4:	c0 e0       	ldi	r28, 0x00	; 0
    3ba6:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    3ba8:	0f 2e       	mov	r0, r31
    3baa:	f0 e3       	ldi	r31, 0x30	; 48
    3bac:	ef 2e       	mov	r14, r31
    3bae:	f9 e0       	ldi	r31, 0x09	; 9
    3bb0:	ff 2e       	mov	r15, r31
    3bb2:	f0 2d       	mov	r31, r0
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3bb4:	01 e3       	ldi	r16, 0x31	; 49
    3bb6:	19 e0       	ldi	r17, 0x09	; 9
    3bb8:	cc 2e       	mov	r12, r28
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    3bba:	dc 2e       	mov	r13, r28
    3bbc:	f7 01       	movw	r30, r14
    3bbe:	40 81       	ld	r20, Z
    3bc0:	50 e0       	ldi	r21, 0x00	; 0
    3bc2:	0c 2e       	mov	r0, r28
    3bc4:	02 c0       	rjmp	.+4      	; 0x3bca <st_generate_step_dir_invert_masks+0x3e>
    3bc6:	55 95       	asr	r21
    3bc8:	47 95       	ror	r20
    3bca:	0a 94       	dec	r0
    3bcc:	e2 f7       	brpl	.-8      	; 0x3bc6 <st_generate_step_dir_invert_masks+0x3a>
    3bce:	40 ff       	sbrs	r20, 0
    3bd0:	08 c0       	rjmp	.+16     	; 0x3be2 <st_generate_step_dir_invert_masks+0x56>
    3bd2:	8c 2f       	mov	r24, r28
    3bd4:	0e 94 07 29 	call	0x520e	; 0x520e <get_step_pin_mask>
    3bd8:	90 91 87 01 	lds	r25, 0x0187
    3bdc:	89 2b       	or	r24, r25
    3bde:	80 93 87 01 	sts	0x0187, r24
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3be2:	f8 01       	movw	r30, r16
    3be4:	20 81       	ld	r18, Z
    3be6:	30 e0       	ldi	r19, 0x00	; 0
    3be8:	02 c0       	rjmp	.+4      	; 0x3bee <st_generate_step_dir_invert_masks+0x62>
    3bea:	35 95       	asr	r19
    3bec:	27 95       	ror	r18
    3bee:	da 94       	dec	r13
    3bf0:	e2 f7       	brpl	.-8      	; 0x3bea <st_generate_step_dir_invert_masks+0x5e>
    3bf2:	20 ff       	sbrs	r18, 0
    3bf4:	08 c0       	rjmp	.+16     	; 0x3c06 <st_generate_step_dir_invert_masks+0x7a>
    3bf6:	8c 2d       	mov	r24, r12
    3bf8:	0e 94 11 29 	call	0x5222	; 0x5222 <get_direction_pin_mask>
    3bfc:	90 91 86 01 	lds	r25, 0x0186
    3c00:	89 2b       	or	r24, r25
    3c02:	80 93 86 01 	sts	0x0186, r24
    3c06:	21 96       	adiw	r28, 0x01	; 1
void st_generate_step_dir_invert_masks()
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    3c08:	c3 30       	cpi	r28, 0x03	; 3
    3c0a:	d1 05       	cpc	r29, r1
    3c0c:	a9 f6       	brne	.-86     	; 0x3bb8 <st_generate_step_dir_invert_masks+0x2c>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
  }
}
    3c0e:	df 91       	pop	r29
    3c10:	cf 91       	pop	r28
    3c12:	1f 91       	pop	r17
    3c14:	0f 91       	pop	r16
    3c16:	ff 90       	pop	r15
    3c18:	ef 90       	pop	r14
    3c1a:	df 90       	pop	r13
    3c1c:	cf 90       	pop	r12
    3c1e:	08 95       	ret

00003c20 <st_reset>:

// Reset and clear stepper subsystem variables
void st_reset()
{
  // Initialize stepper driver idle state.
  st_go_idle();
    3c20:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <st_go_idle>
  
  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(prep));
    3c24:	8b e2       	ldi	r24, 0x2B	; 43
    3c26:	e6 e5       	ldi	r30, 0x56	; 86
    3c28:	f1 e0       	ldi	r31, 0x01	; 1
    3c2a:	df 01       	movw	r26, r30
    3c2c:	1d 92       	st	X+, r1
    3c2e:	8a 95       	dec	r24
    3c30:	e9 f7       	brne	.-6      	; 0x3c2c <st_reset+0xc>
  memset(&st, 0, sizeof(st));
    3c32:	83 e2       	ldi	r24, 0x23	; 35
    3c34:	eb e8       	ldi	r30, 0x8B	; 139
    3c36:	f1 e0       	ldi	r31, 0x01	; 1
    3c38:	df 01       	movw	r26, r30
    3c3a:	1d 92       	st	X+, r1
    3c3c:	8a 95       	dec	r24
    3c3e:	e9 f7       	brne	.-6      	; 0x3c3a <st_reset+0x1a>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    3c40:	10 92 84 01 	sts	0x0184, r1
    3c44:	10 92 83 01 	sts	0x0183, r1
  segment_buffer_tail = 0;
    3c48:	10 92 8a 01 	sts	0x018A, r1
  segment_buffer_head = 0; // empty = tail
    3c4c:	10 92 89 01 	sts	0x0189, r1
  segment_next_head = 1;
    3c50:	81 e0       	ldi	r24, 0x01	; 1
    3c52:	80 93 88 01 	sts	0x0188, r24
  busy = false;
    3c56:	10 92 85 01 	sts	0x0185, r1
  
  st_generate_step_dir_invert_masks();
    3c5a:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <st_generate_step_dir_invert_masks>
      
  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    3c5e:	8b b1       	in	r24, 0x0b	; 11
    3c60:	8b 7a       	andi	r24, 0xAB	; 171
    3c62:	90 91 87 01 	lds	r25, 0x0187
    3c66:	89 2b       	or	r24, r25
    3c68:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    3c6a:	8b b1       	in	r24, 0x0b	; 11
    3c6c:	87 75       	andi	r24, 0x57	; 87
    3c6e:	90 91 86 01 	lds	r25, 0x0186
    3c72:	89 2b       	or	r24, r25
    3c74:	8b b9       	out	0x0b, r24	; 11
    3c76:	08 95       	ret

00003c78 <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    3c78:	8a b1       	in	r24, 0x0a	; 10
    3c7a:	84 65       	ori	r24, 0x54	; 84
    3c7c:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    3c7e:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    3c80:	8a b1       	in	r24, 0x0a	; 10
    3c82:	88 6a       	ori	r24, 0xA8	; 168
    3c84:	8a b9       	out	0x0a, r24	; 10

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    3c86:	e1 e8       	ldi	r30, 0x81	; 129
    3c88:	f0 e0       	ldi	r31, 0x00	; 0
    3c8a:	80 81       	ld	r24, Z
    3c8c:	8f 7e       	andi	r24, 0xEF	; 239
    3c8e:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    3c90:	80 81       	ld	r24, Z
    3c92:	88 60       	ori	r24, 0x08	; 8
    3c94:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10)); 
    3c96:	e0 e8       	ldi	r30, 0x80	; 128
    3c98:	f0 e0       	ldi	r31, 0x00	; 0
    3c9a:	80 81       	ld	r24, Z
    3c9c:	8c 7f       	andi	r24, 0xFC	; 252
    3c9e:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    3ca0:	80 81       	ld	r24, Z
    3ca2:	8f 70       	andi	r24, 0x0F	; 15
    3ca4:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().
  
  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    3ca6:	ee e6       	ldi	r30, 0x6E	; 110
    3ca8:	f0 e0       	ldi	r31, 0x00	; 0
    3caa:	80 81       	ld	r24, Z
    3cac:	88 7f       	andi	r24, 0xF8	; 248
    3cae:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    3cb0:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    3cb2:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    3cb4:	80 81       	ld	r24, Z
    3cb6:	81 60       	ori	r24, 0x01	; 1
    3cb8:	80 83       	st	Z, r24
    3cba:	08 95       	ret

00003cbc <st_update_plan_block_parameters>:
}
  

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{ 
    3cbc:	cf 93       	push	r28
    3cbe:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    3cc0:	c0 91 83 01 	lds	r28, 0x0183
    3cc4:	d0 91 84 01 	lds	r29, 0x0184
    3cc8:	20 97       	sbiw	r28, 0x00	; 0
    3cca:	b9 f0       	breq	.+46     	; 0x3cfa <st_update_plan_block_parameters+0x3e>
    prep.flag_partial_block = true;
    3ccc:	81 e0       	ldi	r24, 0x01	; 1
    3cce:	80 93 57 01 	sts	0x0157, r24
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    3cd2:	60 91 6d 01 	lds	r22, 0x016D
    3cd6:	70 91 6e 01 	lds	r23, 0x016E
    3cda:	80 91 6f 01 	lds	r24, 0x016F
    3cde:	90 91 70 01 	lds	r25, 0x0170
    3ce2:	9b 01       	movw	r18, r22
    3ce4:	ac 01       	movw	r20, r24
    3ce6:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    3cea:	69 8b       	std	Y+17, r22	; 0x11
    3cec:	7a 8b       	std	Y+18, r23	; 0x12
    3cee:	8b 8b       	std	Y+19, r24	; 0x13
    3cf0:	9c 8b       	std	Y+20, r25	; 0x14
    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.
    3cf2:	10 92 84 01 	sts	0x0184, r1
    3cf6:	10 92 83 01 	sts	0x0183, r1
  }
}
    3cfa:	df 91       	pop	r29
    3cfc:	cf 91       	pop	r28
    3cfe:	08 95       	ret

00003d00 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it. 
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    3d00:	2f 92       	push	r2
    3d02:	3f 92       	push	r3
    3d04:	4f 92       	push	r4
    3d06:	5f 92       	push	r5
    3d08:	6f 92       	push	r6
    3d0a:	7f 92       	push	r7
    3d0c:	8f 92       	push	r8
    3d0e:	9f 92       	push	r9
    3d10:	af 92       	push	r10
    3d12:	bf 92       	push	r11
    3d14:	cf 92       	push	r12
    3d16:	df 92       	push	r13
    3d18:	ef 92       	push	r14
    3d1a:	ff 92       	push	r15
    3d1c:	0f 93       	push	r16
    3d1e:	1f 93       	push	r17
    3d20:	cf 93       	push	r28
    3d22:	df 93       	push	r29
    3d24:	cd b7       	in	r28, 0x3d	; 61
    3d26:	de b7       	in	r29, 0x3e	; 62
    3d28:	e6 97       	sbiw	r28, 0x36	; 54
    3d2a:	0f b6       	in	r0, 0x3f	; 63
    3d2c:	f8 94       	cli
    3d2e:	de bf       	out	0x3e, r29	; 62
    3d30:	0f be       	out	0x3f, r0	; 63
    3d32:	cd bf       	out	0x3d, r28	; 61

  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    3d34:	80 91 68 07 	lds	r24, 0x0768
    3d38:	80 77       	andi	r24, 0x70	; 112
    3d3a:	09 f4       	brne	.+2      	; 0x3d3e <st_prep_buffer+0x3e>
    3d3c:	6e c6       	rjmp	.+3292   	; 0x4a1a <st_prep_buffer+0xd1a>
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
    3d3e:	20 e0       	ldi	r18, 0x00	; 0
    3d40:	30 e0       	ldi	r19, 0x00	; 0
    3d42:	a9 01       	movw	r20, r18
    3d44:	60 91 6d 01 	lds	r22, 0x016D
    3d48:	70 91 6e 01 	lds	r23, 0x016E
    3d4c:	80 91 6f 01 	lds	r24, 0x016F
    3d50:	90 91 70 01 	lds	r25, 0x0170
    3d54:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    3d58:	81 11       	cpse	r24, r1
    3d5a:	5f c6       	rjmp	.+3262   	; 0x4a1a <st_prep_buffer+0xd1a>
    3d5c:	64 c6       	rjmp	.+3272   	; 0x4a26 <st_prep_buffer+0xd26>
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block has been replanned. 
    if (pl_block == NULL) {
    3d5e:	80 91 83 01 	lds	r24, 0x0183
    3d62:	90 91 84 01 	lds	r25, 0x0184
    3d66:	89 2b       	or	r24, r25
    3d68:	09 f0       	breq	.+2      	; 0x3d6c <st_prep_buffer+0x6c>
    3d6a:	6c c2       	rjmp	.+1240   	; 0x4244 <st_prep_buffer+0x544>
      pl_block = plan_get_current_block(); // Query planner for a queued block
    3d6c:	0e 94 7a 2a 	call	0x54f4	; 0x54f4 <plan_get_current_block>
    3d70:	8c 01       	movw	r16, r24
    3d72:	90 93 84 01 	sts	0x0184, r25
    3d76:	80 93 83 01 	sts	0x0183, r24
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    3d7a:	00 97       	sbiw	r24, 0x00	; 0
    3d7c:	09 f4       	brne	.+2      	; 0x3d80 <st_prep_buffer+0x80>
    3d7e:	53 c6       	rjmp	.+3238   	; 0x4a26 <st_prep_buffer+0xd26>
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    3d80:	a7 e5       	ldi	r26, 0x57	; 87
    3d82:	b1 e0       	ldi	r27, 0x01	; 1
    3d84:	8c 91       	ld	r24, X
    3d86:	88 23       	and	r24, r24
    3d88:	11 f0       	breq	.+4      	; 0x3d8e <st_prep_buffer+0x8e>
        prep.flag_partial_block = false; // Reset flag
    3d8a:	1c 92       	st	X, r1
    3d8c:	dc c0       	rjmp	.+440    	; 0x3f46 <st_prep_buffer+0x246>
      } else {
        // Increment stepper common data index to store new planner block data. 
        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
    3d8e:	e6 e5       	ldi	r30, 0x56	; 86
    3d90:	f1 e0       	ldi	r31, 0x01	; 1
    3d92:	80 81       	ld	r24, Z
    3d94:	8f 5f       	subi	r24, 0xFF	; 255
    3d96:	85 30       	cpi	r24, 0x05	; 5
    3d98:	11 f0       	breq	.+4      	; 0x3d9e <st_prep_buffer+0x9e>
    3d9a:	80 83       	st	Z, r24
    3d9c:	03 c0       	rjmp	.+6      	; 0x3da4 <st_prep_buffer+0xa4>
    3d9e:	a6 e5       	ldi	r26, 0x56	; 86
    3da0:	b1 e0       	ldi	r27, 0x01	; 1
    3da2:	1c 92       	st	X, r1
        
        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the 
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. 
        st_prep_block = &st_block_buffer[prep.st_block_index];
    3da4:	a6 e5       	ldi	r26, 0x56	; 86
    3da6:	b1 e0       	ldi	r27, 0x01	; 1
    3da8:	ec 91       	ld	r30, X
    3daa:	b1 e1       	ldi	r27, 0x11	; 17
    3dac:	eb 9f       	mul	r30, r27
    3dae:	f0 01       	movw	r30, r0
    3db0:	11 24       	eor	r1, r1
    3db2:	ee 52       	subi	r30, 0x2E	; 46
    3db4:	fe 4f       	sbci	r31, 0xFE	; 254
    3db6:	f0 93 82 01 	sts	0x0182, r31
    3dba:	e0 93 81 01 	sts	0x0181, r30
        st_prep_block->direction_bits = pl_block->direction_bits;
    3dbe:	d8 01       	movw	r26, r16
    3dc0:	8c 91       	ld	r24, X
    3dc2:	80 83       	st	Z, r24
          st_prep_block->step_event_count = pl_block->step_event_count;
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS 
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS] << MAX_AMASS_LEVEL;
    3dc4:	11 96       	adiw	r26, 0x01	; 1
    3dc6:	4d 91       	ld	r20, X+
    3dc8:	5d 91       	ld	r21, X+
    3dca:	6d 91       	ld	r22, X+
    3dcc:	7c 91       	ld	r23, X
    3dce:	14 97       	sbiw	r26, 0x04	; 4
    3dd0:	db 01       	movw	r26, r22
    3dd2:	ca 01       	movw	r24, r20
    3dd4:	88 0f       	add	r24, r24
    3dd6:	99 1f       	adc	r25, r25
    3dd8:	aa 1f       	adc	r26, r26
    3dda:	bb 1f       	adc	r27, r27
    3ddc:	88 0f       	add	r24, r24
    3dde:	99 1f       	adc	r25, r25
    3de0:	aa 1f       	adc	r26, r26
    3de2:	bb 1f       	adc	r27, r27
    3de4:	88 0f       	add	r24, r24
    3de6:	99 1f       	adc	r25, r25
    3de8:	aa 1f       	adc	r26, r26
    3dea:	bb 1f       	adc	r27, r27
    3dec:	81 83       	std	Z+1, r24	; 0x01
    3dee:	92 83       	std	Z+2, r25	; 0x02
    3df0:	a3 83       	std	Z+3, r26	; 0x03
    3df2:	b4 83       	std	Z+4, r27	; 0x04
          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS] << MAX_AMASS_LEVEL;
    3df4:	d8 01       	movw	r26, r16
    3df6:	15 96       	adiw	r26, 0x05	; 5
    3df8:	4d 91       	ld	r20, X+
    3dfa:	5d 91       	ld	r21, X+
    3dfc:	6d 91       	ld	r22, X+
    3dfe:	7c 91       	ld	r23, X
    3e00:	18 97       	sbiw	r26, 0x08	; 8
    3e02:	db 01       	movw	r26, r22
    3e04:	ca 01       	movw	r24, r20
    3e06:	88 0f       	add	r24, r24
    3e08:	99 1f       	adc	r25, r25
    3e0a:	aa 1f       	adc	r26, r26
    3e0c:	bb 1f       	adc	r27, r27
    3e0e:	88 0f       	add	r24, r24
    3e10:	99 1f       	adc	r25, r25
    3e12:	aa 1f       	adc	r26, r26
    3e14:	bb 1f       	adc	r27, r27
    3e16:	88 0f       	add	r24, r24
    3e18:	99 1f       	adc	r25, r25
    3e1a:	aa 1f       	adc	r26, r26
    3e1c:	bb 1f       	adc	r27, r27
    3e1e:	85 83       	std	Z+5, r24	; 0x05
    3e20:	96 83       	std	Z+6, r25	; 0x06
    3e22:	a7 83       	std	Z+7, r26	; 0x07
    3e24:	b0 87       	std	Z+8, r27	; 0x08
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;
    3e26:	d8 01       	movw	r26, r16
    3e28:	19 96       	adiw	r26, 0x09	; 9
    3e2a:	4d 91       	ld	r20, X+
    3e2c:	5d 91       	ld	r21, X+
    3e2e:	6d 91       	ld	r22, X+
    3e30:	7c 91       	ld	r23, X
    3e32:	1c 97       	sbiw	r26, 0x0c	; 12
    3e34:	db 01       	movw	r26, r22
    3e36:	ca 01       	movw	r24, r20
    3e38:	88 0f       	add	r24, r24
    3e3a:	99 1f       	adc	r25, r25
    3e3c:	aa 1f       	adc	r26, r26
    3e3e:	bb 1f       	adc	r27, r27
    3e40:	88 0f       	add	r24, r24
    3e42:	99 1f       	adc	r25, r25
    3e44:	aa 1f       	adc	r26, r26
    3e46:	bb 1f       	adc	r27, r27
    3e48:	88 0f       	add	r24, r24
    3e4a:	99 1f       	adc	r25, r25
    3e4c:	aa 1f       	adc	r26, r26
    3e4e:	bb 1f       	adc	r27, r27
    3e50:	81 87       	std	Z+9, r24	; 0x09
    3e52:	92 87       	std	Z+10, r25	; 0x0a
    3e54:	a3 87       	std	Z+11, r26	; 0x0b
    3e56:	b4 87       	std	Z+12, r27	; 0x0c
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    3e58:	d8 01       	movw	r26, r16
    3e5a:	1d 96       	adiw	r26, 0x0d	; 13
    3e5c:	4d 91       	ld	r20, X+
    3e5e:	5d 91       	ld	r21, X+
    3e60:	6d 91       	ld	r22, X+
    3e62:	7c 91       	ld	r23, X
    3e64:	50 97       	sbiw	r26, 0x10	; 16
    3e66:	44 0f       	add	r20, r20
    3e68:	55 1f       	adc	r21, r21
    3e6a:	66 1f       	adc	r22, r22
    3e6c:	77 1f       	adc	r23, r23
    3e6e:	44 0f       	add	r20, r20
    3e70:	55 1f       	adc	r21, r21
    3e72:	66 1f       	adc	r22, r22
    3e74:	77 1f       	adc	r23, r23
    3e76:	44 0f       	add	r20, r20
    3e78:	55 1f       	adc	r21, r21
    3e7a:	66 1f       	adc	r22, r22
    3e7c:	77 1f       	adc	r23, r23
    3e7e:	45 87       	std	Z+13, r20	; 0x0d
    3e80:	56 87       	std	Z+14, r21	; 0x0e
    3e82:	67 87       	std	Z+15, r22	; 0x0f
    3e84:	70 8b       	std	Z+16, r23	; 0x10
        #endif
        
        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = pl_block->step_event_count;
    3e86:	1d 96       	adiw	r26, 0x0d	; 13
    3e88:	6d 91       	ld	r22, X+
    3e8a:	7d 91       	ld	r23, X+
    3e8c:	8d 91       	ld	r24, X+
    3e8e:	9c 91       	ld	r25, X
    3e90:	50 97       	sbiw	r26, 0x10	; 16
    3e92:	0e 94 4d 3d 	call	0x7a9a	; 0x7a9a <__floatunsisf>
    3e96:	e8 e5       	ldi	r30, 0x58	; 88
    3e98:	f1 e0       	ldi	r31, 0x01	; 1
    3e9a:	60 83       	st	Z, r22
    3e9c:	71 83       	std	Z+1, r23	; 0x01
    3e9e:	82 83       	std	Z+2, r24	; 0x02
    3ea0:	93 83       	std	Z+3, r25	; 0x03
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    3ea2:	d8 01       	movw	r26, r16
    3ea4:	95 96       	adiw	r26, 0x25	; 37
    3ea6:	2d 91       	ld	r18, X+
    3ea8:	3d 91       	ld	r19, X+
    3eaa:	4d 91       	ld	r20, X+
    3eac:	5c 91       	ld	r21, X
    3eae:	98 97       	sbiw	r26, 0x28	; 40
    3eb0:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    3eb4:	9b 01       	movw	r18, r22
    3eb6:	ac 01       	movw	r20, r24
    3eb8:	ec e5       	ldi	r30, 0x5C	; 92
    3eba:	f1 e0       	ldi	r31, 0x01	; 1
    3ebc:	60 83       	st	Z, r22
    3ebe:	71 83       	std	Z+1, r23	; 0x01
    3ec0:	82 83       	std	Z+2, r24	; 0x02
    3ec2:	93 83       	std	Z+3, r25	; 0x03
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    3ec4:	60 e0       	ldi	r22, 0x00	; 0
    3ec6:	70 e0       	ldi	r23, 0x00	; 0
    3ec8:	80 ea       	ldi	r24, 0xA0	; 160
    3eca:	9f e3       	ldi	r25, 0x3F	; 63
    3ecc:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    3ed0:	60 93 60 01 	sts	0x0160, r22
    3ed4:	70 93 61 01 	sts	0x0161, r23
    3ed8:	80 93 62 01 	sts	0x0162, r24
    3edc:	90 93 63 01 	sts	0x0163, r25
        
        prep.dt_remainder = 0.0; // Reset for new planner block
    3ee0:	10 92 64 01 	sts	0x0164, r1
    3ee4:	10 92 65 01 	sts	0x0165, r1
    3ee8:	10 92 66 01 	sts	0x0166, r1
    3eec:	10 92 67 01 	sts	0x0167, r1

        if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    3ef0:	a8 e6       	ldi	r26, 0x68	; 104
    3ef2:	b7 e0       	ldi	r27, 0x07	; 7
    3ef4:	8c 91       	ld	r24, X
    3ef6:	80 77       	andi	r24, 0x70	; 112
    3ef8:	b9 f0       	breq	.+46     	; 0x3f28 <st_prep_buffer+0x228>
          // Override planner block entry speed and enforce deceleration during feed hold.
          prep.current_speed = prep.exit_speed; 
    3efa:	e5 e7       	ldi	r30, 0x75	; 117
    3efc:	f1 e0       	ldi	r31, 0x01	; 1
    3efe:	60 81       	ld	r22, Z
    3f00:	71 81       	ldd	r23, Z+1	; 0x01
    3f02:	82 81       	ldd	r24, Z+2	; 0x02
    3f04:	93 81       	ldd	r25, Z+3	; 0x03
    3f06:	ad e6       	ldi	r26, 0x6D	; 109
    3f08:	b1 e0       	ldi	r27, 0x01	; 1
    3f0a:	6d 93       	st	X+, r22
    3f0c:	7d 93       	st	X+, r23
    3f0e:	8d 93       	st	X+, r24
    3f10:	9c 93       	st	X, r25
    3f12:	13 97       	sbiw	r26, 0x03	; 3
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; 
    3f14:	9b 01       	movw	r18, r22
    3f16:	ac 01       	movw	r20, r24
    3f18:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    3f1c:	f8 01       	movw	r30, r16
    3f1e:	61 8b       	std	Z+17, r22	; 0x11
    3f20:	72 8b       	std	Z+18, r23	; 0x12
    3f22:	83 8b       	std	Z+19, r24	; 0x13
    3f24:	94 8b       	std	Z+20, r25	; 0x14
    3f26:	0f c0       	rjmp	.+30     	; 0x3f46 <st_prep_buffer+0x246>
        }
        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }
    3f28:	d8 01       	movw	r26, r16
    3f2a:	51 96       	adiw	r26, 0x11	; 17
    3f2c:	6d 91       	ld	r22, X+
    3f2e:	7d 91       	ld	r23, X+
    3f30:	8d 91       	ld	r24, X+
    3f32:	9c 91       	ld	r25, X
    3f34:	54 97       	sbiw	r26, 0x14	; 20
    3f36:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    3f3a:	ed e6       	ldi	r30, 0x6D	; 109
    3f3c:	f1 e0       	ldi	r31, 0x01	; 1
    3f3e:	60 83       	st	Z, r22
    3f40:	71 83       	std	Z+1, r23	; 0x01
    3f42:	82 83       	std	Z+2, r24	; 0x02
    3f44:	93 83       	std	Z+3, r25	; 0x03
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
      */
      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    3f46:	a9 e6       	ldi	r26, 0x69	; 105
    3f48:	b1 e0       	ldi	r27, 0x01	; 1
    3f4a:	1d 92       	st	X+, r1
    3f4c:	1d 92       	st	X+, r1
    3f4e:	1d 92       	st	X+, r1
    3f50:	1c 92       	st	X, r1
    3f52:	13 97       	sbiw	r26, 0x03	; 3
      float inv_2_accel = 0.5/pl_block->acceleration;
    3f54:	00 91 83 01 	lds	r16, 0x0183
    3f58:	10 91 84 01 	lds	r17, 0x0184
    3f5c:	f8 01       	movw	r30, r16
    3f5e:	81 a0       	ldd	r8, Z+33	; 0x21
    3f60:	92 a0       	ldd	r9, Z+34	; 0x22
    3f62:	a3 a0       	ldd	r10, Z+35	; 0x23
    3f64:	b4 a0       	ldd	r11, Z+36	; 0x24
    3f66:	a5 01       	movw	r20, r10
    3f68:	94 01       	movw	r18, r8
    3f6a:	60 e0       	ldi	r22, 0x00	; 0
    3f6c:	70 e0       	ldi	r23, 0x00	; 0
    3f6e:	80 e0       	ldi	r24, 0x00	; 0
    3f70:	9f e3       	ldi	r25, 0x3F	; 63
    3f72:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    3f76:	6b 01       	movw	r12, r22
    3f78:	7c 01       	movw	r14, r24
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { // [Forced Deceleration to Zero Velocity]
    3f7a:	a8 e6       	ldi	r26, 0x68	; 104
    3f7c:	b7 e0       	ldi	r27, 0x07	; 7
    3f7e:	8c 91       	ld	r24, X
    3f80:	80 77       	andi	r24, 0x70	; 112
    3f82:	09 f4       	brne	.+2      	; 0x3f86 <st_prep_buffer+0x286>
    3f84:	57 c0       	rjmp	.+174    	; 0x4034 <st_prep_buffer+0x334>
        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
        // the planner block profile, enforcing a deceleration to zero speed.
        prep.ramp_type = RAMP_DECEL;
    3f86:	82 e0       	ldi	r24, 0x02	; 2
    3f88:	e8 e6       	ldi	r30, 0x68	; 104
    3f8a:	f1 e0       	ldi	r31, 0x01	; 1
    3f8c:	80 83       	st	Z, r24
        // Compute decelerate distance relative to end of block.
        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    3f8e:	d8 01       	movw	r26, r16
    3f90:	95 96       	adiw	r26, 0x25	; 37
    3f92:	4d 90       	ld	r4, X+
    3f94:	5d 90       	ld	r5, X+
    3f96:	6d 90       	ld	r6, X+
    3f98:	7c 90       	ld	r7, X
    3f9a:	98 97       	sbiw	r26, 0x28	; 40
    3f9c:	51 96       	adiw	r26, 0x11	; 17
    3f9e:	2d 91       	ld	r18, X+
    3fa0:	3d 91       	ld	r19, X+
    3fa2:	4d 91       	ld	r20, X+
    3fa4:	5c 91       	ld	r21, X
    3fa6:	54 97       	sbiw	r26, 0x14	; 20
    3fa8:	29 83       	std	Y+1, r18	; 0x01
    3faa:	3a 83       	std	Y+2, r19	; 0x02
    3fac:	4b 83       	std	Y+3, r20	; 0x03
    3fae:	5c 83       	std	Y+4, r21	; 0x04
    3fb0:	a7 01       	movw	r20, r14
    3fb2:	96 01       	movw	r18, r12
    3fb4:	69 81       	ldd	r22, Y+1	; 0x01
    3fb6:	7a 81       	ldd	r23, Y+2	; 0x02
    3fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fba:	9c 81       	ldd	r25, Y+4	; 0x04
    3fbc:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    3fc0:	9b 01       	movw	r18, r22
    3fc2:	ac 01       	movw	r20, r24
    3fc4:	c3 01       	movw	r24, r6
    3fc6:	b2 01       	movw	r22, r4
    3fc8:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    3fcc:	6b 01       	movw	r12, r22
    3fce:	7c 01       	movw	r14, r24
        if (decel_dist < 0.0) {
    3fd0:	20 e0       	ldi	r18, 0x00	; 0
    3fd2:	30 e0       	ldi	r19, 0x00	; 0
    3fd4:	a9 01       	movw	r20, r18
    3fd6:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    3fda:	88 23       	and	r24, r24
    3fdc:	ec f4       	brge	.+58     	; 0x4018 <st_prep_buffer+0x318>
          // Deceleration through entire planner block. End of feed hold is not in this block.
          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3fde:	a5 01       	movw	r20, r10
    3fe0:	94 01       	movw	r18, r8
    3fe2:	c5 01       	movw	r24, r10
    3fe4:	b4 01       	movw	r22, r8
    3fe6:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    3fea:	9b 01       	movw	r18, r22
    3fec:	ac 01       	movw	r20, r24
    3fee:	c3 01       	movw	r24, r6
    3ff0:	b2 01       	movw	r22, r4
    3ff2:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    3ff6:	9b 01       	movw	r18, r22
    3ff8:	ac 01       	movw	r20, r24
    3ffa:	69 81       	ldd	r22, Y+1	; 0x01
    3ffc:	7a 81       	ldd	r23, Y+2	; 0x02
    3ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    4000:	9c 81       	ldd	r25, Y+4	; 0x04
    4002:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    4006:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    400a:	e5 e7       	ldi	r30, 0x75	; 117
    400c:	f1 e0       	ldi	r31, 0x01	; 1
    400e:	60 83       	st	Z, r22
    4010:	71 83       	std	Z+1, r23	; 0x01
    4012:	82 83       	std	Z+2, r24	; 0x02
    4014:	93 83       	std	Z+3, r25	; 0x03
    4016:	16 c1       	rjmp	.+556    	; 0x4244 <st_prep_buffer+0x544>
        } else {
          prep.mm_complete = decel_dist; // End of feed hold.
    4018:	a9 e6       	ldi	r26, 0x69	; 105
    401a:	b1 e0       	ldi	r27, 0x01	; 1
    401c:	cd 92       	st	X+, r12
    401e:	dd 92       	st	X+, r13
    4020:	ed 92       	st	X+, r14
    4022:	fc 92       	st	X, r15
    4024:	13 97       	sbiw	r26, 0x03	; 3
          prep.exit_speed = 0.0;
    4026:	e5 e7       	ldi	r30, 0x75	; 117
    4028:	f1 e0       	ldi	r31, 0x01	; 1
    402a:	10 82       	st	Z, r1
    402c:	11 82       	std	Z+1, r1	; 0x01
    402e:	12 82       	std	Z+2, r1	; 0x02
    4030:	13 82       	std	Z+3, r1	; 0x03
    4032:	08 c1       	rjmp	.+528    	; 0x4244 <st_prep_buffer+0x544>
        }
      } else { // [Normal Operation]
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    4034:	a8 e6       	ldi	r26, 0x68	; 104
    4036:	b1 e0       	ldi	r27, 0x01	; 1
    4038:	1c 92       	st	X, r1
        prep.accelerate_until = pl_block->millimeters; 
    403a:	f8 01       	movw	r30, r16
    403c:	85 a1       	ldd	r24, Z+37	; 0x25
    403e:	96 a1       	ldd	r25, Z+38	; 0x26
    4040:	a7 a1       	ldd	r26, Z+39	; 0x27
    4042:	b0 a5       	ldd	r27, Z+40	; 0x28
    4044:	e9 e7       	ldi	r30, 0x79	; 121
    4046:	f1 e0       	ldi	r31, 0x01	; 1
    4048:	80 83       	st	Z, r24
    404a:	91 83       	std	Z+1, r25	; 0x01
    404c:	a2 83       	std	Z+2, r26	; 0x02
    404e:	b3 83       	std	Z+3, r27	; 0x03
        prep.exit_speed = plan_get_exec_block_exit_speed();   
    4050:	0e 94 8a 2a 	call	0x5514	; 0x5514 <plan_get_exec_block_exit_speed>
    4054:	2b 01       	movw	r4, r22
    4056:	3c 01       	movw	r6, r24
    4058:	a5 e7       	ldi	r26, 0x75	; 117
    405a:	b1 e0       	ldi	r27, 0x01	; 1
    405c:	6d 93       	st	X+, r22
    405e:	7d 93       	st	X+, r23
    4060:	8d 93       	st	X+, r24
    4062:	9c 93       	st	X, r25
    4064:	13 97       	sbiw	r26, 0x03	; 3
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
    4066:	9b 01       	movw	r18, r22
    4068:	ac 01       	movw	r20, r24
    406a:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    406e:	69 83       	std	Y+1, r22	; 0x01
    4070:	7a 83       	std	Y+2, r23	; 0x02
    4072:	8b 83       	std	Y+3, r24	; 0x03
    4074:	9c 83       	std	Y+4, r25	; 0x04
        float intersect_distance =
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    4076:	00 91 83 01 	lds	r16, 0x0183
    407a:	10 91 84 01 	lds	r17, 0x0184
    407e:	d8 01       	movw	r26, r16
    4080:	95 96       	adiw	r26, 0x25	; 37
    4082:	2d 91       	ld	r18, X+
    4084:	3d 91       	ld	r19, X+
    4086:	4d 91       	ld	r20, X+
    4088:	5c 91       	ld	r21, X
    408a:	98 97       	sbiw	r26, 0x28	; 40
    408c:	2d 83       	std	Y+5, r18	; 0x05
    408e:	3e 83       	std	Y+6, r19	; 0x06
    4090:	4f 83       	std	Y+7, r20	; 0x07
    4092:	58 87       	std	Y+8, r21	; 0x08
    4094:	9b 01       	movw	r18, r22
    4096:	ac 01       	movw	r20, r24
    4098:	51 96       	adiw	r26, 0x11	; 17
    409a:	6d 91       	ld	r22, X+
    409c:	7d 91       	ld	r23, X+
    409e:	8d 91       	ld	r24, X+
    40a0:	9c 91       	ld	r25, X
    40a2:	54 97       	sbiw	r26, 0x14	; 20
    40a4:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    40a8:	a7 01       	movw	r20, r14
    40aa:	96 01       	movw	r18, r12
    40ac:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    40b0:	9b 01       	movw	r18, r22
    40b2:	ac 01       	movw	r20, r24
    40b4:	6d 81       	ldd	r22, Y+5	; 0x05
    40b6:	7e 81       	ldd	r23, Y+6	; 0x06
    40b8:	8f 81       	ldd	r24, Y+7	; 0x07
    40ba:	98 85       	ldd	r25, Y+8	; 0x08
    40bc:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
        prep.accelerate_until = pl_block->millimeters; 
        prep.exit_speed = plan_get_exec_block_exit_speed();   
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
        float intersect_distance =
    40c0:	20 e0       	ldi	r18, 0x00	; 0
    40c2:	30 e0       	ldi	r19, 0x00	; 0
    40c4:	40 e0       	ldi	r20, 0x00	; 0
    40c6:	5f e3       	ldi	r21, 0x3F	; 63
    40c8:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    40cc:	4b 01       	movw	r8, r22
    40ce:	5c 01       	movw	r10, r24
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
        if (intersect_distance > 0.0) {
    40d0:	20 e0       	ldi	r18, 0x00	; 0
    40d2:	30 e0       	ldi	r19, 0x00	; 0
    40d4:	a9 01       	movw	r20, r18
    40d6:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    40da:	18 16       	cp	r1, r24
    40dc:	0c f0       	brlt	.+2      	; 0x40e0 <st_prep_buffer+0x3e0>
    40de:	a5 c0       	rjmp	.+330    	; 0x422a <st_prep_buffer+0x52a>
          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    40e0:	a5 01       	movw	r20, r10
    40e2:	94 01       	movw	r18, r8
    40e4:	6d 81       	ldd	r22, Y+5	; 0x05
    40e6:	7e 81       	ldd	r23, Y+6	; 0x06
    40e8:	8f 81       	ldd	r24, Y+7	; 0x07
    40ea:	98 85       	ldd	r25, Y+8	; 0x08
    40ec:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    40f0:	18 16       	cp	r1, r24
    40f2:	0c f0       	brlt	.+2      	; 0x40f6 <st_prep_buffer+0x3f6>
    40f4:	89 c0       	rjmp	.+274    	; 0x4208 <st_prep_buffer+0x508>
            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);
    40f6:	29 81       	ldd	r18, Y+1	; 0x01
    40f8:	3a 81       	ldd	r19, Y+2	; 0x02
    40fa:	4b 81       	ldd	r20, Y+3	; 0x03
    40fc:	5c 81       	ldd	r21, Y+4	; 0x04
    40fe:	f8 01       	movw	r30, r16
    4100:	65 8d       	ldd	r22, Z+29	; 0x1d
    4102:	76 8d       	ldd	r23, Z+30	; 0x1e
    4104:	87 8d       	ldd	r24, Z+31	; 0x1f
    4106:	90 a1       	ldd	r25, Z+32	; 0x20
    4108:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    410c:	a7 01       	movw	r20, r14
    410e:	96 01       	movw	r18, r12
    4110:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    4114:	9b 01       	movw	r18, r22
    4116:	ac 01       	movw	r20, r24
    4118:	ad e7       	ldi	r26, 0x7D	; 125
    411a:	b1 e0       	ldi	r27, 0x01	; 1
    411c:	6d 93       	st	X+, r22
    411e:	7d 93       	st	X+, r23
    4120:	8d 93       	st	X+, r24
    4122:	9c 93       	st	X, r25
    4124:	13 97       	sbiw	r26, 0x03	; 3
            if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    4126:	c5 01       	movw	r24, r10
    4128:	b4 01       	movw	r22, r8
    412a:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    412e:	18 16       	cp	r1, r24
    4130:	0c f0       	brlt	.+2      	; 0x4134 <st_prep_buffer+0x434>
    4132:	40 c0       	rjmp	.+128    	; 0x41b4 <st_prep_buffer+0x4b4>
              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);
    4134:	f8 01       	movw	r30, r16
    4136:	65 8d       	ldd	r22, Z+29	; 0x1d
    4138:	76 8d       	ldd	r23, Z+30	; 0x1e
    413a:	87 8d       	ldd	r24, Z+31	; 0x1f
    413c:	90 a1       	ldd	r25, Z+32	; 0x20
    413e:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    4142:	a1 e7       	ldi	r26, 0x71	; 113
    4144:	b1 e0       	ldi	r27, 0x01	; 1
    4146:	6d 93       	st	X+, r22
    4148:	7d 93       	st	X+, r23
    414a:	8d 93       	st	X+, r24
    414c:	9c 93       	st	X, r25
    414e:	13 97       	sbiw	r26, 0x03	; 3
              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { 
    4150:	f8 01       	movw	r30, r16
    4152:	41 88       	ldd	r4, Z+17	; 0x11
    4154:	52 88       	ldd	r5, Z+18	; 0x12
    4156:	63 88       	ldd	r6, Z+19	; 0x13
    4158:	74 88       	ldd	r7, Z+20	; 0x14
    415a:	85 8c       	ldd	r8, Z+29	; 0x1d
    415c:	96 8c       	ldd	r9, Z+30	; 0x1e
    415e:	a7 8c       	ldd	r10, Z+31	; 0x1f
    4160:	b0 a0       	ldd	r11, Z+32	; 0x20
    4162:	a5 01       	movw	r20, r10
    4164:	94 01       	movw	r18, r8
    4166:	c3 01       	movw	r24, r6
    4168:	b2 01       	movw	r22, r4
    416a:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    416e:	81 11       	cpse	r24, r1
    4170:	05 c0       	rjmp	.+10     	; 0x417c <st_prep_buffer+0x47c>
                // Cruise-deceleration or cruise-only type.
                prep.ramp_type = RAMP_CRUISE;
    4172:	81 e0       	ldi	r24, 0x01	; 1
    4174:	a8 e6       	ldi	r26, 0x68	; 104
    4176:	b1 e0       	ldi	r27, 0x01	; 1
    4178:	8c 93       	st	X, r24
    417a:	64 c0       	rjmp	.+200    	; 0x4244 <st_prep_buffer+0x544>
              } else {
                // Full-trapezoid or acceleration-cruise types
                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); 
    417c:	a3 01       	movw	r20, r6
    417e:	92 01       	movw	r18, r4
    4180:	c5 01       	movw	r24, r10
    4182:	b4 01       	movw	r22, r8
    4184:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    4188:	a7 01       	movw	r20, r14
    418a:	96 01       	movw	r18, r12
    418c:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    4190:	9b 01       	movw	r18, r22
    4192:	ac 01       	movw	r20, r24
    4194:	e9 e7       	ldi	r30, 0x79	; 121
    4196:	f1 e0       	ldi	r31, 0x01	; 1
    4198:	60 81       	ld	r22, Z
    419a:	71 81       	ldd	r23, Z+1	; 0x01
    419c:	82 81       	ldd	r24, Z+2	; 0x02
    419e:	93 81       	ldd	r25, Z+3	; 0x03
    41a0:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    41a4:	a9 e7       	ldi	r26, 0x79	; 121
    41a6:	b1 e0       	ldi	r27, 0x01	; 1
    41a8:	6d 93       	st	X+, r22
    41aa:	7d 93       	st	X+, r23
    41ac:	8d 93       	st	X+, r24
    41ae:	9c 93       	st	X, r25
    41b0:	13 97       	sbiw	r26, 0x03	; 3
    41b2:	48 c0       	rjmp	.+144    	; 0x4244 <st_prep_buffer+0x544>
              }
            } else { // Triangle type
              prep.accelerate_until = intersect_distance;
    41b4:	e9 e7       	ldi	r30, 0x79	; 121
    41b6:	f1 e0       	ldi	r31, 0x01	; 1
    41b8:	80 82       	st	Z, r8
    41ba:	91 82       	std	Z+1, r9	; 0x01
    41bc:	a2 82       	std	Z+2, r10	; 0x02
    41be:	b3 82       	std	Z+3, r11	; 0x03
              prep.decelerate_after = intersect_distance;
    41c0:	ad e7       	ldi	r26, 0x7D	; 125
    41c2:	b1 e0       	ldi	r27, 0x01	; 1
    41c4:	8d 92       	st	X+, r8
    41c6:	9d 92       	st	X+, r9
    41c8:	ad 92       	st	X+, r10
    41ca:	bc 92       	st	X, r11
    41cc:	13 97       	sbiw	r26, 0x03	; 3
              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    41ce:	f8 01       	movw	r30, r16
    41d0:	61 a1       	ldd	r22, Z+33	; 0x21
    41d2:	72 a1       	ldd	r23, Z+34	; 0x22
    41d4:	83 a1       	ldd	r24, Z+35	; 0x23
    41d6:	94 a1       	ldd	r25, Z+36	; 0x24
    41d8:	9b 01       	movw	r18, r22
    41da:	ac 01       	movw	r20, r24
    41dc:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    41e0:	a5 01       	movw	r20, r10
    41e2:	94 01       	movw	r18, r8
    41e4:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    41e8:	29 81       	ldd	r18, Y+1	; 0x01
    41ea:	3a 81       	ldd	r19, Y+2	; 0x02
    41ec:	4b 81       	ldd	r20, Y+3	; 0x03
    41ee:	5c 81       	ldd	r21, Y+4	; 0x04
    41f0:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    41f4:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    41f8:	a1 e7       	ldi	r26, 0x71	; 113
    41fa:	b1 e0       	ldi	r27, 0x01	; 1
    41fc:	6d 93       	st	X+, r22
    41fe:	7d 93       	st	X+, r23
    4200:	8d 93       	st	X+, r24
    4202:	9c 93       	st	X, r25
    4204:	13 97       	sbiw	r26, 0x03	; 3
    4206:	1e c0       	rjmp	.+60     	; 0x4244 <st_prep_buffer+0x544>
            }          
          } else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    4208:	82 e0       	ldi	r24, 0x02	; 2
    420a:	e8 e6       	ldi	r30, 0x68	; 104
    420c:	f1 e0       	ldi	r31, 0x01	; 1
    420e:	80 83       	st	Z, r24
            // prep.decelerate_after = pl_block->millimeters;
            prep.maximum_speed = prep.current_speed;
    4210:	ed e6       	ldi	r30, 0x6D	; 109
    4212:	f1 e0       	ldi	r31, 0x01	; 1
    4214:	80 81       	ld	r24, Z
    4216:	91 81       	ldd	r25, Z+1	; 0x01
    4218:	a2 81       	ldd	r26, Z+2	; 0x02
    421a:	b3 81       	ldd	r27, Z+3	; 0x03
    421c:	e1 e7       	ldi	r30, 0x71	; 113
    421e:	f1 e0       	ldi	r31, 0x01	; 1
    4220:	80 83       	st	Z, r24
    4222:	91 83       	std	Z+1, r25	; 0x01
    4224:	a2 83       	std	Z+2, r26	; 0x02
    4226:	b3 83       	std	Z+3, r27	; 0x03
    4228:	0d c0       	rjmp	.+26     	; 0x4244 <st_prep_buffer+0x544>
          }
        } else { // Acceleration-only type
          prep.accelerate_until = 0.0;
    422a:	a9 e7       	ldi	r26, 0x79	; 121
    422c:	b1 e0       	ldi	r27, 0x01	; 1
    422e:	1d 92       	st	X+, r1
    4230:	1d 92       	st	X+, r1
    4232:	1d 92       	st	X+, r1
    4234:	1c 92       	st	X, r1
    4236:	13 97       	sbiw	r26, 0x03	; 3
          // prep.decelerate_after = 0.0;
          prep.maximum_speed = prep.exit_speed;
    4238:	e1 e7       	ldi	r30, 0x71	; 113
    423a:	f1 e0       	ldi	r31, 0x01	; 1
    423c:	40 82       	st	Z, r4
    423e:	51 82       	std	Z+1, r5	; 0x01
    4240:	62 82       	std	Z+2, r6	; 0x02
    4242:	73 82       	std	Z+3, r7	; 0x03
        }
      }  
    }

    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    4244:	80 91 89 01 	lds	r24, 0x0189
    4248:	90 e0       	ldi	r25, 0x00	; 0
    424a:	9c 01       	movw	r18, r24
    424c:	22 0f       	add	r18, r18
    424e:	33 1f       	adc	r19, r19
    4250:	82 0f       	add	r24, r18
    4252:	93 1f       	adc	r25, r19
    4254:	88 0f       	add	r24, r24
    4256:	99 1f       	adc	r25, r25
    4258:	9c 01       	movw	r18, r24
    425a:	22 55       	subi	r18, 0x52	; 82
    425c:	3e 4f       	sbci	r19, 0xFE	; 254
    425e:	3c a7       	std	Y+44, r19	; 0x2c
    4260:	2b a7       	std	Y+43, r18	; 0x2b

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    4262:	a6 e5       	ldi	r26, 0x56	; 86
    4264:	b1 e0       	ldi	r27, 0x01	; 1
    4266:	8c 91       	ld	r24, X
    4268:	f9 01       	movw	r30, r18
    426a:	82 83       	std	Z+2, r24	; 0x02
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable   
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    426c:	20 91 83 01 	lds	r18, 0x0183
    4270:	30 91 84 01 	lds	r19, 0x0184
    4274:	3e 8b       	std	Y+22, r19	; 0x16
    4276:	2d 8b       	std	Y+21, r18	; 0x15
    4278:	d9 01       	movw	r26, r18
    427a:	95 96       	adiw	r26, 0x25	; 37
    427c:	bc 91       	ld	r27, X
    427e:	bd a7       	std	Y+45, r27	; 0x2d
    4280:	f9 01       	movw	r30, r18
    4282:	f6 a1       	ldd	r31, Z+38	; 0x26
    4284:	fe a7       	std	Y+46, r31	; 0x2e
    4286:	d9 01       	movw	r26, r18
    4288:	97 96       	adiw	r26, 0x27	; 39
    428a:	bc 91       	ld	r27, X
    428c:	bf a7       	std	Y+47, r27	; 0x2f
    428e:	f9 01       	movw	r30, r18
    4290:	f0 a5       	ldd	r31, Z+40	; 0x28
    4292:	f8 ab       	std	Y+48, r31	; 0x30
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    4294:	20 91 60 01 	lds	r18, 0x0160
    4298:	30 91 61 01 	lds	r19, 0x0161
    429c:	40 91 62 01 	lds	r20, 0x0162
    42a0:	50 91 63 01 	lds	r21, 0x0163
    42a4:	6d a5       	ldd	r22, Y+45	; 0x2d
    42a6:	7e a5       	ldd	r23, Y+46	; 0x2e
    42a8:	8b 2f       	mov	r24, r27
    42aa:	9f 2f       	mov	r25, r31
    42ac:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    42b0:	6b a3       	std	Y+35, r22	; 0x23
    42b2:	7c a3       	std	Y+36, r23	; 0x24
    42b4:	8d a3       	std	Y+37, r24	; 0x25
    42b6:	9e a3       	std	Y+38, r25	; 0x26
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    42b8:	20 e0       	ldi	r18, 0x00	; 0
    42ba:	30 e0       	ldi	r19, 0x00	; 0
    42bc:	a9 01       	movw	r20, r18
    42be:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    42c2:	88 23       	and	r24, r24
    42c4:	24 f4       	brge	.+8      	; 0x42ce <st_prep_buffer+0x5ce>
    42c6:	1b a2       	std	Y+35, r1	; 0x23
    42c8:	1c a2       	std	Y+36, r1	; 0x24
    42ca:	1d a2       	std	Y+37, r1	; 0x25
    42cc:	1e a2       	std	Y+38, r1	; 0x26
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    42ce:	a9 e7       	ldi	r26, 0x79	; 121
    42d0:	b1 e0       	ldi	r27, 0x01	; 1
    42d2:	bc 91       	ld	r27, X
    42d4:	bf 8b       	std	Y+23, r27	; 0x17
    42d6:	e0 91 7a 01 	lds	r30, 0x017A
    42da:	e8 8f       	std	Y+24, r30	; 0x18
    42dc:	f0 91 7b 01 	lds	r31, 0x017B
    42e0:	f9 8f       	std	Y+25, r31	; 0x19
    42e2:	20 91 7c 01 	lds	r18, 0x017C
    42e6:	2a 8f       	std	Y+26, r18	; 0x1a
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    42e8:	a1 e7       	ldi	r26, 0x71	; 113
    42ea:	b1 e0       	ldi	r27, 0x01	; 1
    42ec:	bc 91       	ld	r27, X
    42ee:	bb 8f       	std	Y+27, r27	; 0x1b
    42f0:	e0 91 72 01 	lds	r30, 0x0172
    42f4:	ec 8f       	std	Y+28, r30	; 0x1c
    42f6:	f0 91 73 01 	lds	r31, 0x0173
    42fa:	fd 8f       	std	Y+29, r31	; 0x1d
    42fc:	20 91 74 01 	lds	r18, 0x0174
    4300:	2e 8f       	std	Y+30, r18	; 0x1e
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    4302:	ad e7       	ldi	r26, 0x7D	; 125
    4304:	b1 e0       	ldi	r27, 0x01	; 1
    4306:	bc 91       	ld	r27, X
    4308:	bf 8f       	std	Y+31, r27	; 0x1f
    430a:	e0 91 7e 01 	lds	r30, 0x017E
    430e:	e8 a3       	std	Y+32, r30	; 0x20
    4310:	f0 91 7f 01 	lds	r31, 0x017F
    4314:	f9 a3       	std	Y+33, r31	; 0x21
    4316:	20 91 80 01 	lds	r18, 0x0180
    431a:	2a a3       	std	Y+34, r18	; 0x22
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
    431c:	a9 e6       	ldi	r26, 0x69	; 105
    431e:	b1 e0       	ldi	r27, 0x01	; 1
    4320:	bc 91       	ld	r27, X
    4322:	b9 8b       	std	Y+17, r27	; 0x11
    4324:	e0 91 6a 01 	lds	r30, 0x016A
    4328:	ea 8b       	std	Y+18, r30	; 0x12
    432a:	f0 91 6b 01 	lds	r31, 0x016B
    432e:	fb 8b       	std	Y+19, r31	; 0x13
    4330:	20 91 6c 01 	lds	r18, 0x016C
    4334:	2c 8b       	std	Y+20, r18	; 0x14
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    4336:	a5 e7       	ldi	r26, 0x75	; 117
    4338:	b1 e0       	ldi	r27, 0x01	; 1
    433a:	8d 91       	ld	r24, X+
    433c:	9d 91       	ld	r25, X+
    433e:	0d 90       	ld	r0, X+
    4340:	bc 91       	ld	r27, X
    4342:	a0 2d       	mov	r26, r0
    4344:	89 ab       	std	Y+49, r24	; 0x31
    4346:	9a ab       	std	Y+50, r25	; 0x32
    4348:	ab ab       	std	Y+51, r26	; 0x33
    434a:	bc ab       	std	Y+52, r27	; 0x34
    434c:	ed e6       	ldi	r30, 0x6D	; 109
    434e:	f1 e0       	ldi	r31, 0x01	; 1
    4350:	f0 81       	ld	r31, Z
    4352:	fd 87       	std	Y+13, r31	; 0x0d
    4354:	20 91 6e 01 	lds	r18, 0x016E
    4358:	2e 87       	std	Y+14, r18	; 0x0e
    435a:	30 91 6f 01 	lds	r19, 0x016F
    435e:	3f 87       	std	Y+15, r19	; 0x0f
    4360:	40 91 70 01 	lds	r20, 0x0170
    4364:	48 8b       	std	Y+16, r20	; 0x10
    4366:	a8 e6       	ldi	r26, 0x68	; 104
    4368:	b1 e0       	ldi	r27, 0x01	; 1
    436a:	bc 91       	ld	r27, X
    436c:	b9 87       	std	Y+9, r27	; 0x09
    436e:	ed a5       	ldd	r30, Y+45	; 0x2d
    4370:	fe a5       	ldd	r31, Y+46	; 0x2e
    4372:	ff a3       	std	Y+39, r31	; 0x27
    4374:	0f a5       	ldd	r16, Y+47	; 0x2f
    4376:	18 a9       	ldd	r17, Y+48	; 0x30
    4378:	0f 2e       	mov	r0, r31
    437a:	fe e3       	ldi	r31, 0x3E	; 62
    437c:	2f 2e       	mov	r2, r31
    437e:	f0 2d       	mov	r31, r0
    4380:	0f 2e       	mov	r0, r31
    4382:	f3 ec       	ldi	r31, 0xC3	; 195
    4384:	6f 2e       	mov	r6, r31
    4386:	f0 2d       	mov	r31, r0
    4388:	0f 2e       	mov	r0, r31
    438a:	fe ea       	ldi	r31, 0xAE	; 174
    438c:	7f 2e       	mov	r7, r31
    438e:	f0 2d       	mov	r31, r0
    4390:	0f 2e       	mov	r0, r31
    4392:	f9 e3       	ldi	r31, 0x39	; 57
    4394:	3f 2e       	mov	r3, r31
    4396:	f0 2d       	mov	r31, r0
    4398:	c1 2c       	mov	r12, r1
    439a:	d1 2c       	mov	r13, r1
    439c:	76 01       	movw	r14, r12
    439e:	0f 2e       	mov	r0, r31
    43a0:	fe e3       	ldi	r31, 0x3E	; 62
    43a2:	4f 2e       	mov	r4, r31
    43a4:	f0 2d       	mov	r31, r0
    43a6:	0f 2e       	mov	r0, r31
    43a8:	f3 ec       	ldi	r31, 0xC3	; 195
    43aa:	5f 2e       	mov	r5, r31
    43ac:	f0 2d       	mov	r31, r0
    43ae:	2e ea       	ldi	r18, 0xAE	; 174
    43b0:	29 83       	std	Y+1, r18	; 0x01
    43b2:	39 e3       	ldi	r19, 0x39	; 57
    43b4:	3d 83       	std	Y+5, r19	; 0x05
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
    43b6:	ed ab       	std	Y+53, r30	; 0x35
    43b8:	fe ab       	std	Y+54, r31	; 0x36
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    43ba:	49 85       	ldd	r20, Y+9	; 0x09
    43bc:	44 23       	and	r20, r20
    43be:	21 f0       	breq	.+8      	; 0x43c8 <st_prep_buffer+0x6c8>
    43c0:	41 30       	cpi	r20, 0x01	; 1
    43c2:	09 f4       	brne	.+2      	; 0x43c6 <st_prep_buffer+0x6c6>
    43c4:	8a c0       	rjmp	.+276    	; 0x44da <st_prep_buffer+0x7da>
    43c6:	c9 c0       	rjmp	.+402    	; 0x455a <st_prep_buffer+0x85a>
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    43c8:	ad 89       	ldd	r26, Y+21	; 0x15
    43ca:	be 89       	ldd	r27, Y+22	; 0x16
    43cc:	91 96       	adiw	r26, 0x21	; 33
    43ce:	2d 91       	ld	r18, X+
    43d0:	3d 91       	ld	r19, X+
    43d2:	4d 91       	ld	r20, X+
    43d4:	5c 91       	ld	r21, X
    43d6:	94 97       	sbiw	r26, 0x24	; 36
    43d8:	62 2d       	mov	r22, r2
    43da:	76 2d       	mov	r23, r6
    43dc:	87 2d       	mov	r24, r7
    43de:	93 2d       	mov	r25, r3
    43e0:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    43e4:	4b 01       	movw	r8, r22
    43e6:	5c 01       	movw	r10, r24
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    43e8:	20 e0       	ldi	r18, 0x00	; 0
    43ea:	30 e0       	ldi	r19, 0x00	; 0
    43ec:	40 e0       	ldi	r20, 0x00	; 0
    43ee:	5f e3       	ldi	r21, 0x3F	; 63
    43f0:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    43f4:	2d 85       	ldd	r18, Y+13	; 0x0d
    43f6:	3e 85       	ldd	r19, Y+14	; 0x0e
    43f8:	4f 85       	ldd	r20, Y+15	; 0x0f
    43fa:	58 89       	ldd	r21, Y+16	; 0x10
    43fc:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    4400:	22 2d       	mov	r18, r2
    4402:	36 2d       	mov	r19, r6
    4404:	47 2d       	mov	r20, r7
    4406:	53 2d       	mov	r21, r3
    4408:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    440c:	9b 01       	movw	r18, r22
    440e:	ac 01       	movw	r20, r24
    4410:	6d a9       	ldd	r22, Y+53	; 0x35
    4412:	7e a9       	ldd	r23, Y+54	; 0x36
    4414:	80 2f       	mov	r24, r16
    4416:	91 2f       	mov	r25, r17
    4418:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    441c:	6d ab       	std	Y+53, r22	; 0x35
    441e:	7e ab       	std	Y+54, r23	; 0x36
    4420:	08 2f       	mov	r16, r24
    4422:	19 2f       	mov	r17, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    4424:	2f 89       	ldd	r18, Y+23	; 0x17
    4426:	38 8d       	ldd	r19, Y+24	; 0x18
    4428:	49 8d       	ldd	r20, Y+25	; 0x19
    442a:	5a 8d       	ldd	r21, Y+26	; 0x1a
    442c:	91 2f       	mov	r25, r17
    442e:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    4432:	88 23       	and	r24, r24
    4434:	0c f0       	brlt	.+2      	; 0x4438 <st_prep_buffer+0x738>
    4436:	44 c0       	rjmp	.+136    	; 0x44c0 <st_prep_buffer+0x7c0>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    4438:	2f 89       	ldd	r18, Y+23	; 0x17
    443a:	38 8d       	ldd	r19, Y+24	; 0x18
    443c:	49 8d       	ldd	r20, Y+25	; 0x19
    443e:	5a 8d       	ldd	r21, Y+26	; 0x1a
    4440:	6d a5       	ldd	r22, Y+45	; 0x2d
    4442:	7e a5       	ldd	r23, Y+46	; 0x2e
    4444:	8f a5       	ldd	r24, Y+47	; 0x2f
    4446:	98 a9       	ldd	r25, Y+48	; 0x30
    4448:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    444c:	9b 01       	movw	r18, r22
    444e:	ac 01       	movw	r20, r24
    4450:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    4454:	4b 01       	movw	r8, r22
    4456:	5c 01       	movw	r10, r24
    4458:	2d 85       	ldd	r18, Y+13	; 0x0d
    445a:	3e 85       	ldd	r19, Y+14	; 0x0e
    445c:	4f 85       	ldd	r20, Y+15	; 0x0f
    445e:	58 89       	ldd	r21, Y+16	; 0x10
    4460:	6b 8d       	ldd	r22, Y+27	; 0x1b
    4462:	7c 8d       	ldd	r23, Y+28	; 0x1c
    4464:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4466:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4468:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    446c:	9b 01       	movw	r18, r22
    446e:	ac 01       	movw	r20, r24
    4470:	c5 01       	movw	r24, r10
    4472:	b4 01       	movw	r22, r8
    4474:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    4478:	26 2e       	mov	r2, r22
    447a:	67 2e       	mov	r6, r23
    447c:	78 2e       	mov	r7, r24
    447e:	39 2e       	mov	r3, r25
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    4480:	2f 8d       	ldd	r18, Y+31	; 0x1f
    4482:	38 a1       	ldd	r19, Y+32	; 0x20
    4484:	49 a1       	ldd	r20, Y+33	; 0x21
    4486:	5a a1       	ldd	r21, Y+34	; 0x22
    4488:	6f 89       	ldd	r22, Y+23	; 0x17
    448a:	78 8d       	ldd	r23, Y+24	; 0x18
    448c:	89 8d       	ldd	r24, Y+25	; 0x19
    448e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4490:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    4494:	88 23       	and	r24, r24
    4496:	19 f0       	breq	.+6      	; 0x449e <st_prep_buffer+0x79e>
            else { prep.ramp_type = RAMP_CRUISE; }
    4498:	b1 e0       	ldi	r27, 0x01	; 1
    449a:	b9 87       	std	Y+9, r27	; 0x09
    449c:	02 c0       	rjmp	.+4      	; 0x44a2 <st_prep_buffer+0x7a2>
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    449e:	e2 e0       	ldi	r30, 0x02	; 2
    44a0:	e9 87       	std	Y+9, r30	; 0x09
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    44a2:	fb 8d       	ldd	r31, Y+27	; 0x1b
    44a4:	fd 87       	std	Y+13, r31	; 0x0d
    44a6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    44a8:	2e 87       	std	Y+14, r18	; 0x0e
    44aa:	3d 8d       	ldd	r19, Y+29	; 0x1d
    44ac:	3f 87       	std	Y+15, r19	; 0x0f
    44ae:	4e 8d       	ldd	r20, Y+30	; 0x1e
    44b0:	48 8b       	std	Y+16, r20	; 0x10
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    44b2:	5f 89       	ldd	r21, Y+23	; 0x17
    44b4:	5d ab       	std	Y+53, r21	; 0x35
    44b6:	88 8d       	ldd	r24, Y+24	; 0x18
    44b8:	8e ab       	std	Y+54, r24	; 0x36
    44ba:	09 8d       	ldd	r16, Y+25	; 0x19
    44bc:	1a 8d       	ldd	r17, Y+26	; 0x1a
    44be:	d1 c0       	rjmp	.+418    	; 0x4662 <st_prep_buffer+0x962>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only. 
            prep.current_speed += speed_var;
    44c0:	2d 85       	ldd	r18, Y+13	; 0x0d
    44c2:	3e 85       	ldd	r19, Y+14	; 0x0e
    44c4:	4f 85       	ldd	r20, Y+15	; 0x0f
    44c6:	58 89       	ldd	r21, Y+16	; 0x10
    44c8:	c5 01       	movw	r24, r10
    44ca:	b4 01       	movw	r22, r8
    44cc:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    44d0:	6d 87       	std	Y+13, r22	; 0x0d
    44d2:	7e 87       	std	Y+14, r23	; 0x0e
    44d4:	8f 87       	std	Y+15, r24	; 0x0f
    44d6:	98 8b       	std	Y+16, r25	; 0x10
    44d8:	c4 c0       	rjmp	.+392    	; 0x4662 <st_prep_buffer+0x962>
          break;
        case RAMP_CRUISE: 
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To 
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    44da:	2b 8d       	ldd	r18, Y+27	; 0x1b
    44dc:	3c 8d       	ldd	r19, Y+28	; 0x1c
    44de:	4d 8d       	ldd	r20, Y+29	; 0x1d
    44e0:	5e 8d       	ldd	r21, Y+30	; 0x1e
    44e2:	62 2d       	mov	r22, r2
    44e4:	76 2d       	mov	r23, r6
    44e6:	87 2d       	mov	r24, r7
    44e8:	93 2d       	mov	r25, r3
    44ea:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    44ee:	9b 01       	movw	r18, r22
    44f0:	ac 01       	movw	r20, r24
    44f2:	6d a9       	ldd	r22, Y+53	; 0x35
    44f4:	7e a9       	ldd	r23, Y+54	; 0x36
    44f6:	80 2f       	mov	r24, r16
    44f8:	91 2f       	mov	r25, r17
    44fa:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    44fe:	a6 2e       	mov	r10, r22
    4500:	b7 2e       	mov	r11, r23
    4502:	88 2e       	mov	r8, r24
    4504:	99 2e       	mov	r9, r25
          if (mm_var < prep.decelerate_after) { // End of cruise. 
    4506:	26 2f       	mov	r18, r22
    4508:	37 2f       	mov	r19, r23
    450a:	48 2f       	mov	r20, r24
    450c:	59 2f       	mov	r21, r25
    450e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4510:	78 a1       	ldd	r23, Y+32	; 0x20
    4512:	89 a1       	ldd	r24, Y+33	; 0x21
    4514:	9a a1       	ldd	r25, Y+34	; 0x22
    4516:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    451a:	18 16       	cp	r1, r24
    451c:	0c f0       	brlt	.+2      	; 0x4520 <st_prep_buffer+0x820>
    451e:	9d c0       	rjmp	.+314    	; 0x465a <st_prep_buffer+0x95a>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    4520:	2f 8d       	ldd	r18, Y+31	; 0x1f
    4522:	38 a1       	ldd	r19, Y+32	; 0x20
    4524:	49 a1       	ldd	r20, Y+33	; 0x21
    4526:	5a a1       	ldd	r21, Y+34	; 0x22
    4528:	6d a9       	ldd	r22, Y+53	; 0x35
    452a:	7e a9       	ldd	r23, Y+54	; 0x36
    452c:	80 2f       	mov	r24, r16
    452e:	91 2f       	mov	r25, r17
    4530:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    4534:	2b 8d       	ldd	r18, Y+27	; 0x1b
    4536:	3c 8d       	ldd	r19, Y+28	; 0x1c
    4538:	4d 8d       	ldd	r20, Y+29	; 0x1d
    453a:	5e 8d       	ldd	r21, Y+30	; 0x1e
    453c:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    4540:	26 2e       	mov	r2, r22
    4542:	67 2e       	mov	r6, r23
    4544:	78 2e       	mov	r7, r24
    4546:	39 2e       	mov	r3, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    4548:	9f 8d       	ldd	r25, Y+31	; 0x1f
    454a:	9d ab       	std	Y+53, r25	; 0x35
    454c:	a8 a1       	ldd	r26, Y+32	; 0x20
    454e:	ae ab       	std	Y+54, r26	; 0x36
    4550:	09 a1       	ldd	r16, Y+33	; 0x21
    4552:	1a a1       	ldd	r17, Y+34	; 0x22
            prep.ramp_type = RAMP_DECEL;
    4554:	b2 e0       	ldi	r27, 0x02	; 2
    4556:	b9 87       	std	Y+9, r27	; 0x09
    4558:	84 c0       	rjmp	.+264    	; 0x4662 <st_prep_buffer+0x962>
            mm_remaining = mm_var; 
          } 
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    455a:	ed 89       	ldd	r30, Y+21	; 0x15
    455c:	fe 89       	ldd	r31, Y+22	; 0x16
    455e:	21 a1       	ldd	r18, Z+33	; 0x21
    4560:	32 a1       	ldd	r19, Z+34	; 0x22
    4562:	43 a1       	ldd	r20, Z+35	; 0x23
    4564:	54 a1       	ldd	r21, Z+36	; 0x24
    4566:	62 2d       	mov	r22, r2
    4568:	76 2d       	mov	r23, r6
    456a:	87 2d       	mov	r24, r7
    456c:	93 2d       	mov	r25, r3
    456e:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    4572:	4b 01       	movw	r8, r22
    4574:	5c 01       	movw	r10, r24
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    4576:	9b 01       	movw	r18, r22
    4578:	ac 01       	movw	r20, r24
    457a:	6d 85       	ldd	r22, Y+13	; 0x0d
    457c:	7e 85       	ldd	r23, Y+14	; 0x0e
    457e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4580:	98 89       	ldd	r25, Y+16	; 0x10
    4582:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    4586:	18 16       	cp	r1, r24
    4588:	ec f5       	brge	.+122    	; 0x4604 <st_prep_buffer+0x904>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    458a:	20 e0       	ldi	r18, 0x00	; 0
    458c:	30 e0       	ldi	r19, 0x00	; 0
    458e:	40 e0       	ldi	r20, 0x00	; 0
    4590:	5f e3       	ldi	r21, 0x3F	; 63
    4592:	c5 01       	movw	r24, r10
    4594:	b4 01       	movw	r22, r8
    4596:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    459a:	9b 01       	movw	r18, r22
    459c:	ac 01       	movw	r20, r24
    459e:	6d 85       	ldd	r22, Y+13	; 0x0d
    45a0:	7e 85       	ldd	r23, Y+14	; 0x0e
    45a2:	8f 85       	ldd	r24, Y+15	; 0x0f
    45a4:	98 89       	ldd	r25, Y+16	; 0x10
    45a6:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    45aa:	22 2d       	mov	r18, r2
    45ac:	36 2d       	mov	r19, r6
    45ae:	47 2d       	mov	r20, r7
    45b0:	53 2d       	mov	r21, r3
    45b2:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    45b6:	9b 01       	movw	r18, r22
    45b8:	ac 01       	movw	r20, r24
    45ba:	6d a9       	ldd	r22, Y+53	; 0x35
    45bc:	7e a9       	ldd	r23, Y+54	; 0x36
    45be:	80 2f       	mov	r24, r16
    45c0:	91 2f       	mov	r25, r17
    45c2:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    45c6:	6f a3       	std	Y+39, r22	; 0x27
    45c8:	78 a7       	std	Y+40, r23	; 0x28
    45ca:	89 a7       	std	Y+41, r24	; 0x29
    45cc:	9a a7       	std	Y+42, r25	; 0x2a
            if (mm_var > prep.mm_complete) { // Deceleration only.
    45ce:	29 89       	ldd	r18, Y+17	; 0x11
    45d0:	3a 89       	ldd	r19, Y+18	; 0x12
    45d2:	4b 89       	ldd	r20, Y+19	; 0x13
    45d4:	5c 89       	ldd	r21, Y+20	; 0x14
    45d6:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    45da:	18 16       	cp	r1, r24
    45dc:	9c f4       	brge	.+38     	; 0x4604 <st_prep_buffer+0x904>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    45de:	a5 01       	movw	r20, r10
    45e0:	94 01       	movw	r18, r8
    45e2:	6d 85       	ldd	r22, Y+13	; 0x0d
    45e4:	7e 85       	ldd	r23, Y+14	; 0x0e
    45e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    45e8:	98 89       	ldd	r25, Y+16	; 0x10
    45ea:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    45ee:	6d 87       	std	Y+13, r22	; 0x0d
    45f0:	7e 87       	std	Y+14, r23	; 0x0e
    45f2:	8f 87       	std	Y+15, r24	; 0x0f
    45f4:	98 8b       	std	Y+16, r25	; 0x10
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
              mm_remaining = mm_var;
    45f6:	ff a1       	ldd	r31, Y+39	; 0x27
    45f8:	fd ab       	std	Y+53, r31	; 0x35
    45fa:	28 a5       	ldd	r18, Y+40	; 0x28
    45fc:	2e ab       	std	Y+54, r18	; 0x36
    45fe:	09 a5       	ldd	r16, Y+41	; 0x29
    4600:	1a a5       	ldd	r17, Y+42	; 0x2a
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    4602:	2f c0       	rjmp	.+94     	; 0x4662 <st_prep_buffer+0x962>
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    4604:	29 89       	ldd	r18, Y+17	; 0x11
    4606:	3a 89       	ldd	r19, Y+18	; 0x12
    4608:	4b 89       	ldd	r20, Y+19	; 0x13
    460a:	5c 89       	ldd	r21, Y+20	; 0x14
    460c:	6d a9       	ldd	r22, Y+53	; 0x35
    460e:	7e a9       	ldd	r23, Y+54	; 0x36
    4610:	80 2f       	mov	r24, r16
    4612:	91 2f       	mov	r25, r17
    4614:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    4618:	9b 01       	movw	r18, r22
    461a:	ac 01       	movw	r20, r24
    461c:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    4620:	4b 01       	movw	r8, r22
    4622:	5c 01       	movw	r10, r24
    4624:	29 a9       	ldd	r18, Y+49	; 0x31
    4626:	3a a9       	ldd	r19, Y+50	; 0x32
    4628:	4b a9       	ldd	r20, Y+51	; 0x33
    462a:	5c a9       	ldd	r21, Y+52	; 0x34
    462c:	6d 85       	ldd	r22, Y+13	; 0x0d
    462e:	7e 85       	ldd	r23, Y+14	; 0x0e
    4630:	8f 85       	ldd	r24, Y+15	; 0x0f
    4632:	98 89       	ldd	r25, Y+16	; 0x10
    4634:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    4638:	9b 01       	movw	r18, r22
    463a:	ac 01       	movw	r20, r24
    463c:	c5 01       	movw	r24, r10
    463e:	b4 01       	movw	r22, r8
    4640:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    4644:	26 2e       	mov	r2, r22
    4646:	67 2e       	mov	r6, r23
    4648:	78 2e       	mov	r7, r24
    464a:	39 2e       	mov	r3, r25
          mm_remaining = prep.mm_complete; 
    464c:	39 89       	ldd	r19, Y+17	; 0x11
    464e:	3d ab       	std	Y+53, r19	; 0x35
    4650:	4a 89       	ldd	r20, Y+18	; 0x12
    4652:	4e ab       	std	Y+54, r20	; 0x36
    4654:	0b 89       	ldd	r16, Y+19	; 0x13
    4656:	1c 89       	ldd	r17, Y+20	; 0x14
    4658:	04 c0       	rjmp	.+8      	; 0x4662 <st_prep_buffer+0x962>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.         
            mm_remaining = mm_var; 
    465a:	ad aa       	std	Y+53, r10	; 0x35
    465c:	be aa       	std	Y+54, r11	; 0x36
    465e:	08 2d       	mov	r16, r8
    4660:	19 2d       	mov	r17, r9
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete; 
      }
      dt += time_var; // Add computed ramp time to total segment time.
    4662:	22 2d       	mov	r18, r2
    4664:	36 2d       	mov	r19, r6
    4666:	47 2d       	mov	r20, r7
    4668:	53 2d       	mov	r21, r3
    466a:	c7 01       	movw	r24, r14
    466c:	b6 01       	movw	r22, r12
    466e:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    4672:	6b 01       	movw	r12, r22
    4674:	7c 01       	movw	r14, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    4676:	9b 01       	movw	r18, r22
    4678:	ac 01       	movw	r20, r24
    467a:	64 2d       	mov	r22, r4
    467c:	75 2d       	mov	r23, r5
    467e:	89 81       	ldd	r24, Y+1	; 0x01
    4680:	9d 81       	ldd	r25, Y+5	; 0x05
    4682:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    4686:	18 16       	cp	r1, r24
    4688:	6c f4       	brge	.+26     	; 0x46a4 <st_prep_buffer+0x9a4>
    468a:	a7 01       	movw	r20, r14
    468c:	96 01       	movw	r18, r12
    468e:	64 2d       	mov	r22, r4
    4690:	75 2d       	mov	r23, r5
    4692:	89 81       	ldd	r24, Y+1	; 0x01
    4694:	9d 81       	ldd	r25, Y+5	; 0x05
    4696:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    469a:	26 2e       	mov	r2, r22
    469c:	67 2e       	mov	r6, r23
    469e:	78 2e       	mov	r7, r24
    46a0:	39 2e       	mov	r3, r25
    46a2:	33 c0       	rjmp	.+102    	; 0x470a <st_prep_buffer+0xa0a>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    46a4:	2b a1       	ldd	r18, Y+35	; 0x23
    46a6:	3c a1       	ldd	r19, Y+36	; 0x24
    46a8:	4d a1       	ldd	r20, Y+37	; 0x25
    46aa:	5e a1       	ldd	r21, Y+38	; 0x26
    46ac:	6d a9       	ldd	r22, Y+53	; 0x35
    46ae:	7e a9       	ldd	r23, Y+54	; 0x36
    46b0:	80 2f       	mov	r24, r16
    46b2:	91 2f       	mov	r25, r17
    46b4:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    46b8:	18 16       	cp	r1, r24
    46ba:	8c f0       	brlt	.+34     	; 0x46de <st_prep_buffer+0x9de>
    46bc:	8e a9       	ldd	r24, Y+54	; 0x36
    46be:	8f a3       	std	Y+39, r24	; 0x27
    46c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    46c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    46c4:	af 85       	ldd	r26, Y+15	; 0x0f
    46c6:	b8 89       	ldd	r27, Y+16	; 0x10
    46c8:	ed e6       	ldi	r30, 0x6D	; 109
    46ca:	f1 e0       	ldi	r31, 0x01	; 1
    46cc:	80 83       	st	Z, r24
    46ce:	91 83       	std	Z+1, r25	; 0x01
    46d0:	a2 83       	std	Z+2, r26	; 0x02
    46d2:	b3 83       	std	Z+3, r27	; 0x03
    46d4:	e9 85       	ldd	r30, Y+9	; 0x09
    46d6:	a8 e6       	ldi	r26, 0x68	; 104
    46d8:	b1 e0       	ldi	r27, 0x01	; 1
    46da:	ec 93       	st	X, r30
    46dc:	33 c0       	rjmp	.+102    	; 0x4744 <st_prep_buffer+0xa44>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    46de:	2e e3       	ldi	r18, 0x3E	; 62
    46e0:	33 ec       	ldi	r19, 0xC3	; 195
    46e2:	4e ea       	ldi	r20, 0xAE	; 174
    46e4:	59 e3       	ldi	r21, 0x39	; 57
    46e6:	64 2d       	mov	r22, r4
    46e8:	75 2d       	mov	r23, r5
    46ea:	89 81       	ldd	r24, Y+1	; 0x01
    46ec:	9d 81       	ldd	r25, Y+5	; 0x05
    46ee:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    46f2:	46 2e       	mov	r4, r22
    46f4:	57 2e       	mov	r5, r23
    46f6:	89 83       	std	Y+1, r24	; 0x01
    46f8:	9d 83       	std	Y+5, r25	; 0x05
          time_var = dt_max - dt;
    46fa:	a7 01       	movw	r20, r14
    46fc:	96 01       	movw	r18, r12
    46fe:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    4702:	26 2e       	mov	r2, r22
    4704:	67 2e       	mov	r6, r23
    4706:	78 2e       	mov	r7, r24
    4708:	39 2e       	mov	r3, r25
        } else { 
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    470a:	29 89       	ldd	r18, Y+17	; 0x11
    470c:	3a 89       	ldd	r19, Y+18	; 0x12
    470e:	4b 89       	ldd	r20, Y+19	; 0x13
    4710:	5c 89       	ldd	r21, Y+20	; 0x14
    4712:	6d a9       	ldd	r22, Y+53	; 0x35
    4714:	7e a9       	ldd	r23, Y+54	; 0x36
    4716:	80 2f       	mov	r24, r16
    4718:	91 2f       	mov	r25, r17
    471a:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    471e:	18 16       	cp	r1, r24
    4720:	0c f4       	brge	.+2      	; 0x4724 <st_prep_buffer+0xa24>
    4722:	4b ce       	rjmp	.-874    	; 0x43ba <st_prep_buffer+0x6ba>
    4724:	8e a9       	ldd	r24, Y+54	; 0x36
    4726:	8f a3       	std	Y+39, r24	; 0x27
    4728:	8d 85       	ldd	r24, Y+13	; 0x0d
    472a:	9e 85       	ldd	r25, Y+14	; 0x0e
    472c:	af 85       	ldd	r26, Y+15	; 0x0f
    472e:	b8 89       	ldd	r27, Y+16	; 0x10
    4730:	ed e6       	ldi	r30, 0x6D	; 109
    4732:	f1 e0       	ldi	r31, 0x01	; 1
    4734:	80 83       	st	Z, r24
    4736:	91 83       	std	Z+1, r25	; 0x01
    4738:	a2 83       	std	Z+2, r26	; 0x02
    473a:	b3 83       	std	Z+3, r27	; 0x03
    473c:	e9 85       	ldd	r30, Y+9	; 0x09
    473e:	a8 e6       	ldi	r26, 0x68	; 104
    4740:	b1 e0       	ldi	r27, 0x01	; 1
    4742:	ec 93       	st	X, r30
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    4744:	ac e5       	ldi	r26, 0x5C	; 92
    4746:	b1 e0       	ldi	r27, 0x01	; 1
    4748:	2d 91       	ld	r18, X+
    474a:	3d 91       	ld	r19, X+
    474c:	4d 91       	ld	r20, X+
    474e:	5c 91       	ld	r21, X
    4750:	29 87       	std	Y+9, r18	; 0x09
    4752:	3a 87       	std	Y+10, r19	; 0x0a
    4754:	4b 87       	std	Y+11, r20	; 0x0b
    4756:	5c 87       	std	Y+12, r21	; 0x0c
    4758:	2d a9       	ldd	r18, Y+53	; 0x35
    475a:	3f a1       	ldd	r19, Y+39	; 0x27
    475c:	40 2f       	mov	r20, r16
    475e:	51 2f       	mov	r21, r17
    4760:	69 85       	ldd	r22, Y+9	; 0x09
    4762:	7a 85       	ldd	r23, Y+10	; 0x0a
    4764:	8b 85       	ldd	r24, Y+11	; 0x0b
    4766:	9c 85       	ldd	r25, Y+12	; 0x0c
    4768:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    476c:	2b 01       	movw	r4, r22
    476e:	3c 01       	movw	r6, r24
    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining
    4770:	0e 94 9a 3c 	call	0x7934	; 0x7934 <ceil>
    4774:	6d 83       	std	Y+5, r22	; 0x05
    4776:	7e 83       	std	Y+6, r23	; 0x06
    4778:	8f 83       	std	Y+7, r24	; 0x07
    477a:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    477c:	e8 e5       	ldi	r30, 0x58	; 88
    477e:	f1 e0       	ldi	r31, 0x01	; 1
    4780:	60 81       	ld	r22, Z
    4782:	71 81       	ldd	r23, Z+1	; 0x01
    4784:	82 81       	ldd	r24, Z+2	; 0x02
    4786:	93 81       	ldd	r25, Z+3	; 0x03
    4788:	0e 94 9a 3c 	call	0x7934	; 0x7934 <ceil>
    478c:	4b 01       	movw	r8, r22
    478e:	5c 01       	movw	r10, r24
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    4790:	2d 81       	ldd	r18, Y+5	; 0x05
    4792:	3e 81       	ldd	r19, Y+6	; 0x06
    4794:	4f 81       	ldd	r20, Y+7	; 0x07
    4796:	58 85       	ldd	r21, Y+8	; 0x08
    4798:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    479c:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
    47a0:	69 83       	std	Y+1, r22	; 0x01
    47a2:	7a 83       	std	Y+2, r23	; 0x02
    47a4:	8b 83       	std	Y+3, r24	; 0x03
    47a6:	9c 83       	std	Y+4, r25	; 0x04
    47a8:	e9 81       	ldd	r30, Y+1	; 0x01
    47aa:	fa 81       	ldd	r31, Y+2	; 0x02
    47ac:	ab a5       	ldd	r26, Y+43	; 0x2b
    47ae:	bc a5       	ldd	r27, Y+44	; 0x2c
    47b0:	ed 93       	st	X+, r30
    47b2:	fc 93       	st	X, r31
    
    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    47b4:	30 97       	sbiw	r30, 0x00	; 0
    47b6:	91 f5       	brne	.+100    	; 0x481c <st_prep_buffer+0xb1c>
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    47b8:	a8 e6       	ldi	r26, 0x68	; 104
    47ba:	b7 e0       	ldi	r27, 0x07	; 7
    47bc:	8c 91       	ld	r24, X
    47be:	80 77       	andi	r24, 0x70	; 112
    47c0:	69 f1       	breq	.+90     	; 0x481c <st_prep_buffer+0xb1c>
    47c2:	4d 80       	ldd	r4, Y+5	; 0x05
    47c4:	5e 80       	ldd	r5, Y+6	; 0x06
    47c6:	6f 80       	ldd	r6, Y+7	; 0x07
    47c8:	78 84       	ldd	r7, Y+8	; 0x08
        // Less than one step to decelerate to zero speed, but already very close. AMASS 
        // requires full steps to execute. So, just bail.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    47ca:	10 92 6d 01 	sts	0x016D, r1
    47ce:	10 92 6e 01 	sts	0x016E, r1
    47d2:	10 92 6f 01 	sts	0x016F, r1
    47d6:	10 92 70 01 	sts	0x0170, r1
        prep.dt_remainder = 0.0;
    47da:	10 92 64 01 	sts	0x0164, r1
    47de:	10 92 65 01 	sts	0x0165, r1
    47e2:	10 92 66 01 	sts	0x0166, r1
    47e6:	10 92 67 01 	sts	0x0167, r1
        prep.steps_remaining = n_steps_remaining;
    47ea:	40 92 58 01 	sts	0x0158, r4
    47ee:	50 92 59 01 	sts	0x0159, r5
    47f2:	60 92 5a 01 	sts	0x015A, r6
    47f6:	70 92 5b 01 	sts	0x015B, r7
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    47fa:	29 85       	ldd	r18, Y+9	; 0x09
    47fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    47fe:	4b 85       	ldd	r20, Y+11	; 0x0b
    4800:	5c 85       	ldd	r21, Y+12	; 0x0c
    4802:	c3 01       	movw	r24, r6
    4804:	b2 01       	movw	r22, r4
    4806:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    480a:	ed 89       	ldd	r30, Y+21	; 0x15
    480c:	fe 89       	ldd	r31, Y+22	; 0x16
    480e:	65 a3       	std	Z+37, r22	; 0x25
    4810:	76 a3       	std	Z+38, r23	; 0x26
    4812:	87 a3       	std	Z+39, r24	; 0x27
    4814:	90 a7       	std	Z+40, r25	; 0x28
        plan_cycle_reinitialize();         
    4816:	0e 94 03 2e 	call	0x5c06	; 0x5c06 <plan_cycle_reinitialize>
        return; // Segment not generated, but current step data still retained.
    481a:	05 c1       	rjmp	.+522    	; 0x4a26 <st_prep_buffer+0xd26>
    // compensate, we track the time to execute the previous segment's partial step and simply
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are 
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    481c:	0f 2e       	mov	r0, r31
    481e:	f4 e6       	ldi	r31, 0x64	; 100
    4820:	2f 2e       	mov	r2, r31
    4822:	f1 e0       	ldi	r31, 0x01	; 1
    4824:	3f 2e       	mov	r3, r31
    4826:	f0 2d       	mov	r31, r0
    4828:	d1 01       	movw	r26, r2
    482a:	2d 91       	ld	r18, X+
    482c:	3d 91       	ld	r19, X+
    482e:	4d 91       	ld	r20, X+
    4830:	5c 91       	ld	r21, X
    4832:	c7 01       	movw	r24, r14
    4834:	b6 01       	movw	r22, r12
    4836:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    483a:	6b 01       	movw	r12, r22
    483c:	7c 01       	movw	r14, r24
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
    483e:	a3 01       	movw	r20, r6
    4840:	92 01       	movw	r18, r4
    4842:	c5 01       	movw	r24, r10
    4844:	b4 01       	movw	r22, r8
    4846:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    484a:	9b 01       	movw	r18, r22
    484c:	ac 01       	movw	r20, r24
    484e:	c7 01       	movw	r24, r14
    4850:	b6 01       	movw	r22, r12
    4852:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    4856:	6b 01       	movw	r12, r22
    4858:	7c 01       	movw	r14, r24
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time
    485a:	a3 01       	movw	r20, r6
    485c:	92 01       	movw	r18, r4
    485e:	6d 81       	ldd	r22, Y+5	; 0x05
    4860:	7e 81       	ldd	r23, Y+6	; 0x06
    4862:	8f 81       	ldd	r24, Y+7	; 0x07
    4864:	98 85       	ldd	r25, Y+8	; 0x08
    4866:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    486a:	a7 01       	movw	r20, r14
    486c:	96 01       	movw	r18, r12
    486e:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    4872:	f1 01       	movw	r30, r2
    4874:	60 83       	st	Z, r22
    4876:	71 83       	std	Z+1, r23	; 0x01
    4878:	82 83       	std	Z+2, r24	; 0x02
    487a:	93 83       	std	Z+3, r25	; 0x03

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)    
    487c:	2c ef       	ldi	r18, 0xFC	; 252
    487e:	3e eb       	ldi	r19, 0xBE	; 190
    4880:	40 e8       	ldi	r20, 0x80	; 128
    4882:	5e e4       	ldi	r21, 0x4E	; 78
    4884:	c7 01       	movw	r24, r14
    4886:	b6 01       	movw	r22, r12
    4888:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    488c:	0e 94 9a 3c 	call	0x7934	; 0x7934 <ceil>
    4890:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    4894:	61 15       	cp	r22, r1
    4896:	f9 e0       	ldi	r31, 0x09	; 9
    4898:	7f 07       	cpc	r23, r31
    489a:	81 05       	cpc	r24, r1
    489c:	91 05       	cpc	r25, r1
    489e:	28 f4       	brcc	.+10     	; 0x48aa <st_prep_buffer+0xbaa>
    48a0:	ab a5       	ldd	r26, Y+43	; 0x2b
    48a2:	bc a5       	ldd	r27, Y+44	; 0x2c
    48a4:	15 96       	adiw	r26, 0x05	; 5
    48a6:	1c 92       	st	X, r1
    48a8:	31 c0       	rjmp	.+98     	; 0x490c <st_prep_buffer+0xc0c>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    48aa:	61 15       	cp	r22, r1
    48ac:	b2 e1       	ldi	r27, 0x12	; 18
    48ae:	7b 07       	cpc	r23, r27
    48b0:	81 05       	cpc	r24, r1
    48b2:	91 05       	cpc	r25, r1
    48b4:	28 f4       	brcc	.+10     	; 0x48c0 <st_prep_buffer+0xbc0>
    48b6:	21 e0       	ldi	r18, 0x01	; 1
    48b8:	eb a5       	ldd	r30, Y+43	; 0x2b
    48ba:	fc a5       	ldd	r31, Y+44	; 0x2c
    48bc:	25 83       	std	Z+5, r18	; 0x05
    48be:	10 c0       	rjmp	.+32     	; 0x48e0 <st_prep_buffer+0xbe0>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    48c0:	61 15       	cp	r22, r1
    48c2:	f4 e2       	ldi	r31, 0x24	; 36
    48c4:	7f 07       	cpc	r23, r31
    48c6:	81 05       	cpc	r24, r1
    48c8:	91 05       	cpc	r25, r1
    48ca:	30 f4       	brcc	.+12     	; 0x48d8 <st_prep_buffer+0xbd8>
    48cc:	22 e0       	ldi	r18, 0x02	; 2
    48ce:	ab a5       	ldd	r26, Y+43	; 0x2b
    48d0:	bc a5       	ldd	r27, Y+44	; 0x2c
    48d2:	15 96       	adiw	r26, 0x05	; 5
    48d4:	2c 93       	st	X, r18
    48d6:	04 c0       	rjmp	.+8      	; 0x48e0 <st_prep_buffer+0xbe0>
        else { prep_segment->amass_level = 3; }    
    48d8:	23 e0       	ldi	r18, 0x03	; 3
    48da:	eb a5       	ldd	r30, Y+43	; 0x2b
    48dc:	fc a5       	ldd	r31, Y+44	; 0x2c
    48de:	25 83       	std	Z+5, r18	; 0x05
        cycles >>= prep_segment->amass_level; 
    48e0:	ab a5       	ldd	r26, Y+43	; 0x2b
    48e2:	bc a5       	ldd	r27, Y+44	; 0x2c
    48e4:	15 96       	adiw	r26, 0x05	; 5
    48e6:	2c 91       	ld	r18, X
    48e8:	15 97       	sbiw	r26, 0x05	; 5
    48ea:	02 2e       	mov	r0, r18
    48ec:	04 c0       	rjmp	.+8      	; 0x48f6 <st_prep_buffer+0xbf6>
    48ee:	96 95       	lsr	r25
    48f0:	87 95       	ror	r24
    48f2:	77 95       	ror	r23
    48f4:	67 95       	ror	r22
    48f6:	0a 94       	dec	r0
    48f8:	d2 f7       	brpl	.-12     	; 0x48ee <st_prep_buffer+0xbee>
        prep_segment->n_step <<= prep_segment->amass_level;
    48fa:	e9 81       	ldd	r30, Y+1	; 0x01
    48fc:	fa 81       	ldd	r31, Y+2	; 0x02
    48fe:	02 c0       	rjmp	.+4      	; 0x4904 <st_prep_buffer+0xc04>
    4900:	ee 0f       	add	r30, r30
    4902:	ff 1f       	adc	r31, r31
    4904:	2a 95       	dec	r18
    4906:	e2 f7       	brpl	.-8      	; 0x4900 <st_prep_buffer+0xc00>
    4908:	ed 93       	st	X+, r30
    490a:	fc 93       	st	X, r31
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    490c:	61 15       	cp	r22, r1
    490e:	71 05       	cpc	r23, r1
    4910:	f1 e0       	ldi	r31, 0x01	; 1
    4912:	8f 07       	cpc	r24, r31
    4914:	91 05       	cpc	r25, r1
    4916:	38 f4       	brcc	.+14     	; 0x4926 <st_prep_buffer+0xc26>
    4918:	ab a5       	ldd	r26, Y+43	; 0x2b
    491a:	bc a5       	ldd	r27, Y+44	; 0x2c
    491c:	14 96       	adiw	r26, 0x04	; 4
    491e:	7c 93       	st	X, r23
    4920:	6e 93       	st	-X, r22
    4922:	13 97       	sbiw	r26, 0x03	; 3
    4924:	06 c0       	rjmp	.+12     	; 0x4932 <st_prep_buffer+0xc32>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    4926:	8f ef       	ldi	r24, 0xFF	; 255
    4928:	9f ef       	ldi	r25, 0xFF	; 255
    492a:	eb a5       	ldd	r30, Y+43	; 0x2b
    492c:	fc a5       	ldd	r31, Y+44	; 0x2c
    492e:	94 83       	std	Z+4, r25	; 0x04
    4930:	83 83       	std	Z+3, r24	; 0x03
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices.
    segment_buffer_head = segment_next_head;
    4932:	80 91 88 01 	lds	r24, 0x0188
    4936:	80 93 89 01 	sts	0x0189, r24
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    493a:	8f 5f       	subi	r24, 0xFF	; 255
    493c:	86 30       	cpi	r24, 0x06	; 6
    493e:	19 f0       	breq	.+6      	; 0x4946 <st_prep_buffer+0xc46>
    4940:	80 93 88 01 	sts	0x0188, r24
    4944:	02 c0       	rjmp	.+4      	; 0x494a <st_prep_buffer+0xc4a>
    4946:	10 92 88 01 	sts	0x0188, r1

    // Setup initial conditions for next segment.
    if (mm_remaining > prep.mm_complete) { 
    494a:	2d a9       	ldd	r18, Y+53	; 0x35
    494c:	3f a1       	ldd	r19, Y+39	; 0x27
    494e:	40 2f       	mov	r20, r16
    4950:	51 2f       	mov	r21, r17
    4952:	a9 e6       	ldi	r26, 0x69	; 105
    4954:	b1 e0       	ldi	r27, 0x01	; 1
    4956:	6d 91       	ld	r22, X+
    4958:	7d 91       	ld	r23, X+
    495a:	8d 91       	ld	r24, X+
    495c:	9c 91       	ld	r25, X
    495e:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    4962:	88 23       	and	r24, r24
    4964:	9c f4       	brge	.+38     	; 0x498c <st_prep_buffer+0xc8c>
      // Normal operation. Block incomplete. Distance remaining in block to be executed.
      pl_block->millimeters = mm_remaining;      
    4966:	e0 91 83 01 	lds	r30, 0x0183
    496a:	f0 91 84 01 	lds	r31, 0x0184
    496e:	8d a9       	ldd	r24, Y+53	; 0x35
    4970:	9f a1       	ldd	r25, Y+39	; 0x27
    4972:	a0 2f       	mov	r26, r16
    4974:	b1 2f       	mov	r27, r17
    4976:	85 a3       	std	Z+37, r24	; 0x25
    4978:	96 a3       	std	Z+38, r25	; 0x26
    497a:	a7 a3       	std	Z+39, r26	; 0x27
    497c:	b0 a7       	std	Z+40, r27	; 0x28
      prep.steps_remaining = steps_remaining;  
    497e:	e8 e5       	ldi	r30, 0x58	; 88
    4980:	f1 e0       	ldi	r31, 0x01	; 1
    4982:	40 82       	st	Z, r4
    4984:	51 82       	std	Z+1, r5	; 0x01
    4986:	62 82       	std	Z+2, r6	; 0x02
    4988:	73 82       	std	Z+3, r7	; 0x03
    498a:	47 c0       	rjmp	.+142    	; 0x4a1a <st_prep_buffer+0xd1a>
    } else { 
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    498c:	20 e0       	ldi	r18, 0x00	; 0
    498e:	30 e0       	ldi	r19, 0x00	; 0
    4990:	a9 01       	movw	r20, r18
    4992:	6d a9       	ldd	r22, Y+53	; 0x35
    4994:	7f a1       	ldd	r23, Y+39	; 0x27
    4996:	80 2f       	mov	r24, r16
    4998:	91 2f       	mov	r25, r17
    499a:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    499e:	18 16       	cp	r1, r24
    49a0:	b4 f5       	brge	.+108    	; 0x4a0e <st_prep_buffer+0xd0e>
    49a2:	4d 80       	ldd	r4, Y+5	; 0x05
    49a4:	5e 80       	ldd	r5, Y+6	; 0x06
    49a6:	6f 80       	ldd	r6, Y+7	; 0x07
    49a8:	78 84       	ldd	r7, Y+8	; 0x08
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the 
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    49aa:	10 92 6d 01 	sts	0x016D, r1
    49ae:	10 92 6e 01 	sts	0x016E, r1
    49b2:	10 92 6f 01 	sts	0x016F, r1
    49b6:	10 92 70 01 	sts	0x0170, r1
        prep.dt_remainder = 0.0;
    49ba:	10 92 64 01 	sts	0x0164, r1
    49be:	10 92 65 01 	sts	0x0165, r1
    49c2:	10 92 66 01 	sts	0x0166, r1
    49c6:	10 92 67 01 	sts	0x0167, r1
        prep.steps_remaining = ceil(steps_remaining);
    49ca:	40 92 58 01 	sts	0x0158, r4
    49ce:	50 92 59 01 	sts	0x0159, r5
    49d2:	60 92 5a 01 	sts	0x015A, r6
    49d6:	70 92 5b 01 	sts	0x015B, r7
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    49da:	00 91 83 01 	lds	r16, 0x0183
    49de:	10 91 84 01 	lds	r17, 0x0184
    49e2:	20 91 5c 01 	lds	r18, 0x015C
    49e6:	30 91 5d 01 	lds	r19, 0x015D
    49ea:	40 91 5e 01 	lds	r20, 0x015E
    49ee:	50 91 5f 01 	lds	r21, 0x015F
    49f2:	c3 01       	movw	r24, r6
    49f4:	b2 01       	movw	r22, r4
    49f6:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    49fa:	d8 01       	movw	r26, r16
    49fc:	95 96       	adiw	r26, 0x25	; 37
    49fe:	6d 93       	st	X+, r22
    4a00:	7d 93       	st	X+, r23
    4a02:	8d 93       	st	X+, r24
    4a04:	9c 93       	st	X, r25
    4a06:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize(); 
    4a08:	0e 94 03 2e 	call	0x5c06	; 0x5c06 <plan_cycle_reinitialize>
        return; // Bail!
    4a0c:	0c c0       	rjmp	.+24     	; 0x4a26 <st_prep_buffer+0xd26>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    4a0e:	10 92 84 01 	sts	0x0184, r1
    4a12:	10 92 83 01 	sts	0x0183, r1
        plan_discard_current_block();
    4a16:	0e 94 66 2a 	call	0x54cc	; 0x54cc <plan_discard_current_block>
  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    4a1a:	90 91 8a 01 	lds	r25, 0x018A
    4a1e:	80 91 88 01 	lds	r24, 0x0188
    4a22:	98 13       	cpse	r25, r24
    4a24:	9c c9       	rjmp	.-3272   	; 0x3d5e <st_prep_buffer+0x5e>
        plan_discard_current_block();
      }
    }

  } 
}      
    4a26:	e6 96       	adiw	r28, 0x36	; 54
    4a28:	0f b6       	in	r0, 0x3f	; 63
    4a2a:	f8 94       	cli
    4a2c:	de bf       	out	0x3e, r29	; 62
    4a2e:	0f be       	out	0x3f, r0	; 63
    4a30:	cd bf       	out	0x3d, r28	; 61
    4a32:	df 91       	pop	r29
    4a34:	cf 91       	pop	r28
    4a36:	1f 91       	pop	r17
    4a38:	0f 91       	pop	r16
    4a3a:	ff 90       	pop	r15
    4a3c:	ef 90       	pop	r14
    4a3e:	df 90       	pop	r13
    4a40:	cf 90       	pop	r12
    4a42:	bf 90       	pop	r11
    4a44:	af 90       	pop	r10
    4a46:	9f 90       	pop	r9
    4a48:	8f 90       	pop	r8
    4a4a:	7f 90       	pop	r7
    4a4c:	6f 90       	pop	r6
    4a4e:	5f 90       	pop	r5
    4a50:	4f 90       	pop	r4
    4a52:	3f 90       	pop	r3
    4a54:	2f 90       	pop	r2
    4a56:	08 95       	ret

00004a58 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4a58:	f9 99       	sbic	0x1f, 1	; 31
    4a5a:	fe cf       	rjmp	.-4      	; 0x4a58 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    4a5c:	92 bd       	out	0x22, r25	; 34
    4a5e:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4a60:	81 e0       	ldi	r24, 0x01	; 1
    4a62:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    4a64:	80 b5       	in	r24, 0x20	; 32
}
    4a66:	08 95       	ret

00004a68 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    4a68:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4a6a:	f9 99       	sbic	0x1f, 1	; 31
    4a6c:	fe cf       	rjmp	.-4      	; 0x4a6a <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    4a6e:	92 bd       	out	0x22, r25	; 34
    4a70:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4a72:	81 e0       	ldi	r24, 0x01	; 1
    4a74:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    4a76:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    4a78:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    4a7a:	98 2f       	mov	r25, r24
    4a7c:	96 23       	and	r25, r22
    4a7e:	59 f0       	breq	.+22     	; 0x4a96 <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    4a80:	6f 3f       	cpi	r22, 0xFF	; 255
    4a82:	29 f0       	breq	.+10     	; 0x4a8e <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    4a84:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a86:	84 e0       	ldi	r24, 0x04	; 4
    4a88:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    4a8a:	f9 9a       	sbi	0x1f, 1	; 31
    4a8c:	0a c0       	rjmp	.+20     	; 0x4aa2 <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a8e:	84 e1       	ldi	r24, 0x14	; 20
    4a90:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    4a92:	f9 9a       	sbi	0x1f, 1	; 31
    4a94:	06 c0       	rjmp	.+12     	; 0x4aa2 <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    4a96:	88 23       	and	r24, r24
    4a98:	21 f0       	breq	.+8      	; 0x4aa2 <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    4a9a:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a9c:	84 e2       	ldi	r24, 0x24	; 36
    4a9e:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4aa0:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    4aa2:	78 94       	sei
    4aa4:	08 95       	ret

00004aa6 <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    4aa6:	8f 92       	push	r8
    4aa8:	9f 92       	push	r9
    4aaa:	af 92       	push	r10
    4aac:	bf 92       	push	r11
    4aae:	cf 92       	push	r12
    4ab0:	df 92       	push	r13
    4ab2:	ef 92       	push	r14
    4ab4:	ff 92       	push	r15
    4ab6:	0f 93       	push	r16
    4ab8:	1f 93       	push	r17
    4aba:	cf 93       	push	r28
    4abc:	df 93       	push	r29
    4abe:	6c 01       	movw	r12, r24
    4ac0:	8b 01       	movw	r16, r22
    4ac2:	5a 01       	movw	r10, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4ac4:	41 15       	cp	r20, r1
    4ac6:	51 05       	cpc	r21, r1
    4ac8:	11 f1       	breq	.+68     	; 0x4b0e <memcpy_to_eeprom_with_checksum+0x68>
    4aca:	ea 01       	movw	r28, r20

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4acc:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    4ace:	88 24       	eor	r8, r8
    4ad0:	83 94       	inc	r8
    4ad2:	91 10       	cpse	r9, r1
    4ad4:	09 c0       	rjmp	.+18     	; 0x4ae8 <memcpy_to_eeprom_with_checksum+0x42>
    4ad6:	69 2d       	mov	r22, r9
    4ad8:	77 27       	eor	r23, r23
    4ada:	67 fd       	sbrc	r22, 7
    4adc:	70 95       	com	r23
    4ade:	97 2e       	mov	r9, r23
    4ae0:	99 1c       	adc	r9, r9
    4ae2:	99 24       	eor	r9, r9
    4ae4:	99 1c       	adc	r9, r9
    4ae6:	01 c0       	rjmp	.+2      	; 0x4aea <memcpy_to_eeprom_with_checksum+0x44>
    4ae8:	98 2c       	mov	r9, r8
    checksum += *source;
    4aea:	f8 01       	movw	r30, r16
    4aec:	61 91       	ld	r22, Z+
    4aee:	8f 01       	movw	r16, r30
    4af0:	96 0e       	add	r9, r22
    eeprom_put_char(destination++, *(source++)); 
    4af2:	7c 01       	movw	r14, r24
    4af4:	ff ef       	ldi	r31, 0xFF	; 255
    4af6:	ef 1a       	sub	r14, r31
    4af8:	ff 0a       	sbc	r15, r31
    4afa:	0e 94 34 25 	call	0x4a68	; 0x4a68 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4afe:	21 97       	sbiw	r28, 0x01	; 1
    4b00:	20 97       	sbiw	r28, 0x00	; 0
    4b02:	11 f0       	breq	.+4      	; 0x4b08 <memcpy_to_eeprom_with_checksum+0x62>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    4b04:	c7 01       	movw	r24, r14
    4b06:	e5 cf       	rjmp	.-54     	; 0x4ad2 <memcpy_to_eeprom_with_checksum+0x2c>
    4b08:	ca 0c       	add	r12, r10
    4b0a:	db 1c       	adc	r13, r11
    4b0c:	01 c0       	rjmp	.+2      	; 0x4b10 <memcpy_to_eeprom_with_checksum+0x6a>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4b0e:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    4b10:	69 2d       	mov	r22, r9
    4b12:	c6 01       	movw	r24, r12
    4b14:	0e 94 34 25 	call	0x4a68	; 0x4a68 <eeprom_put_char>
}
    4b18:	df 91       	pop	r29
    4b1a:	cf 91       	pop	r28
    4b1c:	1f 91       	pop	r17
    4b1e:	0f 91       	pop	r16
    4b20:	ff 90       	pop	r15
    4b22:	ef 90       	pop	r14
    4b24:	df 90       	pop	r13
    4b26:	cf 90       	pop	r12
    4b28:	bf 90       	pop	r11
    4b2a:	af 90       	pop	r10
    4b2c:	9f 90       	pop	r9
    4b2e:	8f 90       	pop	r8
    4b30:	08 95       	ret

00004b32 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    4b32:	8f 92       	push	r8
    4b34:	9f 92       	push	r9
    4b36:	af 92       	push	r10
    4b38:	bf 92       	push	r11
    4b3a:	cf 92       	push	r12
    4b3c:	df 92       	push	r13
    4b3e:	ef 92       	push	r14
    4b40:	ff 92       	push	r15
    4b42:	0f 93       	push	r16
    4b44:	1f 93       	push	r17
    4b46:	cf 93       	push	r28
    4b48:	df 93       	push	r29
    4b4a:	6b 01       	movw	r12, r22
    4b4c:	5a 01       	movw	r10, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4b4e:	41 15       	cp	r20, r1
    4b50:	51 05       	cpc	r21, r1
    4b52:	29 f1       	breq	.+74     	; 0x4b9e <memcpy_from_eeprom_with_checksum+0x6c>
    4b54:	08 2f       	mov	r16, r24
    4b56:	19 2f       	mov	r17, r25
    4b58:	ea 01       	movw	r28, r20
    4b5a:	cb 01       	movw	r24, r22
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4b5c:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    4b5e:	88 24       	eor	r8, r8
    4b60:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    4b62:	7c 01       	movw	r14, r24
    4b64:	2f ef       	ldi	r18, 0xFF	; 255
    4b66:	e2 1a       	sub	r14, r18
    4b68:	f2 0a       	sbc	r15, r18
    4b6a:	0e 94 2c 25 	call	0x4a58	; 0x4a58 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    4b6e:	91 10       	cpse	r9, r1
    4b70:	09 c0       	rjmp	.+18     	; 0x4b84 <memcpy_from_eeprom_with_checksum+0x52>
    4b72:	29 2d       	mov	r18, r9
    4b74:	33 27       	eor	r19, r19
    4b76:	27 fd       	sbrc	r18, 7
    4b78:	30 95       	com	r19
    4b7a:	93 2e       	mov	r9, r19
    4b7c:	99 1c       	adc	r9, r9
    4b7e:	99 24       	eor	r9, r9
    4b80:	99 1c       	adc	r9, r9
    4b82:	01 c0       	rjmp	.+2      	; 0x4b86 <memcpy_from_eeprom_with_checksum+0x54>
    4b84:	98 2c       	mov	r9, r8
    checksum += data;    
    4b86:	98 0e       	add	r9, r24
    *(destination++) = data; 
    4b88:	f8 01       	movw	r30, r16
    4b8a:	81 93       	st	Z+, r24
    4b8c:	8f 01       	movw	r16, r30
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4b8e:	21 97       	sbiw	r28, 0x01	; 1
    4b90:	20 97       	sbiw	r28, 0x00	; 0
    4b92:	11 f0       	breq	.+4      	; 0x4b98 <memcpy_from_eeprom_with_checksum+0x66>
    data = eeprom_get_char(source++);
    4b94:	c7 01       	movw	r24, r14
    4b96:	e5 cf       	rjmp	.-54     	; 0x4b62 <memcpy_from_eeprom_with_checksum+0x30>
    4b98:	ca 0c       	add	r12, r10
    4b9a:	db 1c       	adc	r13, r11
    4b9c:	01 c0       	rjmp	.+2      	; 0x4ba0 <memcpy_from_eeprom_with_checksum+0x6e>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4b9e:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4ba0:	c6 01       	movw	r24, r12
    4ba2:	0e 94 2c 25 	call	0x4a58	; 0x4a58 <eeprom_get_char>
    4ba6:	41 e0       	ldi	r20, 0x01	; 1
    4ba8:	50 e0       	ldi	r21, 0x00	; 0
    4baa:	89 15       	cp	r24, r9
    4bac:	11 f0       	breq	.+4      	; 0x4bb2 <memcpy_from_eeprom_with_checksum+0x80>
    4bae:	40 e0       	ldi	r20, 0x00	; 0
    4bb0:	50 e0       	ldi	r21, 0x00	; 0
}
    4bb2:	ca 01       	movw	r24, r20
    4bb4:	df 91       	pop	r29
    4bb6:	cf 91       	pop	r28
    4bb8:	1f 91       	pop	r17
    4bba:	0f 91       	pop	r16
    4bbc:	ff 90       	pop	r15
    4bbe:	ef 90       	pop	r14
    4bc0:	df 90       	pop	r13
    4bc2:	cf 90       	pop	r12
    4bc4:	bf 90       	pop	r11
    4bc6:	af 90       	pop	r10
    4bc8:	9f 90       	pop	r9
    4bca:	8f 90       	pop	r8
    4bcc:	08 95       	ret

00004bce <settings_store_startup_line>:


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    4bce:	21 e5       	ldi	r18, 0x51	; 81
    4bd0:	82 9f       	mul	r24, r18
    4bd2:	c0 01       	movw	r24, r0
    4bd4:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    4bd6:	40 e5       	ldi	r20, 0x50	; 80
    4bd8:	50 e0       	ldi	r21, 0x00	; 0
    4bda:	9d 5f       	subi	r25, 0xFD	; 253
    4bdc:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <memcpy_to_eeprom_with_checksum>
    4be0:	08 95       	ret

00004be2 <settings_store_build_info>:


// Method to store build info into EEPROM
void settings_store_build_info(char *line)
{
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    4be2:	40 e5       	ldi	r20, 0x50	; 80
    4be4:	50 e0       	ldi	r21, 0x00	; 0
    4be6:	bc 01       	movw	r22, r24
    4be8:	8e ea       	ldi	r24, 0xAE	; 174
    4bea:	93 e0       	ldi	r25, 0x03	; 3
    4bec:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <memcpy_to_eeprom_with_checksum>
    4bf0:	08 95       	ret

00004bf2 <settings_write_coord_data>:


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{  
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    4bf2:	2d e0       	ldi	r18, 0x0D	; 13
    4bf4:	82 9f       	mul	r24, r18
    4bf6:	c0 01       	movw	r24, r0
    4bf8:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    4bfa:	4c e0       	ldi	r20, 0x0C	; 12
    4bfc:	50 e0       	ldi	r21, 0x00	; 0
    4bfe:	9e 5f       	subi	r25, 0xFE	; 254
    4c00:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <memcpy_to_eeprom_with_checksum>
    4c04:	08 95       	ret

00004c06 <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
void write_global_settings() 
{
  eeprom_put_char(0, SETTINGS_VERSION);
    4c06:	69 e0       	ldi	r22, 0x09	; 9
    4c08:	80 e0       	ldi	r24, 0x00	; 0
    4c0a:	90 e0       	ldi	r25, 0x00	; 0
    4c0c:	0e 94 34 25 	call	0x4a68	; 0x4a68 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    4c10:	45 e5       	ldi	r20, 0x55	; 85
    4c12:	50 e0       	ldi	r21, 0x00	; 0
    4c14:	6f ef       	ldi	r22, 0xFF	; 255
    4c16:	78 e0       	ldi	r23, 0x08	; 8
    4c18:	81 e0       	ldi	r24, 0x01	; 1
    4c1a:	90 e0       	ldi	r25, 0x00	; 0
    4c1c:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <memcpy_to_eeprom_with_checksum>
    4c20:	08 95       	ret

00004c22 <settings_restore_global_settings>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults. 
void settings_restore_global_settings() {  
  settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
    4c22:	8a e0       	ldi	r24, 0x0A	; 10
    4c24:	80 93 2f 09 	sts	0x092F, r24
  settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
    4c28:	89 e1       	ldi	r24, 0x19	; 25
    4c2a:	80 93 32 09 	sts	0x0932, r24
  settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
    4c2e:	10 92 30 09 	sts	0x0930, r1
  settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
    4c32:	10 92 31 09 	sts	0x0931, r1
  settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
    4c36:	83 e0       	ldi	r24, 0x03	; 3
    4c38:	80 93 33 09 	sts	0x0933, r24
  settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
    4c3c:	8d ec       	ldi	r24, 0xCD	; 205
    4c3e:	9c ec       	ldi	r25, 0xCC	; 204
    4c40:	ac ec       	ldi	r26, 0xCC	; 204
    4c42:	bd e3       	ldi	r27, 0x3D	; 61
    4c44:	80 93 34 09 	sts	0x0934, r24
    4c48:	90 93 35 09 	sts	0x0935, r25
    4c4c:	a0 93 36 09 	sts	0x0936, r26
    4c50:	b0 93 37 09 	sts	0x0937, r27
  settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
    4c54:	8a e0       	ldi	r24, 0x0A	; 10
    4c56:	97 ed       	ldi	r25, 0xD7	; 215
    4c58:	a3 ea       	ldi	r26, 0xA3	; 163
    4c5a:	bc e3       	ldi	r27, 0x3C	; 60
    4c5c:	80 93 38 09 	sts	0x0938, r24
    4c60:	90 93 39 09 	sts	0x0939, r25
    4c64:	a0 93 3a 09 	sts	0x093A, r26
    4c68:	b0 93 3b 09 	sts	0x093B, r27
  settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
    4c6c:	10 92 3d 09 	sts	0x093D, r1
  settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
    4c70:	80 e0       	ldi	r24, 0x00	; 0
    4c72:	90 e0       	ldi	r25, 0x00	; 0
    4c74:	a8 e4       	ldi	r26, 0x48	; 72
    4c76:	b3 e4       	ldi	r27, 0x43	; 67
    4c78:	80 93 3e 09 	sts	0x093E, r24
    4c7c:	90 93 3f 09 	sts	0x093F, r25
    4c80:	a0 93 40 09 	sts	0x0940, r26
    4c84:	b0 93 41 09 	sts	0x0941, r27
  settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
    4c88:	80 e0       	ldi	r24, 0x00	; 0
    4c8a:	90 e8       	ldi	r25, 0x80	; 128
    4c8c:	ab eb       	ldi	r26, 0xBB	; 187
    4c8e:	b4 e4       	ldi	r27, 0x44	; 68
    4c90:	80 93 42 09 	sts	0x0942, r24
    4c94:	90 93 43 09 	sts	0x0943, r25
    4c98:	a0 93 44 09 	sts	0x0944, r26
    4c9c:	b0 93 45 09 	sts	0x0945, r27
  settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
    4ca0:	84 e6       	ldi	r24, 0x64	; 100
    4ca2:	90 e0       	ldi	r25, 0x00	; 0
    4ca4:	90 93 47 09 	sts	0x0947, r25
    4ca8:	80 93 46 09 	sts	0x0946, r24
  settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
    4cac:	80 e0       	ldi	r24, 0x00	; 0
    4cae:	90 e0       	ldi	r25, 0x00	; 0
    4cb0:	a0 ea       	ldi	r26, 0xA0	; 160
    4cb2:	b0 e4       	ldi	r27, 0x40	; 64
    4cb4:	80 93 48 09 	sts	0x0948, r24
    4cb8:	90 93 49 09 	sts	0x0949, r25
    4cbc:	a0 93 4a 09 	sts	0x094A, r26
    4cc0:	b0 93 4b 09 	sts	0x094B, r27
  settings.z_zero_gauge = DEFAULT_Z_GAUGE;
    4cc4:	80 e0       	ldi	r24, 0x00	; 0
    4cc6:	90 e0       	ldi	r25, 0x00	; 0
    4cc8:	a0 e2       	ldi	r26, 0x20	; 32
    4cca:	b1 e4       	ldi	r27, 0x41	; 65
    4ccc:	80 93 50 09 	sts	0x0950, r24
    4cd0:	90 93 51 09 	sts	0x0951, r25
    4cd4:	a0 93 52 09 	sts	0x0952, r26
    4cd8:	b0 93 53 09 	sts	0x0953, r27
  settings.z_zero_pulloff = DEFAULT_Z_PULLOFF;
    4cdc:	10 92 4c 09 	sts	0x094C, r1
    4ce0:	10 92 4d 09 	sts	0x094D, r1
    4ce4:	10 92 4e 09 	sts	0x094E, r1
    4ce8:	10 92 4f 09 	sts	0x094F, r1
  if (DEFAULT_REPORT_INCHES) { settings.flags |= BITFLAG_REPORT_INCHES; }
  if (DEFAULT_INVERT_ST_ENABLE) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
  if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
  if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
  if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
  if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    4cec:	88 e1       	ldi	r24, 0x18	; 24
    4cee:	80 93 3c 09 	sts	0x093C, r24
  
  settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
    4cf2:	80 e0       	ldi	r24, 0x00	; 0
    4cf4:	90 e0       	ldi	r25, 0x00	; 0
    4cf6:	a0 ea       	ldi	r26, 0xA0	; 160
    4cf8:	b2 e4       	ldi	r27, 0x42	; 66
    4cfa:	80 93 ff 08 	sts	0x08FF, r24
    4cfe:	90 93 00 09 	sts	0x0900, r25
    4d02:	a0 93 01 09 	sts	0x0901, r26
    4d06:	b0 93 02 09 	sts	0x0902, r27
  settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
    4d0a:	80 93 03 09 	sts	0x0903, r24
    4d0e:	90 93 04 09 	sts	0x0904, r25
    4d12:	a0 93 05 09 	sts	0x0905, r26
    4d16:	b0 93 06 09 	sts	0x0906, r27
  settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
    4d1a:	80 e0       	ldi	r24, 0x00	; 0
    4d1c:	90 e0       	ldi	r25, 0x00	; 0
    4d1e:	a8 ec       	ldi	r26, 0xC8	; 200
    4d20:	b2 e4       	ldi	r27, 0x42	; 66
    4d22:	80 93 07 09 	sts	0x0907, r24
    4d26:	90 93 08 09 	sts	0x0908, r25
    4d2a:	a0 93 09 09 	sts	0x0909, r26
    4d2e:	b0 93 0a 09 	sts	0x090A, r27
  settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
    4d32:	40 e0       	ldi	r20, 0x00	; 0
    4d34:	50 e0       	ldi	r21, 0x00	; 0
    4d36:	68 ec       	ldi	r22, 0xC8	; 200
    4d38:	73 e4       	ldi	r23, 0x43	; 67
    4d3a:	40 93 0b 09 	sts	0x090B, r20
    4d3e:	50 93 0c 09 	sts	0x090C, r21
    4d42:	60 93 0d 09 	sts	0x090D, r22
    4d46:	70 93 0e 09 	sts	0x090E, r23
  settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
    4d4a:	40 93 0f 09 	sts	0x090F, r20
    4d4e:	50 93 10 09 	sts	0x0910, r21
    4d52:	60 93 11 09 	sts	0x0911, r22
    4d56:	70 93 12 09 	sts	0x0912, r23
  settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
    4d5a:	80 93 13 09 	sts	0x0913, r24
    4d5e:	90 93 14 09 	sts	0x0914, r25
    4d62:	a0 93 15 09 	sts	0x0915, r26
    4d66:	b0 93 16 09 	sts	0x0916, r27
  settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
    4d6a:	80 e0       	ldi	r24, 0x00	; 0
    4d6c:	98 ec       	ldi	r25, 0xC8	; 200
    4d6e:	af e2       	ldi	r26, 0x2F	; 47
    4d70:	b9 e4       	ldi	r27, 0x49	; 73
    4d72:	80 93 17 09 	sts	0x0917, r24
    4d76:	90 93 18 09 	sts	0x0918, r25
    4d7a:	a0 93 19 09 	sts	0x0919, r26
    4d7e:	b0 93 1a 09 	sts	0x091A, r27
  settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
    4d82:	80 93 1b 09 	sts	0x091B, r24
    4d86:	90 93 1c 09 	sts	0x091C, r25
    4d8a:	a0 93 1d 09 	sts	0x091D, r26
    4d8e:	b0 93 1e 09 	sts	0x091E, r27
  settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
    4d92:	80 93 1f 09 	sts	0x091F, r24
    4d96:	90 93 20 09 	sts	0x0920, r25
    4d9a:	a0 93 21 09 	sts	0x0921, r26
    4d9e:	b0 93 22 09 	sts	0x0922, r27
  settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
    4da2:	80 e0       	ldi	r24, 0x00	; 0
    4da4:	90 e0       	ldi	r25, 0x00	; 0
    4da6:	a8 e4       	ldi	r26, 0x48	; 72
    4da8:	b4 ec       	ldi	r27, 0xC4	; 196
    4daa:	80 93 23 09 	sts	0x0923, r24
    4dae:	90 93 24 09 	sts	0x0924, r25
    4db2:	a0 93 25 09 	sts	0x0925, r26
    4db6:	b0 93 26 09 	sts	0x0926, r27
  settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
    4dba:	80 e0       	ldi	r24, 0x00	; 0
    4dbc:	90 e0       	ldi	r25, 0x00	; 0
    4dbe:	aa ef       	ldi	r26, 0xFA	; 250
    4dc0:	b3 ec       	ldi	r27, 0xC3	; 195
    4dc2:	80 93 27 09 	sts	0x0927, r24
    4dc6:	90 93 28 09 	sts	0x0928, r25
    4dca:	a0 93 29 09 	sts	0x0929, r26
    4dce:	b0 93 2a 09 	sts	0x092A, r27
  settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    
    4dd2:	80 e0       	ldi	r24, 0x00	; 0
    4dd4:	90 e0       	ldi	r25, 0x00	; 0
    4dd6:	a0 ef       	ldi	r26, 0xF0	; 240
    4dd8:	b2 ec       	ldi	r27, 0xC2	; 194
    4dda:	80 93 2b 09 	sts	0x092B, r24
    4dde:	90 93 2c 09 	sts	0x092C, r25
    4de2:	a0 93 2d 09 	sts	0x092D, r26
    4de6:	b0 93 2e 09 	sts	0x092E, r27

  write_global_settings();
    4dea:	0e 94 03 26 	call	0x4c06	; 0x4c06 <write_global_settings>
    4dee:	08 95       	ret

00004df0 <settings_clear_startup_lines>:


// Helper function to clear the EEPROM space containing the startup lines.
void settings_clear_startup_lines() {
  #if N_STARTUP_LINE > 0
  eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    4df0:	60 e0       	ldi	r22, 0x00	; 0
    4df2:	80 e0       	ldi	r24, 0x00	; 0
    4df4:	93 e0       	ldi	r25, 0x03	; 3
    4df6:	0e 94 34 25 	call	0x4a68	; 0x4a68 <eeprom_put_char>
  #endif
  #if N_STARTUP_LINE > 1
  eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    4dfa:	60 e0       	ldi	r22, 0x00	; 0
    4dfc:	81 e5       	ldi	r24, 0x51	; 81
    4dfe:	93 e0       	ldi	r25, 0x03	; 3
    4e00:	0e 94 34 25 	call	0x4a68	; 0x4a68 <eeprom_put_char>
    4e04:	08 95       	ret

00004e06 <settings_clear_build_info>:
  #endif
}


// Helper function to clear the EEPROM space containing the user build info string.
void settings_clear_build_info() { eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0); }
    4e06:	60 e0       	ldi	r22, 0x00	; 0
    4e08:	8e ea       	ldi	r24, 0xAE	; 174
    4e0a:	93 e0       	ldi	r25, 0x03	; 3
    4e0c:	0e 94 34 25 	call	0x4a68	; 0x4a68 <eeprom_put_char>
    4e10:	08 95       	ret

00004e12 <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    4e12:	1f 93       	push	r17
    4e14:	cf 93       	push	r28
    4e16:	df 93       	push	r29
    4e18:	18 2f       	mov	r17, r24
    4e1a:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    4e1c:	81 e5       	ldi	r24, 0x51	; 81
    4e1e:	18 9f       	mul	r17, r24
    4e20:	b0 01       	movw	r22, r0
    4e22:	11 24       	eor	r1, r1
    4e24:	7d 5f       	subi	r23, 0xFD	; 253
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    4e26:	40 e5       	ldi	r20, 0x50	; 80
    4e28:	50 e0       	ldi	r21, 0x00	; 0
    4e2a:	ce 01       	movw	r24, r28
    4e2c:	0e 94 99 25 	call	0x4b32	; 0x4b32 <memcpy_from_eeprom_with_checksum>
    4e30:	89 2b       	or	r24, r25
    4e32:	39 f4       	brne	.+14     	; 0x4e42 <settings_read_startup_line+0x30>
    // Reset line with default value
    line[0] = 0; // Empty line
    4e34:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    4e36:	be 01       	movw	r22, r28
    4e38:	81 2f       	mov	r24, r17
    4e3a:	0e 94 e7 25 	call	0x4bce	; 0x4bce <settings_store_startup_line>
    return(false);
    4e3e:	80 e0       	ldi	r24, 0x00	; 0
    4e40:	01 c0       	rjmp	.+2      	; 0x4e44 <settings_read_startup_line+0x32>
  }
  return(true);
    4e42:	81 e0       	ldi	r24, 0x01	; 1
}
    4e44:	df 91       	pop	r29
    4e46:	cf 91       	pop	r28
    4e48:	1f 91       	pop	r17
    4e4a:	08 95       	ret

00004e4c <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    4e4c:	cf 93       	push	r28
    4e4e:	df 93       	push	r29
    4e50:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    4e52:	40 e5       	ldi	r20, 0x50	; 80
    4e54:	50 e0       	ldi	r21, 0x00	; 0
    4e56:	6e ea       	ldi	r22, 0xAE	; 174
    4e58:	73 e0       	ldi	r23, 0x03	; 3
    4e5a:	0e 94 99 25 	call	0x4b32	; 0x4b32 <memcpy_from_eeprom_with_checksum>
    4e5e:	89 2b       	or	r24, r25
    4e60:	31 f4       	brne	.+12     	; 0x4e6e <settings_read_build_info+0x22>
    // Reset line with default value
    line[0] = 0; // Empty line
    4e62:	18 82       	st	Y, r1
    settings_store_build_info(line);
    4e64:	ce 01       	movw	r24, r28
    4e66:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <settings_store_build_info>
    return(false);
    4e6a:	80 e0       	ldi	r24, 0x00	; 0
    4e6c:	01 c0       	rjmp	.+2      	; 0x4e70 <settings_read_build_info+0x24>
  }
  return(true);
    4e6e:	81 e0       	ldi	r24, 0x01	; 1
}
    4e70:	df 91       	pop	r29
    4e72:	cf 91       	pop	r28
    4e74:	08 95       	ret

00004e76 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    4e76:	1f 93       	push	r17
    4e78:	cf 93       	push	r28
    4e7a:	df 93       	push	r29
    4e7c:	18 2f       	mov	r17, r24
    4e7e:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    4e80:	8d e0       	ldi	r24, 0x0D	; 13
    4e82:	18 9f       	mul	r17, r24
    4e84:	b0 01       	movw	r22, r0
    4e86:	11 24       	eor	r1, r1
    4e88:	7e 5f       	subi	r23, 0xFE	; 254
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    4e8a:	4c e0       	ldi	r20, 0x0C	; 12
    4e8c:	50 e0       	ldi	r21, 0x00	; 0
    4e8e:	ce 01       	movw	r24, r28
    4e90:	0e 94 99 25 	call	0x4b32	; 0x4b32 <memcpy_from_eeprom_with_checksum>
    4e94:	89 2b       	or	r24, r25
    4e96:	59 f4       	brne	.+22     	; 0x4eae <settings_read_coord_data+0x38>
    // Reset with default zero vector
    clear_vector_float(coord_data); 
    4e98:	8c e0       	ldi	r24, 0x0C	; 12
    4e9a:	fe 01       	movw	r30, r28
    4e9c:	11 92       	st	Z+, r1
    4e9e:	8a 95       	dec	r24
    4ea0:	e9 f7       	brne	.-6      	; 0x4e9c <settings_read_coord_data+0x26>
    settings_write_coord_data(coord_select,coord_data);
    4ea2:	be 01       	movw	r22, r28
    4ea4:	81 2f       	mov	r24, r17
    4ea6:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <settings_write_coord_data>
    return(false);
    4eaa:	80 e0       	ldi	r24, 0x00	; 0
    4eac:	01 c0       	rjmp	.+2      	; 0x4eb0 <settings_read_coord_data+0x3a>
  }
  return(true);
    4eae:	81 e0       	ldi	r24, 0x01	; 1
}  
    4eb0:	df 91       	pop	r29
    4eb2:	cf 91       	pop	r28
    4eb4:	1f 91       	pop	r17
    4eb6:	08 95       	ret

00004eb8 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    4eb8:	80 e0       	ldi	r24, 0x00	; 0
    4eba:	90 e0       	ldi	r25, 0x00	; 0
    4ebc:	0e 94 2c 25 	call	0x4a58	; 0x4a58 <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4ec0:	89 30       	cpi	r24, 0x09	; 9
    4ec2:	69 f4       	brne	.+26     	; 0x4ede <read_global_settings+0x26>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4ec4:	45 e5       	ldi	r20, 0x55	; 85
    4ec6:	50 e0       	ldi	r21, 0x00	; 0
    4ec8:	61 e0       	ldi	r22, 0x01	; 1
    4eca:	70 e0       	ldi	r23, 0x00	; 0
    4ecc:	8f ef       	ldi	r24, 0xFF	; 255
    4ece:	98 e0       	ldi	r25, 0x08	; 8
    4ed0:	0e 94 99 25 	call	0x4b32	; 0x4b32 <memcpy_from_eeprom_with_checksum>
    4ed4:	21 e0       	ldi	r18, 0x01	; 1
    4ed6:	89 2b       	or	r24, r25
    4ed8:	19 f4       	brne	.+6      	; 0x4ee0 <read_global_settings+0x28>
    4eda:	20 e0       	ldi	r18, 0x00	; 0
    4edc:	01 c0       	rjmp	.+2      	; 0x4ee0 <read_global_settings+0x28>
      return(false);
    }
  } else {
    return(false); 
    4ede:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    4ee0:	82 2f       	mov	r24, r18
    4ee2:	08 95       	ret

00004ee4 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4ee4:	cf 92       	push	r12
    4ee6:	df 92       	push	r13
    4ee8:	ef 92       	push	r14
    4eea:	ff 92       	push	r15
    4eec:	cf 93       	push	r28
    4eee:	df 93       	push	r29
    4ef0:	d8 2f       	mov	r29, r24
    4ef2:	6a 01       	movw	r12, r20
    4ef4:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    4ef6:	20 e0       	ldi	r18, 0x00	; 0
    4ef8:	30 e0       	ldi	r19, 0x00	; 0
    4efa:	a9 01       	movw	r20, r18
    4efc:	c7 01       	movw	r24, r14
    4efe:	b6 01       	movw	r22, r12
    4f00:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    4f04:	88 23       	and	r24, r24
    4f06:	0c f4       	brge	.+2      	; 0x4f0a <settings_store_global_setting+0x26>
    4f08:	ef c0       	rjmp	.+478    	; 0x50e8 <settings_store_global_setting+0x204>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    4f0a:	d4 36       	cpi	r29, 0x64	; 100
    4f0c:	a0 f0       	brcs	.+40     	; 0x4f36 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    4f0e:	ec e9       	ldi	r30, 0x9C	; 156
    4f10:	ed 0f       	add	r30, r29
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4f12:	e3 30       	cpi	r30, 0x03	; 3
    4f14:	20 f0       	brcs	.+8      	; 0x4f1e <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4f16:	ea 30       	cpi	r30, 0x0A	; 10
    4f18:	08 f0       	brcs	.+2      	; 0x4f1c <settings_store_global_setting+0x38>
    4f1a:	f4 c0       	rjmp	.+488    	; 0x5104 <settings_store_global_setting+0x220>
    4f1c:	e7 c0       	rjmp	.+462    	; 0x50ec <settings_store_global_setting+0x208>
      if (parameter < N_AXIS) {
        // Valid axis setting found.
        switch (set_idx) {
          case 0:
            // if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.steps_per_mm[parameter] = value;
    4f1e:	f0 e0       	ldi	r31, 0x00	; 0
    4f20:	ee 0f       	add	r30, r30
    4f22:	ff 1f       	adc	r31, r31
    4f24:	ee 0f       	add	r30, r30
    4f26:	ff 1f       	adc	r31, r31
    4f28:	e1 50       	subi	r30, 0x01	; 1
    4f2a:	f7 4f       	sbci	r31, 0xF7	; 247
    4f2c:	c0 82       	st	Z, r12
    4f2e:	d1 82       	std	Z+1, r13	; 0x01
    4f30:	e2 82       	std	Z+2, r14	; 0x02
    4f32:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4f34:	d5 c0       	rjmp	.+426    	; 0x50e0 <settings_store_global_setting+0x1fc>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    4f36:	c7 01       	movw	r24, r14
    4f38:	b6 01       	movw	r22, r12
    4f3a:	0e 94 b9 3f 	call	0x7f72	; 0x7f72 <trunc>
    4f3e:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
    switch(parameter) {
    4f42:	8d 2f       	mov	r24, r29
    4f44:	90 e0       	ldi	r25, 0x00	; 0
    4f46:	80 32       	cpi	r24, 0x20	; 32
    4f48:	91 05       	cpc	r25, r1
    4f4a:	08 f0       	brcs	.+2      	; 0x4f4e <settings_store_global_setting+0x6a>
    4f4c:	d1 c0       	rjmp	.+418    	; 0x50f0 <settings_store_global_setting+0x20c>
    4f4e:	fc 01       	movw	r30, r24
    4f50:	e5 52       	subi	r30, 0x25	; 37
    4f52:	ff 4f       	sbci	r31, 0xFF	; 255
    4f54:	0c 94 fa 3f 	jmp	0x7ff4	; 0x7ff4 <__tablejump2__>
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4f58:	63 30       	cpi	r22, 0x03	; 3
    4f5a:	08 f4       	brcc	.+2      	; 0x4f5e <settings_store_global_setting+0x7a>
    4f5c:	cb c0       	rjmp	.+406    	; 0x50f4 <settings_store_global_setting+0x210>
        settings.pulse_microseconds = int_value; break;
    4f5e:	60 93 2f 09 	sts	0x092F, r22
    4f62:	be c0       	rjmp	.+380    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4f64:	60 93 32 09 	sts	0x0932, r22
    4f68:	bb c0       	rjmp	.+374    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 2: 
        settings.step_invert_mask = int_value; 
    4f6a:	60 93 30 09 	sts	0x0930, r22
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4f6e:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <st_generate_step_dir_invert_masks>
        break;
    4f72:	b6 c0       	rjmp	.+364    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 3: 
        settings.dir_invert_mask = int_value; 
    4f74:	60 93 31 09 	sts	0x0931, r22
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4f78:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <st_generate_step_dir_invert_masks>
        break;
    4f7c:	b1 c0       	rjmp	.+354    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4f7e:	66 23       	and	r22, r22
    4f80:	31 f0       	breq	.+12     	; 0x4f8e <settings_store_global_setting+0xaa>
    4f82:	ec e3       	ldi	r30, 0x3C	; 60
    4f84:	f9 e0       	ldi	r31, 0x09	; 9
    4f86:	80 81       	ld	r24, Z
    4f88:	84 60       	ori	r24, 0x04	; 4
    4f8a:	80 83       	st	Z, r24
    4f8c:	a9 c0       	rjmp	.+338    	; 0x50e0 <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4f8e:	ec e3       	ldi	r30, 0x3C	; 60
    4f90:	f9 e0       	ldi	r31, 0x09	; 9
    4f92:	80 81       	ld	r24, Z
    4f94:	8b 7f       	andi	r24, 0xFB	; 251
    4f96:	80 83       	st	Z, r24
    4f98:	a3 c0       	rjmp	.+326    	; 0x50e0 <settings_store_global_setting+0x1fc>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4f9a:	66 23       	and	r22, r22
    4f9c:	31 f0       	breq	.+12     	; 0x4faa <settings_store_global_setting+0xc6>
    4f9e:	ec e3       	ldi	r30, 0x3C	; 60
    4fa0:	f9 e0       	ldi	r31, 0x09	; 9
    4fa2:	80 81       	ld	r24, Z
    4fa4:	80 64       	ori	r24, 0x40	; 64
    4fa6:	80 83       	st	Z, r24
    4fa8:	9b c0       	rjmp	.+310    	; 0x50e0 <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4faa:	ec e3       	ldi	r30, 0x3C	; 60
    4fac:	f9 e0       	ldi	r31, 0x09	; 9
    4fae:	80 81       	ld	r24, Z
    4fb0:	8f 7b       	andi	r24, 0xBF	; 191
    4fb2:	80 83       	st	Z, r24
    4fb4:	95 c0       	rjmp	.+298    	; 0x50e0 <settings_store_global_setting+0x1fc>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4fb6:	66 23       	and	r22, r22
    4fb8:	31 f0       	breq	.+12     	; 0x4fc6 <settings_store_global_setting+0xe2>
    4fba:	ec e3       	ldi	r30, 0x3C	; 60
    4fbc:	f9 e0       	ldi	r31, 0x09	; 9
    4fbe:	80 81       	ld	r24, Z
    4fc0:	80 68       	ori	r24, 0x80	; 128
    4fc2:	80 83       	st	Z, r24
    4fc4:	8d c0       	rjmp	.+282    	; 0x50e0 <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4fc6:	ec e3       	ldi	r30, 0x3C	; 60
    4fc8:	f9 e0       	ldi	r31, 0x09	; 9
    4fca:	80 81       	ld	r24, Z
    4fcc:	8f 77       	andi	r24, 0x7F	; 127
    4fce:	80 83       	st	Z, r24
    4fd0:	87 c0       	rjmp	.+270    	; 0x50e0 <settings_store_global_setting+0x1fc>
        break;
      case 10: settings.status_report_mask = int_value; break;
    4fd2:	60 93 33 09 	sts	0x0933, r22
    4fd6:	84 c0       	rjmp	.+264    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 11: settings.junction_deviation = value; break;
    4fd8:	c0 92 34 09 	sts	0x0934, r12
    4fdc:	d0 92 35 09 	sts	0x0935, r13
    4fe0:	e0 92 36 09 	sts	0x0936, r14
    4fe4:	f0 92 37 09 	sts	0x0937, r15
    4fe8:	7b c0       	rjmp	.+246    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 12: settings.arc_tolerance = value; break;
    4fea:	c0 92 38 09 	sts	0x0938, r12
    4fee:	d0 92 39 09 	sts	0x0939, r13
    4ff2:	e0 92 3a 09 	sts	0x093A, r14
    4ff6:	f0 92 3b 09 	sts	0x093B, r15
    4ffa:	72 c0       	rjmp	.+228    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4ffc:	66 23       	and	r22, r22
    4ffe:	31 f0       	breq	.+12     	; 0x500c <settings_store_global_setting+0x128>
    5000:	ec e3       	ldi	r30, 0x3C	; 60
    5002:	f9 e0       	ldi	r31, 0x09	; 9
    5004:	80 81       	ld	r24, Z
    5006:	81 60       	ori	r24, 0x01	; 1
    5008:	80 83       	st	Z, r24
    500a:	6a c0       	rjmp	.+212    	; 0x50e0 <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    500c:	ec e3       	ldi	r30, 0x3C	; 60
    500e:	f9 e0       	ldi	r31, 0x09	; 9
    5010:	80 81       	ld	r24, Z
    5012:	8e 7f       	andi	r24, 0xFE	; 254
    5014:	80 83       	st	Z, r24
    5016:	64 c0       	rjmp	.+200    	; 0x50e0 <settings_store_global_setting+0x1fc>
        break;
      case 20:
        if (int_value) { 
    5018:	66 23       	and	r22, r22
    501a:	41 f0       	breq	.+16     	; 0x502c <settings_store_global_setting+0x148>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    501c:	80 91 3c 09 	lds	r24, 0x093C
    5020:	84 ff       	sbrs	r24, 4
    5022:	6a c0       	rjmp	.+212    	; 0x50f8 <settings_store_global_setting+0x214>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; 
    5024:	80 62       	ori	r24, 0x20	; 32
    5026:	80 93 3c 09 	sts	0x093C, r24
    502a:	5a c0       	rjmp	.+180    	; 0x50e0 <settings_store_global_setting+0x1fc>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    502c:	ec e3       	ldi	r30, 0x3C	; 60
    502e:	f9 e0       	ldi	r31, 0x09	; 9
    5030:	80 81       	ld	r24, Z
    5032:	8f 7d       	andi	r24, 0xDF	; 223
    5034:	80 83       	st	Z, r24
    5036:	54 c0       	rjmp	.+168    	; 0x50e0 <settings_store_global_setting+0x1fc>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    5038:	66 23       	and	r22, r22
    503a:	31 f0       	breq	.+12     	; 0x5048 <settings_store_global_setting+0x164>
    503c:	ec e3       	ldi	r30, 0x3C	; 60
    503e:	f9 e0       	ldi	r31, 0x09	; 9
    5040:	80 81       	ld	r24, Z
    5042:	88 60       	ori	r24, 0x08	; 8
    5044:	80 83       	st	Z, r24
    5046:	05 c0       	rjmp	.+10     	; 0x5052 <settings_store_global_setting+0x16e>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    5048:	ec e3       	ldi	r30, 0x3C	; 60
    504a:	f9 e0       	ldi	r31, 0x09	; 9
    504c:	80 81       	ld	r24, Z
    504e:	87 7f       	andi	r24, 0xF7	; 247
    5050:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    5052:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <limits_init>
        break;
    5056:	44 c0       	rjmp	.+136    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    5058:	66 23       	and	r22, r22
    505a:	31 f0       	breq	.+12     	; 0x5068 <settings_store_global_setting+0x184>
    505c:	ec e3       	ldi	r30, 0x3C	; 60
    505e:	f9 e0       	ldi	r31, 0x09	; 9
    5060:	80 81       	ld	r24, Z
    5062:	80 61       	ori	r24, 0x10	; 16
    5064:	80 83       	st	Z, r24
    5066:	3c c0       	rjmp	.+120    	; 0x50e0 <settings_store_global_setting+0x1fc>
        else { 
          settings.flags &= ~BITFLAG_HOMING_ENABLE; 
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    5068:	ec e3       	ldi	r30, 0x3C	; 60
    506a:	f9 e0       	ldi	r31, 0x09	; 9
    506c:	80 81       	ld	r24, Z
    506e:	8f 7c       	andi	r24, 0xCF	; 207
    5070:	80 83       	st	Z, r24
    5072:	36 c0       	rjmp	.+108    	; 0x50e0 <settings_store_global_setting+0x1fc>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    5074:	60 93 3d 09 	sts	0x093D, r22
    5078:	33 c0       	rjmp	.+102    	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 24: settings.homing_feed_rate = value; break;
    507a:	c0 92 3e 09 	sts	0x093E, r12
    507e:	d0 92 3f 09 	sts	0x093F, r13
    5082:	e0 92 40 09 	sts	0x0940, r14
    5086:	f0 92 41 09 	sts	0x0941, r15
    508a:	2a c0       	rjmp	.+84     	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 25: settings.homing_seek_rate = value; break;
    508c:	c0 92 42 09 	sts	0x0942, r12
    5090:	d0 92 43 09 	sts	0x0943, r13
    5094:	e0 92 44 09 	sts	0x0944, r14
    5098:	f0 92 45 09 	sts	0x0945, r15
    509c:	21 c0       	rjmp	.+66     	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 26: settings.homing_debounce_delay = int_value; break;
    509e:	86 2f       	mov	r24, r22
    50a0:	90 e0       	ldi	r25, 0x00	; 0
    50a2:	90 93 47 09 	sts	0x0947, r25
    50a6:	80 93 46 09 	sts	0x0946, r24
    50aa:	1a c0       	rjmp	.+52     	; 0x50e0 <settings_store_global_setting+0x1fc>
      case 27: settings.homing_pulloff = value; break;
    50ac:	c0 92 48 09 	sts	0x0948, r12
    50b0:	d0 92 49 09 	sts	0x0949, r13
    50b4:	e0 92 4a 09 	sts	0x094A, r14
    50b8:	f0 92 4b 09 	sts	0x094B, r15
    50bc:	11 c0       	rjmp	.+34     	; 0x50e0 <settings_store_global_setting+0x1fc>
	  case 30: settings.z_zero_gauge = value; break;
    50be:	c0 92 50 09 	sts	0x0950, r12
    50c2:	d0 92 51 09 	sts	0x0951, r13
    50c6:	e0 92 52 09 	sts	0x0952, r14
    50ca:	f0 92 53 09 	sts	0x0953, r15
    50ce:	08 c0       	rjmp	.+16     	; 0x50e0 <settings_store_global_setting+0x1fc>
	  case 31: settings.z_zero_pulloff = value; break;
    50d0:	c0 92 4c 09 	sts	0x094C, r12
    50d4:	d0 92 4d 09 	sts	0x094D, r13
    50d8:	e0 92 4e 09 	sts	0x094E, r14
    50dc:	f0 92 4f 09 	sts	0x094F, r15
      default: 
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    50e0:	0e 94 03 26 	call	0x4c06	; 0x4c06 <write_global_settings>
  return(STATUS_OK);
    50e4:	80 e0       	ldi	r24, 0x00	; 0
    50e6:	56 c0       	rjmp	.+172    	; 0x5194 <settings_store_global_setting+0x2b0>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    50e8:	84 e0       	ldi	r24, 0x04	; 4
    50ea:	54 c0       	rjmp	.+168    	; 0x5194 <settings_store_global_setting+0x2b0>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50ec:	83 e0       	ldi	r24, 0x03	; 3
    50ee:	52 c0       	rjmp	.+164    	; 0x5194 <settings_store_global_setting+0x2b0>
      case 26: settings.homing_debounce_delay = int_value; break;
      case 27: settings.homing_pulloff = value; break;
	  case 30: settings.z_zero_gauge = value; break;
	  case 31: settings.z_zero_pulloff = value; break;
      default: 
        return(STATUS_INVALID_STATEMENT);
    50f0:	83 e0       	ldi	r24, 0x03	; 3
    50f2:	50 c0       	rjmp	.+160    	; 0x5194 <settings_store_global_setting+0x2b0>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    50f4:	86 e0       	ldi	r24, 0x06	; 6
    50f6:	4e c0       	rjmp	.+156    	; 0x5194 <settings_store_global_setting+0x2b0>
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        break;
      case 20:
        if (int_value) { 
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    50f8:	8a e0       	ldi	r24, 0x0A	; 10
    50fa:	4c c0       	rjmp	.+152    	; 0x5194 <settings_store_global_setting+0x2b0>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50fc:	83 e0       	ldi	r24, 0x03	; 3
    50fe:	4a c0       	rjmp	.+148    	; 0x5194 <settings_store_global_setting+0x2b0>
    5100:	83 e0       	ldi	r24, 0x03	; 3
    5102:	48 c0       	rjmp	.+144    	; 0x5194 <settings_store_global_setting+0x2b0>
        parameter -= AXIS_SETTINGS_INCREMENT;
    5104:	e2 e9       	ldi	r30, 0x92	; 146
    5106:	ed 0f       	add	r30, r29
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    5108:	e3 30       	cpi	r30, 0x03	; 3
    510a:	68 f0       	brcs	.+26     	; 0x5126 <settings_store_global_setting+0x242>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    510c:	ea 30       	cpi	r30, 0x0A	; 10
    510e:	b0 f3       	brcs	.-20     	; 0x50fc <settings_store_global_setting+0x218>
        parameter -= AXIS_SETTINGS_INCREMENT;
    5110:	c8 e8       	ldi	r28, 0x88	; 136
    5112:	cd 0f       	add	r28, r29
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    5114:	c3 30       	cpi	r28, 0x03	; 3
    5116:	98 f0       	brcs	.+38     	; 0x513e <settings_store_global_setting+0x25a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5118:	ca 30       	cpi	r28, 0x0A	; 10
    511a:	90 f3       	brcs	.-28     	; 0x5100 <settings_store_global_setting+0x21c>
        parameter -= AXIS_SETTINGS_INCREMENT;
    511c:	d2 58       	subi	r29, 0x82	; 130
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    511e:	d3 30       	cpi	r29, 0x03	; 3
    5120:	40 f1       	brcs	.+80     	; 0x5172 <settings_store_global_setting+0x28e>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5122:	83 e0       	ldi	r24, 0x03	; 3
    5124:	37 c0       	rjmp	.+110    	; 0x5194 <settings_store_global_setting+0x2b0>
            // if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.steps_per_mm[parameter] = value;
            break;
          case 1:
            // if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.max_rate[parameter] = value;
    5126:	f0 e0       	ldi	r31, 0x00	; 0
    5128:	ee 0f       	add	r30, r30
    512a:	ff 1f       	adc	r31, r31
    512c:	ee 0f       	add	r30, r30
    512e:	ff 1f       	adc	r31, r31
    5130:	e5 5f       	subi	r30, 0xF5	; 245
    5132:	f6 4f       	sbci	r31, 0xF6	; 246
    5134:	c0 82       	st	Z, r12
    5136:	d1 82       	std	Z+1, r13	; 0x01
    5138:	e2 82       	std	Z+2, r14	; 0x02
    513a:	f3 82       	std	Z+3, r15	; 0x03
            break;
    513c:	d1 cf       	rjmp	.-94     	; 0x50e0 <settings_store_global_setting+0x1fc>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    513e:	d0 e0       	ldi	r29, 0x00	; 0
    5140:	cc 0f       	add	r28, r28
    5142:	dd 1f       	adc	r29, r29
    5144:	cc 0f       	add	r28, r28
    5146:	dd 1f       	adc	r29, r29
    5148:	c9 5e       	subi	r28, 0xE9	; 233
    514a:	d6 4f       	sbci	r29, 0xF6	; 246
    514c:	20 e0       	ldi	r18, 0x00	; 0
    514e:	30 e0       	ldi	r19, 0x00	; 0
    5150:	40 e7       	ldi	r20, 0x70	; 112
    5152:	52 e4       	ldi	r21, 0x42	; 66
    5154:	c7 01       	movw	r24, r14
    5156:	b6 01       	movw	r22, r12
    5158:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    515c:	20 e0       	ldi	r18, 0x00	; 0
    515e:	30 e0       	ldi	r19, 0x00	; 0
    5160:	40 e7       	ldi	r20, 0x70	; 112
    5162:	52 e4       	ldi	r21, 0x42	; 66
    5164:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5168:	68 83       	st	Y, r22
    516a:	79 83       	std	Y+1, r23	; 0x01
    516c:	8a 83       	std	Y+2, r24	; 0x02
    516e:	9b 83       	std	Y+3, r25	; 0x03
    5170:	b7 cf       	rjmp	.-146    	; 0x50e0 <settings_store_global_setting+0x1fc>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    5172:	ed 2f       	mov	r30, r29
    5174:	f0 e0       	ldi	r31, 0x00	; 0
    5176:	ee 0f       	add	r30, r30
    5178:	ff 1f       	adc	r31, r31
    517a:	ee 0f       	add	r30, r30
    517c:	ff 1f       	adc	r31, r31
    517e:	ed 5d       	subi	r30, 0xDD	; 221
    5180:	f6 4f       	sbci	r31, 0xF6	; 246
    5182:	f7 fa       	bst	r15, 7
    5184:	f0 94       	com	r15
    5186:	f7 f8       	bld	r15, 7
    5188:	f0 94       	com	r15
    518a:	c0 82       	st	Z, r12
    518c:	d1 82       	std	Z+1, r13	; 0x01
    518e:	e2 82       	std	Z+2, r14	; 0x02
    5190:	f3 82       	std	Z+3, r15	; 0x03
    5192:	a6 cf       	rjmp	.-180    	; 0x50e0 <settings_store_global_setting+0x1fc>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    5194:	df 91       	pop	r29
    5196:	cf 91       	pop	r28
    5198:	ff 90       	pop	r15
    519a:	ef 90       	pop	r14
    519c:	df 90       	pop	r13
    519e:	cf 90       	pop	r12
    51a0:	08 95       	ret

000051a2 <settings_init>:


// Initialize the config subsystem
void settings_init() {
    51a2:	1f 93       	push	r17
    51a4:	cf 93       	push	r28
    51a6:	df 93       	push	r29
    51a8:	cd b7       	in	r28, 0x3d	; 61
    51aa:	de b7       	in	r29, 0x3e	; 62
    51ac:	2c 97       	sbiw	r28, 0x0c	; 12
    51ae:	0f b6       	in	r0, 0x3f	; 63
    51b0:	f8 94       	cli
    51b2:	de bf       	out	0x3e, r29	; 62
    51b4:	0f be       	out	0x3f, r0	; 63
    51b6:	cd bf       	out	0x3d, r28	; 61
  if(!read_global_settings()) {
    51b8:	0e 94 5c 27 	call	0x4eb8	; 0x4eb8 <read_global_settings>
    51bc:	81 11       	cpse	r24, r1
    51be:	1b c0       	rjmp	.+54     	; 0x51f6 <settings_init+0x54>
    report_status_message(STATUS_SETTING_READ_FAIL);
    51c0:	87 e0       	ldi	r24, 0x07	; 7
    51c2:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>

    settings_restore_global_settings();
    51c6:	0e 94 11 26 	call	0x4c22	; 0x4c22 <settings_restore_global_settings>
    
    // Force clear startup lines and build info user data. Parameters should be ok.
    // TODO: For next version, remove these clears. Only here because line buffer increased.
    settings_clear_startup_lines();
    51ca:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <settings_clear_startup_lines>
    settings_clear_build_info();
    51ce:	0e 94 03 27 	call	0x4e06	; 0x4e06 <settings_clear_build_info>
    
    report_grbl_settings();
    51d2:	0e 94 41 35 	call	0x6a82	; 0x6a82 <report_grbl_settings>
    51d6:	0f c0       	rjmp	.+30     	; 0x51f6 <settings_init+0x54>

  // Check all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.
  float coord_data[N_AXIS];
  uint8_t i;
  for (i=0; i<=SETTING_INDEX_NCOORD; i++) {
    if (!settings_read_coord_data(i, coord_data)) {
    51d8:	be 01       	movw	r22, r28
    51da:	6f 5f       	subi	r22, 0xFF	; 255
    51dc:	7f 4f       	sbci	r23, 0xFF	; 255
    51de:	81 2f       	mov	r24, r17
    51e0:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <settings_read_coord_data>
    51e4:	81 11       	cpse	r24, r1
    51e6:	03 c0       	rjmp	.+6      	; 0x51ee <settings_init+0x4c>
      report_status_message(STATUS_SETTING_READ_FAIL);
    51e8:	87 e0       	ldi	r24, 0x07	; 7
    51ea:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
  }

  // Check all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.
  float coord_data[N_AXIS];
  uint8_t i;
  for (i=0; i<=SETTING_INDEX_NCOORD; i++) {
    51ee:	1f 5f       	subi	r17, 0xFF	; 255
    51f0:	18 30       	cpi	r17, 0x08	; 8
    51f2:	91 f7       	brne	.-28     	; 0x51d8 <settings_init+0x36>
    51f4:	02 c0       	rjmp	.+4      	; 0x51fa <settings_init+0x58>
  return(STATUS_OK);
}


// Initialize the config subsystem
void settings_init() {
    51f6:	10 e0       	ldi	r17, 0x00	; 0
    51f8:	ef cf       	rjmp	.-34     	; 0x51d8 <settings_init+0x36>
      report_status_message(STATUS_SETTING_READ_FAIL);
    }
  }
  // NOTE: Startup lines are checked and executed by protocol_main_loop at the end of initialization.
  // TODO: Build info should be checked here, but will wait until v1.0 to address this. Ok for now.
}
    51fa:	2c 96       	adiw	r28, 0x0c	; 12
    51fc:	0f b6       	in	r0, 0x3f	; 63
    51fe:	f8 94       	cli
    5200:	de bf       	out	0x3e, r29	; 62
    5202:	0f be       	out	0x3f, r0	; 63
    5204:	cd bf       	out	0x3d, r28	; 61
    5206:	df 91       	pop	r29
    5208:	cf 91       	pop	r28
    520a:	1f 91       	pop	r17
    520c:	08 95       	ret

0000520e <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    520e:	88 23       	and	r24, r24
    5210:	21 f0       	breq	.+8      	; 0x521a <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    5212:	81 30       	cpi	r24, 0x01	; 1
    5214:	21 f4       	brne	.+8      	; 0x521e <get_step_pin_mask+0x10>
    5216:	80 e1       	ldi	r24, 0x10	; 16
    5218:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    521a:	80 e4       	ldi	r24, 0x40	; 64
    521c:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
  return((1<<Z_STEP_BIT));
    521e:	84 e0       	ldi	r24, 0x04	; 4
}
    5220:	08 95       	ret

00005222 <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    5222:	88 23       	and	r24, r24
    5224:	21 f0       	breq	.+8      	; 0x522e <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    5226:	81 30       	cpi	r24, 0x01	; 1
    5228:	21 f4       	brne	.+8      	; 0x5232 <get_direction_pin_mask+0x10>
    522a:	80 e2       	ldi	r24, 0x20	; 32
    522c:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    522e:	80 e8       	ldi	r24, 0x80	; 128
    5230:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
  return((1<<Z_DIRECTION_BIT));
    5232:	88 e0       	ldi	r24, 0x08	; 8
}
    5234:	08 95       	ret

00005236 <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    5236:	88 23       	and	r24, r24
    5238:	21 f0       	breq	.+8      	; 0x5242 <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    523a:	81 30       	cpi	r24, 0x01	; 1
    523c:	21 f4       	brne	.+8      	; 0x5246 <get_limit_pin_mask+0x10>
    523e:	84 e0       	ldi	r24, 0x04	; 4
    5240:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    5242:	82 e0       	ldi	r24, 0x02	; 2
    5244:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
  return((1<<Z_LIMIT_BIT));
    5246:	88 e0       	ldi	r24, 0x08	; 8
}
    5248:	08 95       	ret

0000524a <planner_recalculate>:
  to compute an optimal plan, so select carefully. The Arduino 328p memory is already maxed out, but future
  ARM versions should have enough memory and speed for look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate() 
{   
    524a:	3f 92       	push	r3
    524c:	4f 92       	push	r4
    524e:	5f 92       	push	r5
    5250:	6f 92       	push	r6
    5252:	7f 92       	push	r7
    5254:	8f 92       	push	r8
    5256:	9f 92       	push	r9
    5258:	af 92       	push	r10
    525a:	bf 92       	push	r11
    525c:	cf 92       	push	r12
    525e:	df 92       	push	r13
    5260:	ef 92       	push	r14
    5262:	ff 92       	push	r15
    5264:	0f 93       	push	r16
    5266:	1f 93       	push	r17
    5268:	cf 93       	push	r28
    526a:	df 93       	push	r29
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
    526c:	80 91 45 02 	lds	r24, 0x0245


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    5270:	81 11       	cpse	r24, r1
    5272:	01 c0       	rjmp	.+2      	; 0x5276 <planner_recalculate+0x2c>
    5274:	80 e2       	ldi	r24, 0x20	; 32
  block_index--;
    5276:	77 24       	eor	r7, r7
    5278:	7a 94       	dec	r7
    527a:	78 0e       	add	r7, r24
{   
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
        
  // Bail. Can't do anything with one only one plan-able block.
  if (block_index == block_buffer_planned) { return; }
    527c:	c0 91 43 02 	lds	r28, 0x0243
    5280:	c7 15       	cp	r28, r7
    5282:	09 f4       	brne	.+2      	; 0x5286 <planner_recalculate+0x3c>
    5284:	00 c1       	rjmp	.+512    	; 0x5486 <planner_recalculate+0x23c>
  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
  float entry_speed_sqr;
  plan_block_t *next;
  plan_block_t *current = &block_buffer[block_index];
    5286:	89 e2       	ldi	r24, 0x29	; 41
    5288:	78 9e       	mul	r7, r24
    528a:	80 01       	movw	r16, r0
    528c:	11 24       	eor	r1, r1
    528e:	09 5b       	subi	r16, 0xB9	; 185
    5290:	1d 4f       	sbci	r17, 0xFD	; 253

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
    5292:	f8 01       	movw	r30, r16
    5294:	95 88       	ldd	r9, Z+21	; 0x15
    5296:	a6 88       	ldd	r10, Z+22	; 0x16
    5298:	b7 88       	ldd	r11, Z+23	; 0x17
    529a:	c0 8c       	ldd	r12, Z+24	; 0x18
    529c:	61 a1       	ldd	r22, Z+33	; 0x21
    529e:	72 a1       	ldd	r23, Z+34	; 0x22
    52a0:	83 a1       	ldd	r24, Z+35	; 0x23
    52a2:	94 a1       	ldd	r25, Z+36	; 0x24
    52a4:	9b 01       	movw	r18, r22
    52a6:	ac 01       	movw	r20, r24
    52a8:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    52ac:	f8 01       	movw	r30, r16
    52ae:	25 a1       	ldd	r18, Z+37	; 0x25
    52b0:	36 a1       	ldd	r19, Z+38	; 0x26
    52b2:	47 a1       	ldd	r20, Z+39	; 0x27
    52b4:	50 a5       	ldd	r21, Z+40	; 0x28
    52b6:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    52ba:	d6 2e       	mov	r13, r22
    52bc:	e7 2e       	mov	r14, r23
    52be:	f8 2e       	mov	r15, r24
    52c0:	d9 2f       	mov	r29, r25
    52c2:	26 2f       	mov	r18, r22
    52c4:	37 2f       	mov	r19, r23
    52c6:	48 2f       	mov	r20, r24
    52c8:	59 2f       	mov	r21, r25
    52ca:	69 2d       	mov	r22, r9
    52cc:	7a 2d       	mov	r23, r10
    52ce:	8b 2d       	mov	r24, r11
    52d0:	9c 2d       	mov	r25, r12
    52d2:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    52d6:	88 23       	and	r24, r24
    52d8:	24 f4       	brge	.+8      	; 0x52e2 <planner_recalculate+0x98>
    52da:	d9 2c       	mov	r13, r9
    52dc:	ea 2c       	mov	r14, r10
    52de:	fb 2c       	mov	r15, r11
    52e0:	dc 2d       	mov	r29, r12
    52e2:	4d 2d       	mov	r20, r13
    52e4:	5e 2d       	mov	r21, r14
    52e6:	6f 2d       	mov	r22, r15
    52e8:	7d 2f       	mov	r23, r29
    52ea:	f8 01       	movw	r30, r16
    52ec:	41 8b       	std	Z+17, r20	; 0x11
    52ee:	52 8b       	std	Z+18, r21	; 0x12
    52f0:	63 8b       	std	Z+19, r22	; 0x13
    52f2:	74 8b       	std	Z+20, r23	; 0x14


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    52f4:	71 10       	cpse	r7, r1
    52f6:	03 c0       	rjmp	.+6      	; 0x52fe <planner_recalculate+0xb4>
    52f8:	68 94       	set
    52fa:	77 24       	eor	r7, r7
    52fc:	75 f8       	bld	r7, 5
  block_index--;
    52fe:	7a 94       	dec	r7

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    5300:	c7 15       	cp	r28, r7
    5302:	29 f0       	breq	.+10     	; 0x530e <planner_recalculate+0xc4>
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
    5304:	0f 2e       	mov	r0, r31
    5306:	f9 e2       	ldi	r31, 0x29	; 41
    5308:	6f 2e       	mov	r6, r31
    530a:	f0 2d       	mov	r31, r0
    530c:	4f c0       	rjmp	.+158    	; 0x53ac <planner_recalculate+0x162>
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
    530e:	80 91 46 02 	lds	r24, 0x0246
    5312:	c8 13       	cpse	r28, r24
    5314:	4f c0       	rjmp	.+158    	; 0x53b4 <planner_recalculate+0x16a>
    5316:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <st_update_plan_block_parameters>
    531a:	4c c0       	rjmp	.+152    	; 0x53b4 <planner_recalculate+0x16a>
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
    531c:	67 9c       	mul	r6, r7
    531e:	e0 01       	movw	r28, r0
    5320:	11 24       	eor	r1, r1
    5322:	c9 5b       	subi	r28, 0xB9	; 185
    5324:	dd 4f       	sbci	r29, 0xFD	; 253


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    5326:	71 10       	cpse	r7, r1
    5328:	03 c0       	rjmp	.+6      	; 0x5330 <planner_recalculate+0xe6>
    532a:	68 94       	set
    532c:	77 24       	eor	r7, r7
    532e:	75 f8       	bld	r7, 5
  block_index--;
    5330:	7a 94       	dec	r7
      next = current;
      current = &block_buffer[block_index];
      block_index = plan_prev_block_index(block_index);

      // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
      if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); } 
    5332:	80 91 46 02 	lds	r24, 0x0246
    5336:	87 11       	cpse	r24, r7
    5338:	02 c0       	rjmp	.+4      	; 0x533e <planner_recalculate+0xf4>
    533a:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <st_update_plan_block_parameters>

      // Compute maximum entry speed decelerating over the current block from its exit speed.
      if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
    533e:	cd 88       	ldd	r12, Y+21	; 0x15
    5340:	de 88       	ldd	r13, Y+22	; 0x16
    5342:	ef 88       	ldd	r14, Y+23	; 0x17
    5344:	f8 8c       	ldd	r15, Y+24	; 0x18
    5346:	a7 01       	movw	r20, r14
    5348:	96 01       	movw	r18, r12
    534a:	69 89       	ldd	r22, Y+17	; 0x11
    534c:	7a 89       	ldd	r23, Y+18	; 0x12
    534e:	8b 89       	ldd	r24, Y+19	; 0x13
    5350:	9c 89       	ldd	r25, Y+20	; 0x14
    5352:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    5356:	88 23       	and	r24, r24
    5358:	41 f1       	breq	.+80     	; 0x53aa <planner_recalculate+0x160>
        entry_speed_sqr = next->entry_speed_sqr + 2*current->acceleration*current->millimeters;
    535a:	69 a1       	ldd	r22, Y+33	; 0x21
    535c:	7a a1       	ldd	r23, Y+34	; 0x22
    535e:	8b a1       	ldd	r24, Y+35	; 0x23
    5360:	9c a1       	ldd	r25, Y+36	; 0x24
    5362:	9b 01       	movw	r18, r22
    5364:	ac 01       	movw	r20, r24
    5366:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    536a:	2d a1       	ldd	r18, Y+37	; 0x25
    536c:	3e a1       	ldd	r19, Y+38	; 0x26
    536e:	4f a1       	ldd	r20, Y+39	; 0x27
    5370:	58 a5       	ldd	r21, Y+40	; 0x28
    5372:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5376:	f8 01       	movw	r30, r16
    5378:	21 89       	ldd	r18, Z+17	; 0x11
    537a:	32 89       	ldd	r19, Z+18	; 0x12
    537c:	43 89       	ldd	r20, Z+19	; 0x13
    537e:	54 89       	ldd	r21, Z+20	; 0x14
    5380:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    5384:	4b 01       	movw	r8, r22
    5386:	5c 01       	movw	r10, r24
        if (entry_speed_sqr < current->max_entry_speed_sqr) {
    5388:	9b 01       	movw	r18, r22
    538a:	ac 01       	movw	r20, r24
    538c:	c7 01       	movw	r24, r14
    538e:	b6 01       	movw	r22, r12
    5390:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    5394:	18 16       	cp	r1, r24
    5396:	2c f4       	brge	.+10     	; 0x53a2 <planner_recalculate+0x158>
          current->entry_speed_sqr = entry_speed_sqr;
    5398:	89 8a       	std	Y+17, r8	; 0x11
    539a:	9a 8a       	std	Y+18, r9	; 0x12
    539c:	ab 8a       	std	Y+19, r10	; 0x13
    539e:	bc 8a       	std	Y+20, r11	; 0x14
    53a0:	04 c0       	rjmp	.+8      	; 0x53aa <planner_recalculate+0x160>
        } else {
          current->entry_speed_sqr = current->max_entry_speed_sqr;
    53a2:	c9 8a       	std	Y+17, r12	; 0x11
    53a4:	da 8a       	std	Y+18, r13	; 0x12
    53a6:	eb 8a       	std	Y+19, r14	; 0x13
    53a8:	fc 8a       	std	Y+20, r15	; 0x14


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    53aa:	8e 01       	movw	r16, r28
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
    53ac:	80 91 43 02 	lds	r24, 0x0243
    53b0:	78 12       	cpse	r7, r24
    53b2:	b4 cf       	rjmp	.-152    	; 0x531c <planner_recalculate+0xd2>
    }
  }    

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
    53b4:	40 90 43 02 	lds	r4, 0x0243
    53b8:	f9 e2       	ldi	r31, 0x29	; 41
    53ba:	4f 9e       	mul	r4, r31
    53bc:	80 01       	movw	r16, r0
    53be:	11 24       	eor	r1, r1
    53c0:	09 5b       	subi	r16, 0xB9	; 185
    53c2:	1d 4f       	sbci	r17, 0xFD	; 253


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    53c4:	77 24       	eor	r7, r7
    53c6:	73 94       	inc	r7
    53c8:	74 0c       	add	r7, r4
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    53ca:	80 e2       	ldi	r24, 0x20	; 32
    53cc:	78 12       	cpse	r7, r24
    53ce:	01 c0       	rjmp	.+2      	; 0x53d2 <planner_recalculate+0x188>
    53d0:	71 2c       	mov	r7, r1

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    53d2:	60 90 45 02 	lds	r6, 0x0245
    current = next;
    next = &block_buffer[block_index];
    53d6:	0f 2e       	mov	r0, r31
    53d8:	f9 e2       	ldi	r31, 0x29	; 41
    53da:	5f 2e       	mov	r5, r31
    53dc:	f0 2d       	mov	r31, r0

// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    53de:	31 2c       	mov	r3, r1

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    53e0:	4e c0       	rjmp	.+156    	; 0x547e <planner_recalculate+0x234>
    current = next;
    next = &block_buffer[block_index];
    53e2:	57 9c       	mul	r5, r7
    53e4:	e0 01       	movw	r28, r0
    53e6:	11 24       	eor	r1, r1
    53e8:	c9 5b       	subi	r28, 0xB9	; 185
    53ea:	dd 4f       	sbci	r29, 0xFD	; 253
    
    // Any acceleration detected in the forward pass automatically moves the optimal planned
    // pointer forward, since everything before this is all optimal. In other words, nothing
    // can improve the plan from the buffer tail to the planned pointer by logic.
    if (current->entry_speed_sqr < next->entry_speed_sqr) {
    53ec:	f8 01       	movw	r30, r16
    53ee:	81 88       	ldd	r8, Z+17	; 0x11
    53f0:	92 88       	ldd	r9, Z+18	; 0x12
    53f2:	a3 88       	ldd	r10, Z+19	; 0x13
    53f4:	b4 88       	ldd	r11, Z+20	; 0x14
    53f6:	c9 88       	ldd	r12, Y+17	; 0x11
    53f8:	da 88       	ldd	r13, Y+18	; 0x12
    53fa:	eb 88       	ldd	r14, Y+19	; 0x13
    53fc:	fc 88       	ldd	r15, Y+20	; 0x14
    53fe:	a7 01       	movw	r20, r14
    5400:	96 01       	movw	r18, r12
    5402:	c5 01       	movw	r24, r10
    5404:	b4 01       	movw	r22, r8
    5406:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    540a:	88 23       	and	r24, r24
    540c:	2c f5       	brge	.+74     	; 0x5458 <planner_recalculate+0x20e>
      entry_speed_sqr = current->entry_speed_sqr + 2*current->acceleration*current->millimeters;
    540e:	f8 01       	movw	r30, r16
    5410:	61 a1       	ldd	r22, Z+33	; 0x21
    5412:	72 a1       	ldd	r23, Z+34	; 0x22
    5414:	83 a1       	ldd	r24, Z+35	; 0x23
    5416:	94 a1       	ldd	r25, Z+36	; 0x24
    5418:	9b 01       	movw	r18, r22
    541a:	ac 01       	movw	r20, r24
    541c:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    5420:	f8 01       	movw	r30, r16
    5422:	25 a1       	ldd	r18, Z+37	; 0x25
    5424:	36 a1       	ldd	r19, Z+38	; 0x26
    5426:	47 a1       	ldd	r20, Z+39	; 0x27
    5428:	50 a5       	ldd	r21, Z+40	; 0x28
    542a:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    542e:	9b 01       	movw	r18, r22
    5430:	ac 01       	movw	r20, r24
    5432:	c5 01       	movw	r24, r10
    5434:	b4 01       	movw	r22, r8
    5436:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    543a:	4b 01       	movw	r8, r22
    543c:	5c 01       	movw	r10, r24
      // If true, current block is full-acceleration and we can move the planned pointer forward.
      if (entry_speed_sqr < next->entry_speed_sqr) {
    543e:	9b 01       	movw	r18, r22
    5440:	ac 01       	movw	r20, r24
    5442:	c7 01       	movw	r24, r14
    5444:	b6 01       	movw	r22, r12
    5446:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    544a:	18 16       	cp	r1, r24
    544c:	2c f4       	brge	.+10     	; 0x5458 <planner_recalculate+0x20e>
        next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
    544e:	89 8a       	std	Y+17, r8	; 0x11
    5450:	9a 8a       	std	Y+18, r9	; 0x12
    5452:	ab 8a       	std	Y+19, r10	; 0x13
    5454:	bc 8a       	std	Y+20, r11	; 0x14
        block_buffer_planned = block_index; // Set optimal plan pointer.
    5456:	47 2c       	mov	r4, r7
    
    // Any block set at its maximum entry speed also creates an optimal plan up to this
    // point in the buffer. When the plan is bracketed by either the beginning of the
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    5458:	2d 89       	ldd	r18, Y+21	; 0x15
    545a:	3e 89       	ldd	r19, Y+22	; 0x16
    545c:	4f 89       	ldd	r20, Y+23	; 0x17
    545e:	58 8d       	ldd	r21, Y+24	; 0x18
    5460:	69 89       	ldd	r22, Y+17	; 0x11
    5462:	7a 89       	ldd	r23, Y+18	; 0x12
    5464:	8b 89       	ldd	r24, Y+19	; 0x13
    5466:	9c 89       	ldd	r25, Y+20	; 0x14
    5468:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    546c:	81 11       	cpse	r24, r1
    546e:	01 c0       	rjmp	.+2      	; 0x5472 <planner_recalculate+0x228>
    5470:	47 2c       	mov	r4, r7


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    5472:	73 94       	inc	r7
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    5474:	f0 e2       	ldi	r31, 0x20	; 32
    5476:	7f 12       	cpse	r7, r31
    5478:	01 c0       	rjmp	.+2      	; 0x547c <planner_recalculate+0x232>
    547a:	73 2c       	mov	r7, r3
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    current = next;
    next = &block_buffer[block_index];
    547c:	8e 01       	movw	r16, r28

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    547e:	76 10       	cpse	r7, r6
    5480:	b0 cf       	rjmp	.-160    	; 0x53e2 <planner_recalculate+0x198>
    5482:	40 92 43 02 	sts	0x0243, r4
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    block_index = plan_next_block_index( block_index );
  } 
}
    5486:	df 91       	pop	r29
    5488:	cf 91       	pop	r28
    548a:	1f 91       	pop	r17
    548c:	0f 91       	pop	r16
    548e:	ff 90       	pop	r15
    5490:	ef 90       	pop	r14
    5492:	df 90       	pop	r13
    5494:	cf 90       	pop	r12
    5496:	bf 90       	pop	r11
    5498:	af 90       	pop	r10
    549a:	9f 90       	pop	r9
    549c:	8f 90       	pop	r8
    549e:	7f 90       	pop	r7
    54a0:	6f 90       	pop	r6
    54a2:	5f 90       	pop	r5
    54a4:	4f 90       	pop	r4
    54a6:	3f 90       	pop	r3
    54a8:	08 95       	ret

000054aa <plan_reset>:


void plan_reset() 
{
  memset(&pl, 0, sizeof(pl)); // Clear planner struct
    54aa:	8c e1       	ldi	r24, 0x1C	; 28
    54ac:	e7 e2       	ldi	r30, 0x27	; 39
    54ae:	f2 e0       	ldi	r31, 0x02	; 2
    54b0:	df 01       	movw	r26, r30
    54b2:	1d 92       	st	X+, r1
    54b4:	8a 95       	dec	r24
    54b6:	e9 f7       	brne	.-6      	; 0x54b2 <plan_reset+0x8>
  block_buffer_tail = 0;
    54b8:	10 92 46 02 	sts	0x0246, r1
  block_buffer_head = 0; // Empty = tail
    54bc:	10 92 45 02 	sts	0x0245, r1
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
    54c0:	81 e0       	ldi	r24, 0x01	; 1
    54c2:	80 93 44 02 	sts	0x0244, r24
  block_buffer_planned = 0; // = block_buffer_tail;
    54c6:	10 92 43 02 	sts	0x0243, r1
    54ca:	08 95       	ret

000054cc <plan_discard_current_block>:
}


void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    54cc:	80 91 46 02 	lds	r24, 0x0246
    54d0:	90 91 45 02 	lds	r25, 0x0245
    54d4:	98 17       	cp	r25, r24
    54d6:	69 f0       	breq	.+26     	; 0x54f2 <plan_discard_current_block+0x26>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    54d8:	91 e0       	ldi	r25, 0x01	; 1
    54da:	98 0f       	add	r25, r24
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    54dc:	90 32       	cpi	r25, 0x20	; 32
    54de:	09 f4       	brne	.+2      	; 0x54e2 <plan_discard_current_block+0x16>
    54e0:	90 e0       	ldi	r25, 0x00	; 0
void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
    54e2:	20 91 43 02 	lds	r18, 0x0243
    54e6:	82 13       	cpse	r24, r18
    54e8:	02 c0       	rjmp	.+4      	; 0x54ee <plan_discard_current_block+0x22>
    54ea:	90 93 43 02 	sts	0x0243, r25
    block_buffer_tail = block_index;
    54ee:	90 93 46 02 	sts	0x0246, r25
    54f2:	08 95       	ret

000054f4 <plan_get_current_block>:
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    54f4:	80 91 46 02 	lds	r24, 0x0246
    54f8:	90 91 45 02 	lds	r25, 0x0245
    54fc:	98 17       	cp	r25, r24
    54fe:	39 f0       	breq	.+14     	; 0x550e <plan_get_current_block+0x1a>
  return(&block_buffer[block_buffer_tail]);
    5500:	29 e2       	ldi	r18, 0x29	; 41
    5502:	82 9f       	mul	r24, r18
    5504:	c0 01       	movw	r24, r0
    5506:	11 24       	eor	r1, r1
    5508:	89 5b       	subi	r24, 0xB9	; 185
    550a:	9d 4f       	sbci	r25, 0xFD	; 253
    550c:	08 95       	ret
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    550e:	80 e0       	ldi	r24, 0x00	; 0
    5510:	90 e0       	ldi	r25, 0x00	; 0
  return(&block_buffer[block_buffer_tail]);
}
    5512:	08 95       	ret

00005514 <plan_get_exec_block_exit_speed>:


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    5514:	e0 91 46 02 	lds	r30, 0x0246
    5518:	ef 5f       	subi	r30, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    551a:	e0 32       	cpi	r30, 0x20	; 32
    551c:	09 f4       	brne	.+2      	; 0x5520 <plan_get_exec_block_exit_speed+0xc>
    551e:	e0 e0       	ldi	r30, 0x00	; 0


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    5520:	80 91 45 02 	lds	r24, 0x0245
    5524:	8e 17       	cp	r24, r30
    5526:	69 f0       	breq	.+26     	; 0x5542 <plan_get_exec_block_exit_speed+0x2e>
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
    5528:	89 e2       	ldi	r24, 0x29	; 41
    552a:	e8 9f       	mul	r30, r24
    552c:	f0 01       	movw	r30, r0
    552e:	11 24       	eor	r1, r1
    5530:	e9 5b       	subi	r30, 0xB9	; 185
    5532:	fd 4f       	sbci	r31, 0xFD	; 253
    5534:	61 89       	ldd	r22, Z+17	; 0x11
    5536:	72 89       	ldd	r23, Z+18	; 0x12
    5538:	83 89       	ldd	r24, Z+19	; 0x13
    553a:	94 89       	ldd	r25, Z+20	; 0x14
    553c:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    5540:	08 95       	ret


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    5542:	60 e0       	ldi	r22, 0x00	; 0
    5544:	70 e0       	ldi	r23, 0x00	; 0
    5546:	cb 01       	movw	r24, r22
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
}
    5548:	08 95       	ret

0000554a <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
  if (block_buffer_tail == next_buffer_head) { return(true); }
    554a:	81 e0       	ldi	r24, 0x01	; 1
    554c:	20 91 46 02 	lds	r18, 0x0246
    5550:	90 91 44 02 	lds	r25, 0x0244
    5554:	29 13       	cpse	r18, r25
    5556:	80 e0       	ldi	r24, 0x00	; 0
  return(false);
}
    5558:	08 95       	ret

0000555a <plan_buffer_line>:
#ifdef USE_LINE_NUMBERS   
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number) 
#else
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate) 
#endif
{
    555a:	2f 92       	push	r2
    555c:	3f 92       	push	r3
    555e:	4f 92       	push	r4
    5560:	5f 92       	push	r5
    5562:	6f 92       	push	r6
    5564:	7f 92       	push	r7
    5566:	8f 92       	push	r8
    5568:	9f 92       	push	r9
    556a:	af 92       	push	r10
    556c:	bf 92       	push	r11
    556e:	cf 92       	push	r12
    5570:	df 92       	push	r13
    5572:	ef 92       	push	r14
    5574:	ff 92       	push	r15
    5576:	0f 93       	push	r16
    5578:	1f 93       	push	r17
    557a:	cf 93       	push	r28
    557c:	df 93       	push	r29
    557e:	cd b7       	in	r28, 0x3d	; 61
    5580:	de b7       	in	r29, 0x3e	; 62
    5582:	ad 97       	sbiw	r28, 0x2d	; 45
    5584:	0f b6       	in	r0, 0x3f	; 63
    5586:	f8 94       	cli
    5588:	de bf       	out	0x3e, r29	; 62
    558a:	0f be       	out	0x3f, r0	; 63
    558c:	cd bf       	out	0x3d, r28	; 61
    558e:	49 a3       	std	Y+33, r20	; 0x21
    5590:	5a a3       	std	Y+34, r21	; 0x22
    5592:	6b a3       	std	Y+35, r22	; 0x23
    5594:	7c a3       	std	Y+36, r23	; 0x24
    5596:	2d a3       	std	Y+37, r18	; 0x25
  // Prepare and initialize new block
  plan_block_t *block = &block_buffer[block_buffer_head];
    5598:	20 91 45 02 	lds	r18, 0x0245
    559c:	49 e2       	ldi	r20, 0x29	; 41
    559e:	24 9f       	mul	r18, r20
    55a0:	90 01       	movw	r18, r0
    55a2:	11 24       	eor	r1, r1
    55a4:	f9 01       	movw	r30, r18
    55a6:	e9 5b       	subi	r30, 0xB9	; 185
    55a8:	fd 4f       	sbci	r31, 0xFD	; 253
    55aa:	1f 01       	movw	r2, r30
  block->step_event_count = 0;
    55ac:	15 86       	std	Z+13, r1	; 0x0d
    55ae:	16 86       	std	Z+14, r1	; 0x0e
    55b0:	17 86       	std	Z+15, r1	; 0x0f
    55b2:	10 8a       	std	Z+16, r1	; 0x10
  block->millimeters = 0;
    55b4:	15 a2       	std	Z+37, r1	; 0x25
    55b6:	16 a2       	std	Z+38, r1	; 0x26
    55b8:	17 a2       	std	Z+39, r1	; 0x27
    55ba:	10 a6       	std	Z+40, r1	; 0x28
  block->direction_bits = 0;
    55bc:	10 82       	st	Z, r1
  block->acceleration = SOME_LARGE_VALUE; // Scaled down to maximum acceleration later
    55be:	49 e9       	ldi	r20, 0x99	; 153
    55c0:	56 e7       	ldi	r21, 0x76	; 118
    55c2:	66 e9       	ldi	r22, 0x96	; 150
    55c4:	7e e7       	ldi	r23, 0x7E	; 126
    55c6:	41 a3       	std	Z+33, r20	; 0x21
    55c8:	52 a3       	std	Z+34, r21	; 0x22
    55ca:	63 a3       	std	Z+35, r22	; 0x23
    55cc:	74 a3       	std	Z+36, r23	; 0x24
    55ce:	5c 01       	movw	r10, r24
    55d0:	0f ef       	ldi	r16, 0xFF	; 255
    55d2:	18 e0       	ldi	r17, 0x08	; 8
    55d4:	ae 01       	movw	r20, r28
    55d6:	4f 5f       	subi	r20, 0xFF	; 255
    55d8:	5f 4f       	sbci	r21, 0xFF	; 255
    55da:	5c 8f       	std	Y+28, r21	; 0x1c
    55dc:	4b 8f       	std	Y+27, r20	; 0x1b
    55de:	0f 2e       	mov	r0, r31
    55e0:	f7 e2       	ldi	r31, 0x27	; 39
    55e2:	4f 2e       	mov	r4, r31
    55e4:	f2 e0       	ldi	r31, 0x02	; 2
    55e6:	5f 2e       	mov	r5, r31
    55e8:	f0 2d       	mov	r31, r0
    55ea:	7f 01       	movw	r14, r30
    55ec:	ce 01       	movw	r24, r28
    55ee:	0d 96       	adiw	r24, 0x0d	; 13
    55f0:	6c 01       	movw	r12, r24
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    55f2:	71 2c       	mov	r7, r1
    55f4:	be 8e       	std	Y+30, r11	; 0x1e
    55f6:	ad 8e       	std	Y+29, r10	; 0x1d
        delta_mm = ((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]))/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
    55f8:	ed 8d       	ldd	r30, Y+29	; 0x1d
    55fa:	fe 8d       	ldd	r31, Y+30	; 0x1e
    55fc:	61 91       	ld	r22, Z+
    55fe:	71 91       	ld	r23, Z+
    5600:	81 91       	ld	r24, Z+
    5602:	91 91       	ld	r25, Z+
    5604:	fe 8f       	std	Y+30, r31	; 0x1e
    5606:	ed 8f       	std	Y+29, r30	; 0x1d
    5608:	18 a3       	std	Y+32, r17	; 0x20
    560a:	0f 8f       	std	Y+31, r16	; 0x1f
    560c:	f8 01       	movw	r30, r16
    560e:	20 81       	ld	r18, Z
    5610:	31 81       	ldd	r19, Z+1	; 0x01
    5612:	42 81       	ldd	r20, Z+2	; 0x02
    5614:	53 81       	ldd	r21, Z+3	; 0x03
    5616:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    561a:	0e 94 bb 3e 	call	0x7d76	; 0x7d76 <lround>
    561e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5620:	fc 8d       	ldd	r31, Y+28	; 0x1c
    5622:	61 93       	st	Z+, r22
    5624:	71 93       	st	Z+, r23
    5626:	81 93       	st	Z+, r24
    5628:	91 93       	st	Z+, r25
    562a:	fc 8f       	std	Y+28, r31	; 0x1c
    562c:	eb 8f       	std	Y+27, r30	; 0x1b
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
    562e:	f2 01       	movw	r30, r4
    5630:	81 90       	ld	r8, Z+
    5632:	91 90       	ld	r9, Z+
    5634:	a1 90       	ld	r10, Z+
    5636:	b1 90       	ld	r11, Z+
    5638:	2f 01       	movw	r4, r30
    563a:	68 19       	sub	r22, r8
    563c:	79 09       	sbc	r23, r9
    563e:	8a 09       	sbc	r24, r10
    5640:	9b 09       	sbc	r25, r11
    5642:	9b 01       	movw	r18, r22
    5644:	ac 01       	movw	r20, r24
    5646:	3a f4       	brpl	.+14     	; 0x5656 <plan_buffer_line+0xfc>
    5648:	22 27       	eor	r18, r18
    564a:	33 27       	eor	r19, r19
    564c:	a9 01       	movw	r20, r18
    564e:	26 1b       	sub	r18, r22
    5650:	37 0b       	sbc	r19, r23
    5652:	48 0b       	sbc	r20, r24
    5654:	59 0b       	sbc	r21, r25
    5656:	f7 01       	movw	r30, r14
    5658:	21 83       	std	Z+1, r18	; 0x01
    565a:	32 83       	std	Z+2, r19	; 0x02
    565c:	43 83       	std	Z+3, r20	; 0x03
    565e:	54 83       	std	Z+4, r21	; 0x04
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    5660:	f1 01       	movw	r30, r2
    5662:	85 84       	ldd	r8, Z+13	; 0x0d
    5664:	96 84       	ldd	r9, Z+14	; 0x0e
    5666:	a7 84       	ldd	r10, Z+15	; 0x0f
    5668:	b0 88       	ldd	r11, Z+16	; 0x10
    566a:	28 15       	cp	r18, r8
    566c:	39 05       	cpc	r19, r9
    566e:	4a 05       	cpc	r20, r10
    5670:	5b 05       	cpc	r21, r11
    5672:	10 f4       	brcc	.+4      	; 0x5678 <plan_buffer_line+0x11e>
    5674:	a5 01       	movw	r20, r10
    5676:	94 01       	movw	r18, r8
    5678:	f1 01       	movw	r30, r2
    567a:	25 87       	std	Z+13, r18	; 0x0d
    567c:	36 87       	std	Z+14, r19	; 0x0e
    567e:	47 87       	std	Z+15, r20	; 0x0f
    5680:	50 8b       	std	Z+16, r21	; 0x10
      delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
    5682:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <__floatsisf>
    5686:	ef 8d       	ldd	r30, Y+31	; 0x1f
    5688:	f8 a1       	ldd	r31, Y+32	; 0x20
    568a:	20 81       	ld	r18, Z
    568c:	31 81       	ldd	r19, Z+1	; 0x01
    568e:	42 81       	ldd	r20, Z+2	; 0x02
    5690:	53 81       	ldd	r21, Z+3	; 0x03
    5692:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    5696:	4b 01       	movw	r8, r22
    5698:	5c 01       	movw	r10, r24
    #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
    569a:	f6 01       	movw	r30, r12
    569c:	61 93       	st	Z+, r22
    569e:	71 93       	st	Z+, r23
    56a0:	81 93       	st	Z+, r24
    56a2:	91 93       	st	Z+, r25
    56a4:	6f 01       	movw	r12, r30
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    56a6:	20 e0       	ldi	r18, 0x00	; 0
    56a8:	30 e0       	ldi	r19, 0x00	; 0
    56aa:	a9 01       	movw	r20, r18
    56ac:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    56b0:	88 23       	and	r24, r24
    56b2:	44 f4       	brge	.+16     	; 0x56c4 <plan_buffer_line+0x16a>
    56b4:	f1 01       	movw	r30, r2
    56b6:	60 80       	ld	r6, Z
    56b8:	87 2d       	mov	r24, r7
    56ba:	0e 94 11 29 	call	0x5222	; 0x5222 <get_direction_pin_mask>
    56be:	86 29       	or	r24, r6
    56c0:	f1 01       	movw	r30, r2
    56c2:	80 83       	st	Z, r24
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    56c4:	a5 01       	movw	r20, r10
    56c6:	94 01       	movw	r18, r8
    56c8:	c5 01       	movw	r24, r10
    56ca:	b4 01       	movw	r22, r8
    56cc:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    56d0:	f1 01       	movw	r30, r2
    56d2:	25 a1       	ldd	r18, Z+37	; 0x25
    56d4:	36 a1       	ldd	r19, Z+38	; 0x26
    56d6:	47 a1       	ldd	r20, Z+39	; 0x27
    56d8:	50 a5       	ldd	r21, Z+40	; 0x28
    56da:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    56de:	f1 01       	movw	r30, r2
    56e0:	65 a3       	std	Z+37, r22	; 0x25
    56e2:	76 a3       	std	Z+38, r23	; 0x26
    56e4:	87 a3       	std	Z+39, r24	; 0x27
    56e6:	90 a7       	std	Z+40, r25	; 0x28
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    56e8:	73 94       	inc	r7
    56ea:	0c 5f       	subi	r16, 0xFC	; 252
    56ec:	1f 4f       	sbci	r17, 0xFF	; 255
    56ee:	f4 e0       	ldi	r31, 0x04	; 4
    56f0:	ef 0e       	add	r14, r31
    56f2:	f1 1c       	adc	r15, r1
    56f4:	23 e0       	ldi	r18, 0x03	; 3
    56f6:	72 12       	cpse	r7, r18
    56f8:	7f cf       	rjmp	.-258    	; 0x55f8 <plan_buffer_line+0x9e>
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
  }
  block->millimeters = sqrt(block->millimeters); // Complete millimeters calculation with sqrt()
    56fa:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    56fe:	6b 01       	movw	r12, r22
    5700:	7c 01       	movw	r14, r24
    5702:	f1 01       	movw	r30, r2
    5704:	65 a3       	std	Z+37, r22	; 0x25
    5706:	76 a3       	std	Z+38, r23	; 0x26
    5708:	87 a3       	std	Z+39, r24	; 0x27
    570a:	90 a7       	std	Z+40, r25	; 0x28
  
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
    570c:	85 85       	ldd	r24, Z+13	; 0x0d
    570e:	96 85       	ldd	r25, Z+14	; 0x0e
    5710:	a7 85       	ldd	r26, Z+15	; 0x0f
    5712:	b0 89       	ldd	r27, Z+16	; 0x10
    5714:	89 2b       	or	r24, r25
    5716:	8a 2b       	or	r24, r26
    5718:	8b 2b       	or	r24, r27
    571a:	09 f4       	brne	.+2      	; 0x571e <plan_buffer_line+0x1c4>
    571c:	1f c2       	rjmp	.+1086   	; 0x5b5c <plan_buffer_line+0x602>
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    571e:	20 e0       	ldi	r18, 0x00	; 0
    5720:	30 e0       	ldi	r19, 0x00	; 0
    5722:	a9 01       	movw	r20, r18
    5724:	69 a1       	ldd	r22, Y+33	; 0x21
    5726:	7a a1       	ldd	r23, Y+34	; 0x22
    5728:	8b a1       	ldd	r24, Y+35	; 0x23
    572a:	9c a1       	ldd	r25, Y+36	; 0x24
    572c:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    5730:	88 23       	and	r24, r24
    5732:	e4 f0       	brlt	.+56     	; 0x576c <plan_buffer_line+0x212>
  else if (invert_feed_rate) { feed_rate = block->millimeters/feed_rate; }
    5734:	fd a1       	ldd	r31, Y+37	; 0x25
    5736:	ff 23       	and	r31, r31
    5738:	61 f0       	breq	.+24     	; 0x5752 <plan_buffer_line+0x1f8>
    573a:	29 a1       	ldd	r18, Y+33	; 0x21
    573c:	3a a1       	ldd	r19, Y+34	; 0x22
    573e:	4b a1       	ldd	r20, Y+35	; 0x23
    5740:	5c a1       	ldd	r21, Y+36	; 0x24
    5742:	c7 01       	movw	r24, r14
    5744:	b6 01       	movw	r22, r12
    5746:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    574a:	69 a3       	std	Y+33, r22	; 0x21
    574c:	7a a3       	std	Y+34, r23	; 0x22
    574e:	8b a3       	std	Y+35, r24	; 0x23
    5750:	9c a3       	std	Y+36, r25	; 0x24
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    5752:	20 e0       	ldi	r18, 0x00	; 0
    5754:	30 e0       	ldi	r19, 0x00	; 0
    5756:	40 e8       	ldi	r20, 0x80	; 128
    5758:	5f e3       	ldi	r21, 0x3F	; 63
    575a:	69 a1       	ldd	r22, Y+33	; 0x21
    575c:	7a a1       	ldd	r23, Y+34	; 0x22
    575e:	8b a1       	ldd	r24, Y+35	; 0x23
    5760:	9c a1       	ldd	r25, Y+36	; 0x24
    5762:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    5766:	88 23       	and	r24, r24
    5768:	84 f4       	brge	.+32     	; 0x578a <plan_buffer_line+0x230>
    576a:	09 c0       	rjmp	.+18     	; 0x577e <plan_buffer_line+0x224>
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    576c:	29 e9       	ldi	r18, 0x99	; 153
    576e:	29 a3       	std	Y+33, r18	; 0x21
    5770:	46 e7       	ldi	r20, 0x76	; 118
    5772:	4a a3       	std	Y+34, r20	; 0x22
    5774:	56 e9       	ldi	r21, 0x96	; 150
    5776:	5b a3       	std	Y+35, r21	; 0x23
    5778:	8e e7       	ldi	r24, 0x7E	; 126
    577a:	8c a3       	std	Y+36, r24	; 0x24
    577c:	06 c0       	rjmp	.+12     	; 0x578a <plan_buffer_line+0x230>
  else if (invert_feed_rate) { feed_rate = block->millimeters/feed_rate; }
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    577e:	19 a2       	std	Y+33, r1	; 0x21
    5780:	1a a2       	std	Y+34, r1	; 0x22
    5782:	90 e8       	ldi	r25, 0x80	; 128
    5784:	9b a3       	std	Y+35, r25	; 0x23
    5786:	ef e3       	ldi	r30, 0x3F	; 63
    5788:	ec a3       	std	Y+36, r30	; 0x24
  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled 
  // down such that no individual axes maximum values are exceeded with respect to the line direction. 
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
    578a:	a7 01       	movw	r20, r14
    578c:	96 01       	movw	r18, r12
    578e:	60 e0       	ldi	r22, 0x00	; 0
    5790:	70 e0       	ldi	r23, 0x00	; 0
    5792:	80 e8       	ldi	r24, 0x80	; 128
    5794:	9f e3       	ldi	r25, 0x3F	; 63
    5796:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    579a:	6a a7       	std	Y+42, r22	; 0x2a
    579c:	7b a7       	std	Y+43, r23	; 0x2b
    579e:	8c a7       	std	Y+44, r24	; 0x2c
    57a0:	9d a7       	std	Y+45, r25	; 0x2d
    57a2:	03 e3       	ldi	r16, 0x33	; 51
    57a4:	12 e0       	ldi	r17, 0x02	; 2
    57a6:	0f 2e       	mov	r0, r31
    57a8:	fb e0       	ldi	r31, 0x0B	; 11
    57aa:	4f 2e       	mov	r4, r31
    57ac:	f9 e0       	ldi	r31, 0x09	; 9
    57ae:	5f 2e       	mov	r5, r31
    57b0:	f0 2d       	mov	r31, r0
    57b2:	ae 01       	movw	r20, r28
    57b4:	47 5e       	subi	r20, 0xE7	; 231
    57b6:	5f 4f       	sbci	r21, 0xFF	; 255
    57b8:	5a 8f       	std	Y+26, r21	; 0x1a
    57ba:	49 8f       	std	Y+25, r20	; 0x19
    57bc:	ce 01       	movw	r24, r28
    57be:	0d 96       	adiw	r24, 0x0d	; 13
  float junction_cos_theta = 0;
    57c0:	1f 8e       	std	Y+31, r1	; 0x1f
    57c2:	1d a2       	std	Y+37, r1	; 0x25
    57c4:	1e a2       	std	Y+38, r1	; 0x26
    57c6:	1f a2       	std	Y+39, r1	; 0x27
    57c8:	3c 8e       	std	Y+28, r3	; 0x1c
    57ca:	2b 8e       	std	Y+27, r2	; 0x1b
    57cc:	1e 8f       	std	Y+30, r17	; 0x1e
    57ce:	0d 8f       	std	Y+29, r16	; 0x1d
    57d0:	8c 01       	movw	r16, r24
    57d2:	32 01       	movw	r6, r4
    57d4:	29 a0       	ldd	r2, Y+33	; 0x21
    57d6:	3a a0       	ldd	r3, Y+34	; 0x22
    57d8:	4b a0       	ldd	r4, Y+35	; 0x23
    57da:	5c a0       	ldd	r5, Y+36	; 0x24
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    57dc:	f8 01       	movw	r30, r16
    57de:	c0 80       	ld	r12, Z
    57e0:	d1 80       	ldd	r13, Z+1	; 0x01
    57e2:	e2 80       	ldd	r14, Z+2	; 0x02
    57e4:	f3 80       	ldd	r15, Z+3	; 0x03
    57e6:	20 e0       	ldi	r18, 0x00	; 0
    57e8:	30 e0       	ldi	r19, 0x00	; 0
    57ea:	a9 01       	movw	r20, r18
    57ec:	c7 01       	movw	r24, r14
    57ee:	b6 01       	movw	r22, r12
    57f0:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    57f4:	88 23       	and	r24, r24
    57f6:	09 f4       	brne	.+2      	; 0x57fa <plan_buffer_line+0x2a0>
    57f8:	7e c0       	rjmp	.+252    	; 0x58f6 <plan_buffer_line+0x39c>
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
    57fa:	a7 01       	movw	r20, r14
    57fc:	96 01       	movw	r18, r12
    57fe:	6a a5       	ldd	r22, Y+42	; 0x2a
    5800:	7b a5       	ldd	r23, Y+43	; 0x2b
    5802:	8c a5       	ldd	r24, Y+44	; 0x2c
    5804:	9d a5       	ldd	r25, Y+45	; 0x2d
    5806:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    580a:	6b 01       	movw	r12, r22
    580c:	7c 01       	movw	r14, r24
    580e:	f8 01       	movw	r30, r16
    5810:	60 83       	st	Z, r22
    5812:	71 83       	std	Z+1, r23	; 0x01
    5814:	82 83       	std	Z+2, r24	; 0x02
    5816:	93 83       	std	Z+3, r25	; 0x03
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.
    5818:	9b 01       	movw	r18, r22
    581a:	ac 01       	movw	r20, r24
    581c:	60 e0       	ldi	r22, 0x00	; 0
    581e:	70 e0       	ldi	r23, 0x00	; 0
    5820:	80 e8       	ldi	r24, 0x80	; 128
    5822:	9f e3       	ldi	r25, 0x3F	; 63
    5824:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    5828:	4b 01       	movw	r8, r22
    582a:	5c 01       	movw	r10, r24
    582c:	e8 94       	clt
    582e:	b7 f8       	bld	r11, 7
    5830:	79 a6       	std	Y+41, r7	; 0x29
    5832:	68 a6       	std	Y+40, r6	; 0x28

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    5834:	f3 01       	movw	r30, r6
    5836:	20 81       	ld	r18, Z
    5838:	31 81       	ldd	r19, Z+1	; 0x01
    583a:	42 81       	ldd	r20, Z+2	; 0x02
    583c:	53 81       	ldd	r21, Z+3	; 0x03
    583e:	c5 01       	movw	r24, r10
    5840:	b4 01       	movw	r22, r8
    5842:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5846:	69 a3       	std	Y+33, r22	; 0x21
    5848:	7a a3       	std	Y+34, r23	; 0x22
    584a:	8b a3       	std	Y+35, r24	; 0x23
    584c:	9c a3       	std	Y+36, r25	; 0x24
    584e:	22 2d       	mov	r18, r2
    5850:	33 2d       	mov	r19, r3
    5852:	44 2d       	mov	r20, r4
    5854:	55 2d       	mov	r21, r5
    5856:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    585a:	18 16       	cp	r1, r24
    585c:	24 f4       	brge	.+8      	; 0x5866 <plan_buffer_line+0x30c>
    585e:	29 a2       	std	Y+33, r2	; 0x21
    5860:	3a a2       	std	Y+34, r3	; 0x22
    5862:	4b a2       	std	Y+35, r4	; 0x23
    5864:	5c a2       	std	Y+36, r5	; 0x24
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    5866:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5868:	fc 8d       	ldd	r31, Y+28	; 0x1c
    586a:	21 a0       	ldd	r2, Z+33	; 0x21
    586c:	32 a0       	ldd	r3, Z+34	; 0x22
    586e:	43 a0       	ldd	r4, Z+35	; 0x23
    5870:	54 a0       	ldd	r5, Z+36	; 0x24
    5872:	e8 a5       	ldd	r30, Y+40	; 0x28
    5874:	f9 a5       	ldd	r31, Y+41	; 0x29
    5876:	24 85       	ldd	r18, Z+12	; 0x0c
    5878:	35 85       	ldd	r19, Z+13	; 0x0d
    587a:	46 85       	ldd	r20, Z+14	; 0x0e
    587c:	57 85       	ldd	r21, Z+15	; 0x0f
    587e:	c5 01       	movw	r24, r10
    5880:	b4 01       	movw	r22, r8
    5882:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5886:	86 2e       	mov	r8, r22
    5888:	97 2e       	mov	r9, r23
    588a:	a8 2e       	mov	r10, r24
    588c:	b9 2e       	mov	r11, r25
    588e:	26 2f       	mov	r18, r22
    5890:	37 2f       	mov	r19, r23
    5892:	48 2f       	mov	r20, r24
    5894:	59 2f       	mov	r21, r25
    5896:	62 2d       	mov	r22, r2
    5898:	73 2d       	mov	r23, r3
    589a:	84 2d       	mov	r24, r4
    589c:	95 2d       	mov	r25, r5
    589e:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    58a2:	88 23       	and	r24, r24
    58a4:	24 f0       	brlt	.+8      	; 0x58ae <plan_buffer_line+0x354>
    58a6:	28 2c       	mov	r2, r8
    58a8:	39 2c       	mov	r3, r9
    58aa:	4a 2c       	mov	r4, r10
    58ac:	5b 2c       	mov	r5, r11
    58ae:	82 2d       	mov	r24, r2
    58b0:	93 2d       	mov	r25, r3
    58b2:	a4 2d       	mov	r26, r4
    58b4:	b5 2d       	mov	r27, r5
    58b6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    58b8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    58ba:	81 a3       	std	Z+33, r24	; 0x21
    58bc:	92 a3       	std	Z+34, r25	; 0x22
    58be:	a3 a3       	std	Z+35, r26	; 0x23
    58c0:	b4 a3       	std	Z+36, r27	; 0x24

      // Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction
      // between the current move and the previous move is simply the dot product of the two unit vectors, 
      // where prev_unit_vec is negative. Used later to compute maximum junction speed.
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    58c2:	ed 8d       	ldd	r30, Y+29	; 0x1d
    58c4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    58c6:	20 81       	ld	r18, Z
    58c8:	31 81       	ldd	r19, Z+1	; 0x01
    58ca:	42 81       	ldd	r20, Z+2	; 0x02
    58cc:	53 81       	ldd	r21, Z+3	; 0x03
    58ce:	c7 01       	movw	r24, r14
    58d0:	b6 01       	movw	r22, r12
    58d2:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    58d6:	9b 01       	movw	r18, r22
    58d8:	ac 01       	movw	r20, r24
    58da:	6f 8d       	ldd	r22, Y+31	; 0x1f
    58dc:	7d a1       	ldd	r23, Y+37	; 0x25
    58de:	8e a1       	ldd	r24, Y+38	; 0x26
    58e0:	9f a1       	ldd	r25, Y+39	; 0x27
    58e2:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    58e6:	6f 8f       	std	Y+31, r22	; 0x1f
    58e8:	7d a3       	std	Y+37, r23	; 0x25
    58ea:	8e a3       	std	Y+38, r24	; 0x26
    58ec:	9f a3       	std	Y+39, r25	; 0x27
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    58ee:	29 a0       	ldd	r2, Y+33	; 0x21
    58f0:	3a a0       	ldd	r3, Y+34	; 0x22
    58f2:	4b a0       	ldd	r4, Y+35	; 0x23
    58f4:	5c a0       	ldd	r5, Y+36	; 0x24
    58f6:	0c 5f       	subi	r16, 0xFC	; 252
    58f8:	1f 4f       	sbci	r17, 0xFF	; 255
    58fa:	4d 8d       	ldd	r20, Y+29	; 0x1d
    58fc:	5e 8d       	ldd	r21, Y+30	; 0x1e
    58fe:	4c 5f       	subi	r20, 0xFC	; 252
    5900:	5f 4f       	sbci	r21, 0xFF	; 255
    5902:	5e 8f       	std	Y+30, r21	; 0x1e
    5904:	4d 8f       	std	Y+29, r20	; 0x1d
    5906:	54 e0       	ldi	r21, 0x04	; 4
    5908:	65 0e       	add	r6, r21
    590a:	71 1c       	adc	r7, r1
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    590c:	89 8d       	ldd	r24, Y+25	; 0x19
    590e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    5910:	08 17       	cp	r16, r24
    5912:	19 07       	cpc	r17, r25
    5914:	09 f0       	breq	.+2      	; 0x5918 <plan_buffer_line+0x3be>
    5916:	62 cf       	rjmp	.-316    	; 0x57dc <plan_buffer_line+0x282>
    5918:	29 a2       	std	Y+33, r2	; 0x21
    591a:	3a a2       	std	Y+34, r3	; 0x22
    591c:	2b 8c       	ldd	r2, Y+27	; 0x1b
    591e:	3c 8c       	ldd	r3, Y+28	; 0x1c
    5920:	4b a2       	std	Y+35, r4	; 0x23
    5922:	5c a2       	std	Y+36, r5	; 0x24
    5924:	ef 8c       	ldd	r14, Y+31	; 0x1f
    5926:	fd a0       	ldd	r15, Y+37	; 0x25
    5928:	0e a1       	ldd	r16, Y+38	; 0x26
    592a:	1f a1       	ldd	r17, Y+39	; 0x27
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    }
  }
  
  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if (block_buffer_head == block_buffer_tail) {
    592c:	90 91 45 02 	lds	r25, 0x0245
    5930:	80 91 46 02 	lds	r24, 0x0246
    5934:	98 13       	cpse	r25, r24
    5936:	0a c0       	rjmp	.+20     	; 0x594c <plan_buffer_line+0x3f2>
  
    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    block->entry_speed_sqr = 0.0;
    5938:	f1 01       	movw	r30, r2
    593a:	11 8a       	std	Z+17, r1	; 0x11
    593c:	12 8a       	std	Z+18, r1	; 0x12
    593e:	13 8a       	std	Z+19, r1	; 0x13
    5940:	14 8a       	std	Z+20, r1	; 0x14
    block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
    5942:	11 8e       	std	Z+25, r1	; 0x19
    5944:	12 8e       	std	Z+26, r1	; 0x1a
    5946:	13 8e       	std	Z+27, r1	; 0x1b
    5948:	14 8e       	std	Z+28, r1	; 0x1c
    594a:	75 c0       	rjmp	.+234    	; 0x5a36 <plan_buffer_line+0x4dc>
       changed dynamically during operation nor can the line move geometry. This must be kept in
       memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
       change the overall maximum entry speed conditions of all blocks.
    */
    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.99) {
    594c:	24 ea       	ldi	r18, 0xA4	; 164
    594e:	30 e7       	ldi	r19, 0x70	; 112
    5950:	4d e7       	ldi	r20, 0x7D	; 125
    5952:	5f e3       	ldi	r21, 0x3F	; 63
    5954:	6f 8d       	ldd	r22, Y+31	; 0x1f
    5956:	7d a1       	ldd	r23, Y+37	; 0x25
    5958:	8e a1       	ldd	r24, Y+38	; 0x26
    595a:	9f a1       	ldd	r25, Y+39	; 0x27
    595c:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    5960:	18 16       	cp	r1, r24
    5962:	34 f4       	brge	.+12     	; 0x5970 <plan_buffer_line+0x416>
      //  For a 0 degree acute junction, just set minimum junction speed. 
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
    5964:	f1 01       	movw	r30, r2
    5966:	11 8e       	std	Z+25, r1	; 0x19
    5968:	12 8e       	std	Z+26, r1	; 0x1a
    596a:	13 8e       	std	Z+27, r1	; 0x1b
    596c:	14 8e       	std	Z+28, r1	; 0x1c
    596e:	63 c0       	rjmp	.+198    	; 0x5a36 <plan_buffer_line+0x4dc>
    } else {
      junction_cos_theta = max(junction_cos_theta,-0.99); // Check for numerical round-off to avoid divide by zero.
    5970:	24 ea       	ldi	r18, 0xA4	; 164
    5972:	30 e7       	ldi	r19, 0x70	; 112
    5974:	4d e7       	ldi	r20, 0x7D	; 125
    5976:	5f eb       	ldi	r21, 0xBF	; 191
    5978:	6e 2d       	mov	r22, r14
    597a:	7f 2d       	mov	r23, r15
    597c:	80 2f       	mov	r24, r16
    597e:	91 2f       	mov	r25, r17
    5980:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    5984:	18 16       	cp	r1, r24
    5986:	44 f0       	brlt	.+16     	; 0x5998 <plan_buffer_line+0x43e>
    5988:	f4 ea       	ldi	r31, 0xA4	; 164
    598a:	ff 8f       	std	Y+31, r31	; 0x1f
    598c:	20 e7       	ldi	r18, 0x70	; 112
    598e:	2d a3       	std	Y+37, r18	; 0x25
    5990:	4d e7       	ldi	r20, 0x7D	; 125
    5992:	4e a3       	std	Y+38, r20	; 0x26
    5994:	5f eb       	ldi	r21, 0xBF	; 191
    5996:	5f a3       	std	Y+39, r21	; 0x27
      float sin_theta_d2 = sqrt(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Always positive.
    5998:	2f 8d       	ldd	r18, Y+31	; 0x1f
    599a:	3d a1       	ldd	r19, Y+37	; 0x25
    599c:	4e a1       	ldd	r20, Y+38	; 0x26
    599e:	5f a1       	ldd	r21, Y+39	; 0x27
    59a0:	60 e0       	ldi	r22, 0x00	; 0
    59a2:	70 e0       	ldi	r23, 0x00	; 0
    59a4:	80 e8       	ldi	r24, 0x80	; 128
    59a6:	9f e3       	ldi	r25, 0x3F	; 63
    59a8:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    59ac:	20 e0       	ldi	r18, 0x00	; 0
    59ae:	30 e0       	ldi	r19, 0x00	; 0
    59b0:	40 e0       	ldi	r20, 0x00	; 0
    59b2:	5f e3       	ldi	r21, 0x3F	; 63
    59b4:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    59b8:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    59bc:	6b 01       	movw	r12, r22
    59be:	7c 01       	movw	r14, r24

      // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
      // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
      block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
    59c0:	20 91 34 09 	lds	r18, 0x0934
    59c4:	30 91 35 09 	lds	r19, 0x0935
    59c8:	40 91 36 09 	lds	r20, 0x0936
    59cc:	50 91 37 09 	lds	r21, 0x0937
    59d0:	f1 01       	movw	r30, r2
    59d2:	61 a1       	ldd	r22, Z+33	; 0x21
    59d4:	72 a1       	ldd	r23, Z+34	; 0x22
    59d6:	83 a1       	ldd	r24, Z+35	; 0x23
    59d8:	94 a1       	ldd	r25, Z+36	; 0x24
    59da:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    59de:	a7 01       	movw	r20, r14
    59e0:	96 01       	movw	r18, r12
    59e2:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    59e6:	4b 01       	movw	r8, r22
    59e8:	5c 01       	movw	r10, r24
    59ea:	a7 01       	movw	r20, r14
    59ec:	96 01       	movw	r18, r12
    59ee:	60 e0       	ldi	r22, 0x00	; 0
    59f0:	70 e0       	ldi	r23, 0x00	; 0
    59f2:	80 e8       	ldi	r24, 0x80	; 128
    59f4:	9f e3       	ldi	r25, 0x3F	; 63
    59f6:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    59fa:	9b 01       	movw	r18, r22
    59fc:	ac 01       	movw	r20, r24
    59fe:	c5 01       	movw	r24, r10
    5a00:	b4 01       	movw	r22, r8
    5a02:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    5a06:	e6 2e       	mov	r14, r22
    5a08:	f7 2e       	mov	r15, r23
    5a0a:	08 2f       	mov	r16, r24
    5a0c:	19 2f       	mov	r17, r25
    5a0e:	20 e0       	ldi	r18, 0x00	; 0
    5a10:	30 e0       	ldi	r19, 0x00	; 0
    5a12:	a9 01       	movw	r20, r18
    5a14:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    5a18:	88 23       	and	r24, r24
    5a1a:	24 f4       	brge	.+8      	; 0x5a24 <plan_buffer_line+0x4ca>
    5a1c:	e1 2c       	mov	r14, r1
    5a1e:	f1 2c       	mov	r15, r1
    5a20:	00 e0       	ldi	r16, 0x00	; 0
    5a22:	10 e0       	ldi	r17, 0x00	; 0
    5a24:	4e 2d       	mov	r20, r14
    5a26:	5f 2d       	mov	r21, r15
    5a28:	60 2f       	mov	r22, r16
    5a2a:	71 2f       	mov	r23, r17
    5a2c:	f1 01       	movw	r30, r2
    5a2e:	41 8f       	std	Z+25, r20	; 0x19
    5a30:	52 8f       	std	Z+26, r21	; 0x1a
    5a32:	63 8f       	std	Z+27, r22	; 0x1b
    5a34:	74 8f       	std	Z+28, r23	; 0x1c

    }
  }

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
    5a36:	29 a1       	ldd	r18, Y+33	; 0x21
    5a38:	3a a1       	ldd	r19, Y+34	; 0x22
    5a3a:	4b a1       	ldd	r20, Y+35	; 0x23
    5a3c:	5c a1       	ldd	r21, Y+36	; 0x24
    5a3e:	69 a1       	ldd	r22, Y+33	; 0x21
    5a40:	7a a1       	ldd	r23, Y+34	; 0x22
    5a42:	8b a1       	ldd	r24, Y+35	; 0x23
    5a44:	9c a1       	ldd	r25, Y+36	; 0x24
    5a46:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5a4a:	16 2f       	mov	r17, r22
    5a4c:	07 2f       	mov	r16, r23
    5a4e:	f8 2e       	mov	r15, r24
    5a50:	e9 2e       	mov	r14, r25
    5a52:	86 2f       	mov	r24, r22
    5a54:	90 2f       	mov	r25, r16
    5a56:	af 2d       	mov	r26, r15
    5a58:	be 2d       	mov	r27, r14
    5a5a:	f1 01       	movw	r30, r2
    5a5c:	85 8f       	std	Z+29, r24	; 0x1d
    5a5e:	96 8f       	std	Z+30, r25	; 0x1e
    5a60:	a7 8f       	std	Z+31, r26	; 0x1f
    5a62:	b0 a3       	std	Z+32, r27	; 0x20
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    5a64:	91 8c       	ldd	r9, Z+25	; 0x19
    5a66:	82 8c       	ldd	r8, Z+26	; 0x1a
    5a68:	73 8c       	ldd	r7, Z+27	; 0x1b
    5a6a:	64 8c       	ldd	r6, Z+28	; 0x1c
    5a6c:	a0 90 3f 02 	lds	r10, 0x023F
    5a70:	b0 90 40 02 	lds	r11, 0x0240
    5a74:	c0 90 41 02 	lds	r12, 0x0241
    5a78:	d0 90 42 02 	lds	r13, 0x0242
    5a7c:	2a 2d       	mov	r18, r10
    5a7e:	3b 2d       	mov	r19, r11
    5a80:	4c 2d       	mov	r20, r12
    5a82:	5d 2d       	mov	r21, r13
    5a84:	61 2f       	mov	r22, r17
    5a86:	70 2f       	mov	r23, r16
    5a88:	8f 2d       	mov	r24, r15
    5a8a:	9e 2d       	mov	r25, r14
    5a8c:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    5a90:	88 23       	and	r24, r24
    5a92:	0c f4       	brge	.+2      	; 0x5a96 <plan_buffer_line+0x53c>
    5a94:	55 c0       	rjmp	.+170    	; 0x5b40 <plan_buffer_line+0x5e6>
    5a96:	2a 2d       	mov	r18, r10
    5a98:	3b 2d       	mov	r19, r11
    5a9a:	4c 2d       	mov	r20, r12
    5a9c:	5d 2d       	mov	r21, r13
    5a9e:	69 2d       	mov	r22, r9
    5aa0:	78 2d       	mov	r23, r8
    5aa2:	87 2d       	mov	r24, r7
    5aa4:	96 2d       	mov	r25, r6
    5aa6:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    5aaa:	88 23       	and	r24, r24
    5aac:	ac f0       	brlt	.+42     	; 0x5ad8 <plan_buffer_line+0x57e>
    5aae:	2a 2d       	mov	r18, r10
    5ab0:	3b 2d       	mov	r19, r11
    5ab2:	4c 2d       	mov	r20, r12
    5ab4:	5d 2d       	mov	r21, r13
    5ab6:	61 2f       	mov	r22, r17
    5ab8:	70 2f       	mov	r23, r16
    5aba:	8f 2d       	mov	r24, r15
    5abc:	9e 2d       	mov	r25, r14
    5abe:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    5ac2:	88 23       	and	r24, r24
    5ac4:	2c f4       	brge	.+10     	; 0x5ad0 <plan_buffer_line+0x576>
    5ac6:	91 2e       	mov	r9, r17
    5ac8:	80 2e       	mov	r8, r16
    5aca:	7f 2c       	mov	r7, r15
    5acc:	6e 2c       	mov	r6, r14
    5ace:	04 c0       	rjmp	.+8      	; 0x5ad8 <plan_buffer_line+0x57e>
    5ad0:	9a 2c       	mov	r9, r10
    5ad2:	8b 2c       	mov	r8, r11
    5ad4:	7c 2c       	mov	r7, r12
    5ad6:	6d 2c       	mov	r6, r13
    5ad8:	89 2d       	mov	r24, r9
    5ada:	98 2d       	mov	r25, r8
    5adc:	a7 2d       	mov	r26, r7
    5ade:	b6 2d       	mov	r27, r6
    5ae0:	f1 01       	movw	r30, r2
    5ae2:	85 8b       	std	Z+21, r24	; 0x15
    5ae4:	96 8b       	std	Z+22, r25	; 0x16
    5ae6:	a7 8b       	std	Z+23, r26	; 0x17
    5ae8:	b0 8f       	std	Z+24, r27	; 0x18
                                   min(block->nominal_speed_sqr,pl.previous_nominal_speed_sqr));
  
  // Update previous path unit_vector and nominal speed (squared)
  memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
    5aea:	8c e0       	ldi	r24, 0x0C	; 12
    5aec:	fe 01       	movw	r30, r28
    5aee:	3d 96       	adiw	r30, 0x0d	; 13
    5af0:	a3 e3       	ldi	r26, 0x33	; 51
    5af2:	b2 e0       	ldi	r27, 0x02	; 2
    5af4:	01 90       	ld	r0, Z+
    5af6:	0d 92       	st	X+, r0
    5af8:	8a 95       	dec	r24
    5afa:	e1 f7       	brne	.-8      	; 0x5af4 <plan_buffer_line+0x59a>
  pl.previous_nominal_speed_sqr = block->nominal_speed_sqr;
    5afc:	81 2f       	mov	r24, r17
    5afe:	90 2f       	mov	r25, r16
    5b00:	af 2d       	mov	r26, r15
    5b02:	be 2d       	mov	r27, r14
    5b04:	80 93 3f 02 	sts	0x023F, r24
    5b08:	90 93 40 02 	sts	0x0240, r25
    5b0c:	a0 93 41 02 	sts	0x0241, r26
    5b10:	b0 93 42 02 	sts	0x0242, r27
    
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
    5b14:	8c e0       	ldi	r24, 0x0C	; 12
    5b16:	fe 01       	movw	r30, r28
    5b18:	31 96       	adiw	r30, 0x01	; 1
    5b1a:	a7 e2       	ldi	r26, 0x27	; 39
    5b1c:	b2 e0       	ldi	r27, 0x02	; 2
    5b1e:	01 90       	ld	r0, Z+
    5b20:	0d 92       	st	X+, r0
    5b22:	8a 95       	dec	r24
    5b24:	e1 f7       	brne	.-8      	; 0x5b1e <plan_buffer_line+0x5c4>

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
    5b26:	80 91 44 02 	lds	r24, 0x0244
    5b2a:	80 93 45 02 	sts	0x0245, r24


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    5b2e:	8f 5f       	subi	r24, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    5b30:	80 32       	cpi	r24, 0x20	; 32
    5b32:	09 f4       	brne	.+2      	; 0x5b36 <plan_buffer_line+0x5dc>
    5b34:	80 e0       	ldi	r24, 0x00	; 0
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
    5b36:	80 93 44 02 	sts	0x0244, r24
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
    5b3a:	0e 94 25 29 	call	0x524a	; 0x524a <planner_recalculate>
    5b3e:	0e c0       	rjmp	.+28     	; 0x5b5c <plan_buffer_line+0x602>

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    5b40:	29 2d       	mov	r18, r9
    5b42:	38 2d       	mov	r19, r8
    5b44:	47 2d       	mov	r20, r7
    5b46:	56 2d       	mov	r21, r6
    5b48:	61 2f       	mov	r22, r17
    5b4a:	70 2f       	mov	r23, r16
    5b4c:	8f 2d       	mov	r24, r15
    5b4e:	9e 2d       	mov	r25, r14
    5b50:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    5b54:	18 16       	cp	r1, r24
    5b56:	0c f0       	brlt	.+2      	; 0x5b5a <plan_buffer_line+0x600>
    5b58:	b6 cf       	rjmp	.-148    	; 0x5ac6 <plan_buffer_line+0x56c>
    5b5a:	be cf       	rjmp	.-132    	; 0x5ad8 <plan_buffer_line+0x57e>
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
}
    5b5c:	ad 96       	adiw	r28, 0x2d	; 45
    5b5e:	0f b6       	in	r0, 0x3f	; 63
    5b60:	f8 94       	cli
    5b62:	de bf       	out	0x3e, r29	; 62
    5b64:	0f be       	out	0x3f, r0	; 63
    5b66:	cd bf       	out	0x3d, r28	; 61
    5b68:	df 91       	pop	r29
    5b6a:	cf 91       	pop	r28
    5b6c:	1f 91       	pop	r17
    5b6e:	0f 91       	pop	r16
    5b70:	ff 90       	pop	r15
    5b72:	ef 90       	pop	r14
    5b74:	df 90       	pop	r13
    5b76:	cf 90       	pop	r12
    5b78:	bf 90       	pop	r11
    5b7a:	af 90       	pop	r10
    5b7c:	9f 90       	pop	r9
    5b7e:	8f 90       	pop	r8
    5b80:	7f 90       	pop	r7
    5b82:	6f 90       	pop	r6
    5b84:	5f 90       	pop	r5
    5b86:	4f 90       	pop	r4
    5b88:	3f 90       	pop	r3
    5b8a:	2f 90       	pop	r2
    5b8c:	08 95       	ret

00005b8e <plan_sync_position>:
        pl.position[idx] = (sys.position[A_MOTOR] - sys.position[B_MOTOR])/2;
      } else {
        pl.position[idx] = sys.position[idx];
      }
    #else
      pl.position[idx] = sys.position[idx];
    5b8e:	80 91 6c 07 	lds	r24, 0x076C
    5b92:	90 91 6d 07 	lds	r25, 0x076D
    5b96:	a0 91 6e 07 	lds	r26, 0x076E
    5b9a:	b0 91 6f 07 	lds	r27, 0x076F
    5b9e:	80 93 27 02 	sts	0x0227, r24
    5ba2:	90 93 28 02 	sts	0x0228, r25
    5ba6:	a0 93 29 02 	sts	0x0229, r26
    5baa:	b0 93 2a 02 	sts	0x022A, r27
    5bae:	80 91 70 07 	lds	r24, 0x0770
    5bb2:	90 91 71 07 	lds	r25, 0x0771
    5bb6:	a0 91 72 07 	lds	r26, 0x0772
    5bba:	b0 91 73 07 	lds	r27, 0x0773
    5bbe:	80 93 2b 02 	sts	0x022B, r24
    5bc2:	90 93 2c 02 	sts	0x022C, r25
    5bc6:	a0 93 2d 02 	sts	0x022D, r26
    5bca:	b0 93 2e 02 	sts	0x022E, r27
    5bce:	80 91 74 07 	lds	r24, 0x0774
    5bd2:	90 91 75 07 	lds	r25, 0x0775
    5bd6:	a0 91 76 07 	lds	r26, 0x0776
    5bda:	b0 91 77 07 	lds	r27, 0x0777
    5bde:	80 93 2f 02 	sts	0x022F, r24
    5be2:	90 93 30 02 	sts	0x0230, r25
    5be6:	a0 93 31 02 	sts	0x0231, r26
    5bea:	b0 93 32 02 	sts	0x0232, r27
    5bee:	08 95       	ret

00005bf0 <plan_get_block_buffer_count>:


// Returns the number of active blocks are in the planner buffer.
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
    5bf0:	80 91 45 02 	lds	r24, 0x0245
    5bf4:	90 91 46 02 	lds	r25, 0x0246
    5bf8:	89 17       	cp	r24, r25
    5bfa:	10 f0       	brcs	.+4      	; 0x5c00 <plan_get_block_buffer_count+0x10>
    5bfc:	89 1b       	sub	r24, r25
    5bfe:	08 95       	ret
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
    5c00:	80 5e       	subi	r24, 0xE0	; 224
    5c02:	89 1b       	sub	r24, r25
}
    5c04:	08 95       	ret

00005c06 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    5c06:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    5c0a:	80 91 46 02 	lds	r24, 0x0246
    5c0e:	80 93 43 02 	sts	0x0243, r24
  planner_recalculate();  
    5c12:	0e 94 25 29 	call	0x524a	; 0x524a <planner_recalculate>
    5c16:	08 95       	ret

00005c18 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized. 
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
uint8_t read_float(char *line, uint8_t *char_counter, float *float_ptr)                  
{
    5c18:	4f 92       	push	r4
    5c1a:	5f 92       	push	r5
    5c1c:	6f 92       	push	r6
    5c1e:	7f 92       	push	r7
    5c20:	9f 92       	push	r9
    5c22:	af 92       	push	r10
    5c24:	bf 92       	push	r11
    5c26:	cf 92       	push	r12
    5c28:	df 92       	push	r13
    5c2a:	ef 92       	push	r14
    5c2c:	ff 92       	push	r15
    5c2e:	0f 93       	push	r16
    5c30:	1f 93       	push	r17
    5c32:	cf 93       	push	r28
    5c34:	df 93       	push	r29
    5c36:	7c 01       	movw	r14, r24
    5c38:	8b 01       	movw	r16, r22
    5c3a:	6a 01       	movw	r12, r20
  char *ptr = line + *char_counter;
    5c3c:	fb 01       	movw	r30, r22
    5c3e:	80 81       	ld	r24, Z
    5c40:	f7 01       	movw	r30, r14
    5c42:	e8 0f       	add	r30, r24
    5c44:	f1 1d       	adc	r31, r1
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
    5c46:	40 81       	ld	r20, Z
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    5c48:	4d 32       	cpi	r20, 0x2D	; 45
    5c4a:	39 f4       	brne	.+14     	; 0x5c5a <read_float+0x42>
    isnegative = true;
    c = *ptr++;
    5c4c:	9f 01       	movw	r18, r30
    5c4e:	2e 5f       	subi	r18, 0xFE	; 254
    5c50:	3f 4f       	sbci	r19, 0xFF	; 255
    5c52:	41 81       	ldd	r20, Z+1	; 0x01
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    isnegative = true;
    5c54:	aa 24       	eor	r10, r10
    5c56:	a3 94       	inc	r10
    5c58:	0c c0       	rjmp	.+24     	; 0x5c72 <read_float+0x5a>
    c = *ptr++;
  } else if (c == '+') {
    5c5a:	4b 32       	cpi	r20, 0x2B	; 43
    5c5c:	29 f0       	breq	.+10     	; 0x5c68 <read_float+0x50>
{
  char *ptr = line + *char_counter;
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
    5c5e:	9f 01       	movw	r18, r30
    5c60:	2f 5f       	subi	r18, 0xFF	; 255
    5c62:	3f 4f       	sbci	r19, 0xFF	; 255
  
  // Capture initial positive/minus character
  bool isnegative = false;
    5c64:	a1 2c       	mov	r10, r1
    5c66:	05 c0       	rjmp	.+10     	; 0x5c72 <read_float+0x5a>
  if (c == '-') {
    isnegative = true;
    c = *ptr++;
  } else if (c == '+') {
    c = *ptr++;
    5c68:	9f 01       	movw	r18, r30
    5c6a:	2e 5f       	subi	r18, 0xFE	; 254
    5c6c:	3f 4f       	sbci	r19, 0xFF	; 255
    5c6e:	41 81       	ldd	r20, Z+1	; 0x01
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
    5c70:	a1 2c       	mov	r10, r1
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
    5c72:	e0 e0       	ldi	r30, 0x00	; 0
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
    5c74:	50 e0       	ldi	r21, 0x00	; 0
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
    5c76:	b1 2c       	mov	r11, r1
  } else if (c == '+') {
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
    5c78:	60 e0       	ldi	r22, 0x00	; 0
    5c7a:	70 e0       	ldi	r23, 0x00	; 0
    5c7c:	cb 01       	movw	r24, r22
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
      isdecimal = true;
    5c7e:	f1 e0       	ldi	r31, 0x01	; 1
    5c80:	e9 01       	movw	r28, r18
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
  while(1) {
    c -= '0';
    5c82:	40 53       	subi	r20, 0x30	; 48
    if (c <= 9) {
    5c84:	4a 30       	cpi	r20, 0x0A	; 10
    5c86:	20 f5       	brcc	.+72     	; 0x5cd0 <read_float+0xb8>
      ndigit++;
    5c88:	5f 5f       	subi	r21, 0xFF	; 255
      if (ndigit <= MAX_INT_DIGITS) {
    5c8a:	59 30       	cpi	r21, 0x09	; 9
    5c8c:	e8 f4       	brcc	.+58     	; 0x5cc8 <read_float+0xb0>
        if (isdecimal) { exp--; }
    5c8e:	e1 11       	cpse	r30, r1
    5c90:	ba 94       	dec	r11
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
    5c92:	2b 01       	movw	r4, r22
    5c94:	3c 01       	movw	r6, r24
    5c96:	44 0c       	add	r4, r4
    5c98:	55 1c       	adc	r5, r5
    5c9a:	66 1c       	adc	r6, r6
    5c9c:	77 1c       	adc	r7, r7
    5c9e:	44 0c       	add	r4, r4
    5ca0:	55 1c       	adc	r5, r5
    5ca2:	66 1c       	adc	r6, r6
    5ca4:	77 1c       	adc	r7, r7
    5ca6:	dc 01       	movw	r26, r24
    5ca8:	cb 01       	movw	r24, r22
    5caa:	84 0d       	add	r24, r4
    5cac:	95 1d       	adc	r25, r5
    5cae:	a6 1d       	adc	r26, r6
    5cb0:	b7 1d       	adc	r27, r7
    5cb2:	88 0f       	add	r24, r24
    5cb4:	99 1f       	adc	r25, r25
    5cb6:	aa 1f       	adc	r26, r26
    5cb8:	bb 1f       	adc	r27, r27
    5cba:	bc 01       	movw	r22, r24
    5cbc:	cd 01       	movw	r24, r26
    5cbe:	64 0f       	add	r22, r20
    5cc0:	71 1d       	adc	r23, r1
    5cc2:	81 1d       	adc	r24, r1
    5cc4:	91 1d       	adc	r25, r1
    5cc6:	09 c0       	rjmp	.+18     	; 0x5cda <read_float+0xc2>
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
    5cc8:	e1 11       	cpse	r30, r1
    5cca:	07 c0       	rjmp	.+14     	; 0x5cda <read_float+0xc2>
    5ccc:	b3 94       	inc	r11
    5cce:	05 c0       	rjmp	.+10     	; 0x5cda <read_float+0xc2>
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
    5cd0:	4e 3f       	cpi	r20, 0xFE	; 254
    5cd2:	39 f4       	brne	.+14     	; 0x5ce2 <read_float+0xca>
    5cd4:	e1 11       	cpse	r30, r1
    5cd6:	07 c0       	rjmp	.+14     	; 0x5ce6 <read_float+0xce>
      isdecimal = true;
    5cd8:	ef 2f       	mov	r30, r31
    } else {
      break;
    }
    c = *ptr++;
    5cda:	48 81       	ld	r20, Y
    5cdc:	2f 5f       	subi	r18, 0xFF	; 255
    5cde:	3f 4f       	sbci	r19, 0xFF	; 255
  }
    5ce0:	cf cf       	rjmp	.-98     	; 0x5c80 <read_float+0x68>
    5ce2:	9b 2c       	mov	r9, r11
    5ce4:	01 c0       	rjmp	.+2      	; 0x5ce8 <read_float+0xd0>
    5ce6:	9b 2c       	mov	r9, r11
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
    5ce8:	55 23       	and	r21, r21
    5cea:	09 f4       	brne	.+2      	; 0x5cee <read_float+0xd6>
    5cec:	50 c0       	rjmp	.+160    	; 0x5d8e <read_float+0x176>
  
  // Convert integer into floating point.
  float fval;
  fval = (float)intval;
    5cee:	0e 94 4d 3d 	call	0x7a9a	; 0x7a9a <__floatunsisf>
    5cf2:	2b 01       	movw	r4, r22
    5cf4:	3c 01       	movw	r6, r24
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    5cf6:	20 e0       	ldi	r18, 0x00	; 0
    5cf8:	30 e0       	ldi	r19, 0x00	; 0
    5cfa:	a9 01       	movw	r20, r18
    5cfc:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    5d00:	88 23       	and	r24, r24
    5d02:	69 f1       	breq	.+90     	; 0x5d5e <read_float+0x146>
    while (exp <= -2) {
    5d04:	ff ef       	ldi	r31, 0xFF	; 255
    5d06:	9f 16       	cp	r9, r31
    5d08:	7c f4       	brge	.+30     	; 0x5d28 <read_float+0x110>
      fval *= 0.01; 
    5d0a:	2a e0       	ldi	r18, 0x0A	; 10
    5d0c:	37 ed       	ldi	r19, 0xD7	; 215
    5d0e:	43 e2       	ldi	r20, 0x23	; 35
    5d10:	5c e3       	ldi	r21, 0x3C	; 60
    5d12:	c3 01       	movw	r24, r6
    5d14:	b2 01       	movw	r22, r4
    5d16:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5d1a:	2b 01       	movw	r4, r22
    5d1c:	3c 01       	movw	r6, r24
    5d1e:	b3 94       	inc	r11
    5d20:	b3 94       	inc	r11
  fval = (float)intval;
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    while (exp <= -2) {
    5d22:	8f ef       	ldi	r24, 0xFF	; 255
    5d24:	b8 16       	cp	r11, r24
    5d26:	8c f3       	brlt	.-30     	; 0x5d0a <read_float+0xf2>
      fval *= 0.01; 
      exp += 2;
    }
    if (exp < 0) { 
    5d28:	bb 20       	and	r11, r11
    5d2a:	5c f4       	brge	.+22     	; 0x5d42 <read_float+0x12a>
      fval *= 0.1; 
    5d2c:	2d ec       	ldi	r18, 0xCD	; 205
    5d2e:	3c ec       	ldi	r19, 0xCC	; 204
    5d30:	4c ec       	ldi	r20, 0xCC	; 204
    5d32:	5d e3       	ldi	r21, 0x3D	; 61
    5d34:	c3 01       	movw	r24, r6
    5d36:	b2 01       	movw	r22, r4
    5d38:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5d3c:	2b 01       	movw	r4, r22
    5d3e:	3c 01       	movw	r6, r24
    5d40:	0e c0       	rjmp	.+28     	; 0x5d5e <read_float+0x146>
    } else if (exp > 0) {
    5d42:	1b 14       	cp	r1, r11
    5d44:	64 f4       	brge	.+24     	; 0x5d5e <read_float+0x146>
      do {
        fval *= 10.0;
    5d46:	20 e0       	ldi	r18, 0x00	; 0
    5d48:	30 e0       	ldi	r19, 0x00	; 0
    5d4a:	40 e2       	ldi	r20, 0x20	; 32
    5d4c:	51 e4       	ldi	r21, 0x41	; 65
    5d4e:	c3 01       	movw	r24, r6
    5d50:	b2 01       	movw	r22, r4
    5d52:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5d56:	2b 01       	movw	r4, r22
    5d58:	3c 01       	movw	r6, r24
      } while (--exp > 0);
    5d5a:	ba 94       	dec	r11
    5d5c:	a1 f7       	brne	.-24     	; 0x5d46 <read_float+0x12e>
    } 
  }

  // Assign floating point value with correct sign.    
  if (isnegative) {
    5d5e:	aa 20       	and	r10, r10
    5d60:	51 f0       	breq	.+20     	; 0x5d76 <read_float+0x15e>
    *float_ptr = -fval;
    5d62:	77 fa       	bst	r7, 7
    5d64:	70 94       	com	r7
    5d66:	77 f8       	bld	r7, 7
    5d68:	70 94       	com	r7
    5d6a:	f6 01       	movw	r30, r12
    5d6c:	40 82       	st	Z, r4
    5d6e:	51 82       	std	Z+1, r5	; 0x01
    5d70:	62 82       	std	Z+2, r6	; 0x02
    5d72:	73 82       	std	Z+3, r7	; 0x03
    5d74:	05 c0       	rjmp	.+10     	; 0x5d80 <read_float+0x168>
  } else {
    *float_ptr = fval;
    5d76:	f6 01       	movw	r30, r12
    5d78:	40 82       	st	Z, r4
    5d7a:	51 82       	std	Z+1, r5	; 0x01
    5d7c:	62 82       	std	Z+2, r6	; 0x02
    5d7e:	73 82       	std	Z+3, r7	; 0x03
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
    5d80:	ce 19       	sub	r28, r14
    5d82:	df 09       	sbc	r29, r15
    5d84:	c1 50       	subi	r28, 0x01	; 1
    5d86:	f8 01       	movw	r30, r16
    5d88:	c0 83       	st	Z, r28
  
  return(true);
    5d8a:	81 e0       	ldi	r24, 0x01	; 1
    5d8c:	01 c0       	rjmp	.+2      	; 0x5d90 <read_float+0x178>
    }
    c = *ptr++;
  }
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
    5d8e:	80 e0       	ldi	r24, 0x00	; 0
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
  
  return(true);
}
    5d90:	df 91       	pop	r29
    5d92:	cf 91       	pop	r28
    5d94:	1f 91       	pop	r17
    5d96:	0f 91       	pop	r16
    5d98:	ff 90       	pop	r15
    5d9a:	ef 90       	pop	r14
    5d9c:	df 90       	pop	r13
    5d9e:	cf 90       	pop	r12
    5da0:	bf 90       	pop	r11
    5da2:	af 90       	pop	r10
    5da4:	9f 90       	pop	r9
    5da6:	7f 90       	pop	r7
    5da8:	6f 90       	pop	r6
    5daa:	5f 90       	pop	r5
    5dac:	4f 90       	pop	r4
    5dae:	08 95       	ret

00005db0 <delay_ms>:

// Delays variable defined milliseconds. Compiler compatibility fix for _delay_ms(),
// which only accepts constants in future compiler releases.
void delay_ms(uint16_t ms) 
{
  while ( ms-- ) { _delay_ms(1); }
    5db0:	00 97       	sbiw	r24, 0x00	; 0
    5db2:	49 f0       	breq	.+18     	; 0x5dc6 <delay_ms+0x16>
    5db4:	ef ef       	ldi	r30, 0xFF	; 255
    5db6:	f1 e1       	ldi	r31, 0x11	; 17
    5db8:	31 97       	sbiw	r30, 0x01	; 1
    5dba:	f1 f7       	brne	.-4      	; 0x5db8 <delay_ms+0x8>
    5dbc:	00 c0       	rjmp	.+0      	; 0x5dbe <delay_ms+0xe>
    5dbe:	00 00       	nop
    5dc0:	01 97       	sbiw	r24, 0x01	; 1
    5dc2:	00 97       	sbiw	r24, 0x00	; 0
    5dc4:	b9 f7       	brne	.-18     	; 0x5db4 <delay_ms+0x4>
    5dc6:	08 95       	ret

00005dc8 <delay_us>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    5dc8:	61 15       	cp	r22, r1
    5dca:	71 05       	cpc	r23, r1
    5dcc:	81 05       	cpc	r24, r1
    5dce:	91 05       	cpc	r25, r1
    5dd0:	e1 f1       	breq	.+120    	; 0x5e4a <delay_us+0x82>
    if (us < 10) { 
    5dd2:	6a 30       	cpi	r22, 0x0A	; 10
    5dd4:	71 05       	cpc	r23, r1
    5dd6:	81 05       	cpc	r24, r1
    5dd8:	91 05       	cpc	r25, r1
    5dda:	48 f4       	brcc	.+18     	; 0x5dee <delay_us+0x26>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5ddc:	26 e0       	ldi	r18, 0x06	; 6
    5dde:	2a 95       	dec	r18
    5de0:	f1 f7       	brne	.-4      	; 0x5dde <delay_us+0x16>
    5de2:	00 00       	nop
      _delay_us(1);
      us--;
    5de4:	61 50       	subi	r22, 0x01	; 1
    5de6:	71 09       	sbc	r23, r1
    5de8:	81 09       	sbc	r24, r1
    5dea:	91 09       	sbc	r25, r1
    5dec:	29 c0       	rjmp	.+82     	; 0x5e40 <delay_us+0x78>
    } else if (us < 100) {
    5dee:	64 36       	cpi	r22, 0x64	; 100
    5df0:	71 05       	cpc	r23, r1
    5df2:	81 05       	cpc	r24, r1
    5df4:	91 05       	cpc	r25, r1
    5df6:	48 f4       	brcc	.+18     	; 0x5e0a <delay_us+0x42>
    5df8:	ed e3       	ldi	r30, 0x3D	; 61
    5dfa:	ea 95       	dec	r30
    5dfc:	f1 f7       	brne	.-4      	; 0x5dfa <delay_us+0x32>
    5dfe:	00 c0       	rjmp	.+0      	; 0x5e00 <delay_us+0x38>
      _delay_us(10);
      us -= 10;
    5e00:	6a 50       	subi	r22, 0x0A	; 10
    5e02:	71 09       	sbc	r23, r1
    5e04:	81 09       	sbc	r24, r1
    5e06:	91 09       	sbc	r25, r1
    5e08:	1b c0       	rjmp	.+54     	; 0x5e40 <delay_us+0x78>
    } else if (us < 1000) {
    5e0a:	68 3e       	cpi	r22, 0xE8	; 232
    5e0c:	f3 e0       	ldi	r31, 0x03	; 3
    5e0e:	7f 07       	cpc	r23, r31
    5e10:	81 05       	cpc	r24, r1
    5e12:	91 05       	cpc	r25, r1
    5e14:	58 f4       	brcc	.+22     	; 0x5e2c <delay_us+0x64>
    5e16:	ec ec       	ldi	r30, 0xCC	; 204
    5e18:	f1 e0       	ldi	r31, 0x01	; 1
    5e1a:	31 97       	sbiw	r30, 0x01	; 1
    5e1c:	f1 f7       	brne	.-4      	; 0x5e1a <delay_us+0x52>
    5e1e:	00 c0       	rjmp	.+0      	; 0x5e20 <delay_us+0x58>
    5e20:	00 00       	nop
      _delay_us(100);
      us -= 100;
    5e22:	64 56       	subi	r22, 0x64	; 100
    5e24:	71 09       	sbc	r23, r1
    5e26:	81 09       	sbc	r24, r1
    5e28:	91 09       	sbc	r25, r1
    5e2a:	0a c0       	rjmp	.+20     	; 0x5e40 <delay_us+0x78>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5e2c:	ef ef       	ldi	r30, 0xFF	; 255
    5e2e:	f1 e1       	ldi	r31, 0x11	; 17
    5e30:	31 97       	sbiw	r30, 0x01	; 1
    5e32:	f1 f7       	brne	.-4      	; 0x5e30 <delay_us+0x68>
    5e34:	00 c0       	rjmp	.+0      	; 0x5e36 <delay_us+0x6e>
    5e36:	00 00       	nop
    } else {
      _delay_ms(1);
      us -= 1000;
    5e38:	68 5e       	subi	r22, 0xE8	; 232
    5e3a:	73 40       	sbci	r23, 0x03	; 3
    5e3c:	81 09       	sbc	r24, r1
    5e3e:	91 09       	sbc	r25, r1
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    5e40:	61 15       	cp	r22, r1
    5e42:	71 05       	cpc	r23, r1
    5e44:	81 05       	cpc	r24, r1
    5e46:	91 05       	cpc	r25, r1
    5e48:	21 f6       	brne	.-120    	; 0x5dd2 <delay_us+0xa>
    5e4a:	08 95       	ret

00005e4c <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    5e4c:	8f 92       	push	r8
    5e4e:	9f 92       	push	r9
    5e50:	af 92       	push	r10
    5e52:	bf 92       	push	r11
    5e54:	cf 92       	push	r12
    5e56:	df 92       	push	r13
    5e58:	ef 92       	push	r14
    5e5a:	ff 92       	push	r15
    5e5c:	69 01       	movw	r12, r18
    5e5e:	7a 01       	movw	r14, r20
    5e60:	9b 01       	movw	r18, r22
    5e62:	ac 01       	movw	r20, r24
    5e64:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5e68:	4b 01       	movw	r8, r22
    5e6a:	5c 01       	movw	r10, r24
    5e6c:	a7 01       	movw	r20, r14
    5e6e:	96 01       	movw	r18, r12
    5e70:	c7 01       	movw	r24, r14
    5e72:	b6 01       	movw	r22, r12
    5e74:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    5e78:	9b 01       	movw	r18, r22
    5e7a:	ac 01       	movw	r20, r24
    5e7c:	c5 01       	movw	r24, r10
    5e7e:	b4 01       	movw	r22, r8
    5e80:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    5e84:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    5e88:	ff 90       	pop	r15
    5e8a:	ef 90       	pop	r14
    5e8c:	df 90       	pop	r13
    5e8e:	cf 90       	pop	r12
    5e90:	bf 90       	pop	r11
    5e92:	af 90       	pop	r10
    5e94:	9f 90       	pop	r9
    5e96:	8f 90       	pop	r8
    5e98:	08 95       	ret

00005e9a <limits_disable>:
}


void limits_disable()
{
  LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    5e9a:	ec e6       	ldi	r30, 0x6C	; 108
    5e9c:	f0 e0       	ldi	r31, 0x00	; 0
    5e9e:	80 81       	ld	r24, Z
    5ea0:	81 7f       	andi	r24, 0xF1	; 241
    5ea2:	80 83       	st	Z, r24
  PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    5ea4:	e8 e6       	ldi	r30, 0x68	; 104
    5ea6:	f0 e0       	ldi	r31, 0x00	; 0
    5ea8:	80 81       	ld	r24, Z
    5eaa:	8d 7f       	andi	r24, 0xFD	; 253
    5eac:	80 83       	st	Z, r24
    5eae:	08 95       	ret

00005eb0 <limits_init>:
#define HOMING_AXIS_SEARCH_SCALAR  1.5 // Must be > 1 to ensure limit switch will be engaged.


void limits_init() 
{
  LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    5eb0:	84 b1       	in	r24, 0x04	; 4
    5eb2:	81 7f       	andi	r24, 0xF1	; 241
    5eb4:	84 b9       	out	0x04, r24	; 4

  #ifdef DISABLE_LIMIT_PIN_PULL_UP
    LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
  #else
    LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    5eb6:	85 b1       	in	r24, 0x05	; 5
    5eb8:	8e 60       	ori	r24, 0x0E	; 14
    5eba:	85 b9       	out	0x05, r24	; 5
  #endif

  if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    5ebc:	80 91 3c 09 	lds	r24, 0x093C
    5ec0:	83 ff       	sbrs	r24, 3
    5ec2:	0b c0       	rjmp	.+22     	; 0x5eda <limits_init+0x2a>
    LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    5ec4:	ec e6       	ldi	r30, 0x6C	; 108
    5ec6:	f0 e0       	ldi	r31, 0x00	; 0
    5ec8:	80 81       	ld	r24, Z
    5eca:	8e 60       	ori	r24, 0x0E	; 14
    5ecc:	80 83       	st	Z, r24
    PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    5ece:	e8 e6       	ldi	r30, 0x68	; 104
    5ed0:	f0 e0       	ldi	r31, 0x00	; 0
    5ed2:	80 81       	ld	r24, Z
    5ed4:	82 60       	ori	r24, 0x02	; 2
    5ed6:	80 83       	st	Z, r24
    5ed8:	08 95       	ret
  } else {
    limits_disable(); 
    5eda:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <limits_disable>
    5ede:	08 95       	ret

00005ee0 <__vector_5>:
// homing cycles and will not respond correctly. Upon user request or need, there may be a
// special pinout for an e-stop, but it is generally recommended to just directly connect
// your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
#ifndef ENABLE_SOFTWARE_DEBOUNCE
  ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process. 
  {
    5ee0:	1f 92       	push	r1
    5ee2:	0f 92       	push	r0
    5ee4:	0f b6       	in	r0, 0x3f	; 63
    5ee6:	0f 92       	push	r0
    5ee8:	11 24       	eor	r1, r1
    5eea:	2f 93       	push	r18
    5eec:	3f 93       	push	r19
    5eee:	4f 93       	push	r20
    5ef0:	5f 93       	push	r21
    5ef2:	6f 93       	push	r22
    5ef4:	7f 93       	push	r23
    5ef6:	8f 93       	push	r24
    5ef8:	9f 93       	push	r25
    5efa:	af 93       	push	r26
    5efc:	bf 93       	push	r27
    5efe:	ef 93       	push	r30
    5f00:	ff 93       	push	r31
    // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
    // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
    // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
    // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
    // limit setting if their limits are constantly triggering after a reset and move their axes.
    if (sys.state != STATE_ALARM) { 
    5f02:	80 91 68 07 	lds	r24, 0x0768
    5f06:	81 30       	cpi	r24, 0x01	; 1
    5f08:	71 f0       	breq	.+28     	; 0x5f26 <__vector_5+0x46>
      if (!(sys.rt_exec_alarm)) {
    5f0a:	80 91 6b 07 	lds	r24, 0x076B
    5f0e:	81 11       	cpse	r24, r1
    5f10:	0a c0       	rjmp	.+20     	; 0x5f26 <__vector_5+0x46>
        mc_reset(); // Initiate system kill.
    5f12:	0e 94 b2 0c 	call	0x1964	; 0x1964 <mc_reset>
        bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
    5f16:	8f b7       	in	r24, 0x3f	; 63
    5f18:	f8 94       	cli
    5f1a:	eb e6       	ldi	r30, 0x6B	; 107
    5f1c:	f7 e0       	ldi	r31, 0x07	; 7
    5f1e:	90 81       	ld	r25, Z
    5f20:	93 60       	ori	r25, 0x03	; 3
    5f22:	90 83       	st	Z, r25
    5f24:	8f bf       	out	0x3f, r24	; 63
      }
    }
  }  
    5f26:	ff 91       	pop	r31
    5f28:	ef 91       	pop	r30
    5f2a:	bf 91       	pop	r27
    5f2c:	af 91       	pop	r26
    5f2e:	9f 91       	pop	r25
    5f30:	8f 91       	pop	r24
    5f32:	7f 91       	pop	r23
    5f34:	6f 91       	pop	r22
    5f36:	5f 91       	pop	r21
    5f38:	4f 91       	pop	r20
    5f3a:	3f 91       	pop	r19
    5f3c:	2f 91       	pop	r18
    5f3e:	0f 90       	pop	r0
    5f40:	0f be       	out	0x3f, r0	; 63
    5f42:	0f 90       	pop	r0
    5f44:	1f 90       	pop	r1
    5f46:	18 95       	reti

00005f48 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically 
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask) 
{
    5f48:	2f 92       	push	r2
    5f4a:	3f 92       	push	r3
    5f4c:	4f 92       	push	r4
    5f4e:	5f 92       	push	r5
    5f50:	6f 92       	push	r6
    5f52:	7f 92       	push	r7
    5f54:	8f 92       	push	r8
    5f56:	9f 92       	push	r9
    5f58:	af 92       	push	r10
    5f5a:	bf 92       	push	r11
    5f5c:	cf 92       	push	r12
    5f5e:	df 92       	push	r13
    5f60:	ef 92       	push	r14
    5f62:	ff 92       	push	r15
    5f64:	0f 93       	push	r16
    5f66:	1f 93       	push	r17
    5f68:	cf 93       	push	r28
    5f6a:	df 93       	push	r29
    5f6c:	cd b7       	in	r28, 0x3d	; 61
    5f6e:	de b7       	in	r29, 0x3e	; 62
    5f70:	e3 97       	sbiw	r28, 0x33	; 51
    5f72:	0f b6       	in	r0, 0x3f	; 63
    5f74:	f8 94       	cli
    5f76:	de bf       	out	0x3e, r29	; 62
    5f78:	0f be       	out	0x3f, r0	; 63
    5f7a:	cd bf       	out	0x3d, r28	; 61
    5f7c:	a8 2e       	mov	r10, r24
  if (sys.abort) { return; } // Block if system reset has been issued.
    5f7e:	80 91 67 07 	lds	r24, 0x0767
    5f82:	81 11       	cpse	r24, r1
    5f84:	7b c2       	rjmp	.+1270   	; 0x647c <limits_go_home+0x534>

  // Initialize homing in search mode to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    5f86:	80 91 42 09 	lds	r24, 0x0942
    5f8a:	90 91 43 09 	lds	r25, 0x0943
    5f8e:	a0 91 44 09 	lds	r26, 0x0944
    5f92:	b0 91 45 09 	lds	r27, 0x0945
    5f96:	88 a3       	std	Y+32, r24	; 0x20
    5f98:	99 a3       	std	Y+33, r25	; 0x21
    5f9a:	aa a3       	std	Y+34, r26	; 0x22
    5f9c:	bb a3       	std	Y+35, r27	; 0x23
    5f9e:	de 01       	movw	r26, r28
    5fa0:	1d 96       	adiw	r26, 0x0d	; 13
    5fa2:	be 8b       	std	Y+22, r27	; 0x16
    5fa4:	ad 8b       	std	Y+21, r26	; 0x15
    5fa6:	fe 01       	movw	r30, r28
    5fa8:	70 96       	adiw	r30, 0x10	; 16
    5faa:	fc 8b       	std	Y+20, r31	; 0x14
    5fac:	eb 8b       	std	Y+19, r30	; 0x13
    5fae:	1f 01       	movw	r2, r30
    5fb0:	0f 2e       	mov	r0, r31
    5fb2:	f3 e2       	ldi	r31, 0x23	; 35
    5fb4:	4f 2e       	mov	r4, r31
    5fb6:	f9 e0       	ldi	r31, 0x09	; 9
    5fb8:	5f 2e       	mov	r5, r31
    5fba:	f0 2d       	mov	r31, r0
    5fbc:	3f 01       	movw	r6, r30
    5fbe:	8d 01       	movw	r16, r26
  uint8_t invert_pin, idx;
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  float target[N_AXIS];
  
  uint8_t limit_pin[N_AXIS], step_pin[N_AXIS];
  float max_travel = 0.0;
    5fc0:	81 2c       	mov	r8, r1
    5fc2:	91 2c       	mov	r9, r1
    5fc4:	b1 2c       	mov	r11, r1
    5fc6:	a9 8e       	std	Y+25, r10	; 0x19
    5fc8:	ab 2c       	mov	r10, r11
    5fca:	f0 2e       	mov	r15, r16
    5fcc:	3d 89       	ldd	r19, Y+21	; 0x15
    5fce:	f3 1a       	sub	r15, r19
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize limit and step pin masks
    limit_pin[idx] = get_limit_pin_mask(idx);
    5fd0:	8f 2d       	mov	r24, r15
    5fd2:	0e 94 1b 29 	call	0x5236	; 0x5236 <get_limit_pin_mask>
    5fd6:	d8 01       	movw	r26, r16
    5fd8:	8d 93       	st	X+, r24
    5fda:	8d 01       	movw	r16, r26
    step_pin[idx] = get_step_pin_mask(idx);
    5fdc:	8f 2d       	mov	r24, r15
    5fde:	0e 94 07 29 	call	0x520e	; 0x520e <get_step_pin_mask>
    5fe2:	f3 01       	movw	r30, r6
    5fe4:	81 93       	st	Z+, r24
    5fe6:	3f 01       	movw	r6, r30
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif
    
    // Determine travel distance to the furthest homing switch based on user max travel settings.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (max_travel > settings.max_travel[idx]) { max_travel = settings.max_travel[idx]; }
    5fe8:	d2 01       	movw	r26, r4
    5fea:	cd 90       	ld	r12, X+
    5fec:	dd 90       	ld	r13, X+
    5fee:	ed 90       	ld	r14, X+
    5ff0:	fd 90       	ld	r15, X+
    5ff2:	2d 01       	movw	r4, r26
    5ff4:	2b 2d       	mov	r18, r11
    5ff6:	38 2d       	mov	r19, r8
    5ff8:	49 2d       	mov	r20, r9
    5ffa:	5a 2d       	mov	r21, r10
    5ffc:	c7 01       	movw	r24, r14
    5ffe:	b6 01       	movw	r22, r12
    6000:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    6004:	88 23       	and	r24, r24
    6006:	24 f4       	brge	.+8      	; 0x6010 <limits_go_home+0xc8>
    6008:	bc 2c       	mov	r11, r12
    600a:	8d 2c       	mov	r8, r13
    600c:	9e 2c       	mov	r9, r14
    600e:	af 2c       	mov	r10, r15
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  float target[N_AXIS];
  
  uint8_t limit_pin[N_AXIS], step_pin[N_AXIS];
  float max_travel = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {  
    6010:	02 15       	cp	r16, r2
    6012:	13 05       	cpc	r17, r3
    6014:	d1 f6       	brne	.-76     	; 0x5fca <limits_go_home+0x82>
    6016:	fb 2c       	mov	r15, r11
    6018:	ba 2c       	mov	r11, r10
    601a:	a9 8c       	ldd	r10, Y+25	; 0x19
    
    // Determine travel distance to the furthest homing switch based on user max travel settings.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (max_travel > settings.max_travel[idx]) { max_travel = settings.max_travel[idx]; }
  }
  max_travel *= -HOMING_AXIS_SEARCH_SCALAR; // Ensure homing switches engaged by over-estimating max travel.
    601c:	20 e0       	ldi	r18, 0x00	; 0
    601e:	30 e0       	ldi	r19, 0x00	; 0
    6020:	40 ec       	ldi	r20, 0xC0	; 192
    6022:	5f eb       	ldi	r21, 0xBF	; 191
    6024:	6f 2d       	mov	r22, r15
    6026:	78 2d       	mov	r23, r8
    6028:	89 2d       	mov	r24, r9
    602a:	9b 2d       	mov	r25, r11
    602c:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    6030:	6c a3       	std	Y+36, r22	; 0x24
    6032:	7d a3       	std	Y+37, r23	; 0x25
    6034:	8e a3       	std	Y+38, r24	; 0x26
    6036:	9f a3       	std	Y+39, r25	; 0x27
  
  plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
    6038:	0e 94 55 2a 	call	0x54aa	; 0x54aa <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    603c:	0e 94 c7 2d 	call	0x5b8e	; 0x5b8e <plan_sync_position>
    6040:	b6 e0       	ldi	r27, 0x06	; 6
    6042:	be a7       	std	Y+46, r27	; 0x2e
void limits_go_home(uint8_t cycle_mask) 
{
  if (sys.abort) { return; } // Block if system reset has been issued.

  // Initialize homing in search mode to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    6044:	e1 e0       	ldi	r30, 0x01	; 1
    6046:	ec 8f       	std	Y+28, r30	; 0x1c

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    6048:	9e 01       	movw	r18, r28
    604a:	2f 5f       	subi	r18, 0xFF	; 255
    604c:	3f 4f       	sbci	r19, 0xFF	; 255
    604e:	38 8f       	std	Y+24, r19	; 0x18
    6050:	2f 8b       	std	Y+23, r18	; 0x17
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    6052:	8a 2d       	mov	r24, r10
    6054:	90 e0       	ldi	r25, 0x00	; 0
    6056:	9b 8f       	std	Y+27, r25	; 0x1b
    6058:	8a 8f       	std	Y+26, r24	; 0x1a
    605a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    605c:	9d 8f       	std	Y+29, r25	; 0x1d
    605e:	ab 8d       	ldd	r26, Y+27	; 0x1b
    6060:	af a7       	std	Y+47, r26	; 0x2f

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    sys.homing_axis_lock = axislock;
    6062:	0f 2e       	mov	r0, r31
    6064:	f8 e7       	ldi	r31, 0x78	; 120
    6066:	4f 2e       	mov	r4, r31
    6068:	f7 e0       	ldi	r31, 0x07	; 7
    606a:	5f 2e       	mov	r5, r31
    606c:	f0 2d       	mov	r31, r0
    606e:	3e 01       	movw	r6, r28
    6070:	b3 e1       	ldi	r27, 0x13	; 19
    6072:	6b 0e       	add	r6, r27
    6074:	71 1c       	adc	r7, r1
      }
      sys.homing_axis_lock = axislock;
      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
      // Check only for user reset. No time to run protocol_execute_realtime() in this loop.

      if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) { // Abort homing and alarm upon safety door.
    6076:	0f 2e       	mov	r0, r31
    6078:	fa e6       	ldi	r31, 0x6A	; 106
    607a:	cf 2e       	mov	r12, r31
    607c:	f7 e0       	ldi	r31, 0x07	; 7
    607e:	df 2e       	mov	r13, r31
    6080:	f0 2d       	mov	r31, r0
    6082:	2d 88       	ldd	r2, Y+21	; 0x15
    6084:	ee 88       	ldd	r14, Y+22	; 0x16
    6086:	fb 88       	ldd	r15, Y+19	; 0x13
    6088:	3c 88       	ldd	r3, Y+20	; 0x14
    608a:	9f 2c       	mov	r9, r15
    608c:	83 2c       	mov	r8, r3
    608e:	3e 2c       	mov	r3, r14
  plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
  plan_sync_position(); // Sync planner position to current machine position.
  
  do {
    // Initialize invert_pin boolean based on approach and invert pin user setting.
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    6090:	80 91 3c 09 	lds	r24, 0x093C
    6094:	86 fd       	sbrc	r24, 6
    6096:	02 c0       	rjmp	.+4      	; 0x609c <limits_go_home+0x154>
    6098:	ec 8c       	ldd	r14, Y+28	; 0x1c
    609a:	03 c0       	rjmp	.+6      	; 0x60a2 <limits_go_home+0x15a>
    else { invert_pin = !approach; }
    609c:	81 e0       	ldi	r24, 0x01	; 1
    609e:	ec 8c       	ldd	r14, Y+28	; 0x1c
    60a0:	e8 26       	eor	r14, r24

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    60a2:	6c e6       	ldi	r22, 0x6C	; 108
    60a4:	77 e0       	ldi	r23, 0x07	; 7
    60a6:	ce 01       	movw	r24, r28
    60a8:	01 96       	adiw	r24, 0x01	; 1
    60aa:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_convert_array_steps_to_mpos>
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
        n_active_axis++;
        if (approach) {
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] -= max_travel; }
    60ae:	80 91 3d 09 	lds	r24, 0x093D
    60b2:	e8 2f       	mov	r30, r24
    60b4:	f0 e0       	ldi	r31, 0x00	; 0
    60b6:	ff 8f       	std	Y+31, r31	; 0x1f
    60b8:	ee 8f       	std	Y+30, r30	; 0x1e
    60ba:	ff 89       	ldd	r31, Y+23	; 0x17
    60bc:	fa ab       	std	Y+50, r31	; 0x32
    60be:	28 8d       	ldd	r18, Y+24	; 0x18
    60c0:	2b ab       	std	Y+51, r18	; 0x33
    60c2:	ce 01       	movw	r24, r28
    60c4:	01 96       	adiw	r24, 0x01	; 1
    60c6:	00 e0       	ldi	r16, 0x00	; 0
    60c8:	10 e0       	ldi	r17, 0x00	; 0
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    else { invert_pin = !approach; }

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;
    60ca:	f1 2c       	mov	r15, r1
    // Initialize invert_pin boolean based on approach and invert pin user setting.
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    else { invert_pin = !approach; }

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    60cc:	19 8e       	std	Y+25, r1	; 0x19
    60ce:	59 a6       	std	Y+41, r5	; 0x29
    60d0:	48 a6       	std	Y+40, r4	; 0x28
    60d2:	7b a6       	std	Y+43, r7	; 0x2b
    60d4:	6a a6       	std	Y+42, r6	; 0x2a
    60d6:	dd a6       	std	Y+45, r13	; 0x2d
    60d8:	cc a6       	std	Y+44, r12	; 0x2c
    60da:	5f a4       	ldd	r5, Y+47	; 0x2f
    60dc:	d9 2c       	mov	r13, r9
    60de:	9f 2c       	mov	r9, r15
    60e0:	78 2c       	mov	r7, r8
    60e2:	8e 2c       	mov	r8, r14
    60e4:	7c 01       	movw	r14, r24
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    60e6:	ad 8c       	ldd	r10, Y+29	; 0x1d
    60e8:	b5 2c       	mov	r11, r5
    60ea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    60ec:	9b 8d       	ldd	r25, Y+27	; 0x1b
    60ee:	00 2e       	mov	r0, r16
    60f0:	02 c0       	rjmp	.+4      	; 0x60f6 <limits_go_home+0x1ae>
    60f2:	95 95       	asr	r25
    60f4:	87 95       	ror	r24
    60f6:	0a 94       	dec	r0
    60f8:	e2 f7       	brpl	.-8      	; 0x60f2 <limits_go_home+0x1aa>
    60fa:	80 ff       	sbrs	r24, 0
    60fc:	62 c0       	rjmp	.+196    	; 0x61c2 <limits_go_home+0x27a>
        n_active_axis++;
    60fe:	99 8d       	ldd	r25, Y+25	; 0x19
    6100:	9f 5f       	subi	r25, 0xFF	; 255
    6102:	99 8f       	std	Y+25, r25	; 0x19
        if (approach) {
    6104:	ac 8d       	ldd	r26, Y+28	; 0x1c
    6106:	aa 23       	and	r26, r26
    6108:	71 f1       	breq	.+92     	; 0x6166 <limits_go_home+0x21e>
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] -= max_travel; }
    610a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    610c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    610e:	00 2e       	mov	r0, r16
    6110:	02 c0       	rjmp	.+4      	; 0x6116 <limits_go_home+0x1ce>
    6112:	95 95       	asr	r25
    6114:	87 95       	ror	r24
    6116:	0a 94       	dec	r0
    6118:	e2 f7       	brpl	.-8      	; 0x6112 <limits_go_home+0x1ca>
    611a:	80 ff       	sbrs	r24, 0
    611c:	12 c0       	rjmp	.+36     	; 0x6142 <limits_go_home+0x1fa>
    611e:	2c a1       	ldd	r18, Y+36	; 0x24
    6120:	3d a1       	ldd	r19, Y+37	; 0x25
    6122:	4e a1       	ldd	r20, Y+38	; 0x26
    6124:	5f a1       	ldd	r21, Y+39	; 0x27
    6126:	f7 01       	movw	r30, r14
    6128:	60 81       	ld	r22, Z
    612a:	71 81       	ldd	r23, Z+1	; 0x01
    612c:	82 81       	ldd	r24, Z+2	; 0x02
    612e:	93 81       	ldd	r25, Z+3	; 0x03
    6130:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    6134:	d7 01       	movw	r26, r14
    6136:	6d 93       	st	X+, r22
    6138:	7d 93       	st	X+, r23
    613a:	8d 93       	st	X+, r24
    613c:	9c 93       	st	X, r25
    613e:	13 97       	sbiw	r26, 0x03	; 3
    6140:	94 c1       	rjmp	.+808    	; 0x646a <limits_go_home+0x522>
          else { target[idx] += max_travel; }
    6142:	2c a1       	ldd	r18, Y+36	; 0x24
    6144:	3d a1       	ldd	r19, Y+37	; 0x25
    6146:	4e a1       	ldd	r20, Y+38	; 0x26
    6148:	5f a1       	ldd	r21, Y+39	; 0x27
    614a:	f7 01       	movw	r30, r14
    614c:	60 81       	ld	r22, Z
    614e:	71 81       	ldd	r23, Z+1	; 0x01
    6150:	82 81       	ldd	r24, Z+2	; 0x02
    6152:	93 81       	ldd	r25, Z+3	; 0x03
    6154:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    6158:	d7 01       	movw	r26, r14
    615a:	6d 93       	st	X+, r22
    615c:	7d 93       	st	X+, r23
    615e:	8d 93       	st	X+, r24
    6160:	9c 93       	st	X, r25
    6162:	13 97       	sbiw	r26, 0x03	; 3
    6164:	82 c1       	rjmp	.+772    	; 0x646a <limits_go_home+0x522>
        } else { 
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] += max_travel; }
    6166:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6168:	9f 8d       	ldd	r25, Y+31	; 0x1f
    616a:	00 2e       	mov	r0, r16
    616c:	02 c0       	rjmp	.+4      	; 0x6172 <limits_go_home+0x22a>
    616e:	95 95       	asr	r25
    6170:	87 95       	ror	r24
    6172:	0a 94       	dec	r0
    6174:	e2 f7       	brpl	.-8      	; 0x616e <limits_go_home+0x226>
    6176:	80 ff       	sbrs	r24, 0
    6178:	12 c0       	rjmp	.+36     	; 0x619e <limits_go_home+0x256>
    617a:	2c a1       	ldd	r18, Y+36	; 0x24
    617c:	3d a1       	ldd	r19, Y+37	; 0x25
    617e:	4e a1       	ldd	r20, Y+38	; 0x26
    6180:	5f a1       	ldd	r21, Y+39	; 0x27
    6182:	f7 01       	movw	r30, r14
    6184:	60 81       	ld	r22, Z
    6186:	71 81       	ldd	r23, Z+1	; 0x01
    6188:	82 81       	ldd	r24, Z+2	; 0x02
    618a:	93 81       	ldd	r25, Z+3	; 0x03
    618c:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    6190:	d7 01       	movw	r26, r14
    6192:	6d 93       	st	X+, r22
    6194:	7d 93       	st	X+, r23
    6196:	8d 93       	st	X+, r24
    6198:	9c 93       	st	X, r25
    619a:	13 97       	sbiw	r26, 0x03	; 3
    619c:	66 c1       	rjmp	.+716    	; 0x646a <limits_go_home+0x522>
          else { target[idx] -= max_travel; }
    619e:	2c a1       	ldd	r18, Y+36	; 0x24
    61a0:	3d a1       	ldd	r19, Y+37	; 0x25
    61a2:	4e a1       	ldd	r20, Y+38	; 0x26
    61a4:	5f a1       	ldd	r21, Y+39	; 0x27
    61a6:	f7 01       	movw	r30, r14
    61a8:	60 81       	ld	r22, Z
    61aa:	71 81       	ldd	r23, Z+1	; 0x01
    61ac:	82 81       	ldd	r24, Z+2	; 0x02
    61ae:	93 81       	ldd	r25, Z+3	; 0x03
    61b0:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    61b4:	d7 01       	movw	r26, r14
    61b6:	6d 93       	st	X+, r22
    61b8:	7d 93       	st	X+, r23
    61ba:	8d 93       	st	X+, r24
    61bc:	9c 93       	st	X, r25
    61be:	13 97       	sbiw	r26, 0x03	; 3
    61c0:	54 c1       	rjmp	.+680    	; 0x646a <limits_go_home+0x522>
    61c2:	0f 5f       	subi	r16, 0xFF	; 255
    61c4:	1f 4f       	sbci	r17, 0xFF	; 255
    61c6:	b4 e0       	ldi	r27, 0x04	; 4
    61c8:	eb 0e       	add	r14, r27
    61ca:	f1 1c       	adc	r15, r1
    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    for (idx=0; idx<N_AXIS; idx++) {
    61cc:	03 30       	cpi	r16, 0x03	; 3
    61ce:	11 05       	cpc	r17, r1
    61d0:	09 f0       	breq	.+2      	; 0x61d4 <limits_go_home+0x28c>
    61d2:	89 cf       	rjmp	.-238    	; 0x60e6 <limits_go_home+0x19e>
    61d4:	e8 2c       	mov	r14, r8
    61d6:	f9 2c       	mov	r15, r9
    61d8:	b9 aa       	std	Y+49, r11	; 0x31
    61da:	a8 aa       	std	Y+48, r10	; 0x30
    61dc:	48 a4       	ldd	r4, Y+40	; 0x28
    61de:	59 a4       	ldd	r5, Y+41	; 0x29
    61e0:	9d 2c       	mov	r9, r13
    61e2:	cc a4       	ldd	r12, Y+44	; 0x2c
    61e4:	dd a4       	ldd	r13, Y+45	; 0x2d
    61e6:	87 2c       	mov	r8, r7
    61e8:	6a a4       	ldd	r6, Y+42	; 0x2a
    61ea:	7b a4       	ldd	r7, Y+43	; 0x2b
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    61ec:	e9 8d       	ldd	r30, Y+25	; 0x19
    61ee:	6e 2f       	mov	r22, r30
    61f0:	70 e0       	ldi	r23, 0x00	; 0
    61f2:	80 e0       	ldi	r24, 0x00	; 0
    61f4:	90 e0       	ldi	r25, 0x00	; 0
    61f6:	0e 94 4d 3d 	call	0x7a9a	; 0x7a9a <__floatunsisf>
    61fa:	0e 94 78 3f 	call	0x7ef0	; 0x7ef0 <sqrt>
    sys.homing_axis_lock = axislock;
    61fe:	d2 01       	movw	r26, r4
    6200:	fc 92       	st	X, r15
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    6202:	28 a1       	ldd	r18, Y+32	; 0x20
    6204:	39 a1       	ldd	r19, Y+33	; 0x21
    6206:	4a a1       	ldd	r20, Y+34	; 0x22
    6208:	5b a1       	ldd	r21, Y+35	; 0x23
    620a:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    620e:	ab 01       	movw	r20, r22
    6210:	bc 01       	movw	r22, r24
    uint8_t limit_state;
    
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, homing_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan homing motion.
    #else
      plan_buffer_line(target, homing_rate, false); // Bypass mc_line(). Directly plan homing motion.
    6212:	20 e0       	ldi	r18, 0x00	; 0
    6214:	ce 01       	movw	r24, r28
    6216:	01 96       	adiw	r24, 0x01	; 1
    6218:	0e 94 ad 2a 	call	0x555a	; 0x555a <plan_buffer_line>
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    621c:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <st_prep_buffer>
    st_wake_up(); // Initiate motion
    6220:	0e 94 2d 1b 	call	0x365a	; 0x365a <st_wake_up>
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
    6224:	1e e0       	ldi	r17, 0x0E	; 14
    6226:	0f 2d       	mov	r16, r15
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    st_wake_up(); // Initiate motion
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
    6228:	23 b1       	in	r18, 0x03	; 3
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
    622a:	e1 10       	cpse	r14, r1
    622c:	21 27       	eor	r18, r17
    622e:	a2 2d       	mov	r26, r2
    6230:	b3 2d       	mov	r27, r3
    6232:	e9 2d       	mov	r30, r9
    6234:	f8 2d       	mov	r31, r8
      for (idx=0; idx<N_AXIS; idx++) {
        if (axislock & step_pin[idx]) {
    6236:	81 91       	ld	r24, Z+
    6238:	98 2f       	mov	r25, r24
    623a:	90 23       	and	r25, r16
    623c:	29 f0       	breq	.+10     	; 0x6248 <limits_go_home+0x300>
          if (limit_state & limit_pin[idx]) { axislock &= ~(step_pin[idx]); }
    623e:	9c 91       	ld	r25, X
    6240:	92 23       	and	r25, r18
    6242:	11 f0       	breq	.+4      	; 0x6248 <limits_go_home+0x300>
    6244:	80 95       	com	r24
    6246:	08 23       	and	r16, r24
    6248:	11 96       	adiw	r26, 0x01	; 1
    st_wake_up(); // Initiate motion
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
      for (idx=0; idx<N_AXIS; idx++) {
    624a:	e6 15       	cp	r30, r6
    624c:	f7 05       	cpc	r31, r7
    624e:	99 f7       	brne	.-26     	; 0x6236 <limits_go_home+0x2ee>
        if (axislock & step_pin[idx]) {
          if (limit_state & limit_pin[idx]) { axislock &= ~(step_pin[idx]); }
        }
      }
      sys.homing_axis_lock = axislock;
    6250:	f2 01       	movw	r30, r4
    6252:	00 83       	st	Z, r16
      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    6254:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <st_prep_buffer>
      // Check only for user reset. No time to run protocol_execute_realtime() in this loop.

      if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) { // Abort homing and alarm upon safety door.
    6258:	d6 01       	movw	r26, r12
    625a:	8c 91       	ld	r24, X
    625c:	80 73       	andi	r24, 0x30	; 48
    625e:	41 f0       	breq	.+16     	; 0x6270 <limits_go_home+0x328>
        if (sys.rt_exec_state & EXEC_SAFETY_DOOR) { mc_reset(); }  
    6260:	80 91 6a 07 	lds	r24, 0x076A
    6264:	85 fd       	sbrc	r24, 5
    6266:	0e 94 b2 0c 	call	0x1964	; 0x1964 <mc_reset>
        protocol_execute_realtime();
    626a:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
        return;
    626e:	06 c1       	rjmp	.+524    	; 0x647c <limits_go_home+0x534>
      }
    } while (STEP_MASK & axislock);
    6270:	80 2f       	mov	r24, r16
    6272:	84 75       	andi	r24, 0x54	; 84
    6274:	c9 f6       	brne	.-78     	; 0x6228 <limits_go_home+0x2e0>
    
    st_reset(); // Immediately force kill steppers and reset step segment buffer.
    6276:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <st_reset>
    plan_reset(); // Reset planner buffer. Zero planner positions. Ensure homing motion is cleared.
    627a:	0e 94 55 2a 	call	0x54aa	; 0x54aa <plan_reset>
    plan_sync_position(); // Sync planner position to current machine position
    627e:	0e 94 c7 2d 	call	0x5b8e	; 0x5b8e <plan_sync_position>

    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    6282:	80 91 46 09 	lds	r24, 0x0946
    6286:	90 91 47 09 	lds	r25, 0x0947
    628a:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    homing_rate = settings.homing_feed_rate;
    628e:	80 91 3e 09 	lds	r24, 0x093E
    6292:	90 91 3f 09 	lds	r25, 0x093F
    6296:	a0 91 40 09 	lds	r26, 0x0940
    629a:	b0 91 41 09 	lds	r27, 0x0941
    629e:	88 a3       	std	Y+32, r24	; 0x20
    62a0:	99 a3       	std	Y+33, r25	; 0x21
    62a2:	aa a3       	std	Y+34, r26	; 0x22
    62a4:	bb a3       	std	Y+35, r27	; 0x23
    approach = !approach;
    62a6:	81 e0       	ldi	r24, 0x01	; 1
    62a8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    62aa:	98 27       	eor	r25, r24
    62ac:	9c 8f       	std	Y+28, r25	; 0x1c
    62ae:	ae a5       	ldd	r26, Y+46	; 0x2e
    62b0:	a1 50       	subi	r26, 0x01	; 1
    62b2:	ae a7       	std	Y+46, r26	; 0x2e
    
  } while (n_cycle-- > 0);
    62b4:	a1 11       	cpse	r26, r1
    62b6:	ec ce       	rjmp	.-552    	; 0x6090 <limits_go_home+0x148>
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
      #ifndef HOMING_FORCE_SET_ORIGIN
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    62b8:	c0 90 3d 09 	lds	r12, 0x093D
    62bc:	d1 2c       	mov	r13, r1
    62be:	e1 2c       	mov	r14, r1
    62c0:	f1 2c       	mov	r15, r1
    62c2:	00 e0       	ldi	r16, 0x00	; 0
    62c4:	10 e0       	ldi	r17, 0x00	; 0
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
    62c6:	81 2c       	mov	r8, r1
    62c8:	91 2c       	mov	r9, r1
    62ca:	a1 2c       	mov	r10, r1
    62cc:	b1 2c       	mov	r11, r1
    62ce:	68 a8       	ldd	r6, Y+48	; 0x30
    62d0:	79 a8       	ldd	r7, Y+49	; 0x31
  #endif
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    62d2:	c3 01       	movw	r24, r6
    62d4:	00 2e       	mov	r0, r16
    62d6:	02 c0       	rjmp	.+4      	; 0x62dc <limits_go_home+0x394>
    62d8:	95 95       	asr	r25
    62da:	87 95       	ror	r24
    62dc:	0a 94       	dec	r0
    62de:	e2 f7       	brpl	.-8      	; 0x62d8 <limits_go_home+0x390>
    62e0:	80 ff       	sbrs	r24, 0
    62e2:	28 c0       	rjmp	.+80     	; 0x6334 <limits_go_home+0x3ec>
      set_axis_position = 0;     
      #ifndef HOMING_FORCE_SET_ORIGIN
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    62e4:	c6 01       	movw	r24, r12
    62e6:	00 2e       	mov	r0, r16
    62e8:	02 c0       	rjmp	.+4      	; 0x62ee <limits_go_home+0x3a6>
    62ea:	95 95       	asr	r25
    62ec:	87 95       	ror	r24
    62ee:	0a 94       	dec	r0
    62f0:	e2 f7       	brpl	.-8      	; 0x62ea <limits_go_home+0x3a2>
    62f2:	80 ff       	sbrs	r24, 0
    62f4:	14 c0       	rjmp	.+40     	; 0x631e <limits_go_home+0x3d6>
    62f6:	f7 01       	movw	r30, r14
    62f8:	e1 50       	subi	r30, 0x01	; 1
    62fa:	f7 4f       	sbci	r31, 0xF7	; 247
          set_axis_position = lround(settings.max_travel[idx]*settings.steps_per_mm[idx]);
    62fc:	20 81       	ld	r18, Z
    62fe:	31 81       	ldd	r19, Z+1	; 0x01
    6300:	42 81       	ldd	r20, Z+2	; 0x02
    6302:	53 81       	ldd	r21, Z+3	; 0x03
    6304:	64 a1       	ldd	r22, Z+36	; 0x24
    6306:	75 a1       	ldd	r23, Z+37	; 0x25
    6308:	86 a1       	ldd	r24, Z+38	; 0x26
    630a:	97 a1       	ldd	r25, Z+39	; 0x27
    630c:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    6310:	0e 94 bb 3e 	call	0x7d76	; 0x7d76 <lround>
    6314:	46 2f       	mov	r20, r22
    6316:	37 2f       	mov	r19, r23
    6318:	28 2f       	mov	r18, r24
    631a:	89 2f       	mov	r24, r25
    631c:	04 c0       	rjmp	.+8      	; 0x6326 <limits_go_home+0x3de>
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
    631e:	48 2d       	mov	r20, r8
    6320:	39 2d       	mov	r19, r9
    6322:	2a 2d       	mov	r18, r10
    6324:	8b 2d       	mov	r24, r11
    6326:	f7 01       	movw	r30, r14
    6328:	e9 59       	subi	r30, 0x99	; 153
    632a:	f8 4f       	sbci	r31, 0xF8	; 248
          sys.position[B_MOTOR] = off_axis_position + set_axis_position;
        } else {
          sys.position[idx] = set_axis_position;
        }        
      #else 
        sys.position[idx] = set_axis_position;
    632c:	45 83       	std	Z+5, r20	; 0x05
    632e:	36 83       	std	Z+6, r19	; 0x06
    6330:	27 83       	std	Z+7, r18	; 0x07
    6332:	80 87       	std	Z+8, r24	; 0x08
    6334:	0f 5f       	subi	r16, 0xFF	; 255
    6336:	1f 4f       	sbci	r17, 0xFF	; 255
    6338:	b4 e0       	ldi	r27, 0x04	; 4
    633a:	eb 0e       	add	r14, r27
    633c:	f1 1c       	adc	r15, r1
  #ifdef COREXY
    int32_t off_axis_position = 0;
  #endif
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    633e:	03 30       	cpi	r16, 0x03	; 3
    6340:	11 05       	cpc	r17, r1
    6342:	39 f6       	brne	.-114    	; 0x62d2 <limits_go_home+0x38a>
        sys.position[idx] = set_axis_position;
      #endif

    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    6344:	0e 94 c7 2d 	call	0x5b8e	; 0x5b8e <plan_sync_position>

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    6348:	20 e0       	ldi	r18, 0x00	; 0
    634a:	30 e0       	ldi	r19, 0x00	; 0
    634c:	a9 01       	movw	r20, r18
    634e:	60 91 48 09 	lds	r22, 0x0948
    6352:	70 91 49 09 	lds	r23, 0x0949
    6356:	80 91 4a 09 	lds	r24, 0x094A
    635a:	90 91 4b 09 	lds	r25, 0x094B
    635e:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    6362:	18 16       	cp	r1, r24
    6364:	0c f0       	brlt	.+2      	; 0x6368 <limits_go_home+0x420>
    6366:	7d c0       	rjmp	.+250    	; 0x6462 <limits_go_home+0x51a>
    6368:	0f 2e       	mov	r0, r31
    636a:	f3 e2       	ldi	r31, 0x23	; 35
    636c:	cf 2e       	mov	r12, r31
    636e:	f9 e0       	ldi	r31, 0x09	; 9
    6370:	df 2e       	mov	r13, r31
    6372:	f0 2d       	mov	r31, r0
    6374:	ea a8       	ldd	r14, Y+50	; 0x32
    6376:	fb a8       	ldd	r15, Y+51	; 0x33
    6378:	00 e0       	ldi	r16, 0x00	; 0
    637a:	10 e0       	ldi	r17, 0x00	; 0
      if (cycle_mask & bit(idx)) {
        #ifdef HOMING_FORCE_SET_ORIGIN
          target[idx] = settings.homing_pulloff;  
          if ( bit_isfalse(settings.homing_dir_mask,bit(idx)) ) { target[idx] = -target[idx]; }     
        #else
          if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    637c:	0f 2e       	mov	r0, r31
    637e:	fd e3       	ldi	r31, 0x3D	; 61
    6380:	af 2e       	mov	r10, r31
    6382:	f9 e0       	ldi	r31, 0x09	; 9
    6384:	bf 2e       	mov	r11, r31
    6386:	f0 2d       	mov	r31, r0
            target[idx] = settings.homing_pulloff+settings.max_travel[idx];
          } else {
            target[idx] = -settings.homing_pulloff;
    6388:	0f 2e       	mov	r0, r31
    638a:	f8 e4       	ldi	r31, 0x48	; 72
    638c:	8f 2e       	mov	r8, r31
    638e:	f9 e0       	ldi	r31, 0x09	; 9
    6390:	9f 2e       	mov	r9, r31
    6392:	f0 2d       	mov	r31, r0
    6394:	68 a8       	ldd	r6, Y+48	; 0x30
    6396:	79 a8       	ldd	r7, Y+49	; 0x31
  plan_sync_position(); // Sync planner position to homed machine position.

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    for (idx=0; idx<N_AXIS; idx++) {
      if (cycle_mask & bit(idx)) {
    6398:	c3 01       	movw	r24, r6
    639a:	00 2e       	mov	r0, r16
    639c:	02 c0       	rjmp	.+4      	; 0x63a2 <limits_go_home+0x45a>
    639e:	95 95       	asr	r25
    63a0:	87 95       	ror	r24
    63a2:	0a 94       	dec	r0
    63a4:	e2 f7       	brpl	.-8      	; 0x639e <limits_go_home+0x456>
    63a6:	80 ff       	sbrs	r24, 0
    63a8:	2a c0       	rjmp	.+84     	; 0x63fe <limits_go_home+0x4b6>
        #ifdef HOMING_FORCE_SET_ORIGIN
          target[idx] = settings.homing_pulloff;  
          if ( bit_isfalse(settings.homing_dir_mask,bit(idx)) ) { target[idx] = -target[idx]; }     
        #else
          if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    63aa:	f5 01       	movw	r30, r10
    63ac:	80 81       	ld	r24, Z
    63ae:	90 e0       	ldi	r25, 0x00	; 0
    63b0:	00 2e       	mov	r0, r16
    63b2:	02 c0       	rjmp	.+4      	; 0x63b8 <limits_go_home+0x470>
    63b4:	95 95       	asr	r25
    63b6:	87 95       	ror	r24
    63b8:	0a 94       	dec	r0
    63ba:	e2 f7       	brpl	.-8      	; 0x63b4 <limits_go_home+0x46c>
    63bc:	80 ff       	sbrs	r24, 0
    63be:	13 c0       	rjmp	.+38     	; 0x63e6 <limits_go_home+0x49e>
            target[idx] = settings.homing_pulloff+settings.max_travel[idx];
    63c0:	d6 01       	movw	r26, r12
    63c2:	2d 91       	ld	r18, X+
    63c4:	3d 91       	ld	r19, X+
    63c6:	4d 91       	ld	r20, X+
    63c8:	5c 91       	ld	r21, X
    63ca:	f4 01       	movw	r30, r8
    63cc:	60 81       	ld	r22, Z
    63ce:	71 81       	ldd	r23, Z+1	; 0x01
    63d0:	82 81       	ldd	r24, Z+2	; 0x02
    63d2:	93 81       	ldd	r25, Z+3	; 0x03
    63d4:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    63d8:	d7 01       	movw	r26, r14
    63da:	6d 93       	st	X+, r22
    63dc:	7d 93       	st	X+, r23
    63de:	8d 93       	st	X+, r24
    63e0:	9c 93       	st	X, r25
    63e2:	13 97       	sbiw	r26, 0x03	; 3
    63e4:	17 c0       	rjmp	.+46     	; 0x6414 <limits_go_home+0x4cc>
          } else {
            target[idx] = -settings.homing_pulloff;
    63e6:	f4 01       	movw	r30, r8
    63e8:	80 81       	ld	r24, Z
    63ea:	91 81       	ldd	r25, Z+1	; 0x01
    63ec:	a2 81       	ldd	r26, Z+2	; 0x02
    63ee:	b3 81       	ldd	r27, Z+3	; 0x03
    63f0:	b0 58       	subi	r27, 0x80	; 128
    63f2:	f7 01       	movw	r30, r14
    63f4:	80 83       	st	Z, r24
    63f6:	91 83       	std	Z+1, r25	; 0x01
    63f8:	a2 83       	std	Z+2, r26	; 0x02
    63fa:	b3 83       	std	Z+3, r27	; 0x03
    63fc:	0b c0       	rjmp	.+22     	; 0x6414 <limits_go_home+0x4cc>
          }
        #endif      
      } else {
        // Non-active cycle axis. Set target to not move during pull-off. 
        target[idx] = system_convert_axis_steps_to_mpos(sys.position, idx);
    63fe:	60 2f       	mov	r22, r16
    6400:	8c e6       	ldi	r24, 0x6C	; 108
    6402:	97 e0       	ldi	r25, 0x07	; 7
    6404:	0e 94 9d 3b 	call	0x773a	; 0x773a <system_convert_axis_steps_to_mpos>
    6408:	d7 01       	movw	r26, r14
    640a:	6d 93       	st	X+, r22
    640c:	7d 93       	st	X+, r23
    640e:	8d 93       	st	X+, r24
    6410:	9c 93       	st	X, r25
    6412:	13 97       	sbiw	r26, 0x03	; 3
    6414:	0f 5f       	subi	r16, 0xFF	; 255
    6416:	1f 4f       	sbci	r17, 0xFF	; 255
    6418:	b4 e0       	ldi	r27, 0x04	; 4
    641a:	eb 0e       	add	r14, r27
    641c:	f1 1c       	adc	r15, r1
    641e:	e4 e0       	ldi	r30, 0x04	; 4
    6420:	ce 0e       	add	r12, r30
    6422:	d1 1c       	adc	r13, r1
  }
  plan_sync_position(); // Sync planner position to homed machine position.

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    for (idx=0; idx<N_AXIS; idx++) {
    6424:	03 30       	cpi	r16, 0x03	; 3
    6426:	11 05       	cpc	r17, r1
    6428:	09 f0       	breq	.+2      	; 0x642c <limits_go_home+0x4e4>
    642a:	b6 cf       	rjmp	.-148    	; 0x6398 <limits_go_home+0x450>
      }
    }      
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, settings.homing_seek_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan motion.
    #else
      plan_buffer_line(target, settings.homing_seek_rate, false); // Bypass mc_line(). Directly plan motion.
    642c:	40 91 42 09 	lds	r20, 0x0942
    6430:	50 91 43 09 	lds	r21, 0x0943
    6434:	60 91 44 09 	lds	r22, 0x0944
    6438:	70 91 45 09 	lds	r23, 0x0945
    643c:	20 e0       	ldi	r18, 0x00	; 0
    643e:	ce 01       	movw	r24, r28
    6440:	01 96       	adiw	r24, 0x01	; 1
    6442:	0e 94 ad 2a 	call	0x555a	; 0x555a <plan_buffer_line>
    #endif
  
    // Initiate pull-off using main motion control routines. 
    // TODO : Clean up state routines so that this motion still shows homing state.
    sys.state = STATE_IDLE;
    6446:	10 92 68 07 	sts	0x0768, r1
    bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
    644a:	8f b7       	in	r24, 0x3f	; 63
    644c:	f8 94       	cli
    644e:	ea e6       	ldi	r30, 0x6A	; 106
    6450:	f7 e0       	ldi	r31, 0x07	; 7
    6452:	90 81       	ld	r25, Z
    6454:	92 60       	ori	r25, 0x02	; 2
    6456:	90 83       	st	Z, r25
    6458:	8f bf       	out	0x3f, r24	; 63
    protocol_execute_realtime();
    645a:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
    protocol_buffer_synchronize(); // Complete pull-off motion.
    645e:	0e 94 11 1b 	call	0x3622	; 0x3622 <protocol_buffer_synchronize>
  }
  
  // Set system state to homing before returning. 
  sys.state = STATE_HOMING; 
    6462:	84 e0       	ldi	r24, 0x04	; 4
    6464:	80 93 68 07 	sts	0x0768, r24
    6468:	09 c0       	rjmp	.+18     	; 0x647c <limits_go_home+0x534>
    646a:	e0 e1       	ldi	r30, 0x10	; 16
    646c:	f0 e0       	ldi	r31, 0x00	; 0
    646e:	ec 0f       	add	r30, r28
    6470:	fd 1f       	adc	r31, r29
    6472:	e0 0f       	add	r30, r16
    6474:	f1 1f       	adc	r31, r17
          else { target[idx] -= max_travel; }
        }
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    6476:	80 81       	ld	r24, Z
    6478:	98 2a       	or	r9, r24
    647a:	a3 ce       	rjmp	.-698    	; 0x61c2 <limits_go_home+0x27a>
    protocol_buffer_synchronize(); // Complete pull-off motion.
  }
  
  // Set system state to homing before returning. 
  sys.state = STATE_HOMING; 
}
    647c:	e3 96       	adiw	r28, 0x33	; 51
    647e:	0f b6       	in	r0, 0x3f	; 63
    6480:	f8 94       	cli
    6482:	de bf       	out	0x3e, r29	; 62
    6484:	0f be       	out	0x3f, r0	; 63
    6486:	cd bf       	out	0x3d, r28	; 61
    6488:	df 91       	pop	r29
    648a:	cf 91       	pop	r28
    648c:	1f 91       	pop	r17
    648e:	0f 91       	pop	r16
    6490:	ff 90       	pop	r15
    6492:	ef 90       	pop	r14
    6494:	df 90       	pop	r13
    6496:	cf 90       	pop	r12
    6498:	bf 90       	pop	r11
    649a:	af 90       	pop	r10
    649c:	9f 90       	pop	r9
    649e:	8f 90       	pop	r8
    64a0:	7f 90       	pop	r7
    64a2:	6f 90       	pop	r6
    64a4:	5f 90       	pop	r5
    64a6:	4f 90       	pop	r4
    64a8:	3f 90       	pop	r3
    64aa:	2f 90       	pop	r2
    64ac:	08 95       	ret

000064ae <limits_soft_check>:


// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
    64ae:	af 92       	push	r10
    64b0:	bf 92       	push	r11
    64b2:	cf 92       	push	r12
    64b4:	df 92       	push	r13
    64b6:	ef 92       	push	r14
    64b8:	ff 92       	push	r15
    64ba:	0f 93       	push	r16
    64bc:	1f 93       	push	r17
    64be:	cf 93       	push	r28
    64c0:	df 93       	push	r29
    64c2:	ec 01       	movw	r28, r24
    64c4:	03 e2       	ldi	r16, 0x23	; 35
    64c6:	19 e0       	ldi	r17, 0x09	; 9
    64c8:	0f 2e       	mov	r0, r31
    64ca:	ff e2       	ldi	r31, 0x2F	; 47
    64cc:	af 2e       	mov	r10, r31
    64ce:	f9 e0       	ldi	r31, 0x09	; 9
    64d0:	bf 2e       	mov	r11, r31
    64d2:	f0 2d       	mov	r31, r0
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { soft_limit_error = true; }
      }
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { soft_limit_error = true; }
    64d4:	c9 90       	ld	r12, Y+
    64d6:	d9 90       	ld	r13, Y+
    64d8:	e9 90       	ld	r14, Y+
    64da:	f9 90       	ld	r15, Y+
    64dc:	20 e0       	ldi	r18, 0x00	; 0
    64de:	30 e0       	ldi	r19, 0x00	; 0
    64e0:	a9 01       	movw	r20, r18
    64e2:	c7 01       	movw	r24, r14
    64e4:	b6 01       	movw	r22, r12
    64e6:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    64ea:	18 16       	cp	r1, r24
    64ec:	64 f0       	brlt	.+24     	; 0x6506 <limits_soft_check+0x58>
    64ee:	f8 01       	movw	r30, r16
    64f0:	21 91       	ld	r18, Z+
    64f2:	31 91       	ld	r19, Z+
    64f4:	41 91       	ld	r20, Z+
    64f6:	51 91       	ld	r21, Z+
    64f8:	8f 01       	movw	r16, r30
    64fa:	c7 01       	movw	r24, r14
    64fc:	b6 01       	movw	r22, r12
    64fe:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    6502:	88 23       	and	r24, r24
    6504:	34 f5       	brge	.+76     	; 0x6552 <limits_soft_check+0xa4>
    
    if (soft_limit_error) {
      // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within 
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
    6506:	80 91 68 07 	lds	r24, 0x0768
    650a:	88 30       	cpi	r24, 0x08	; 8
    650c:	a9 f4       	brne	.+42     	; 0x6538 <limits_soft_check+0x8a>
        bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD);
    650e:	8f b7       	in	r24, 0x3f	; 63
    6510:	f8 94       	cli
    6512:	ea e6       	ldi	r30, 0x6A	; 106
    6514:	f7 e0       	ldi	r31, 0x07	; 7
    6516:	90 81       	ld	r25, Z
    6518:	98 60       	ori	r25, 0x08	; 8
    651a:	90 83       	st	Z, r25
    651c:	8f bf       	out	0x3f, r24	; 63
        do {
          protocol_execute_realtime();
          if (sys.abort) { return; }
    651e:	c7 e6       	ldi	r28, 0x67	; 103
    6520:	d7 e0       	ldi	r29, 0x07	; 7
        } while ( sys.state != STATE_IDLE );
    6522:	08 e6       	ldi	r16, 0x68	; 104
    6524:	17 e0       	ldi	r17, 0x07	; 7
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
        bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD);
        do {
          protocol_execute_realtime();
    6526:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
          if (sys.abort) { return; }
    652a:	88 81       	ld	r24, Y
    652c:	81 11       	cpse	r24, r1
    652e:	15 c0       	rjmp	.+42     	; 0x655a <limits_soft_check+0xac>
        } while ( sys.state != STATE_IDLE );
    6530:	f8 01       	movw	r30, r16
    6532:	80 81       	ld	r24, Z
    6534:	81 11       	cpse	r24, r1
    6536:	f7 cf       	rjmp	.-18     	; 0x6526 <limits_soft_check+0x78>
      }
    
      mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    6538:	0e 94 b2 0c 	call	0x1964	; 0x1964 <mc_reset>
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
    653c:	8f b7       	in	r24, 0x3f	; 63
    653e:	f8 94       	cli
    6540:	eb e6       	ldi	r30, 0x6B	; 107
    6542:	f7 e0       	ldi	r31, 0x07	; 7
    6544:	90 81       	ld	r25, Z
    6546:	95 60       	ori	r25, 0x05	; 5
    6548:	90 83       	st	Z, r25
    654a:	8f bf       	out	0x3f, r24	; 63
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    654c:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <protocol_execute_realtime>
      return;
    6550:	04 c0       	rjmp	.+8      	; 0x655a <limits_soft_check+0xac>
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
  uint8_t idx;
  uint8_t soft_limit_error = false;
  for (idx=0; idx<N_AXIS; idx++) {
    6552:	0a 15       	cp	r16, r10
    6554:	1b 05       	cpc	r17, r11
    6556:	09 f0       	breq	.+2      	; 0x655a <limits_soft_check+0xac>
    6558:	bd cf       	rjmp	.-134    	; 0x64d4 <limits_soft_check+0x26>
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
      return;
    }
  }
}
    655a:	df 91       	pop	r29
    655c:	cf 91       	pop	r28
    655e:	1f 91       	pop	r17
    6560:	0f 91       	pop	r16
    6562:	ff 90       	pop	r15
    6564:	ef 90       	pop	r14
    6566:	df 90       	pop	r13
    6568:	cf 90       	pop	r12
    656a:	bf 90       	pop	r11
    656c:	af 90       	pop	r10
    656e:	08 95       	ret

00006570 <printString>:

#include "grbl.h"


void printString(const char *s)
{
    6570:	cf 93       	push	r28
    6572:	df 93       	push	r29
    6574:	ec 01       	movw	r28, r24
  while (*s)
    6576:	88 81       	ld	r24, Y
    6578:	88 23       	and	r24, r24
    657a:	31 f0       	breq	.+12     	; 0x6588 <printString+0x18>
    657c:	21 96       	adiw	r28, 0x01	; 1
    serial_write(*s++);
    657e:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
#include "grbl.h"


void printString(const char *s)
{
  while (*s)
    6582:	89 91       	ld	r24, Y+
    6584:	81 11       	cpse	r24, r1
    6586:	fb cf       	rjmp	.-10     	; 0x657e <printString+0xe>
    serial_write(*s++);
}
    6588:	df 91       	pop	r29
    658a:	cf 91       	pop	r28
    658c:	08 95       	ret

0000658e <printPgmString>:


// Print a string stored in PGM-memory
void printPgmString(const char *s)
{
    658e:	cf 93       	push	r28
    6590:	df 93       	push	r29
  char c;
  while ((c = pgm_read_byte_near(s++)))
    6592:	ec 01       	movw	r28, r24
    6594:	21 96       	adiw	r28, 0x01	; 1
    6596:	fc 01       	movw	r30, r24
    6598:	84 91       	lpm	r24, Z
    659a:	88 23       	and	r24, r24
    659c:	39 f0       	breq	.+14     	; 0x65ac <printPgmString+0x1e>
    serial_write(c);
    659e:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>

// Print a string stored in PGM-memory
void printPgmString(const char *s)
{
  char c;
  while ((c = pgm_read_byte_near(s++)))
    65a2:	fe 01       	movw	r30, r28
    65a4:	84 91       	lpm	r24, Z
    65a6:	21 96       	adiw	r28, 0x01	; 1
    65a8:	81 11       	cpse	r24, r1
    65aa:	f9 cf       	rjmp	.-14     	; 0x659e <printPgmString+0x10>
    serial_write(c);
}
    65ac:	df 91       	pop	r29
    65ae:	cf 91       	pop	r28
    65b0:	08 95       	ret

000065b2 <print_uint8_base2>:
// 			'A' + buf[i - 1] - 10);
// }


void print_uint8_base2(uint8_t n)
{ 
    65b2:	ef 92       	push	r14
    65b4:	ff 92       	push	r15
    65b6:	0f 93       	push	r16
    65b8:	1f 93       	push	r17
    65ba:	cf 93       	push	r28
    65bc:	df 93       	push	r29
    65be:	cd b7       	in	r28, 0x3d	; 61
    65c0:	de b7       	in	r29, 0x3e	; 62
    65c2:	28 97       	sbiw	r28, 0x08	; 8
    65c4:	0f b6       	in	r0, 0x3f	; 63
    65c6:	f8 94       	cli
    65c8:	de bf       	out	0x3e, r29	; 62
    65ca:	0f be       	out	0x3f, r0	; 63
    65cc:	cd bf       	out	0x3d, r28	; 61
    65ce:	fe 01       	movw	r30, r28
    65d0:	31 96       	adiw	r30, 0x01	; 1
    65d2:	7f 01       	movw	r14, r30
    65d4:	9e 01       	movw	r18, r28
    65d6:	27 5f       	subi	r18, 0xF7	; 247
    65d8:	3f 4f       	sbci	r19, 0xFF	; 255
	unsigned char buf[8];
	uint8_t i = 0;

	for (; i < 8; i++) {
		buf[i] = n & 1;
    65da:	98 2f       	mov	r25, r24
    65dc:	91 70       	andi	r25, 0x01	; 1
    65de:	91 93       	st	Z+, r25
		n >>= 1;
    65e0:	86 95       	lsr	r24
void print_uint8_base2(uint8_t n)
{ 
	unsigned char buf[8];
	uint8_t i = 0;

	for (; i < 8; i++) {
    65e2:	e2 17       	cp	r30, r18
    65e4:	f3 07       	cpc	r31, r19
    65e6:	c9 f7       	brne	.-14     	; 0x65da <print_uint8_base2+0x28>
    65e8:	8e 01       	movw	r16, r28
    65ea:	07 5f       	subi	r16, 0xF7	; 247
    65ec:	1f 4f       	sbci	r17, 0xFF	; 255
		buf[i] = n & 1;
		n >>= 1;
	}

	for (; i > 0; i--)
		serial_write('0' + buf[i - 1]);
    65ee:	f8 01       	movw	r30, r16
    65f0:	82 91       	ld	r24, -Z
    65f2:	8f 01       	movw	r16, r30
    65f4:	80 5d       	subi	r24, 0xD0	; 208
    65f6:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
	for (; i < 8; i++) {
		buf[i] = n & 1;
		n >>= 1;
	}

	for (; i > 0; i--)
    65fa:	0e 15       	cp	r16, r14
    65fc:	1f 05       	cpc	r17, r15
    65fe:	b9 f7       	brne	.-18     	; 0x65ee <print_uint8_base2+0x3c>
		serial_write('0' + buf[i - 1]);
}
    6600:	28 96       	adiw	r28, 0x08	; 8
    6602:	0f b6       	in	r0, 0x3f	; 63
    6604:	f8 94       	cli
    6606:	de bf       	out	0x3e, r29	; 62
    6608:	0f be       	out	0x3f, r0	; 63
    660a:	cd bf       	out	0x3d, r28	; 61
    660c:	df 91       	pop	r29
    660e:	cf 91       	pop	r28
    6610:	1f 91       	pop	r17
    6612:	0f 91       	pop	r16
    6614:	ff 90       	pop	r15
    6616:	ef 90       	pop	r14
    6618:	08 95       	ret

0000661a <print_uint8_base10>:


void print_uint8_base10(uint8_t n)
{ 
    661a:	1f 93       	push	r17
    661c:	cf 93       	push	r28
    661e:	df 93       	push	r29
    6620:	00 d0       	rcall	.+0      	; 0x6622 <print_uint8_base10+0x8>
    6622:	1f 92       	push	r1
    6624:	cd b7       	in	r28, 0x3d	; 61
    6626:	de b7       	in	r29, 0x3e	; 62
  if (n == 0) {
    6628:	81 11       	cpse	r24, r1
    662a:	04 c0       	rjmp	.+8      	; 0x6634 <print_uint8_base10+0x1a>
    serial_write('0');
    662c:	80 e3       	ldi	r24, 0x30	; 48
    662e:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
    6632:	28 c0       	rjmp	.+80     	; 0x6684 <print_uint8_base10+0x6a>
}


void print_uint8_base10(uint8_t n)
{ 
  if (n == 0) {
    6634:	90 e0       	ldi	r25, 0x00	; 0

  unsigned char buf[3];
  uint8_t i = 0;

  while (n > 0) {
      buf[i++] = n % 10 + '0';
    6636:	4d ec       	ldi	r20, 0xCD	; 205
    6638:	11 e0       	ldi	r17, 0x01	; 1
    663a:	19 0f       	add	r17, r25
    663c:	e1 e0       	ldi	r30, 0x01	; 1
    663e:	f0 e0       	ldi	r31, 0x00	; 0
    6640:	ec 0f       	add	r30, r28
    6642:	fd 1f       	adc	r31, r29
    6644:	e9 0f       	add	r30, r25
    6646:	f1 1d       	adc	r31, r1
    6648:	84 9f       	mul	r24, r20
    664a:	91 2d       	mov	r25, r1
    664c:	11 24       	eor	r1, r1
    664e:	96 95       	lsr	r25
    6650:	96 95       	lsr	r25
    6652:	96 95       	lsr	r25
    6654:	29 2f       	mov	r18, r25
    6656:	22 0f       	add	r18, r18
    6658:	32 2f       	mov	r19, r18
    665a:	33 0f       	add	r19, r19
    665c:	33 0f       	add	r19, r19
    665e:	23 0f       	add	r18, r19
    6660:	82 1b       	sub	r24, r18
    6662:	80 5d       	subi	r24, 0xD0	; 208
    6664:	80 83       	st	Z, r24
      n /= 10;
    6666:	89 2f       	mov	r24, r25
  } 

  unsigned char buf[3];
  uint8_t i = 0;

  while (n > 0) {
    6668:	99 23       	and	r25, r25
    666a:	11 f0       	breq	.+4      	; 0x6670 <print_uint8_base10+0x56>
      buf[i++] = n % 10 + '0';
    666c:	91 2f       	mov	r25, r17
    666e:	e4 cf       	rjmp	.-56     	; 0x6638 <print_uint8_base10+0x1e>
      n /= 10;
  }

  for (; i > 0; i--)
    6670:	11 23       	and	r17, r17
    6672:	41 f0       	breq	.+16     	; 0x6684 <print_uint8_base10+0x6a>
      serial_write(buf[i - 1]);
    6674:	fe 01       	movw	r30, r28
    6676:	e1 0f       	add	r30, r17
    6678:	f1 1d       	adc	r31, r1
    667a:	80 81       	ld	r24, Z
    667c:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
  while (n > 0) {
      buf[i++] = n % 10 + '0';
      n /= 10;
  }

  for (; i > 0; i--)
    6680:	11 50       	subi	r17, 0x01	; 1
    6682:	c1 f7       	brne	.-16     	; 0x6674 <print_uint8_base10+0x5a>
      serial_write(buf[i - 1]);
}
    6684:	0f 90       	pop	r0
    6686:	0f 90       	pop	r0
    6688:	0f 90       	pop	r0
    668a:	df 91       	pop	r29
    668c:	cf 91       	pop	r28
    668e:	1f 91       	pop	r17
    6690:	08 95       	ret

00006692 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up 
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    6692:	8f 92       	push	r8
    6694:	9f 92       	push	r9
    6696:	af 92       	push	r10
    6698:	bf 92       	push	r11
    669a:	cf 92       	push	r12
    669c:	df 92       	push	r13
    669e:	ef 92       	push	r14
    66a0:	ff 92       	push	r15
    66a2:	0f 93       	push	r16
    66a4:	1f 93       	push	r17
    66a6:	cf 93       	push	r28
    66a8:	df 93       	push	r29
    66aa:	cd b7       	in	r28, 0x3d	; 61
    66ac:	de b7       	in	r29, 0x3e	; 62
    66ae:	2a 97       	sbiw	r28, 0x0a	; 10
    66b0:	0f b6       	in	r0, 0x3f	; 63
    66b2:	f8 94       	cli
    66b4:	de bf       	out	0x3e, r29	; 62
    66b6:	0f be       	out	0x3f, r0	; 63
    66b8:	cd bf       	out	0x3d, r28	; 61
    66ba:	6b 01       	movw	r12, r22
    66bc:	7c 01       	movw	r14, r24
    66be:	14 2f       	mov	r17, r20
  if (n < 0) {
    66c0:	20 e0       	ldi	r18, 0x00	; 0
    66c2:	30 e0       	ldi	r19, 0x00	; 0
    66c4:	a9 01       	movw	r20, r18
    66c6:	0e 94 ad 3c 	call	0x795a	; 0x795a <__cmpsf2>
    66ca:	88 23       	and	r24, r24
    66cc:	3c f4       	brge	.+14     	; 0x66dc <printFloat+0x4a>
    serial_write('-');
    66ce:	8d e2       	ldi	r24, 0x2D	; 45
    66d0:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
    n = -n;
    66d4:	f7 fa       	bst	r15, 7
    66d6:	f0 94       	com	r15
    66d8:	f7 f8       	bld	r15, 7
    66da:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    66dc:	12 30       	cpi	r17, 0x02	; 2
    66de:	88 f0       	brcs	.+34     	; 0x6702 <printFloat+0x70>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    66e0:	01 2f       	mov	r16, r17
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    66e2:	20 e0       	ldi	r18, 0x00	; 0
    66e4:	30 e0       	ldi	r19, 0x00	; 0
    66e6:	48 ec       	ldi	r20, 0xC8	; 200
    66e8:	52 e4       	ldi	r21, 0x42	; 66
    66ea:	c7 01       	movw	r24, r14
    66ec:	b6 01       	movw	r22, r12
    66ee:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    66f2:	6b 01       	movw	r12, r22
    66f4:	7c 01       	movw	r14, r24
    decimals -= 2;
    66f6:	02 50       	subi	r16, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    66f8:	02 30       	cpi	r16, 0x02	; 2
    66fa:	98 f7       	brcc	.-26     	; 0x66e2 <printFloat+0x50>
    66fc:	81 2f       	mov	r24, r17
    66fe:	81 70       	andi	r24, 0x01	; 1
    6700:	01 c0       	rjmp	.+2      	; 0x6704 <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    6702:	81 2f       	mov	r24, r17
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    6704:	88 23       	and	r24, r24
    6706:	51 f0       	breq	.+20     	; 0x671c <printFloat+0x8a>
    6708:	20 e0       	ldi	r18, 0x00	; 0
    670a:	30 e0       	ldi	r19, 0x00	; 0
    670c:	40 e2       	ldi	r20, 0x20	; 32
    670e:	51 e4       	ldi	r21, 0x41	; 65
    6710:	c7 01       	movw	r24, r14
    6712:	b6 01       	movw	r22, r12
    6714:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    6718:	6b 01       	movw	r12, r22
    671a:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    671c:	20 e0       	ldi	r18, 0x00	; 0
    671e:	30 e0       	ldi	r19, 0x00	; 0
    6720:	40 e0       	ldi	r20, 0x00	; 0
    6722:	5f e3       	ldi	r21, 0x3F	; 63
    6724:	c7 01       	movw	r24, r14
    6726:	b6 01       	movw	r22, r12
    6728:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
    672c:	0e 94 1c 3d 	call	0x7a38	; 0x7a38 <__fixsfsi>
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
    6730:	2e e2       	ldi	r18, 0x2E	; 46
    6732:	fe 01       	movw	r30, r28
    6734:	e1 0f       	add	r30, r17
    6736:	f1 1d       	adc	r31, r1
    6738:	21 83       	std	Z+1, r18	; 0x01
  while(a > 0) {
    673a:	61 15       	cp	r22, r1
    673c:	71 05       	cpc	r23, r1
    673e:	81 05       	cpc	r24, r1
    6740:	91 05       	cpc	r25, r1
    6742:	49 f1       	breq	.+82     	; 0x6796 <printFloat+0x104>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    6744:	20 e0       	ldi	r18, 0x00	; 0
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    6746:	01 e0       	ldi	r16, 0x01	; 1
    6748:	01 0f       	add	r16, r17
    buf[i++] = (a % 10) + '0'; // Get digit
    674a:	0f 2e       	mov	r0, r31
    674c:	fa e0       	ldi	r31, 0x0A	; 10
    674e:	8f 2e       	mov	r8, r31
    6750:	91 2c       	mov	r9, r1
    6752:	a1 2c       	mov	r10, r1
    6754:	b1 2c       	mov	r11, r1
    6756:	f0 2d       	mov	r31, r0
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    6758:	21 13       	cpse	r18, r17
    675a:	01 c0       	rjmp	.+2      	; 0x675e <printFloat+0xcc>
    675c:	20 2f       	mov	r18, r16
    buf[i++] = (a % 10) + '0'; // Get digit
    675e:	dd 24       	eor	r13, r13
    6760:	d3 94       	inc	r13
    6762:	d2 0e       	add	r13, r18
    6764:	ee 24       	eor	r14, r14
    6766:	e3 94       	inc	r14
    6768:	f1 2c       	mov	r15, r1
    676a:	ec 0e       	add	r14, r28
    676c:	fd 1e       	adc	r15, r29
    676e:	e2 0e       	add	r14, r18
    6770:	f1 1c       	adc	r15, r1
    6772:	a5 01       	movw	r20, r10
    6774:	94 01       	movw	r18, r8
    6776:	0e 94 d8 3f 	call	0x7fb0	; 0x7fb0 <__udivmodsi4>
    677a:	60 5d       	subi	r22, 0xD0	; 208
    677c:	f7 01       	movw	r30, r14
    677e:	60 83       	st	Z, r22
    a /= 10;
    6780:	62 2f       	mov	r22, r18
    6782:	73 2f       	mov	r23, r19
    6784:	84 2f       	mov	r24, r20
    6786:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    6788:	61 15       	cp	r22, r1
    678a:	71 05       	cpc	r23, r1
    678c:	81 05       	cpc	r24, r1
    678e:	91 05       	cpc	r25, r1
    6790:	19 f0       	breq	.+6      	; 0x6798 <printFloat+0x106>
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    6792:	2d 2d       	mov	r18, r13
    6794:	e1 cf       	rjmp	.-62     	; 0x6758 <printFloat+0xc6>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    6796:	d1 2c       	mov	r13, r1
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    6798:	d1 16       	cp	r13, r17
    679a:	70 f4       	brcc	.+28     	; 0x67b8 <printFloat+0x126>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    679c:	90 e3       	ldi	r25, 0x30	; 48
    679e:	81 e0       	ldi	r24, 0x01	; 1
    67a0:	8d 0d       	add	r24, r13
    67a2:	e1 e0       	ldi	r30, 0x01	; 1
    67a4:	f0 e0       	ldi	r31, 0x00	; 0
    67a6:	ec 0f       	add	r30, r28
    67a8:	fd 1f       	adc	r31, r29
    67aa:	ed 0d       	add	r30, r13
    67ac:	f1 1d       	adc	r31, r1
    67ae:	90 83       	st	Z, r25
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    67b0:	81 17       	cp	r24, r17
    67b2:	29 f0       	breq	.+10     	; 0x67be <printFloat+0x12c>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    67b4:	d8 2e       	mov	r13, r24
    67b6:	f3 cf       	rjmp	.-26     	; 0x679e <printFloat+0x10c>
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    67b8:	1d 11       	cpse	r17, r13
    67ba:	0b c0       	rjmp	.+22     	; 0x67d2 <printFloat+0x140>
    67bc:	1d 2d       	mov	r17, r13
    i++;
    buf[i++] = '0'; 
    67be:	68 94       	set
    67c0:	dd 24       	eor	r13, r13
    67c2:	d1 f8       	bld	r13, 1
    67c4:	d1 0e       	add	r13, r17
  }
  while (i < decimal_places) { 
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    i++;
    67c6:	1f 5f       	subi	r17, 0xFF	; 255
    buf[i++] = '0'; 
    67c8:	fe 01       	movw	r30, r28
    67ca:	e1 0f       	add	r30, r17
    67cc:	f1 1d       	adc	r31, r1
    67ce:	80 e3       	ldi	r24, 0x30	; 48
    67d0:	81 83       	std	Z+1, r24	; 0x01
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    67d2:	dd 20       	and	r13, r13
    67d4:	41 f0       	breq	.+16     	; 0x67e6 <printFloat+0x154>
    serial_write(buf[i-1]);
    67d6:	fe 01       	movw	r30, r28
    67d8:	ed 0d       	add	r30, r13
    67da:	f1 1d       	adc	r31, r1
    67dc:	80 81       	ld	r24, Z
    67de:	0e 94 19 18 	call	0x3032	; 0x3032 <serial_write>
    i++;
    buf[i++] = '0'; 
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    67e2:	da 94       	dec	r13
    67e4:	c1 f7       	brne	.-16     	; 0x67d6 <printFloat+0x144>
    serial_write(buf[i-1]);
}
    67e6:	2a 96       	adiw	r28, 0x0a	; 10
    67e8:	0f b6       	in	r0, 0x3f	; 63
    67ea:	f8 94       	cli
    67ec:	de bf       	out	0x3e, r29	; 62
    67ee:	0f be       	out	0x3f, r0	; 63
    67f0:	cd bf       	out	0x3d, r28	; 61
    67f2:	df 91       	pop	r29
    67f4:	cf 91       	pop	r28
    67f6:	1f 91       	pop	r17
    67f8:	0f 91       	pop	r16
    67fa:	ff 90       	pop	r15
    67fc:	ef 90       	pop	r14
    67fe:	df 90       	pop	r13
    6800:	cf 90       	pop	r12
    6802:	bf 90       	pop	r11
    6804:	af 90       	pop	r10
    6806:	9f 90       	pop	r9
    6808:	8f 90       	pop	r8
    680a:	08 95       	ret

0000680c <printFloat_CoordValue>:
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
//  - SettingValue: Handles all floating point settings values (always in mm.)
void printFloat_CoordValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) { 
    680c:	20 91 3c 09 	lds	r18, 0x093C
    6810:	20 ff       	sbrs	r18, 0
    6812:	0a c0       	rjmp	.+20     	; 0x6828 <printFloat_CoordValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    6814:	2b e8       	ldi	r18, 0x8B	; 139
    6816:	32 e4       	ldi	r19, 0x42	; 66
    6818:	41 e2       	ldi	r20, 0x21	; 33
    681a:	5d e3       	ldi	r21, 0x3D	; 61
    681c:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    6820:	44 e0       	ldi	r20, 0x04	; 4
    6822:	0e 94 49 33 	call	0x6692	; 0x6692 <printFloat>
    6826:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    6828:	43 e0       	ldi	r20, 0x03	; 3
    682a:	0e 94 49 33 	call	0x6692	; 0x6692 <printFloat>
    682e:	08 95       	ret

00006830 <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    6830:	20 91 3c 09 	lds	r18, 0x093C
    6834:	20 ff       	sbrs	r18, 0
    6836:	0a c0       	rjmp	.+20     	; 0x684c <printFloat_RateValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    6838:	2b e8       	ldi	r18, 0x8B	; 139
    683a:	32 e4       	ldi	r19, 0x42	; 66
    683c:	41 e2       	ldi	r20, 0x21	; 33
    683e:	5d e3       	ldi	r21, 0x3D	; 61
    6840:	0e 94 eb 3e 	call	0x7dd6	; 0x7dd6 <__mulsf3>
    6844:	41 e0       	ldi	r20, 0x01	; 1
    6846:	0e 94 49 33 	call	0x6692	; 0x6692 <printFloat>
    684a:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    684c:	40 e0       	ldi	r20, 0x00	; 0
    684e:	0e 94 49 33 	call	0x6692	; 0x6692 <printFloat>
    6852:	08 95       	ret

00006854 <printFloat_SettingValue>:
  }
}

void printFloat_SettingValue(float n) { printFloat(n,N_DECIMAL_SETTINGVALUE); }
    6854:	43 e0       	ldi	r20, 0x03	; 3
    6856:	0e 94 49 33 	call	0x6692	; 0x6692 <printFloat>
    685a:	08 95       	ret

0000685c <probe_init>:


// Probe pin initialization routine.
void probe_init() 
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    685c:	24 98       	cbi	0x04, 4	; 4
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    685e:	2c 9a       	sbi	0x05, 4	; 5
    6860:	08 95       	ret

00006862 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to 
// appropriately set the pin logic according to setting for normal-high/normal-low operation 
// and the probing cycle modes for toward-workpiece/away-from-workpiece. 
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    6862:	10 92 54 09 	sts	0x0954, r1
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    6866:	90 91 3c 09 	lds	r25, 0x093C
    686a:	99 23       	and	r25, r25
    686c:	1c f0       	brlt	.+6      	; 0x6874 <probe_configure_invert_mask+0x12>
    686e:	90 e1       	ldi	r25, 0x10	; 16
    6870:	90 93 54 09 	sts	0x0954, r25
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    6874:	88 23       	and	r24, r24
    6876:	31 f0       	breq	.+12     	; 0x6884 <probe_configure_invert_mask+0x22>
    6878:	90 91 54 09 	lds	r25, 0x0954
    687c:	80 e1       	ldi	r24, 0x10	; 16
    687e:	89 27       	eor	r24, r25
    6880:	80 93 54 09 	sts	0x0954, r24
    6884:	08 95       	ret

00006886 <probe_get_state>:
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    6886:	83 b1       	in	r24, 0x03	; 3
    6888:	80 71       	andi	r24, 0x10	; 16
    688a:	90 91 54 09 	lds	r25, 0x0954
    688e:	89 27       	eor	r24, r25
    6890:	08 95       	ret

00006892 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (sys.probe_state == PROBE_ACTIVE) {
    6892:	80 91 79 07 	lds	r24, 0x0779
    6896:	81 30       	cpi	r24, 0x01	; 1
    6898:	a1 f4       	brne	.+40     	; 0x68c2 <probe_state_monitor+0x30>
    if (probe_get_state()) {
    689a:	0e 94 43 34 	call	0x6886	; 0x6886 <probe_get_state>
    689e:	88 23       	and	r24, r24
    68a0:	81 f0       	breq	.+32     	; 0x68c2 <probe_state_monitor+0x30>
      sys.probe_state = PROBE_OFF;
    68a2:	10 92 79 07 	sts	0x0779, r1
      memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS);
    68a6:	8c e0       	ldi	r24, 0x0C	; 12
    68a8:	ec e6       	ldi	r30, 0x6C	; 108
    68aa:	f7 e0       	ldi	r31, 0x07	; 7
    68ac:	aa e7       	ldi	r26, 0x7A	; 122
    68ae:	b7 e0       	ldi	r27, 0x07	; 7
    68b0:	01 90       	ld	r0, Z+
    68b2:	0d 92       	st	X+, r0
    68b4:	8a 95       	dec	r24
    68b6:	e1 f7       	brne	.-8      	; 0x68b0 <probe_state_monitor+0x1e>
      bit_true(sys.rt_exec_state, EXEC_MOTION_CANCEL);
    68b8:	ea e6       	ldi	r30, 0x6A	; 106
    68ba:	f7 e0       	ldi	r31, 0x07	; 7
    68bc:	80 81       	ld	r24, Z
    68be:	80 64       	ori	r24, 0x40	; 64
    68c0:	80 83       	st	Z, r24
    68c2:	08 95       	ret

000068c4 <report_status_message>:
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
// NOTE: In silent mode, all error codes are greater than zero.
// TODO: Install silent mode to return only numeric values, primarily for GUIs.
void report_status_message(uint8_t status_code) 
{
    68c4:	cf 93       	push	r28
    68c6:	c8 2f       	mov	r28, r24
  if (status_code == 0) { // STATUS_OK
    68c8:	81 11       	cpse	r24, r1
    68ca:	05 c0       	rjmp	.+10     	; 0x68d6 <report_status_message+0x12>
    printPgmString(PSTR("ok\r\n"));
    68cc:	83 ec       	ldi	r24, 0xC3	; 195
    68ce:	99 e0       	ldi	r25, 0x09	; 9
    68d0:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    68d4:	66 c0       	rjmp	.+204    	; 0x69a2 <report_status_message+0xde>
  } else {
    printPgmString(PSTR("error: "));
    68d6:	8b eb       	ldi	r24, 0xBB	; 187
    68d8:	99 e0       	ldi	r25, 0x09	; 9
    68da:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    switch(status_code) {          
    68de:	4c 2f       	mov	r20, r28
    68e0:	50 e0       	ldi	r21, 0x00	; 0
    68e2:	fa 01       	movw	r30, r20
    68e4:	31 97       	sbiw	r30, 0x01	; 1
    68e6:	e6 31       	cpi	r30, 0x16	; 22
    68e8:	f1 05       	cpc	r31, r1
    68ea:	08 f0       	brcs	.+2      	; 0x68ee <report_status_message+0x2a>
    68ec:	4f c0       	rjmp	.+158    	; 0x698c <report_status_message+0xc8>
    68ee:	e5 50       	subi	r30, 0x05	; 5
    68f0:	ff 4f       	sbci	r31, 0xFF	; 255
    68f2:	0c 94 fa 3f 	jmp	0x7ff4	; 0x7ff4 <__tablejump2__>
      case STATUS_EXPECTED_COMMAND_LETTER:
      printPgmString(PSTR("Expected command letter")); break;
    68f6:	83 ea       	ldi	r24, 0xA3	; 163
    68f8:	99 e0       	ldi	r25, 0x09	; 9
    68fa:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    68fe:	4d c0       	rjmp	.+154    	; 0x699a <report_status_message+0xd6>
      case STATUS_BAD_NUMBER_FORMAT:
      printPgmString(PSTR("Bad number format")); break;
    6900:	81 e9       	ldi	r24, 0x91	; 145
    6902:	99 e0       	ldi	r25, 0x09	; 9
    6904:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6908:	48 c0       	rjmp	.+144    	; 0x699a <report_status_message+0xd6>
      case STATUS_INVALID_STATEMENT:
      printPgmString(PSTR("Invalid statement")); break;
    690a:	8f e7       	ldi	r24, 0x7F	; 127
    690c:	99 e0       	ldi	r25, 0x09	; 9
    690e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6912:	43 c0       	rjmp	.+134    	; 0x699a <report_status_message+0xd6>
      case STATUS_NEGATIVE_VALUE:
      printPgmString(PSTR("Value < 0")); break;
    6914:	85 e7       	ldi	r24, 0x75	; 117
    6916:	99 e0       	ldi	r25, 0x09	; 9
    6918:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    691c:	3e c0       	rjmp	.+124    	; 0x699a <report_status_message+0xd6>
      case STATUS_SETTING_DISABLED:
      printPgmString(PSTR("Setting disabled")); break;
    691e:	84 e6       	ldi	r24, 0x64	; 100
    6920:	99 e0       	ldi	r25, 0x09	; 9
    6922:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6926:	39 c0       	rjmp	.+114    	; 0x699a <report_status_message+0xd6>
      case STATUS_SETTING_STEP_PULSE_MIN:
      printPgmString(PSTR("Value < 3 usec")); break;
    6928:	85 e5       	ldi	r24, 0x55	; 85
    692a:	99 e0       	ldi	r25, 0x09	; 9
    692c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6930:	34 c0       	rjmp	.+104    	; 0x699a <report_status_message+0xd6>
      case STATUS_SETTING_READ_FAIL:
      printPgmString(PSTR("EEPROM read fail. Using defaults")); break;
    6932:	84 e3       	ldi	r24, 0x34	; 52
    6934:	99 e0       	ldi	r25, 0x09	; 9
    6936:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    693a:	2f c0       	rjmp	.+94     	; 0x699a <report_status_message+0xd6>
      case STATUS_IDLE_ERROR:
      printPgmString(PSTR("Not idle")); break;
    693c:	8b e2       	ldi	r24, 0x2B	; 43
    693e:	99 e0       	ldi	r25, 0x09	; 9
    6940:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6944:	2a c0       	rjmp	.+84     	; 0x699a <report_status_message+0xd6>
      case STATUS_ALARM_LOCK:
      printPgmString(PSTR("Alarm lock")); break;
    6946:	80 e2       	ldi	r24, 0x20	; 32
    6948:	99 e0       	ldi	r25, 0x09	; 9
    694a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    694e:	25 c0       	rjmp	.+74     	; 0x699a <report_status_message+0xd6>
      case STATUS_SOFT_LIMIT_ERROR:
      printPgmString(PSTR("Homing not enabled")); break;
    6950:	8d e0       	ldi	r24, 0x0D	; 13
    6952:	99 e0       	ldi	r25, 0x09	; 9
    6954:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6958:	20 c0       	rjmp	.+64     	; 0x699a <report_status_message+0xd6>
      case STATUS_OVERFLOW:
      printPgmString(PSTR("Line overflow")); break; 
    695a:	8f ef       	ldi	r24, 0xFF	; 255
    695c:	98 e0       	ldi	r25, 0x08	; 8
    695e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6962:	1b c0       	rjmp	.+54     	; 0x699a <report_status_message+0xd6>
      // case STATUS_MAX_STEP_RATE_EXCEEDED: 
      // printPgmString(PSTR("Step rate > 30kHz")); break;
      case STATUS_JOG_ONGOING_LOCK:
	  printPgmString(PSTR("Jogging ongoing; Ignoring GCode")); break;
    6964:	8f ed       	ldi	r24, 0xDF	; 223
    6966:	98 e0       	ldi	r25, 0x08	; 8
    6968:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    696c:	16 c0       	rjmp	.+44     	; 0x699a <report_status_message+0xd6>
	  
      // Common g-code parser errors.
      case STATUS_GCODE_MODAL_GROUP_VIOLATION:
      printPgmString(PSTR("Modal group violation")); break;
    696e:	89 ec       	ldi	r24, 0xC9	; 201
    6970:	98 e0       	ldi	r25, 0x08	; 8
    6972:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6976:	11 c0       	rjmp	.+34     	; 0x699a <report_status_message+0xd6>
      case STATUS_GCODE_UNSUPPORTED_COMMAND:
      printPgmString(PSTR("Unsupported command")); break;
    6978:	85 eb       	ldi	r24, 0xB5	; 181
    697a:	98 e0       	ldi	r25, 0x08	; 8
    697c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6980:	0c c0       	rjmp	.+24     	; 0x699a <report_status_message+0xd6>
      case STATUS_GCODE_UNDEFINED_FEED_RATE:
      printPgmString(PSTR("Undefined feed rate")); break;
    6982:	81 ea       	ldi	r24, 0xA1	; 161
    6984:	98 e0       	ldi	r25, 0x08	; 8
    6986:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    698a:	07 c0       	rjmp	.+14     	; 0x699a <report_status_message+0xd6>
      default:
        // Remaining g-code parser errors with error codes
        printPgmString(PSTR("Invalid gcode ID:"));
    698c:	8f e8       	ldi	r24, 0x8F	; 143
    698e:	98 e0       	ldi	r25, 0x08	; 8
    6990:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
        print_uint8_base10(status_code); // Print error code for user reference
    6994:	8c 2f       	mov	r24, r28
    6996:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
    }
    printPgmString(PSTR("\r\n"));
    699a:	8c e8       	ldi	r24, 0x8C	; 140
    699c:	98 e0       	ldi	r25, 0x08	; 8
    699e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }
}
    69a2:	cf 91       	pop	r28
    69a4:	08 95       	ret

000069a6 <report_alarm_message>:

// Prints alarm messages.
void report_alarm_message(int8_t alarm_code)
{
    69a6:	cf 93       	push	r28
    69a8:	c8 2f       	mov	r28, r24
  printPgmString(PSTR("ALARM: "));
    69aa:	84 e8       	ldi	r24, 0x84	; 132
    69ac:	98 e0       	ldi	r25, 0x08	; 8
    69ae:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  switch (alarm_code) {
    69b2:	cd 3f       	cpi	r28, 0xFD	; 253
    69b4:	91 f0       	breq	.+36     	; 0x69da <report_alarm_message+0x34>
    69b6:	1c f4       	brge	.+6      	; 0x69be <report_alarm_message+0x18>
    69b8:	cc 3f       	cpi	r28, 0xFC	; 252
    69ba:	a1 f0       	breq	.+40     	; 0x69e4 <report_alarm_message+0x3e>
    69bc:	17 c0       	rjmp	.+46     	; 0x69ec <report_alarm_message+0x46>
    69be:	ce 3f       	cpi	r28, 0xFE	; 254
    69c0:	39 f0       	breq	.+14     	; 0x69d0 <report_alarm_message+0x2a>
    69c2:	cf 3f       	cpi	r28, 0xFF	; 255
    69c4:	99 f4       	brne	.+38     	; 0x69ec <report_alarm_message+0x46>
    case ALARM_HARD_LIMIT_ERROR: 
    printPgmString(PSTR("Hard limit")); break;
    69c6:	89 e7       	ldi	r24, 0x79	; 121
    69c8:	98 e0       	ldi	r25, 0x08	; 8
    69ca:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    69ce:	0e c0       	rjmp	.+28     	; 0x69ec <report_alarm_message+0x46>
    case ALARM_SOFT_LIMIT_ERROR:
    printPgmString(PSTR("Soft limit")); break;
    69d0:	8e e6       	ldi	r24, 0x6E	; 110
    69d2:	98 e0       	ldi	r25, 0x08	; 8
    69d4:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    69d8:	09 c0       	rjmp	.+18     	; 0x69ec <report_alarm_message+0x46>
    case ALARM_ABORT_CYCLE: 
    printPgmString(PSTR("Abort during cycle")); break;
    69da:	8b e5       	ldi	r24, 0x5B	; 91
    69dc:	98 e0       	ldi	r25, 0x08	; 8
    69de:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    69e2:	04 c0       	rjmp	.+8      	; 0x69ec <report_alarm_message+0x46>
    case ALARM_PROBE_FAIL:
    printPgmString(PSTR("Probe fail")); break;
    69e4:	80 e5       	ldi	r24, 0x50	; 80
    69e6:	98 e0       	ldi	r25, 0x08	; 8
    69e8:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }
  printPgmString(PSTR("\r\n"));
    69ec:	8d e4       	ldi	r24, 0x4D	; 77
    69ee:	98 e0       	ldi	r25, 0x08	; 8
    69f0:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  delay_ms(500); // Force delay to ensure message clears serial write buffer.
    69f4:	84 ef       	ldi	r24, 0xF4	; 244
    69f6:	91 e0       	ldi	r25, 0x01	; 1
    69f8:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <delay_ms>
}
    69fc:	cf 91       	pop	r28
    69fe:	08 95       	ret

00006a00 <report_feedback_message>:
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
// TODO: Install silence feedback messages option in settings
void report_feedback_message(uint8_t message_code)
{
    6a00:	cf 93       	push	r28
    6a02:	c8 2f       	mov	r28, r24
  printPgmString(PSTR("["));
    6a04:	8b e4       	ldi	r24, 0x4B	; 75
    6a06:	98 e0       	ldi	r25, 0x08	; 8
    6a08:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  switch(message_code) {
    6a0c:	c3 30       	cpi	r28, 0x03	; 3
    6a0e:	b1 f0       	breq	.+44     	; 0x6a3c <report_feedback_message+0x3c>
    6a10:	28 f4       	brcc	.+10     	; 0x6a1c <report_feedback_message+0x1c>
    6a12:	c1 30       	cpi	r28, 0x01	; 1
    6a14:	49 f0       	breq	.+18     	; 0x6a28 <report_feedback_message+0x28>
    6a16:	c2 30       	cpi	r28, 0x02	; 2
    6a18:	61 f0       	breq	.+24     	; 0x6a32 <report_feedback_message+0x32>
    6a1a:	23 c0       	rjmp	.+70     	; 0x6a62 <report_feedback_message+0x62>
    6a1c:	c5 30       	cpi	r28, 0x05	; 5
    6a1e:	c1 f0       	breq	.+48     	; 0x6a50 <report_feedback_message+0x50>
    6a20:	90 f0       	brcs	.+36     	; 0x6a46 <report_feedback_message+0x46>
    6a22:	c6 30       	cpi	r28, 0x06	; 6
    6a24:	d1 f0       	breq	.+52     	; 0x6a5a <report_feedback_message+0x5a>
    6a26:	1d c0       	rjmp	.+58     	; 0x6a62 <report_feedback_message+0x62>
    case MESSAGE_CRITICAL_EVENT:
    printPgmString(PSTR("Reset to continue")); break;
    6a28:	89 e3       	ldi	r24, 0x39	; 57
    6a2a:	98 e0       	ldi	r25, 0x08	; 8
    6a2c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6a30:	18 c0       	rjmp	.+48     	; 0x6a62 <report_feedback_message+0x62>
    case MESSAGE_ALARM_LOCK:
    printPgmString(PSTR("'$H'|'$X' to unlock")); break;
    6a32:	85 e2       	ldi	r24, 0x25	; 37
    6a34:	98 e0       	ldi	r25, 0x08	; 8
    6a36:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6a3a:	13 c0       	rjmp	.+38     	; 0x6a62 <report_feedback_message+0x62>
    case MESSAGE_ALARM_UNLOCK:
    printPgmString(PSTR("Caution: Unlocked")); break;
    6a3c:	83 e1       	ldi	r24, 0x13	; 19
    6a3e:	98 e0       	ldi	r25, 0x08	; 8
    6a40:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6a44:	0e c0       	rjmp	.+28     	; 0x6a62 <report_feedback_message+0x62>
    case MESSAGE_ENABLED:
    printPgmString(PSTR("Enabled")); break;
    6a46:	8b e0       	ldi	r24, 0x0B	; 11
    6a48:	98 e0       	ldi	r25, 0x08	; 8
    6a4a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6a4e:	09 c0       	rjmp	.+18     	; 0x6a62 <report_feedback_message+0x62>
    case MESSAGE_DISABLED:
    printPgmString(PSTR("Disabled")); break; 
    6a50:	82 e0       	ldi	r24, 0x02	; 2
    6a52:	98 e0       	ldi	r25, 0x08	; 8
    6a54:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6a58:	04 c0       	rjmp	.+8      	; 0x6a62 <report_feedback_message+0x62>
    case MESSAGE_SAFETY_DOOR_AJAR:
    printPgmString(PSTR("Check Door")); break;
    6a5a:	87 ef       	ldi	r24, 0xF7	; 247
    6a5c:	97 e0       	ldi	r25, 0x07	; 7
    6a5e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }
  printPgmString(PSTR("]\r\n"));
    6a62:	83 ef       	ldi	r24, 0xF3	; 243
    6a64:	97 e0       	ldi	r25, 0x07	; 7
    6a66:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
}
    6a6a:	cf 91       	pop	r28
    6a6c:	08 95       	ret

00006a6e <report_init_message>:


// Welcome message
void report_init_message()
{
  printPgmString(PSTR("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n"));
    6a6e:	8d ec       	ldi	r24, 0xCD	; 205
    6a70:	97 e0       	ldi	r25, 0x07	; 7
    6a72:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6a76:	08 95       	ret

00006a78 <report_grbl_help>:
}

// Grbl help message
void report_grbl_help() {
  printPgmString(PSTR("$$ (view Grbl settings)\r\n"
    6a78:	89 e8       	ldi	r24, 0x89	; 137
    6a7a:	96 e0       	ldi	r25, 0x06	; 6
    6a7c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6a80:	08 95       	ret

00006a82 <report_grbl_settings>:
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6a82:	cf 92       	push	r12
    6a84:	df 92       	push	r13
    6a86:	ef 92       	push	r14
    6a88:	ff 92       	push	r15
    6a8a:	0f 93       	push	r16
    6a8c:	1f 93       	push	r17
    6a8e:	cf 93       	push	r28
    6a90:	df 93       	push	r29
  // Print Grbl settings.
  printPgmString(PSTR("$0=")); print_uint8_base10(settings.pulse_microseconds);
    6a92:	85 e8       	ldi	r24, 0x85	; 133
    6a94:	96 e0       	ldi	r25, 0x06	; 6
    6a96:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6a9a:	80 91 2f 09 	lds	r24, 0x092F
    6a9e:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (step pulse, usec)\r\n$1=")); print_uint8_base10(settings.stepper_idle_lock_time);
    6aa2:	8c e6       	ldi	r24, 0x6C	; 108
    6aa4:	96 e0       	ldi	r25, 0x06	; 6
    6aa6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6aaa:	80 91 32 09 	lds	r24, 0x0932
    6aae:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (step idle delay, msec)\r\n$2=")); print_uint8_base10(settings.step_invert_mask); 
    6ab2:	8e e4       	ldi	r24, 0x4E	; 78
    6ab4:	96 e0       	ldi	r25, 0x06	; 6
    6ab6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6aba:	c0 e3       	ldi	r28, 0x30	; 48
    6abc:	d9 e0       	ldi	r29, 0x09	; 9
    6abe:	88 81       	ld	r24, Y
    6ac0:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (step port invert mask:")); print_uint8_base2(settings.step_invert_mask);  
    6ac4:	85 e3       	ldi	r24, 0x35	; 53
    6ac6:	96 e0       	ldi	r25, 0x06	; 6
    6ac8:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6acc:	88 81       	ld	r24, Y
    6ace:	0e 94 d9 32 	call	0x65b2	; 0x65b2 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$3=")); print_uint8_base10(settings.dir_invert_mask); 
    6ad2:	8e e2       	ldi	r24, 0x2E	; 46
    6ad4:	96 e0       	ldi	r25, 0x06	; 6
    6ad6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6ada:	c1 e3       	ldi	r28, 0x31	; 49
    6adc:	d9 e0       	ldi	r29, 0x09	; 9
    6ade:	88 81       	ld	r24, Y
    6ae0:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (dir port invert mask:")); print_uint8_base2(settings.dir_invert_mask);  
    6ae4:	86 e1       	ldi	r24, 0x16	; 22
    6ae6:	96 e0       	ldi	r25, 0x06	; 6
    6ae8:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6aec:	88 81       	ld	r24, Y
    6aee:	0e 94 d9 32 	call	0x65b2	; 0x65b2 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$4=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
    6af2:	8f e0       	ldi	r24, 0x0F	; 15
    6af4:	96 e0       	ldi	r25, 0x06	; 6
    6af6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6afa:	cc e3       	ldi	r28, 0x3C	; 60
    6afc:	d9 e0       	ldi	r29, 0x09	; 9
    6afe:	88 81       	ld	r24, Y
    6b00:	82 fb       	bst	r24, 2
    6b02:	88 27       	eor	r24, r24
    6b04:	80 f9       	bld	r24, 0
    6b06:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (step enable invert, bool)\r\n$5=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
    6b0a:	8e ee       	ldi	r24, 0xEE	; 238
    6b0c:	95 e0       	ldi	r25, 0x05	; 5
    6b0e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6b12:	88 81       	ld	r24, Y
    6b14:	86 fb       	bst	r24, 6
    6b16:	88 27       	eor	r24, r24
    6b18:	80 f9       	bld	r24, 0
    6b1a:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (limit pins invert, bool)\r\n$6=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
    6b1e:	8e ec       	ldi	r24, 0xCE	; 206
    6b20:	95 e0       	ldi	r25, 0x05	; 5
    6b22:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6b26:	88 81       	ld	r24, Y
    6b28:	88 1f       	adc	r24, r24
    6b2a:	88 27       	eor	r24, r24
    6b2c:	88 1f       	adc	r24, r24
    6b2e:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (probe pin invert, bool)\r\n$10=")); print_uint8_base10(settings.status_report_mask);
    6b32:	8e ea       	ldi	r24, 0xAE	; 174
    6b34:	95 e0       	ldi	r25, 0x05	; 5
    6b36:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6b3a:	03 e3       	ldi	r16, 0x33	; 51
    6b3c:	19 e0       	ldi	r17, 0x09	; 9
    6b3e:	f8 01       	movw	r30, r16
    6b40:	80 81       	ld	r24, Z
    6b42:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (status report mask:")); print_uint8_base2(settings.status_report_mask);
    6b46:	88 e9       	ldi	r24, 0x98	; 152
    6b48:	95 e0       	ldi	r25, 0x05	; 5
    6b4a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6b4e:	f8 01       	movw	r30, r16
    6b50:	80 81       	ld	r24, Z
    6b52:	0e 94 d9 32 	call	0x65b2	; 0x65b2 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$11=")); printFloat_SettingValue(settings.junction_deviation);
    6b56:	80 e9       	ldi	r24, 0x90	; 144
    6b58:	95 e0       	ldi	r25, 0x05	; 5
    6b5a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6b5e:	60 91 34 09 	lds	r22, 0x0934
    6b62:	70 91 35 09 	lds	r23, 0x0935
    6b66:	80 91 36 09 	lds	r24, 0x0936
    6b6a:	90 91 37 09 	lds	r25, 0x0937
    6b6e:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
  printPgmString(PSTR(" (junction deviation, mm)\r\n$12=")); printFloat_SettingValue(settings.arc_tolerance);
    6b72:	80 e7       	ldi	r24, 0x70	; 112
    6b74:	95 e0       	ldi	r25, 0x05	; 5
    6b76:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6b7a:	60 91 38 09 	lds	r22, 0x0938
    6b7e:	70 91 39 09 	lds	r23, 0x0939
    6b82:	80 91 3a 09 	lds	r24, 0x093A
    6b86:	90 91 3b 09 	lds	r25, 0x093B
    6b8a:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
  printPgmString(PSTR(" (arc tolerance, mm)\r\n$13=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
    6b8e:	85 e5       	ldi	r24, 0x55	; 85
    6b90:	95 e0       	ldi	r25, 0x05	; 5
    6b92:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6b96:	88 81       	ld	r24, Y
    6b98:	81 70       	andi	r24, 0x01	; 1
    6b9a:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (report inches, bool)\r\n$20=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
    6b9e:	88 e3       	ldi	r24, 0x38	; 56
    6ba0:	95 e0       	ldi	r25, 0x05	; 5
    6ba2:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6ba6:	88 81       	ld	r24, Y
    6ba8:	85 fb       	bst	r24, 5
    6baa:	88 27       	eor	r24, r24
    6bac:	80 f9       	bld	r24, 0
    6bae:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (soft limits, bool)\r\n$21=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
    6bb2:	8d e1       	ldi	r24, 0x1D	; 29
    6bb4:	95 e0       	ldi	r25, 0x05	; 5
    6bb6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6bba:	88 81       	ld	r24, Y
    6bbc:	83 fb       	bst	r24, 3
    6bbe:	88 27       	eor	r24, r24
    6bc0:	80 f9       	bld	r24, 0
    6bc2:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (hard limits, bool)\r\n$22=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
    6bc6:	82 e0       	ldi	r24, 0x02	; 2
    6bc8:	95 e0       	ldi	r25, 0x05	; 5
    6bca:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6bce:	88 81       	ld	r24, Y
    6bd0:	82 95       	swap	r24
    6bd2:	81 70       	andi	r24, 0x01	; 1
    6bd4:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (homing cycle, bool)\r\n$23=")); print_uint8_base10(settings.homing_dir_mask);
    6bd8:	86 ee       	ldi	r24, 0xE6	; 230
    6bda:	94 e0       	ldi	r25, 0x04	; 4
    6bdc:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6be0:	cd e3       	ldi	r28, 0x3D	; 61
    6be2:	d9 e0       	ldi	r29, 0x09	; 9
    6be4:	88 81       	ld	r24, Y
    6be6:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (homing dir invert mask:")); print_uint8_base2(settings.homing_dir_mask);  
    6bea:	8c ec       	ldi	r24, 0xCC	; 204
    6bec:	94 e0       	ldi	r25, 0x04	; 4
    6bee:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6bf2:	88 81       	ld	r24, Y
    6bf4:	0e 94 d9 32 	call	0x65b2	; 0x65b2 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$24=")); printFloat_SettingValue(settings.homing_feed_rate);
    6bf8:	84 ec       	ldi	r24, 0xC4	; 196
    6bfa:	94 e0       	ldi	r25, 0x04	; 4
    6bfc:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6c00:	60 91 3e 09 	lds	r22, 0x093E
    6c04:	70 91 3f 09 	lds	r23, 0x093F
    6c08:	80 91 40 09 	lds	r24, 0x0940
    6c0c:	90 91 41 09 	lds	r25, 0x0941
    6c10:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing feed, mm/min)\r\n$25=")); printFloat_SettingValue(settings.homing_seek_rate);
    6c14:	87 ea       	ldi	r24, 0xA7	; 167
    6c16:	94 e0       	ldi	r25, 0x04	; 4
    6c18:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6c1c:	60 91 42 09 	lds	r22, 0x0942
    6c20:	70 91 43 09 	lds	r23, 0x0943
    6c24:	80 91 44 09 	lds	r24, 0x0944
    6c28:	90 91 45 09 	lds	r25, 0x0945
    6c2c:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing seek, mm/min)\r\n$26=")); print_uint8_base10(settings.homing_debounce_delay);
    6c30:	8a e8       	ldi	r24, 0x8A	; 138
    6c32:	94 e0       	ldi	r25, 0x04	; 4
    6c34:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6c38:	80 91 46 09 	lds	r24, 0x0946
    6c3c:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR(" (homing debounce, msec)\r\n$27=")); printFloat_SettingValue(settings.homing_pulloff);
    6c40:	8b e6       	ldi	r24, 0x6B	; 107
    6c42:	94 e0       	ldi	r25, 0x04	; 4
    6c44:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6c48:	60 91 48 09 	lds	r22, 0x0948
    6c4c:	70 91 49 09 	lds	r23, 0x0949
    6c50:	80 91 4a 09 	lds	r24, 0x094A
    6c54:	90 91 4b 09 	lds	r25, 0x094B
    6c58:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing pull-off, mm)\r\n$30=")); printFloat_SettingValue(settings.z_zero_pulloff);
    6c5c:	8e e4       	ldi	r24, 0x4E	; 78
    6c5e:	94 e0       	ldi	r25, 0x04	; 4
    6c60:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6c64:	60 91 4c 09 	lds	r22, 0x094C
    6c68:	70 91 4d 09 	lds	r23, 0x094D
    6c6c:	80 91 4e 09 	lds	r24, 0x094E
    6c70:	90 91 4f 09 	lds	r25, 0x094F
    6c74:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
  printPgmString(PSTR(" (Z zero pull-off, mm)\r\n$31=")); printFloat_SettingValue(settings.z_zero_gauge);
    6c78:	81 e3       	ldi	r24, 0x31	; 49
    6c7a:	94 e0       	ldi	r25, 0x04	; 4
    6c7c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6c80:	60 91 50 09 	lds	r22, 0x0950
    6c84:	70 91 51 09 	lds	r23, 0x0951
    6c88:	80 91 52 09 	lds	r24, 0x0952
    6c8c:	90 91 53 09 	lds	r25, 0x0953
    6c90:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
  printPgmString(PSTR(" (Z zero gauge, mm)\r\n"));
    6c94:	8b e1       	ldi	r24, 0x1B	; 27
    6c96:	94 e0       	ldi	r25, 0x04	; 4
    6c98:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
    6c9c:	0f 2e       	mov	r0, r31
    6c9e:	f4 e6       	ldi	r31, 0x64	; 100
    6ca0:	df 2e       	mov	r13, r31
    6ca2:	f0 2d       	mov	r31, r0
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    6ca4:	10 e0       	ldi	r17, 0x00	; 0
    6ca6:	0f 2e       	mov	r0, r31
    6ca8:	ff ef       	ldi	r31, 0xFF	; 255
    6caa:	ef 2e       	mov	r14, r31
    6cac:	f8 e0       	ldi	r31, 0x08	; 8
    6cae:	ff 2e       	mov	r15, r31
    6cb0:	f0 2d       	mov	r31, r0
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6cb2:	c1 2c       	mov	r12, r1
    6cb4:	7a c0       	rjmp	.+244    	; 0x6daa <report_grbl_settings+0x328>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printPgmString(PSTR("$"));
    6cb6:	89 e1       	ldi	r24, 0x19	; 25
    6cb8:	94 e0       	ldi	r25, 0x04	; 4
    6cba:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
      print_uint8_base10(val+idx);
    6cbe:	80 2f       	mov	r24, r16
    6cc0:	8d 0d       	add	r24, r13
    6cc2:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
      printPgmString(PSTR("="));
    6cc6:	87 e1       	ldi	r24, 0x17	; 23
    6cc8:	94 e0       	ldi	r25, 0x04	; 4
    6cca:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
      switch (set_idx) {
    6cce:	11 30       	cpi	r17, 0x01	; 1
    6cd0:	69 f0       	breq	.+26     	; 0x6cec <report_grbl_settings+0x26a>
    6cd2:	28 f0       	brcs	.+10     	; 0x6cde <report_grbl_settings+0x25c>
    6cd4:	12 30       	cpi	r17, 0x02	; 2
    6cd6:	89 f0       	breq	.+34     	; 0x6cfa <report_grbl_settings+0x278>
    6cd8:	13 30       	cpi	r17, 0x03	; 3
    6cda:	e1 f0       	breq	.+56     	; 0x6d14 <report_grbl_settings+0x292>
    6cdc:	24 c0       	rjmp	.+72     	; 0x6d26 <report_grbl_settings+0x2a4>
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
    6cde:	68 81       	ld	r22, Y
    6ce0:	79 81       	ldd	r23, Y+1	; 0x01
    6ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    6ce4:	9b 81       	ldd	r25, Y+3	; 0x03
    6ce6:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
    6cea:	1d c0       	rjmp	.+58     	; 0x6d26 <report_grbl_settings+0x2a4>
        case 1: printFloat_SettingValue(settings.max_rate[idx]); break;
    6cec:	6c 85       	ldd	r22, Y+12	; 0x0c
    6cee:	7d 85       	ldd	r23, Y+13	; 0x0d
    6cf0:	8e 85       	ldd	r24, Y+14	; 0x0e
    6cf2:	9f 85       	ldd	r25, Y+15	; 0x0f
    6cf4:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
    6cf8:	16 c0       	rjmp	.+44     	; 0x6d26 <report_grbl_settings+0x2a4>
        case 2: printFloat_SettingValue(settings.acceleration[idx]/(60*60)); break;
    6cfa:	20 e0       	ldi	r18, 0x00	; 0
    6cfc:	30 e0       	ldi	r19, 0x00	; 0
    6cfe:	41 e6       	ldi	r20, 0x61	; 97
    6d00:	55 e4       	ldi	r21, 0x45	; 69
    6d02:	68 8d       	ldd	r22, Y+24	; 0x18
    6d04:	79 8d       	ldd	r23, Y+25	; 0x19
    6d06:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d08:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d0a:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
    6d0e:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
    6d12:	09 c0       	rjmp	.+18     	; 0x6d26 <report_grbl_settings+0x2a4>
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
    6d14:	8c a1       	ldd	r24, Y+36	; 0x24
    6d16:	9d a1       	ldd	r25, Y+37	; 0x25
    6d18:	ae a1       	ldd	r26, Y+38	; 0x26
    6d1a:	bf a1       	ldd	r27, Y+39	; 0x27
    6d1c:	bc 01       	movw	r22, r24
    6d1e:	cd 01       	movw	r24, r26
    6d20:	90 58       	subi	r25, 0x80	; 128
    6d22:	0e 94 2a 34 	call	0x6854	; 0x6854 <printFloat_SettingValue>
      }
      printPgmString(PSTR(" ("));
    6d26:	84 e1       	ldi	r24, 0x14	; 20
    6d28:	94 e0       	ldi	r25, 0x04	; 4
    6d2a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
      switch (idx) {
    6d2e:	01 30       	cpi	r16, 0x01	; 1
    6d30:	49 f0       	breq	.+18     	; 0x6d44 <report_grbl_settings+0x2c2>
    6d32:	18 f0       	brcs	.+6      	; 0x6d3a <report_grbl_settings+0x2b8>
    6d34:	02 30       	cpi	r16, 0x02	; 2
    6d36:	59 f0       	breq	.+22     	; 0x6d4e <report_grbl_settings+0x2cc>
    6d38:	0e c0       	rjmp	.+28     	; 0x6d56 <report_grbl_settings+0x2d4>
        case X_AXIS: printPgmString(PSTR("x")); break;
    6d3a:	82 e1       	ldi	r24, 0x12	; 18
    6d3c:	94 e0       	ldi	r25, 0x04	; 4
    6d3e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6d42:	09 c0       	rjmp	.+18     	; 0x6d56 <report_grbl_settings+0x2d4>
        case Y_AXIS: printPgmString(PSTR("y")); break;
    6d44:	80 e1       	ldi	r24, 0x10	; 16
    6d46:	94 e0       	ldi	r25, 0x04	; 4
    6d48:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6d4c:	04 c0       	rjmp	.+8      	; 0x6d56 <report_grbl_settings+0x2d4>
        case Z_AXIS: printPgmString(PSTR("z")); break;
    6d4e:	8e e0       	ldi	r24, 0x0E	; 14
    6d50:	94 e0       	ldi	r25, 0x04	; 4
    6d52:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
      }
      switch (set_idx) {
    6d56:	11 30       	cpi	r17, 0x01	; 1
    6d58:	59 f0       	breq	.+22     	; 0x6d70 <report_grbl_settings+0x2ee>
    6d5a:	28 f0       	brcs	.+10     	; 0x6d66 <report_grbl_settings+0x2e4>
    6d5c:	12 30       	cpi	r17, 0x02	; 2
    6d5e:	69 f0       	breq	.+26     	; 0x6d7a <report_grbl_settings+0x2f8>
    6d60:	13 30       	cpi	r17, 0x03	; 3
    6d62:	81 f0       	breq	.+32     	; 0x6d84 <report_grbl_settings+0x302>
    6d64:	13 c0       	rjmp	.+38     	; 0x6d8c <report_grbl_settings+0x30a>
        case 0: printPgmString(PSTR(", step/mm")); break;
    6d66:	84 e0       	ldi	r24, 0x04	; 4
    6d68:	94 e0       	ldi	r25, 0x04	; 4
    6d6a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6d6e:	0e c0       	rjmp	.+28     	; 0x6d8c <report_grbl_settings+0x30a>
        case 1: printPgmString(PSTR(" max rate, mm/min")); break;
    6d70:	82 ef       	ldi	r24, 0xF2	; 242
    6d72:	93 e0       	ldi	r25, 0x03	; 3
    6d74:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6d78:	09 c0       	rjmp	.+18     	; 0x6d8c <report_grbl_settings+0x30a>
        case 2: printPgmString(PSTR(" accel, mm/sec^2")); break;
    6d7a:	81 ee       	ldi	r24, 0xE1	; 225
    6d7c:	93 e0       	ldi	r25, 0x03	; 3
    6d7e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6d82:	04 c0       	rjmp	.+8      	; 0x6d8c <report_grbl_settings+0x30a>
        case 3: printPgmString(PSTR(" max travel, mm")); break;
    6d84:	81 ed       	ldi	r24, 0xD1	; 209
    6d86:	93 e0       	ldi	r25, 0x03	; 3
    6d88:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
      }      
      printPgmString(PSTR(")\r\n"));
    6d8c:	8d ec       	ldi	r24, 0xCD	; 205
    6d8e:	93 e0       	ldi	r25, 0x03	; 3
    6d90:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
    6d94:	0f 5f       	subi	r16, 0xFF	; 255
    6d96:	24 96       	adiw	r28, 0x04	; 4
    6d98:	03 30       	cpi	r16, 0x03	; 3
    6d9a:	09 f0       	breq	.+2      	; 0x6d9e <report_grbl_settings+0x31c>
    6d9c:	8c cf       	rjmp	.-232    	; 0x6cb6 <report_grbl_settings+0x234>
        case 2: printPgmString(PSTR(" accel, mm/sec^2")); break;
        case 3: printPgmString(PSTR(" max travel, mm")); break;
      }      
      printPgmString(PSTR(")\r\n"));
    }
    val += AXIS_SETTINGS_INCREMENT;
    6d9e:	fa e0       	ldi	r31, 0x0A	; 10
    6da0:	df 0e       	add	r13, r31
  printPgmString(PSTR(" (Z zero gauge, mm)\r\n"));

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    6da2:	1f 5f       	subi	r17, 0xFF	; 255
    6da4:	8c e8       	ldi	r24, 0x8C	; 140
    6da6:	d8 16       	cp	r13, r24
    6da8:	19 f0       	breq	.+6      	; 0x6db0 <report_grbl_settings+0x32e>
    6daa:	e7 01       	movw	r28, r14
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6dac:	0c 2d       	mov	r16, r12
    6dae:	83 cf       	rjmp	.-250    	; 0x6cb6 <report_grbl_settings+0x234>
      }      
      printPgmString(PSTR(")\r\n"));
    }
    val += AXIS_SETTINGS_INCREMENT;
  }  
}
    6db0:	df 91       	pop	r29
    6db2:	cf 91       	pop	r28
    6db4:	1f 91       	pop	r17
    6db6:	0f 91       	pop	r16
    6db8:	ff 90       	pop	r15
    6dba:	ef 90       	pop	r14
    6dbc:	df 90       	pop	r13
    6dbe:	cf 90       	pop	r12
    6dc0:	08 95       	ret

00006dc2 <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported). 
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters()
{
    6dc2:	cf 93       	push	r28
  uint8_t i;
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:"));
    6dc4:	87 ec       	ldi	r24, 0xC7	; 199
    6dc6:	93 e0       	ldi	r25, 0x03	; 3
    6dc8:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  for (i=0; i< N_AXIS; i++) {
    6dcc:	c0 e0       	ldi	r28, 0x00	; 0
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
    6dce:	6c 2f       	mov	r22, r28
    6dd0:	8a e7       	ldi	r24, 0x7A	; 122
    6dd2:	97 e0       	ldi	r25, 0x07	; 7
    6dd4:	0e 94 9d 3b 	call	0x773a	; 0x773a <system_convert_axis_steps_to_mpos>
    printFloat_CoordValue(print_position[i]);
    6dd8:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6ddc:	c2 30       	cpi	r28, 0x02	; 2
    6dde:	20 f4       	brcc	.+8      	; 0x6de8 <report_probe_parameters+0x26>
    6de0:	85 ec       	ldi	r24, 0xC5	; 197
    6de2:	93 e0       	ldi	r25, 0x03	; 3
    6de4:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  uint8_t i;
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:"));
  for (i=0; i< N_AXIS; i++) {
    6de8:	cf 5f       	subi	r28, 0xFF	; 255
    6dea:	c3 30       	cpi	r28, 0x03	; 3
    6dec:	81 f7       	brne	.-32     	; 0x6dce <report_probe_parameters+0xc>
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
    printFloat_CoordValue(print_position[i]);
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
  }
  printPgmString(PSTR(":"));
    6dee:	83 ec       	ldi	r24, 0xC3	; 195
    6df0:	93 e0       	ldi	r25, 0x03	; 3
    6df2:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  print_uint8_base10(sys.probe_succeeded);
    6df6:	80 91 86 07 	lds	r24, 0x0786
    6dfa:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR("]\r\n"));
    6dfe:	8f eb       	ldi	r24, 0xBF	; 191
    6e00:	93 e0       	ldi	r25, 0x03	; 3
    6e02:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
}
    6e06:	cf 91       	pop	r28
    6e08:	08 95       	ret

00006e0a <report_ngc_parameters>:


// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
    6e0a:	df 92       	push	r13
    6e0c:	ef 92       	push	r14
    6e0e:	ff 92       	push	r15
    6e10:	0f 93       	push	r16
    6e12:	1f 93       	push	r17
    6e14:	cf 93       	push	r28
    6e16:	df 93       	push	r29
    6e18:	cd b7       	in	r28, 0x3d	; 61
    6e1a:	de b7       	in	r29, 0x3e	; 62
    6e1c:	2c 97       	sbiw	r28, 0x0c	; 12
    6e1e:	0f b6       	in	r0, 0x3f	; 63
    6e20:	f8 94       	cli
    6e22:	de bf       	out	0x3e, r29	; 62
    6e24:	0f be       	out	0x3f, r0	; 63
    6e26:	cd bf       	out	0x3d, r28	; 61
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    6e28:	e1 2c       	mov	r14, r1
      case 6: printPgmString(PSTR("28")); break;
      case 7: printPgmString(PSTR("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printPgmString(PSTR(":"));         
    for (i=0; i<N_AXIS; i++) {
    6e2a:	d1 2c       	mov	r13, r1
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    if (!(settings_read_coord_data(coord_select,coord_data))) { 
    6e2c:	be 01       	movw	r22, r28
    6e2e:	6f 5f       	subi	r22, 0xFF	; 255
    6e30:	7f 4f       	sbci	r23, 0xFF	; 255
    6e32:	8e 2d       	mov	r24, r14
    6e34:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <settings_read_coord_data>
    6e38:	81 11       	cpse	r24, r1
    6e3a:	04 c0       	rjmp	.+8      	; 0x6e44 <report_ngc_parameters+0x3a>
      report_status_message(STATUS_SETTING_READ_FAIL); 
    6e3c:	87 e0       	ldi	r24, 0x07	; 7
    6e3e:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
    6e42:	70 c0       	rjmp	.+224    	; 0x6f24 <report_ngc_parameters+0x11a>
      return;
    } 
    printPgmString(PSTR("[G"));
    6e44:	8c eb       	ldi	r24, 0xBC	; 188
    6e46:	93 e0       	ldi	r25, 0x03	; 3
    6e48:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    switch (coord_select) {
    6e4c:	86 e0       	ldi	r24, 0x06	; 6
    6e4e:	e8 16       	cp	r14, r24
    6e50:	21 f0       	breq	.+8      	; 0x6e5a <report_ngc_parameters+0x50>
    6e52:	e7 e0       	ldi	r30, 0x07	; 7
    6e54:	ee 16       	cp	r14, r30
    6e56:	31 f0       	breq	.+12     	; 0x6e64 <report_ngc_parameters+0x5a>
    6e58:	0a c0       	rjmp	.+20     	; 0x6e6e <report_ngc_parameters+0x64>
      case 6: printPgmString(PSTR("28")); break;
    6e5a:	89 eb       	ldi	r24, 0xB9	; 185
    6e5c:	93 e0       	ldi	r25, 0x03	; 3
    6e5e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6e62:	09 c0       	rjmp	.+18     	; 0x6e76 <report_ngc_parameters+0x6c>
      case 7: printPgmString(PSTR("30")); break;
    6e64:	86 eb       	ldi	r24, 0xB6	; 182
    6e66:	93 e0       	ldi	r25, 0x03	; 3
    6e68:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6e6c:	04 c0       	rjmp	.+8      	; 0x6e76 <report_ngc_parameters+0x6c>
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    6e6e:	86 e3       	ldi	r24, 0x36	; 54
    6e70:	8e 0d       	add	r24, r14
    6e72:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
    }  
    printPgmString(PSTR(":"));         
    6e76:	84 eb       	ldi	r24, 0xB4	; 180
    6e78:	93 e0       	ldi	r25, 0x03	; 3
    6e7a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6e7e:	8e 01       	movw	r16, r28
    6e80:	0f 5f       	subi	r16, 0xFF	; 255
    6e82:	1f 4f       	sbci	r17, 0xFF	; 255
    for (i=0; i<N_AXIS; i++) {
    6e84:	fd 2c       	mov	r15, r13
      printFloat_CoordValue(coord_data[i]);
    6e86:	f8 01       	movw	r30, r16
    6e88:	61 91       	ld	r22, Z+
    6e8a:	71 91       	ld	r23, Z+
    6e8c:	81 91       	ld	r24, Z+
    6e8e:	91 91       	ld	r25, Z+
    6e90:	8f 01       	movw	r16, r30
    6e92:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6e96:	f1 e0       	ldi	r31, 0x01	; 1
    6e98:	ff 15       	cp	r31, r15
    6e9a:	28 f0       	brcs	.+10     	; 0x6ea6 <report_ngc_parameters+0x9c>
    6e9c:	82 eb       	ldi	r24, 0xB2	; 178
    6e9e:	93 e0       	ldi	r25, 0x03	; 3
    6ea0:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6ea4:	04 c0       	rjmp	.+8      	; 0x6eae <report_ngc_parameters+0xa4>
      else { printPgmString(PSTR("]\r\n")); }
    6ea6:	8e ea       	ldi	r24, 0xAE	; 174
    6ea8:	93 e0       	ldi	r25, 0x03	; 3
    6eaa:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
      case 6: printPgmString(PSTR("28")); break;
      case 7: printPgmString(PSTR("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printPgmString(PSTR(":"));         
    for (i=0; i<N_AXIS; i++) {
    6eae:	f3 94       	inc	r15
    6eb0:	83 e0       	ldi	r24, 0x03	; 3
    6eb2:	f8 12       	cpse	r15, r24
    6eb4:	e8 cf       	rjmp	.-48     	; 0x6e86 <report_ngc_parameters+0x7c>
// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    6eb6:	e3 94       	inc	r14
    6eb8:	e8 e0       	ldi	r30, 0x08	; 8
    6eba:	ee 12       	cpse	r14, r30
    6ebc:	b7 cf       	rjmp	.-146    	; 0x6e2c <report_ngc_parameters+0x22>
      printFloat_CoordValue(coord_data[i]);
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
      else { printPgmString(PSTR("]\r\n")); }
    } 
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
    6ebe:	88 ea       	ldi	r24, 0xA8	; 168
    6ec0:	93 e0       	ldi	r25, 0x03	; 3
    6ec2:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6ec6:	06 eb       	ldi	r16, 0xB6	; 182
    6ec8:	17 e0       	ldi	r17, 0x07	; 7
  for (i=0; i<N_AXIS; i++) {
    6eca:	f1 2c       	mov	r15, r1
    printFloat_CoordValue(gc_state.coord_offset[i]);
    6ecc:	f8 01       	movw	r30, r16
    6ece:	61 91       	ld	r22, Z+
    6ed0:	71 91       	ld	r23, Z+
    6ed2:	81 91       	ld	r24, Z+
    6ed4:	91 91       	ld	r25, Z+
    6ed6:	8f 01       	movw	r16, r30
    6ed8:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6edc:	f1 e0       	ldi	r31, 0x01	; 1
    6ede:	ff 15       	cp	r31, r15
    6ee0:	28 f0       	brcs	.+10     	; 0x6eec <report_ngc_parameters+0xe2>
    6ee2:	86 ea       	ldi	r24, 0xA6	; 166
    6ee4:	93 e0       	ldi	r25, 0x03	; 3
    6ee6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6eea:	04 c0       	rjmp	.+8      	; 0x6ef4 <report_ngc_parameters+0xea>
    else { printPgmString(PSTR("]\r\n")); }
    6eec:	82 ea       	ldi	r24, 0xA2	; 162
    6eee:	93 e0       	ldi	r25, 0x03	; 3
    6ef0:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
      else { printPgmString(PSTR("]\r\n")); }
    } 
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
  for (i=0; i<N_AXIS; i++) {
    6ef4:	f3 94       	inc	r15
    6ef6:	83 e0       	ldi	r24, 0x03	; 3
    6ef8:	f8 12       	cpse	r15, r24
    6efa:	e8 cf       	rjmp	.-48     	; 0x6ecc <report_ngc_parameters+0xc2>
    printFloat_CoordValue(gc_state.coord_offset[i]);
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    else { printPgmString(PSTR("]\r\n")); }
  } 
  printPgmString(PSTR("[TLO:")); // Print tool length offset value
    6efc:	8c e9       	ldi	r24, 0x9C	; 156
    6efe:	93 e0       	ldi	r25, 0x03	; 3
    6f00:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  printFloat_CoordValue(gc_state.tool_length_offset);
    6f04:	60 91 c2 07 	lds	r22, 0x07C2
    6f08:	70 91 c3 07 	lds	r23, 0x07C3
    6f0c:	80 91 c4 07 	lds	r24, 0x07C4
    6f10:	90 91 c5 07 	lds	r25, 0x07C5
    6f14:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
  printPgmString(PSTR("]\r\n"));
    6f18:	88 e9       	ldi	r24, 0x98	; 152
    6f1a:	93 e0       	ldi	r25, 0x03	; 3
    6f1c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  report_probe_parameters(); // Print probe parameters. Not persistent in memory.
    6f20:	0e 94 e1 36 	call	0x6dc2	; 0x6dc2 <report_probe_parameters>
}
    6f24:	2c 96       	adiw	r28, 0x0c	; 12
    6f26:	0f b6       	in	r0, 0x3f	; 63
    6f28:	f8 94       	cli
    6f2a:	de bf       	out	0x3e, r29	; 62
    6f2c:	0f be       	out	0x3f, r0	; 63
    6f2e:	cd bf       	out	0x3d, r28	; 61
    6f30:	df 91       	pop	r29
    6f32:	cf 91       	pop	r28
    6f34:	1f 91       	pop	r17
    6f36:	0f 91       	pop	r16
    6f38:	ff 90       	pop	r15
    6f3a:	ef 90       	pop	r14
    6f3c:	df 90       	pop	r13
    6f3e:	08 95       	ret

00006f40 <report_gcode_modes>:


// Print current gcode parser mode state
void report_gcode_modes()
{
  printPgmString(PSTR("["));
    6f40:	86 e9       	ldi	r24, 0x96	; 150
    6f42:	93 e0       	ldi	r25, 0x03	; 3
    6f44:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  
  switch (gc_state.modal.motion) {
    6f48:	80 91 87 07 	lds	r24, 0x0787
    6f4c:	90 e0       	ldi	r25, 0x00	; 0
    6f4e:	89 30       	cpi	r24, 0x09	; 9
    6f50:	91 05       	cpc	r25, r1
    6f52:	88 f5       	brcc	.+98     	; 0x6fb6 <report_gcode_modes+0x76>
    6f54:	fc 01       	movw	r30, r24
    6f56:	ef 5e       	subi	r30, 0xEF	; 239
    6f58:	fe 4f       	sbci	r31, 0xFE	; 254
    6f5a:	0c 94 fa 3f 	jmp	0x7ff4	; 0x7ff4 <__tablejump2__>
    case MOTION_MODE_SEEK : printPgmString(PSTR("G0")); break;
    6f5e:	83 e9       	ldi	r24, 0x93	; 147
    6f60:	93 e0       	ldi	r25, 0x03	; 3
    6f62:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6f66:	27 c0       	rjmp	.+78     	; 0x6fb6 <report_gcode_modes+0x76>
    case MOTION_MODE_LINEAR : printPgmString(PSTR("G1")); break;
    6f68:	80 e9       	ldi	r24, 0x90	; 144
    6f6a:	93 e0       	ldi	r25, 0x03	; 3
    6f6c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6f70:	22 c0       	rjmp	.+68     	; 0x6fb6 <report_gcode_modes+0x76>
    case MOTION_MODE_CW_ARC : printPgmString(PSTR("G2")); break;
    6f72:	8d e8       	ldi	r24, 0x8D	; 141
    6f74:	93 e0       	ldi	r25, 0x03	; 3
    6f76:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6f7a:	1d c0       	rjmp	.+58     	; 0x6fb6 <report_gcode_modes+0x76>
    case MOTION_MODE_CCW_ARC : printPgmString(PSTR("G3")); break;
    6f7c:	8a e8       	ldi	r24, 0x8A	; 138
    6f7e:	93 e0       	ldi	r25, 0x03	; 3
    6f80:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6f84:	18 c0       	rjmp	.+48     	; 0x6fb6 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_TOWARD : printPgmString(PSTR("G38.2")); break;    
    6f86:	84 e8       	ldi	r24, 0x84	; 132
    6f88:	93 e0       	ldi	r25, 0x03	; 3
    6f8a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6f8e:	13 c0       	rjmp	.+38     	; 0x6fb6 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_TOWARD_NO_ERROR : printPgmString(PSTR("G38.3")); break;    
    6f90:	8e e7       	ldi	r24, 0x7E	; 126
    6f92:	93 e0       	ldi	r25, 0x03	; 3
    6f94:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6f98:	0e c0       	rjmp	.+28     	; 0x6fb6 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_AWAY : printPgmString(PSTR("G38.4")); break;    
    6f9a:	88 e7       	ldi	r24, 0x78	; 120
    6f9c:	93 e0       	ldi	r25, 0x03	; 3
    6f9e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6fa2:	09 c0       	rjmp	.+18     	; 0x6fb6 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_AWAY_NO_ERROR : printPgmString(PSTR("G38.5")); break;    
    6fa4:	82 e7       	ldi	r24, 0x72	; 114
    6fa6:	93 e0       	ldi	r25, 0x03	; 3
    6fa8:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6fac:	04 c0       	rjmp	.+8      	; 0x6fb6 <report_gcode_modes+0x76>
    case MOTION_MODE_NONE : printPgmString(PSTR("G80")); break;
    6fae:	8e e6       	ldi	r24, 0x6E	; 110
    6fb0:	93 e0       	ldi	r25, 0x03	; 3
    6fb2:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }

  printPgmString(PSTR(" G"));
    6fb6:	8b e6       	ldi	r24, 0x6B	; 107
    6fb8:	93 e0       	ldi	r25, 0x03	; 3
    6fba:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  print_uint8_base10(gc_state.modal.coord_select+54);
    6fbe:	80 91 8d 07 	lds	r24, 0x078D
    6fc2:	8a 5c       	subi	r24, 0xCA	; 202
    6fc4:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  
  switch (gc_state.modal.plane_select) {
    6fc8:	80 91 8b 07 	lds	r24, 0x078B
    6fcc:	81 30       	cpi	r24, 0x01	; 1
    6fce:	49 f0       	breq	.+18     	; 0x6fe2 <report_gcode_modes+0xa2>
    6fd0:	18 f0       	brcs	.+6      	; 0x6fd8 <report_gcode_modes+0x98>
    6fd2:	82 30       	cpi	r24, 0x02	; 2
    6fd4:	59 f0       	breq	.+22     	; 0x6fec <report_gcode_modes+0xac>
    6fd6:	0e c0       	rjmp	.+28     	; 0x6ff4 <report_gcode_modes+0xb4>
    case PLANE_SELECT_XY : printPgmString(PSTR(" G17")); break;
    6fd8:	86 e6       	ldi	r24, 0x66	; 102
    6fda:	93 e0       	ldi	r25, 0x03	; 3
    6fdc:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6fe0:	09 c0       	rjmp	.+18     	; 0x6ff4 <report_gcode_modes+0xb4>
    case PLANE_SELECT_ZX : printPgmString(PSTR(" G18")); break;
    6fe2:	81 e6       	ldi	r24, 0x61	; 97
    6fe4:	93 e0       	ldi	r25, 0x03	; 3
    6fe6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    6fea:	04 c0       	rjmp	.+8      	; 0x6ff4 <report_gcode_modes+0xb4>
    case PLANE_SELECT_YZ : printPgmString(PSTR(" G19")); break;
    6fec:	8c e5       	ldi	r24, 0x5C	; 92
    6fee:	93 e0       	ldi	r25, 0x03	; 3
    6ff0:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }
  
  if (gc_state.modal.units == UNITS_MODE_MM) { printPgmString(PSTR(" G21")); }
    6ff4:	80 91 89 07 	lds	r24, 0x0789
    6ff8:	81 11       	cpse	r24, r1
    6ffa:	05 c0       	rjmp	.+10     	; 0x7006 <report_gcode_modes+0xc6>
    6ffc:	87 e5       	ldi	r24, 0x57	; 87
    6ffe:	93 e0       	ldi	r25, 0x03	; 3
    7000:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    7004:	04 c0       	rjmp	.+8      	; 0x700e <report_gcode_modes+0xce>
  else { printPgmString(PSTR(" G20")); }
    7006:	82 e5       	ldi	r24, 0x52	; 82
    7008:	93 e0       	ldi	r25, 0x03	; 3
    700a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  
  if (gc_state.modal.distance == DISTANCE_MODE_ABSOLUTE) { printPgmString(PSTR(" G90")); }
    700e:	80 91 8a 07 	lds	r24, 0x078A
    7012:	81 11       	cpse	r24, r1
    7014:	05 c0       	rjmp	.+10     	; 0x7020 <report_gcode_modes+0xe0>
    7016:	8d e4       	ldi	r24, 0x4D	; 77
    7018:	93 e0       	ldi	r25, 0x03	; 3
    701a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    701e:	04 c0       	rjmp	.+8      	; 0x7028 <report_gcode_modes+0xe8>
  else { printPgmString(PSTR(" G91")); }
    7020:	88 e4       	ldi	r24, 0x48	; 72
    7022:	93 e0       	ldi	r25, 0x03	; 3
    7024:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  
  if (gc_state.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { printPgmString(PSTR(" G93")); }
    7028:	80 91 88 07 	lds	r24, 0x0788
    702c:	81 30       	cpi	r24, 0x01	; 1
    702e:	29 f4       	brne	.+10     	; 0x703a <report_gcode_modes+0xfa>
    7030:	83 e4       	ldi	r24, 0x43	; 67
    7032:	93 e0       	ldi	r25, 0x03	; 3
    7034:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    7038:	04 c0       	rjmp	.+8      	; 0x7042 <report_gcode_modes+0x102>
  else { printPgmString(PSTR(" G94")); }
    703a:	8e e3       	ldi	r24, 0x3E	; 62
    703c:	93 e0       	ldi	r25, 0x03	; 3
    703e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    
  switch (gc_state.modal.program_flow) {
    7042:	80 91 8e 07 	lds	r24, 0x078E
    7046:	81 30       	cpi	r24, 0x01	; 1
    7048:	49 f0       	breq	.+18     	; 0x705c <report_gcode_modes+0x11c>
    704a:	18 f0       	brcs	.+6      	; 0x7052 <report_gcode_modes+0x112>
    704c:	82 30       	cpi	r24, 0x02	; 2
    704e:	59 f0       	breq	.+22     	; 0x7066 <report_gcode_modes+0x126>
    7050:	0e c0       	rjmp	.+28     	; 0x706e <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_RUNNING : printPgmString(PSTR(" M0")); break;
    7052:	8a e3       	ldi	r24, 0x3A	; 58
    7054:	93 e0       	ldi	r25, 0x03	; 3
    7056:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    705a:	09 c0       	rjmp	.+18     	; 0x706e <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_PAUSED : printPgmString(PSTR(" M1")); break;
    705c:	86 e3       	ldi	r24, 0x36	; 54
    705e:	93 e0       	ldi	r25, 0x03	; 3
    7060:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    7064:	04 c0       	rjmp	.+8      	; 0x706e <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_COMPLETED : printPgmString(PSTR(" M2")); break;
    7066:	82 e3       	ldi	r24, 0x32	; 50
    7068:	93 e0       	ldi	r25, 0x03	; 3
    706a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }

  switch (gc_state.modal.spindle) {
    706e:	80 91 90 07 	lds	r24, 0x0790
    7072:	81 30       	cpi	r24, 0x01	; 1
    7074:	21 f0       	breq	.+8      	; 0x707e <report_gcode_modes+0x13e>
    7076:	68 f0       	brcs	.+26     	; 0x7092 <report_gcode_modes+0x152>
    7078:	82 30       	cpi	r24, 0x02	; 2
    707a:	31 f0       	breq	.+12     	; 0x7088 <report_gcode_modes+0x148>
    707c:	0e c0       	rjmp	.+28     	; 0x709a <report_gcode_modes+0x15a>
    case SPINDLE_ENABLE_CW : printPgmString(PSTR(" M3")); break;
    707e:	8e e2       	ldi	r24, 0x2E	; 46
    7080:	93 e0       	ldi	r25, 0x03	; 3
    7082:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    7086:	09 c0       	rjmp	.+18     	; 0x709a <report_gcode_modes+0x15a>
    case SPINDLE_ENABLE_CCW : printPgmString(PSTR(" M4")); break;
    7088:	8a e2       	ldi	r24, 0x2A	; 42
    708a:	93 e0       	ldi	r25, 0x03	; 3
    708c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    7090:	04 c0       	rjmp	.+8      	; 0x709a <report_gcode_modes+0x15a>
    case SPINDLE_DISABLE : printPgmString(PSTR(" M5")); break;
    7092:	86 e2       	ldi	r24, 0x26	; 38
    7094:	93 e0       	ldi	r25, 0x03	; 3
    7096:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }
  
  switch (gc_state.modal.coolant) {
    709a:	80 91 8f 07 	lds	r24, 0x078F
    709e:	88 23       	and	r24, r24
    70a0:	19 f0       	breq	.+6      	; 0x70a8 <report_gcode_modes+0x168>
    70a2:	82 30       	cpi	r24, 0x02	; 2
    70a4:	31 f0       	breq	.+12     	; 0x70b2 <report_gcode_modes+0x172>
    70a6:	09 c0       	rjmp	.+18     	; 0x70ba <report_gcode_modes+0x17a>
    case COOLANT_DISABLE : printPgmString(PSTR(" M9")); break;
    70a8:	82 e2       	ldi	r24, 0x22	; 34
    70aa:	93 e0       	ldi	r25, 0x03	; 3
    70ac:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    70b0:	04 c0       	rjmp	.+8      	; 0x70ba <report_gcode_modes+0x17a>
    case COOLANT_FLOOD_ENABLE : printPgmString(PSTR(" M8")); break;
    70b2:	8e e1       	ldi	r24, 0x1E	; 30
    70b4:	93 e0       	ldi	r25, 0x03	; 3
    70b6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    #ifdef ENABLE_M7
      case COOLANT_MIST_ENABLE : printPgmString(PSTR(" M7")); break;
    #endif
  }
  
  printPgmString(PSTR(" T"));
    70ba:	8b e1       	ldi	r24, 0x1B	; 27
    70bc:	93 e0       	ldi	r25, 0x03	; 3
    70be:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  print_uint8_base10(gc_state.tool);
    70c2:	80 91 99 07 	lds	r24, 0x0799
    70c6:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  
  printPgmString(PSTR(" F"));
    70ca:	88 e1       	ldi	r24, 0x18	; 24
    70cc:	93 e0       	ldi	r25, 0x03	; 3
    70ce:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  printFloat_RateValue(gc_state.feed_rate);
    70d2:	60 91 95 07 	lds	r22, 0x0795
    70d6:	70 91 96 07 	lds	r23, 0x0796
    70da:	80 91 97 07 	lds	r24, 0x0797
    70de:	90 91 98 07 	lds	r25, 0x0798
    70e2:	0e 94 18 34 	call	0x6830	; 0x6830 <printFloat_RateValue>
  #ifdef VARIABLE_SPINDLE
    printPgmString(PSTR(" S"));
    printFloat_RateValue(gc_state.spindle_speed);
  #endif

  printPgmString(PSTR("]\r\n"));
    70e6:	84 e1       	ldi	r24, 0x14	; 20
    70e8:	93 e0       	ldi	r25, 0x03	; 3
    70ea:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    70ee:	08 95       	ret

000070f0 <report_startup_line>:
}

// Prints specified startup line
void report_startup_line(uint8_t n, char *line)
{
    70f0:	1f 93       	push	r17
    70f2:	cf 93       	push	r28
    70f4:	df 93       	push	r29
    70f6:	18 2f       	mov	r17, r24
    70f8:	eb 01       	movw	r28, r22
  printPgmString(PSTR("$N")); print_uint8_base10(n);
    70fa:	81 e1       	ldi	r24, 0x11	; 17
    70fc:	93 e0       	ldi	r25, 0x03	; 3
    70fe:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    7102:	81 2f       	mov	r24, r17
    7104:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  printPgmString(PSTR("=")); printString(line);
    7108:	8f e0       	ldi	r24, 0x0F	; 15
    710a:	93 e0       	ldi	r25, 0x03	; 3
    710c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    7110:	ce 01       	movw	r24, r28
    7112:	0e 94 b8 32 	call	0x6570	; 0x6570 <printString>
  printPgmString(PSTR("\r\n"));
    7116:	8c e0       	ldi	r24, 0x0C	; 12
    7118:	93 e0       	ldi	r25, 0x03	; 3
    711a:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
}
    711e:	df 91       	pop	r29
    7120:	cf 91       	pop	r28
    7122:	1f 91       	pop	r17
    7124:	08 95       	ret

00007126 <report_build_info>:


// Prints build info line
void report_build_info(char *line)
{
    7126:	cf 93       	push	r28
    7128:	df 93       	push	r29
    712a:	ec 01       	movw	r28, r24
  printPgmString(PSTR("[" GRBL_VERSION "." GRBL_VERSION_BUILD ":"));
    712c:	83 ef       	ldi	r24, 0xF3	; 243
    712e:	92 e0       	ldi	r25, 0x02	; 2
    7130:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  printString(line);
    7134:	ce 01       	movw	r24, r28
    7136:	0e 94 b8 32 	call	0x6570	; 0x6570 <printString>
  printPgmString(PSTR("]\r\n"));
    713a:	8f ee       	ldi	r24, 0xEF	; 239
    713c:	92 e0       	ldi	r25, 0x02	; 2
    713e:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
}
    7142:	df 91       	pop	r29
    7144:	cf 91       	pop	r28
    7146:	08 95       	ret

00007148 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly, 
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    7148:	bf 92       	push	r11
    714a:	cf 92       	push	r12
    714c:	df 92       	push	r13
    714e:	ef 92       	push	r14
    7150:	ff 92       	push	r15
    7152:	0f 93       	push	r16
    7154:	1f 93       	push	r17
    7156:	cf 93       	push	r28
    7158:	df 93       	push	r29
    715a:	cd b7       	in	r28, 0x3d	; 61
    715c:	de b7       	in	r29, 0x3e	; 62
    715e:	68 97       	sbiw	r28, 0x18	; 24
    7160:	0f b6       	in	r0, 0x3f	; 63
    7162:	f8 94       	cli
    7164:	de bf       	out	0x3e, r29	; 62
    7166:	0f be       	out	0x3f, r0	; 63
    7168:	cd bf       	out	0x3d, r28	; 61
  // the system power on location (0,0,0) and work coordinate position (G54 and G92 applied). Eventually
  // to be added are distance to go on block, processed block id, and feed rate. Also a settings bitmask
  // for a user to select the desired real-time data.
  uint8_t i;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys.position,sizeof(sys.position));
    716a:	8c e0       	ldi	r24, 0x0C	; 12
    716c:	ec e6       	ldi	r30, 0x6C	; 108
    716e:	f7 e0       	ldi	r31, 0x07	; 7
    7170:	de 01       	movw	r26, r28
    7172:	11 96       	adiw	r26, 0x01	; 1
    7174:	01 90       	ld	r0, Z+
    7176:	0d 92       	st	X+, r0
    7178:	8a 95       	dec	r24
    717a:	e1 f7       	brne	.-8      	; 0x7174 <report_realtime_status+0x2c>
  float print_position[N_AXIS];
 
  // Report current machine state
  switch (sys.state) {
    717c:	80 91 68 07 	lds	r24, 0x0768
    7180:	88 30       	cpi	r24, 0x08	; 8
    7182:	c9 f0       	breq	.+50     	; 0x71b6 <report_realtime_status+0x6e>
    7184:	40 f4       	brcc	.+16     	; 0x7196 <report_realtime_status+0x4e>
    7186:	81 30       	cpi	r24, 0x01	; 1
    7188:	29 f1       	breq	.+74     	; 0x71d4 <report_realtime_status+0x8c>
    718a:	80 f0       	brcs	.+32     	; 0x71ac <report_realtime_status+0x64>
    718c:	82 30       	cpi	r24, 0x02	; 2
    718e:	39 f1       	breq	.+78     	; 0x71de <report_realtime_status+0x96>
    7190:	84 30       	cpi	r24, 0x04	; 4
    7192:	d9 f0       	breq	.+54     	; 0x71ca <report_realtime_status+0x82>
    7194:	32 c0       	rjmp	.+100    	; 0x71fa <report_realtime_status+0xb2>
    7196:	80 32       	cpi	r24, 0x20	; 32
    7198:	39 f1       	breq	.+78     	; 0x71e8 <report_realtime_status+0xa0>
    719a:	18 f4       	brcc	.+6      	; 0x71a2 <report_realtime_status+0x5a>
    719c:	80 31       	cpi	r24, 0x10	; 16
    719e:	81 f0       	breq	.+32     	; 0x71c0 <report_realtime_status+0x78>
    71a0:	2c c0       	rjmp	.+88     	; 0x71fa <report_realtime_status+0xb2>
    71a2:	80 34       	cpi	r24, 0x40	; 64
    71a4:	41 f0       	breq	.+16     	; 0x71b6 <report_realtime_status+0x6e>
    71a6:	80 38       	cpi	r24, 0x80	; 128
    71a8:	21 f1       	breq	.+72     	; 0x71f2 <report_realtime_status+0xaa>
    71aa:	27 c0       	rjmp	.+78     	; 0x71fa <report_realtime_status+0xb2>
    case STATE_IDLE: printPgmString(PSTR("<Idle")); break;
    71ac:	89 ee       	ldi	r24, 0xE9	; 233
    71ae:	92 e0       	ldi	r25, 0x02	; 2
    71b0:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    71b4:	22 c0       	rjmp	.+68     	; 0x71fa <report_realtime_status+0xb2>
    case STATE_MOTION_CANCEL: // Report run state.
    case STATE_CYCLE: printPgmString(PSTR("<Run")); break;
    71b6:	84 ee       	ldi	r24, 0xE4	; 228
    71b8:	92 e0       	ldi	r25, 0x02	; 2
    71ba:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    71be:	1d c0       	rjmp	.+58     	; 0x71fa <report_realtime_status+0xb2>
    case STATE_HOLD: printPgmString(PSTR("<Hold")); break;
    71c0:	8e ed       	ldi	r24, 0xDE	; 222
    71c2:	92 e0       	ldi	r25, 0x02	; 2
    71c4:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    71c8:	18 c0       	rjmp	.+48     	; 0x71fa <report_realtime_status+0xb2>
    case STATE_HOMING: printPgmString(PSTR("<Home")); break;
    71ca:	88 ed       	ldi	r24, 0xD8	; 216
    71cc:	92 e0       	ldi	r25, 0x02	; 2
    71ce:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    71d2:	13 c0       	rjmp	.+38     	; 0x71fa <report_realtime_status+0xb2>
    case STATE_ALARM: printPgmString(PSTR("<Alarm")); break;
    71d4:	81 ed       	ldi	r24, 0xD1	; 209
    71d6:	92 e0       	ldi	r25, 0x02	; 2
    71d8:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    71dc:	0e c0       	rjmp	.+28     	; 0x71fa <report_realtime_status+0xb2>
    case STATE_CHECK_MODE: printPgmString(PSTR("<Check")); break;
    71de:	8a ec       	ldi	r24, 0xCA	; 202
    71e0:	92 e0       	ldi	r25, 0x02	; 2
    71e2:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    71e6:	09 c0       	rjmp	.+18     	; 0x71fa <report_realtime_status+0xb2>
    case STATE_SAFETY_DOOR: printPgmString(PSTR("<Door")); break;
    71e8:	84 ec       	ldi	r24, 0xC4	; 196
    71ea:	92 e0       	ldi	r25, 0x02	; 2
    71ec:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    71f0:	04 c0       	rjmp	.+8      	; 0x71fa <report_realtime_status+0xb2>
	case STATE_JOG: printPgmString(PSTR("<Jog")); break;
    71f2:	8f eb       	ldi	r24, 0xBF	; 191
    71f4:	92 e0       	ldi	r25, 0x02	; 2
    71f6:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }
 
  // If reporting a position, convert the current step count (current_position) to millimeters.
  if (bit_istrue(settings.status_report_mask,(BITFLAG_RT_STATUS_MACHINE_POSITION | BITFLAG_RT_STATUS_WORK_POSITION))) {
    71fa:	80 91 33 09 	lds	r24, 0x0933
    71fe:	83 70       	andi	r24, 0x03	; 3
    7200:	39 f0       	breq	.+14     	; 0x7210 <report_realtime_status+0xc8>
    system_convert_array_steps_to_mpos(print_position,current_position);
    7202:	be 01       	movw	r22, r28
    7204:	6f 5f       	subi	r22, 0xFF	; 255
    7206:	7f 4f       	sbci	r23, 0xFF	; 255
    7208:	ce 01       	movw	r24, r28
    720a:	0d 96       	adiw	r24, 0x0d	; 13
    720c:	0e 94 b9 3b 	call	0x7772	; 0x7772 <system_convert_array_steps_to_mpos>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    7210:	80 91 33 09 	lds	r24, 0x0933
    7214:	80 ff       	sbrs	r24, 0
    7216:	1e c0       	rjmp	.+60     	; 0x7254 <report_realtime_status+0x10c>
    printPgmString(PSTR(",MPos:")); 
    7218:	88 eb       	ldi	r24, 0xB8	; 184
    721a:	92 e0       	ldi	r25, 0x02	; 2
    721c:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    7220:	6d 85       	ldd	r22, Y+13	; 0x0d
    7222:	7e 85       	ldd	r23, Y+14	; 0x0e
    7224:	8f 85       	ldd	r24, Y+15	; 0x0f
    7226:	98 89       	ldd	r25, Y+16	; 0x10
    7228:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    722c:	86 eb       	ldi	r24, 0xB6	; 182
    722e:	92 e0       	ldi	r25, 0x02	; 2
    7230:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    7234:	69 89       	ldd	r22, Y+17	; 0x11
    7236:	7a 89       	ldd	r23, Y+18	; 0x12
    7238:	8b 89       	ldd	r24, Y+19	; 0x13
    723a:	9c 89       	ldd	r25, Y+20	; 0x14
    723c:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    7240:	86 eb       	ldi	r24, 0xB6	; 182
    7242:	92 e0       	ldi	r25, 0x02	; 2
    7244:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    7248:	6d 89       	ldd	r22, Y+21	; 0x15
    724a:	7e 89       	ldd	r23, Y+22	; 0x16
    724c:	8f 89       	ldd	r24, Y+23	; 0x17
    724e:	98 8d       	ldd	r25, Y+24	; 0x18
    7250:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    7254:	80 91 33 09 	lds	r24, 0x0933
    7258:	81 ff       	sbrs	r24, 1
    725a:	4c c0       	rjmp	.+152    	; 0x72f4 <report_realtime_status+0x1ac>
    printPgmString(PSTR(",WPos:")); 
    725c:	8f ea       	ldi	r24, 0xAF	; 175
    725e:	92 e0       	ldi	r25, 0x02	; 2
    7260:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    7264:	8e 01       	movw	r16, r28
    7266:	03 5f       	subi	r16, 0xF3	; 243
    7268:	1f 4f       	sbci	r17, 0xFF	; 255
    726a:	0f 2e       	mov	r0, r31
    726c:	fa ea       	ldi	r31, 0xAA	; 170
    726e:	ef 2e       	mov	r14, r31
    7270:	f7 e0       	ldi	r31, 0x07	; 7
    7272:	ff 2e       	mov	r15, r31
    7274:	f0 2d       	mov	r31, r0
    for (i=0; i< N_AXIS; i++) {
    7276:	b1 2c       	mov	r11, r1
      // Apply work coordinate offsets and tool length offset to current position.
      print_position[i] -= gc_state.coord_system[i]+gc_state.coord_offset[i];
    7278:	f7 01       	movw	r30, r14
    727a:	61 91       	ld	r22, Z+
    727c:	71 91       	ld	r23, Z+
    727e:	81 91       	ld	r24, Z+
    7280:	91 91       	ld	r25, Z+
    7282:	7f 01       	movw	r14, r30
    7284:	20 85       	ldd	r18, Z+8	; 0x08
    7286:	31 85       	ldd	r19, Z+9	; 0x09
    7288:	42 85       	ldd	r20, Z+10	; 0x0a
    728a:	53 85       	ldd	r21, Z+11	; 0x0b
    728c:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <__addsf3>
    7290:	9b 01       	movw	r18, r22
    7292:	ac 01       	movw	r20, r24
    7294:	f8 01       	movw	r30, r16
    7296:	60 81       	ld	r22, Z
    7298:	71 81       	ldd	r23, Z+1	; 0x01
    729a:	82 81       	ldd	r24, Z+2	; 0x02
    729c:	93 81       	ldd	r25, Z+3	; 0x03
    729e:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    72a2:	f8 01       	movw	r30, r16
    72a4:	60 83       	st	Z, r22
    72a6:	71 83       	std	Z+1, r23	; 0x01
    72a8:	82 83       	std	Z+2, r24	; 0x02
    72aa:	93 83       	std	Z+3, r25	; 0x03
      if (i == TOOL_LENGTH_OFFSET_AXIS) { print_position[i] -= gc_state.tool_length_offset; }    
    72ac:	f2 e0       	ldi	r31, 0x02	; 2
    72ae:	bf 12       	cpse	r11, r31
    72b0:	12 c0       	rjmp	.+36     	; 0x72d6 <report_realtime_status+0x18e>
    72b2:	20 91 c2 07 	lds	r18, 0x07C2
    72b6:	30 91 c3 07 	lds	r19, 0x07C3
    72ba:	40 91 c4 07 	lds	r20, 0x07C4
    72be:	50 91 c5 07 	lds	r21, 0x07C5
    72c2:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <__subsf3>
    72c6:	f8 01       	movw	r30, r16
    72c8:	60 83       	st	Z, r22
    72ca:	71 83       	std	Z+1, r23	; 0x01
    72cc:	82 83       	std	Z+2, r24	; 0x02
    72ce:	93 83       	std	Z+3, r25	; 0x03
      printFloat_CoordValue(print_position[i]);
    72d0:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
    72d4:	0f c0       	rjmp	.+30     	; 0x72f4 <report_realtime_status+0x1ac>
    72d6:	0e 94 06 34 	call	0x680c	; 0x680c <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    72da:	f1 e0       	ldi	r31, 0x01	; 1
    72dc:	fb 15       	cp	r31, r11
    72de:	20 f0       	brcs	.+8      	; 0x72e8 <report_realtime_status+0x1a0>
    72e0:	8d ea       	ldi	r24, 0xAD	; 173
    72e2:	92 e0       	ldi	r25, 0x02	; 2
    72e4:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printPgmString(PSTR(",WPos:")); 
    for (i=0; i< N_AXIS; i++) {
    72e8:	b3 94       	inc	r11
    72ea:	0c 5f       	subi	r16, 0xFC	; 252
    72ec:	1f 4f       	sbci	r17, 0xFF	; 255
    72ee:	23 e0       	ldi	r18, 0x03	; 3
    72f0:	b2 12       	cpse	r11, r18
    72f2:	c2 cf       	rjmp	.-124    	; 0x7278 <report_realtime_status+0x130>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
        
  // Returns the number of active blocks are in the planner buffer.
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_PLANNER_BUFFER)) {
    72f4:	80 91 33 09 	lds	r24, 0x0933
    72f8:	82 ff       	sbrs	r24, 2
    72fa:	08 c0       	rjmp	.+16     	; 0x730c <report_realtime_status+0x1c4>
    printPgmString(PSTR(",Buf:"));
    72fc:	87 ea       	ldi	r24, 0xA7	; 167
    72fe:	92 e0       	ldi	r25, 0x02	; 2
    7300:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    print_uint8_base10(plan_get_block_buffer_count());
    7304:	0e 94 f8 2d 	call	0x5bf0	; 0x5bf0 <plan_get_block_buffer_count>
    7308:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
  }

  // Report serial read buffer status
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_SERIAL_RX)) {
    730c:	80 91 33 09 	lds	r24, 0x0933
    7310:	83 ff       	sbrs	r24, 3
    7312:	08 c0       	rjmp	.+16     	; 0x7324 <report_realtime_status+0x1dc>
    printPgmString(PSTR(",RX:"));
    7314:	82 ea       	ldi	r24, 0xA2	; 162
    7316:	92 e0       	ldi	r25, 0x02	; 2
    7318:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
    print_uint8_base10(serial_get_rx_buffer_count());
    731c:	0e 94 f8 17 	call	0x2ff0	; 0x2ff0 <serial_get_rx_buffer_count>
    7320:	0e 94 0d 33 	call	0x661a	; 0x661a <print_uint8_base10>
    print_uint8_base2(LIMIT_PIN & LIMIT_MASK);  
    printPgmString(PSTR(",Ctl:"));
    print_uint8_base2(CONTROL_PIN & CONTROL_MASK);
  #endif
  
  printPgmString(PSTR(">\r\n"));
    7324:	8e e9       	ldi	r24, 0x9E	; 158
    7326:	92 e0       	ldi	r25, 0x02	; 2
    7328:	0e 94 c7 32 	call	0x658e	; 0x658e <printPgmString>
}
    732c:	68 96       	adiw	r28, 0x18	; 24
    732e:	0f b6       	in	r0, 0x3f	; 63
    7330:	f8 94       	cli
    7332:	de bf       	out	0x3e, r29	; 62
    7334:	0f be       	out	0x3f, r0	; 63
    7336:	cd bf       	out	0x3d, r28	; 61
    7338:	df 91       	pop	r29
    733a:	cf 91       	pop	r28
    733c:	1f 91       	pop	r17
    733e:	0f 91       	pop	r16
    7340:	ff 90       	pop	r15
    7342:	ef 90       	pop	r14
    7344:	df 90       	pop	r13
    7346:	cf 90       	pop	r12
    7348:	bf 90       	pop	r11
    734a:	08 95       	ret

0000734c <system_init>:
#include "grbl.h"


void system_init() 
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    734c:	87 b1       	in	r24, 0x07	; 7
    734e:	88 7f       	andi	r24, 0xF8	; 248
    7350:	87 b9       	out	0x07, r24	; 7
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    7352:	88 b1       	in	r24, 0x08	; 8
    7354:	87 60       	ori	r24, 0x07	; 7
    7356:	88 b9       	out	0x08, r24	; 8
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    7358:	ed e6       	ldi	r30, 0x6D	; 109
    735a:	f0 e0       	ldi	r31, 0x00	; 0
    735c:	80 81       	ld	r24, Z
    735e:	87 60       	ori	r24, 0x07	; 7
    7360:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    7362:	e8 e6       	ldi	r30, 0x68	; 104
    7364:	f0 e0       	ldi	r31, 0x00	; 0
    7366:	80 81       	ld	r24, Z
    7368:	84 60       	ori	r24, 0x04	; 4
    736a:	80 83       	st	Z, r24
    736c:	08 95       	ret

0000736e <__vector_6>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when 
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect) 
{
    736e:	1f 92       	push	r1
    7370:	0f 92       	push	r0
    7372:	0f b6       	in	r0, 0x3f	; 63
    7374:	0f 92       	push	r0
    7376:	11 24       	eor	r1, r1
    7378:	2f 93       	push	r18
    737a:	3f 93       	push	r19
    737c:	4f 93       	push	r20
    737e:	5f 93       	push	r21
    7380:	6f 93       	push	r22
    7382:	7f 93       	push	r23
    7384:	8f 93       	push	r24
    7386:	9f 93       	push	r25
    7388:	af 93       	push	r26
    738a:	bf 93       	push	r27
    738c:	ef 93       	push	r30
    738e:	ff 93       	push	r31
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    7390:	86 b1       	in	r24, 0x06	; 6
  #ifndef INVERT_CONTROL_PIN
    pin ^= CONTROL_MASK;
    7392:	80 95       	com	r24
    7394:	87 70       	andi	r24, 0x07	; 7
  #endif
  // Enter only if any CONTROL pin is detected as active.
  if (pin) { 
    7396:	a9 f0       	breq	.+42     	; 0x73c2 <__vector_6+0x54>
    if (bit_istrue(pin,bit(RESET_BIT))) {
    7398:	80 ff       	sbrs	r24, 0
    739a:	03 c0       	rjmp	.+6      	; 0x73a2 <__vector_6+0x34>
      mc_reset();
    739c:	0e 94 b2 0c 	call	0x1964	; 0x1964 <mc_reset>
    73a0:	10 c0       	rjmp	.+32     	; 0x73c2 <__vector_6+0x54>
    } else if (bit_istrue(pin,bit(CYCLE_START_BIT))) {
    73a2:	98 2f       	mov	r25, r24
    73a4:	94 70       	andi	r25, 0x04	; 4
    73a6:	31 f0       	breq	.+12     	; 0x73b4 <__vector_6+0x46>
      bit_true(sys.rt_exec_state, EXEC_CYCLE_START);
    73a8:	ea e6       	ldi	r30, 0x6A	; 106
    73aa:	f7 e0       	ldi	r31, 0x07	; 7
    73ac:	80 81       	ld	r24, Z
    73ae:	82 60       	ori	r24, 0x02	; 2
    73b0:	80 83       	st	Z, r24
    73b2:	07 c0       	rjmp	.+14     	; 0x73c2 <__vector_6+0x54>
    #ifndef ENABLE_SAFETY_DOOR_INPUT_PIN
      } else if (bit_istrue(pin,bit(FEED_HOLD_BIT))) {
    73b4:	81 ff       	sbrs	r24, 1
    73b6:	05 c0       	rjmp	.+10     	; 0x73c2 <__vector_6+0x54>
        bit_true(sys.rt_exec_state, EXEC_FEED_HOLD); 
    73b8:	ea e6       	ldi	r30, 0x6A	; 106
    73ba:	f7 e0       	ldi	r31, 0x07	; 7
    73bc:	80 81       	ld	r24, Z
    73be:	88 60       	ori	r24, 0x08	; 8
    73c0:	80 83       	st	Z, r24
      } else if (bit_istrue(pin,bit(SAFETY_DOOR_BIT))) {
        bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
    #endif
    } 
  }
}
    73c2:	ff 91       	pop	r31
    73c4:	ef 91       	pop	r30
    73c6:	bf 91       	pop	r27
    73c8:	af 91       	pop	r26
    73ca:	9f 91       	pop	r25
    73cc:	8f 91       	pop	r24
    73ce:	7f 91       	pop	r23
    73d0:	6f 91       	pop	r22
    73d2:	5f 91       	pop	r21
    73d4:	4f 91       	pop	r20
    73d6:	3f 91       	pop	r19
    73d8:	2f 91       	pop	r18
    73da:	0f 90       	pop	r0
    73dc:	0f be       	out	0x3f, r0	; 63
    73de:	0f 90       	pop	r0
    73e0:	1f 90       	pop	r1
    73e2:	18 95       	reti

000073e4 <system_check_safety_door_ajar>:
      return(bit_isfalse(CONTROL_PIN,bit(SAFETY_DOOR_BIT)));
    #endif
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
  #endif
}
    73e4:	80 e0       	ldi	r24, 0x00	; 0
    73e6:	08 95       	ret

000073e8 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
    73e8:	1f 93       	push	r17
    73ea:	cf 93       	push	r28
    73ec:	df 93       	push	r29
    73ee:	ec 01       	movw	r28, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    73f0:	10 e0       	ldi	r17, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    73f2:	be 01       	movw	r22, r28
    73f4:	81 2f       	mov	r24, r17
    73f6:	0e 94 09 27 	call	0x4e12	; 0x4e12 <settings_read_startup_line>
    73fa:	81 11       	cpse	r24, r1
    73fc:	04 c0       	rjmp	.+8      	; 0x7406 <system_execute_startup+0x1e>
      report_status_message(STATUS_SETTING_READ_FAIL);
    73fe:	87 e0       	ldi	r24, 0x07	; 7
    7400:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
    7404:	0b c0       	rjmp	.+22     	; 0x741c <system_execute_startup+0x34>
    } else {
      if (line[0] != 0) {
    7406:	88 81       	ld	r24, Y
    7408:	88 23       	and	r24, r24
    740a:	41 f0       	breq	.+16     	; 0x741c <system_execute_startup+0x34>
        printString(line); // Echo startup line to indicate execution.
    740c:	ce 01       	movw	r24, r28
    740e:	0e 94 b8 32 	call	0x6570	; 0x6570 <printString>
        report_status_message(gc_execute_line(line));
    7412:	ce 01       	movw	r24, r28
    7414:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <gc_execute_line>
    7418:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    741c:	1f 5f       	subi	r17, 0xFF	; 255
    741e:	12 30       	cpi	r17, 0x02	; 2
    7420:	41 f7       	brne	.-48     	; 0x73f2 <system_execute_startup+0xa>
        printString(line); // Echo startup line to indicate execution.
        report_status_message(gc_execute_line(line));
      }
    } 
  }  
}
    7422:	df 91       	pop	r29
    7424:	cf 91       	pop	r28
    7426:	1f 91       	pop	r17
    7428:	08 95       	ret

0000742a <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle, 
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
    742a:	8f 92       	push	r8
    742c:	9f 92       	push	r9
    742e:	af 92       	push	r10
    7430:	bf 92       	push	r11
    7432:	cf 92       	push	r12
    7434:	df 92       	push	r13
    7436:	ef 92       	push	r14
    7438:	ff 92       	push	r15
    743a:	1f 93       	push	r17
    743c:	cf 93       	push	r28
    743e:	df 93       	push	r29
    7440:	cd b7       	in	r28, 0x3d	; 61
    7442:	de b7       	in	r29, 0x3e	; 62
    7444:	29 97       	sbiw	r28, 0x09	; 9
    7446:	0f b6       	in	r0, 0x3f	; 63
    7448:	f8 94       	cli
    744a:	de bf       	out	0x3e, r29	; 62
    744c:	0f be       	out	0x3f, r0	; 63
    744e:	cd bf       	out	0x3d, r28	; 61
    7450:	7c 01       	movw	r14, r24
  uint8_t char_counter = 1; 
    7452:	81 e0       	ldi	r24, 0x01	; 1
    7454:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    7456:	f7 01       	movw	r30, r14
    7458:	81 81       	ldd	r24, Z+1	; 0x01
    745a:	83 34       	cpi	r24, 0x43	; 67
    745c:	41 f1       	breq	.+80     	; 0x74ae <system_execute_line+0x84>
    745e:	28 f4       	brcc	.+10     	; 0x746a <system_execute_line+0x40>
    7460:	88 23       	and	r24, r24
    7462:	41 f0       	breq	.+16     	; 0x7474 <system_execute_line+0x4a>
    7464:	84 32       	cpi	r24, 0x24	; 36
    7466:	51 f0       	breq	.+20     	; 0x747c <system_execute_line+0x52>
    7468:	4f c0       	rjmp	.+158    	; 0x7508 <system_execute_line+0xde>
    746a:	87 34       	cpi	r24, 0x47	; 71
    746c:	b1 f0       	breq	.+44     	; 0x749a <system_execute_line+0x70>
    746e:	88 35       	cpi	r24, 0x58	; 88
    7470:	c9 f1       	breq	.+114    	; 0x74e4 <system_execute_line+0xba>
    7472:	4a c0       	rjmp	.+148    	; 0x7508 <system_execute_line+0xde>
    case 0 : report_grbl_help(); break;
    7474:	0e 94 3c 35 	call	0x6a78	; 0x6a78 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7478:	80 e0       	ldi	r24, 0x00	; 0
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    747a:	4d c1       	rjmp	.+666    	; 0x7716 <system_execute_line+0x2ec>
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    747c:	82 e0       	ldi	r24, 0x02	; 2
    747e:	89 83       	std	Y+1, r24	; 0x01
    7480:	f7 01       	movw	r30, r14
    7482:	82 81       	ldd	r24, Z+2	; 0x02
    7484:	81 11       	cpse	r24, r1
    7486:	21 c1       	rjmp	.+578    	; 0x76ca <system_execute_line+0x2a0>
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7488:	80 91 68 07 	lds	r24, 0x0768
    748c:	88 71       	andi	r24, 0x18	; 24
    748e:	09 f0       	breq	.+2      	; 0x7492 <system_execute_line+0x68>
    7490:	1e c1       	rjmp	.+572    	; 0x76ce <system_execute_line+0x2a4>
      else { report_grbl_settings(); }
    7492:	0e 94 41 35 	call	0x6a82	; 0x6a82 <report_grbl_settings>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7496:	80 e0       	ldi	r24, 0x00	; 0
    case 0 : report_grbl_help(); break;
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
      else { report_grbl_settings(); }
      break;
    7498:	3e c1       	rjmp	.+636    	; 0x7716 <system_execute_line+0x2ec>
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    749a:	82 e0       	ldi	r24, 0x02	; 2
    749c:	89 83       	std	Y+1, r24	; 0x01
    749e:	f7 01       	movw	r30, r14
    74a0:	82 81       	ldd	r24, Z+2	; 0x02
    74a2:	81 11       	cpse	r24, r1
    74a4:	16 c1       	rjmp	.+556    	; 0x76d2 <system_execute_line+0x2a8>
      else { report_gcode_modes(); }
    74a6:	0e 94 a0 37 	call	0x6f40	; 0x6f40 <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74aa:	80 e0       	ldi	r24, 0x00	; 0
      break;
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      else { report_gcode_modes(); }
      break;   
    74ac:	34 c1       	rjmp	.+616    	; 0x7716 <system_execute_line+0x2ec>
    case 'C' : // Set check g-code mode [IDLE/CHECK]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    74ae:	82 e0       	ldi	r24, 0x02	; 2
    74b0:	89 83       	std	Y+1, r24	; 0x01
    74b2:	f7 01       	movw	r30, r14
    74b4:	82 81       	ldd	r24, Z+2	; 0x02
    74b6:	81 11       	cpse	r24, r1
    74b8:	0e c1       	rjmp	.+540    	; 0x76d6 <system_execute_line+0x2ac>
      // Perform reset when toggling off. Check g-code mode should only work if Grbl
      // is idle and ready, regardless of alarm locks. This is mainly to keep things
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
    74ba:	80 91 68 07 	lds	r24, 0x0768
    74be:	82 30       	cpi	r24, 0x02	; 2
    74c0:	39 f4       	brne	.+14     	; 0x74d0 <system_execute_line+0xa6>
        mc_reset(); 
    74c2:	0e 94 b2 0c 	call	0x1964	; 0x1964 <mc_reset>
        report_feedback_message(MESSAGE_DISABLED);
    74c6:	85 e0       	ldi	r24, 0x05	; 5
    74c8:	0e 94 00 35 	call	0x6a00	; 0x6a00 <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74cc:	80 e0       	ldi	r24, 0x00	; 0
    74ce:	23 c1       	rjmp	.+582    	; 0x7716 <system_execute_line+0x2ec>
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
        mc_reset(); 
        report_feedback_message(MESSAGE_DISABLED);
      } else {
        if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    74d0:	81 11       	cpse	r24, r1
    74d2:	03 c1       	rjmp	.+518    	; 0x76da <system_execute_line+0x2b0>
        sys.state = STATE_CHECK_MODE;
    74d4:	82 e0       	ldi	r24, 0x02	; 2
    74d6:	80 93 68 07 	sts	0x0768, r24
        report_feedback_message(MESSAGE_ENABLED);
    74da:	84 e0       	ldi	r24, 0x04	; 4
    74dc:	0e 94 00 35 	call	0x6a00	; 0x6a00 <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74e0:	80 e0       	ldi	r24, 0x00	; 0
    74e2:	19 c1       	rjmp	.+562    	; 0x7716 <system_execute_line+0x2ec>
        sys.state = STATE_CHECK_MODE;
        report_feedback_message(MESSAGE_ENABLED);
      }
      break; 
    case 'X' : // Disable alarm lock [ALARM]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    74e4:	82 e0       	ldi	r24, 0x02	; 2
    74e6:	89 83       	std	Y+1, r24	; 0x01
    74e8:	f7 01       	movw	r30, r14
    74ea:	82 81       	ldd	r24, Z+2	; 0x02
    74ec:	81 11       	cpse	r24, r1
    74ee:	f7 c0       	rjmp	.+494    	; 0x76de <system_execute_line+0x2b4>
      if (sys.state == STATE_ALARM) { 
    74f0:	80 91 68 07 	lds	r24, 0x0768
    74f4:	81 30       	cpi	r24, 0x01	; 1
    74f6:	09 f0       	breq	.+2      	; 0x74fa <system_execute_line+0xd0>
    74f8:	f4 c0       	rjmp	.+488    	; 0x76e2 <system_execute_line+0x2b8>
        report_feedback_message(MESSAGE_ALARM_UNLOCK);
    74fa:	83 e0       	ldi	r24, 0x03	; 3
    74fc:	0e 94 00 35 	call	0x6a00	; 0x6a00 <report_feedback_message>
        sys.state = STATE_IDLE;
    7500:	10 92 68 07 	sts	0x0768, r1
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7504:	80 e0       	ldi	r24, 0x00	; 0
    7506:	07 c1       	rjmp	.+526    	; 0x7716 <system_execute_line+0x2ec>
      // handled by the planner. It would be possible for the jog subprogram to insert blocks into the
      // block buffer without having the planner plan them. It would need to manage de/ac-celerations 
      // on its own carefully. This approach could be effective and possibly size/memory efficient.        
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    7508:	90 91 68 07 	lds	r25, 0x0768
    750c:	92 30       	cpi	r25, 0x02	; 2
    750e:	08 f0       	brcs	.+2      	; 0x7512 <system_execute_line+0xe8>
    7510:	ea c0       	rjmp	.+468    	; 0x76e6 <system_execute_line+0x2bc>
      switch( line[char_counter] ) {
    7512:	88 34       	cpi	r24, 0x48	; 72
    7514:	a1 f0       	breq	.+40     	; 0x753e <system_execute_line+0x114>
    7516:	18 f4       	brcc	.+6      	; 0x751e <system_execute_line+0xf4>
    7518:	83 32       	cpi	r24, 0x23	; 35
    751a:	39 f0       	breq	.+14     	; 0x752a <system_execute_line+0x100>
    751c:	66 c0       	rjmp	.+204    	; 0x75ea <system_execute_line+0x1c0>
    751e:	89 34       	cpi	r24, 0x49	; 73
    7520:	21 f1       	breq	.+72     	; 0x756a <system_execute_line+0x140>
    7522:	8e 34       	cpi	r24, 0x4E	; 78
    7524:	09 f4       	brne	.+2      	; 0x7528 <system_execute_line+0xfe>
    7526:	44 c0       	rjmp	.+136    	; 0x75b0 <system_execute_line+0x186>
    7528:	60 c0       	rjmp	.+192    	; 0x75ea <system_execute_line+0x1c0>
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    752a:	82 e0       	ldi	r24, 0x02	; 2
    752c:	89 83       	std	Y+1, r24	; 0x01
    752e:	f7 01       	movw	r30, r14
    7530:	82 81       	ldd	r24, Z+2	; 0x02
    7532:	81 11       	cpse	r24, r1
    7534:	da c0       	rjmp	.+436    	; 0x76ea <system_execute_line+0x2c0>
          else { report_ngc_parameters(); }
    7536:	0e 94 05 37 	call	0x6e0a	; 0x6e0a <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    753a:	80 e0       	ldi	r24, 0x00	; 0
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;          
    753c:	ec c0       	rjmp	.+472    	; 0x7716 <system_execute_line+0x2ec>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
    753e:	80 91 3c 09 	lds	r24, 0x093C
    7542:	84 ff       	sbrs	r24, 4
    7544:	d4 c0       	rjmp	.+424    	; 0x76ee <system_execute_line+0x2c4>
            sys.state = STATE_HOMING; // Set system state variable
    7546:	84 e0       	ldi	r24, 0x04	; 4
    7548:	80 93 68 07 	sts	0x0768, r24
              bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
              protocol_execute_realtime(); // Enter safety door mode.
            }
            
            
            mc_homing_cycle(); 
    754c:	0e 94 17 0c 	call	0x182e	; 0x182e <mc_homing_cycle>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
    7550:	80 91 67 07 	lds	r24, 0x0767
    7554:	81 11       	cpse	r24, r1
    7556:	cd c0       	rjmp	.+410    	; 0x76f2 <system_execute_line+0x2c8>
              sys.state = STATE_IDLE; // Set to IDLE when complete.
    7558:	10 92 68 07 	sts	0x0768, r1
              st_go_idle(); // Set steppers to the settings idle state before returning.
    755c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <st_go_idle>
              system_execute_startup(line); 
    7560:	c7 01       	movw	r24, r14
    7562:	0e 94 f4 39 	call	0x73e8	; 0x73e8 <system_execute_startup>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7566:	80 e0       	ldi	r24, 0x00	; 0
    7568:	d6 c0       	rjmp	.+428    	; 0x7716 <system_execute_line+0x2ec>
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
    756a:	82 e0       	ldi	r24, 0x02	; 2
    756c:	89 83       	std	Y+1, r24	; 0x01
    756e:	f7 01       	movw	r30, r14
    7570:	82 81       	ldd	r24, Z+2	; 0x02
    7572:	81 11       	cpse	r24, r1
    7574:	08 c0       	rjmp	.+16     	; 0x7586 <system_execute_line+0x15c>
            settings_read_build_info(line);
    7576:	c7 01       	movw	r24, r14
    7578:	0e 94 26 27 	call	0x4e4c	; 0x4e4c <settings_read_build_info>
            report_build_info(line);
    757c:	c7 01       	movw	r24, r14
    757e:	0e 94 93 38 	call	0x7126	; 0x7126 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7582:	80 e0       	ldi	r24, 0x00	; 0
    7584:	c8 c0       	rjmp	.+400    	; 0x7716 <system_execute_line+0x2ec>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7586:	8d 33       	cpi	r24, 0x3D	; 61
    7588:	09 f0       	breq	.+2      	; 0x758c <system_execute_line+0x162>
    758a:	b5 c0       	rjmp	.+362    	; 0x76f6 <system_execute_line+0x2cc>
    758c:	83 e0       	ldi	r24, 0x03	; 3
            helper_var = char_counter; // Set helper variable as counter to start of user info line.
            do {
              line[char_counter-helper_var] = line[char_counter];
    758e:	f7 01       	movw	r30, r14
    7590:	e8 0f       	add	r30, r24
    7592:	f1 1d       	adc	r31, r1
    7594:	90 81       	ld	r25, Z
    7596:	df 01       	movw	r26, r30
    7598:	13 97       	sbiw	r26, 0x03	; 3
    759a:	9c 93       	st	X, r25
            } while (line[char_counter++] != 0);
    759c:	8f 5f       	subi	r24, 0xFF	; 255
    759e:	90 81       	ld	r25, Z
    75a0:	91 11       	cpse	r25, r1
    75a2:	f5 cf       	rjmp	.-22     	; 0x758e <system_execute_line+0x164>
    75a4:	89 83       	std	Y+1, r24	; 0x01
            settings_store_build_info(line);
    75a6:	c7 01       	movw	r24, r14
    75a8:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    75ac:	80 e0       	ldi	r24, 0x00	; 0
    75ae:	b3 c0       	rjmp	.+358    	; 0x7716 <system_execute_line+0x2ec>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break;                 
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    75b0:	82 e0       	ldi	r24, 0x02	; 2
    75b2:	89 83       	std	Y+1, r24	; 0x01
    75b4:	f7 01       	movw	r30, r14
    75b6:	82 81       	ldd	r24, Z+2	; 0x02
    75b8:	81 11       	cpse	r24, r1
    75ba:	13 c0       	rjmp	.+38     	; 0x75e2 <system_execute_line+0x1b8>
    75bc:	10 e0       	ldi	r17, 0x00	; 0
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    75be:	b7 01       	movw	r22, r14
    75c0:	81 2f       	mov	r24, r17
    75c2:	0e 94 09 27 	call	0x4e12	; 0x4e12 <settings_read_startup_line>
    75c6:	81 11       	cpse	r24, r1
    75c8:	04 c0       	rjmp	.+8      	; 0x75d2 <system_execute_line+0x1a8>
                report_status_message(STATUS_SETTING_READ_FAIL);
    75ca:	87 e0       	ldi	r24, 0x07	; 7
    75cc:	0e 94 62 34 	call	0x68c4	; 0x68c4 <report_status_message>
    75d0:	04 c0       	rjmp	.+8      	; 0x75da <system_execute_line+0x1b0>
              } else {
                report_startup_line(helper_var,line);
    75d2:	b7 01       	movw	r22, r14
    75d4:	81 2f       	mov	r24, r17
    75d6:	0e 94 78 38 	call	0x70f0	; 0x70f0 <report_startup_line>
            settings_store_build_info(line);
          }
          break;                 
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    75da:	1f 5f       	subi	r17, 0xFF	; 255
    75dc:	12 30       	cpi	r17, 0x02	; 2
    75de:	79 f7       	brne	.-34     	; 0x75be <system_execute_line+0x194>
    75e0:	8c c0       	rjmp	.+280    	; 0x76fa <system_execute_line+0x2d0>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    75e2:	91 11       	cpse	r25, r1
    75e4:	8c c0       	rjmp	.+280    	; 0x76fe <system_execute_line+0x2d4>
            helper_var = true;  // Set helper_var to flag storing method. 
    75e6:	11 e0       	ldi	r17, 0x01	; 1
    75e8:	01 c0       	rjmp	.+2      	; 0x75ec <system_execute_line+0x1c2>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
    75ea:	10 e0       	ldi	r17, 0x00	; 0
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    75ec:	ae 01       	movw	r20, r28
    75ee:	4e 5f       	subi	r20, 0xFE	; 254
    75f0:	5f 4f       	sbci	r21, 0xFF	; 255
    75f2:	be 01       	movw	r22, r28
    75f4:	6f 5f       	subi	r22, 0xFF	; 255
    75f6:	7f 4f       	sbci	r23, 0xFF	; 255
    75f8:	c7 01       	movw	r24, r14
    75fa:	0e 94 0c 2e 	call	0x5c18	; 0x5c18 <read_float>
    75fe:	88 23       	and	r24, r24
    7600:	09 f4       	brne	.+2      	; 0x7604 <system_execute_line+0x1da>
    7602:	7f c0       	rjmp	.+254    	; 0x7702 <system_execute_line+0x2d8>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7604:	89 81       	ldd	r24, Y+1	; 0x01
    7606:	21 e0       	ldi	r18, 0x01	; 1
    7608:	28 0f       	add	r18, r24
    760a:	29 83       	std	Y+1, r18	; 0x01
    760c:	f7 01       	movw	r30, r14
    760e:	e8 0f       	add	r30, r24
    7610:	f1 1d       	adc	r31, r1
    7612:	80 81       	ld	r24, Z
    7614:	8d 33       	cpi	r24, 0x3D	; 61
    7616:	09 f0       	breq	.+2      	; 0x761a <system_execute_line+0x1f0>
    7618:	76 c0       	rjmp	.+236    	; 0x7706 <system_execute_line+0x2dc>
          if (helper_var) { // Store startup line
    761a:	11 23       	and	r17, r17
    761c:	39 f1       	breq	.+78     	; 0x766c <system_execute_line+0x242>
    761e:	42 2f       	mov	r20, r18
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    7620:	30 e0       	ldi	r19, 0x00	; 0
    7622:	84 2f       	mov	r24, r20
    7624:	90 e0       	ldi	r25, 0x00	; 0
    7626:	f7 01       	movw	r30, r14
    7628:	e8 0f       	add	r30, r24
    762a:	f9 1f       	adc	r31, r25
    762c:	50 81       	ld	r21, Z
    762e:	82 1b       	sub	r24, r18
    7630:	93 0b       	sbc	r25, r19
    7632:	d7 01       	movw	r26, r14
    7634:	a8 0f       	add	r26, r24
    7636:	b9 1f       	adc	r27, r25
    7638:	5c 93       	st	X, r21
            } while (line[char_counter++] != 0);
    763a:	4f 5f       	subi	r20, 0xFF	; 255
    763c:	80 81       	ld	r24, Z
    763e:	81 11       	cpse	r24, r1
    7640:	f0 cf       	rjmp	.-32     	; 0x7622 <system_execute_line+0x1f8>
    7642:	49 83       	std	Y+1, r20	; 0x01
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    7644:	c7 01       	movw	r24, r14
    7646:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <gc_execute_line>
    764a:	18 2f       	mov	r17, r24
            if (helper_var) { return(helper_var); }
    764c:	81 11       	cpse	r24, r1
    764e:	5d c0       	rjmp	.+186    	; 0x770a <system_execute_line+0x2e0>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    7650:	6a 81       	ldd	r22, Y+2	; 0x02
    7652:	7b 81       	ldd	r23, Y+3	; 0x03
    7654:	8c 81       	ldd	r24, Y+4	; 0x04
    7656:	9d 81       	ldd	r25, Y+5	; 0x05
    7658:	0e 94 b9 3f 	call	0x7f72	; 0x7f72 <trunc>
    765c:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
    7660:	86 2f       	mov	r24, r22
              settings_store_startup_line(helper_var,line);
    7662:	b7 01       	movw	r22, r14
    7664:	0e 94 e7 25 	call	0x4bce	; 0x4bce <settings_store_startup_line>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7668:	81 2f       	mov	r24, r17
    766a:	55 c0       	rjmp	.+170    	; 0x7716 <system_execute_line+0x2ec>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    766c:	ae 01       	movw	r20, r28
    766e:	4a 5f       	subi	r20, 0xFA	; 250
    7670:	5f 4f       	sbci	r21, 0xFF	; 255
    7672:	be 01       	movw	r22, r28
    7674:	6f 5f       	subi	r22, 0xFF	; 255
    7676:	7f 4f       	sbci	r23, 0xFF	; 255
    7678:	c7 01       	movw	r24, r14
    767a:	0e 94 0c 2e 	call	0x5c18	; 0x5c18 <read_float>
    767e:	88 23       	and	r24, r24
    7680:	09 f4       	brne	.+2      	; 0x7684 <system_execute_line+0x25a>
    7682:	44 c0       	rjmp	.+136    	; 0x770c <system_execute_line+0x2e2>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7684:	89 81       	ldd	r24, Y+1	; 0x01
    7686:	f7 01       	movw	r30, r14
    7688:	e8 0f       	add	r30, r24
    768a:	f1 1d       	adc	r31, r1
    768c:	80 81       	ld	r24, Z
    768e:	81 11       	cpse	r24, r1
    7690:	3f c0       	rjmp	.+126    	; 0x7710 <system_execute_line+0x2e6>
    7692:	ca 80       	ldd	r12, Y+2	; 0x02
    7694:	db 80       	ldd	r13, Y+3	; 0x03
    7696:	ec 80       	ldd	r14, Y+4	; 0x04
    7698:	fd 80       	ldd	r15, Y+5	; 0x05
    769a:	20 e0       	ldi	r18, 0x00	; 0
    769c:	30 e0       	ldi	r19, 0x00	; 0
    769e:	4f e7       	ldi	r20, 0x7F	; 127
    76a0:	53 e4       	ldi	r21, 0x43	; 67
    76a2:	c7 01       	movw	r24, r14
    76a4:	b6 01       	movw	r22, r12
    76a6:	0e 94 b0 3e 	call	0x7d60	; 0x7d60 <__gesf2>
    76aa:	18 16       	cp	r1, r24
    76ac:	9c f1       	brlt	.+102    	; 0x7714 <system_execute_line+0x2ea>
            return(settings_store_global_setting((uint8_t)parameter, value));
    76ae:	8e 80       	ldd	r8, Y+6	; 0x06
    76b0:	9f 80       	ldd	r9, Y+7	; 0x07
    76b2:	a8 84       	ldd	r10, Y+8	; 0x08
    76b4:	b9 84       	ldd	r11, Y+9	; 0x09
    76b6:	c7 01       	movw	r24, r14
    76b8:	b6 01       	movw	r22, r12
    76ba:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <__fixunssfsi>
    76be:	86 2f       	mov	r24, r22
    76c0:	b5 01       	movw	r22, r10
    76c2:	a4 01       	movw	r20, r8
    76c4:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <settings_store_global_setting>
    76c8:	26 c0       	rjmp	.+76     	; 0x7716 <system_execute_line+0x2ec>
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76ca:	83 e0       	ldi	r24, 0x03	; 3
    76cc:	24 c0       	rjmp	.+72     	; 0x7716 <system_execute_line+0x2ec>
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    76ce:	88 e0       	ldi	r24, 0x08	; 8
    76d0:	22 c0       	rjmp	.+68     	; 0x7716 <system_execute_line+0x2ec>
      else { report_grbl_settings(); }
      break;
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76d2:	83 e0       	ldi	r24, 0x03	; 3
    76d4:	20 c0       	rjmp	.+64     	; 0x7716 <system_execute_line+0x2ec>
      else { report_gcode_modes(); }
      break;   
    case 'C' : // Set check g-code mode [IDLE/CHECK]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76d6:	83 e0       	ldi	r24, 0x03	; 3
    76d8:	1e c0       	rjmp	.+60     	; 0x7716 <system_execute_line+0x2ec>
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
        mc_reset(); 
        report_feedback_message(MESSAGE_DISABLED);
      } else {
        if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    76da:	88 e0       	ldi	r24, 0x08	; 8
    76dc:	1c c0       	rjmp	.+56     	; 0x7716 <system_execute_line+0x2ec>
        sys.state = STATE_CHECK_MODE;
        report_feedback_message(MESSAGE_ENABLED);
      }
      break; 
    case 'X' : // Disable alarm lock [ALARM]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76de:	83 e0       	ldi	r24, 0x03	; 3
    76e0:	1a c0       	rjmp	.+52     	; 0x7716 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76e2:	80 e0       	ldi	r24, 0x00	; 0
    76e4:	18 c0       	rjmp	.+48     	; 0x7716 <system_execute_line+0x2ec>
      // handled by the planner. It would be possible for the jog subprogram to insert blocks into the
      // block buffer without having the planner plan them. It would need to manage de/ac-celerations 
      // on its own carefully. This approach could be effective and possibly size/memory efficient.        
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    76e6:	88 e0       	ldi	r24, 0x08	; 8
    76e8:	16 c0       	rjmp	.+44     	; 0x7716 <system_execute_line+0x2ec>
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76ea:	83 e0       	ldi	r24, 0x03	; 3
    76ec:	14 c0       	rjmp	.+40     	; 0x7716 <system_execute_line+0x2ec>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
              sys.state = STATE_IDLE; // Set to IDLE when complete.
              st_go_idle(); // Set steppers to the settings idle state before returning.
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
    76ee:	85 e0       	ldi	r24, 0x05	; 5
    76f0:	12 c0       	rjmp	.+36     	; 0x7716 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76f2:	80 e0       	ldi	r24, 0x00	; 0
    76f4:	10 c0       	rjmp	.+32     	; 0x7716 <system_execute_line+0x2ec>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    76f6:	83 e0       	ldi	r24, 0x03	; 3
    76f8:	0e c0       	rjmp	.+28     	; 0x7716 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76fa:	80 e0       	ldi	r24, 0x00	; 0
    76fc:	0c c0       	rjmp	.+24     	; 0x7716 <system_execute_line+0x2ec>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    76fe:	88 e0       	ldi	r24, 0x08	; 8
    7700:	0a c0       	rjmp	.+20     	; 0x7716 <system_execute_line+0x2ec>
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7702:	82 e0       	ldi	r24, 0x02	; 2
    7704:	08 c0       	rjmp	.+16     	; 0x7716 <system_execute_line+0x2ec>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7706:	83 e0       	ldi	r24, 0x03	; 3
    7708:	06 c0       	rjmp	.+12     	; 0x7716 <system_execute_line+0x2ec>
    770a:	05 c0       	rjmp	.+10     	; 0x7716 <system_execute_line+0x2ec>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    770c:	82 e0       	ldi	r24, 0x02	; 2
    770e:	03 c0       	rjmp	.+6      	; 0x7716 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7710:	83 e0       	ldi	r24, 0x03	; 3
    7712:	01 c0       	rjmp	.+2      	; 0x7716 <system_execute_line+0x2ec>
    7714:	83 e0       	ldi	r24, 0x03	; 3
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    7716:	29 96       	adiw	r28, 0x09	; 9
    7718:	0f b6       	in	r0, 0x3f	; 63
    771a:	f8 94       	cli
    771c:	de bf       	out	0x3e, r29	; 62
    771e:	0f be       	out	0x3f, r0	; 63
    7720:	cd bf       	out	0x3d, r28	; 61
    7722:	df 91       	pop	r29
    7724:	cf 91       	pop	r28
    7726:	1f 91       	pop	r17
    7728:	ff 90       	pop	r15
    772a:	ef 90       	pop	r14
    772c:	df 90       	pop	r13
    772e:	cf 90       	pop	r12
    7730:	bf 90       	pop	r11
    7732:	af 90       	pop	r10
    7734:	9f 90       	pop	r9
    7736:	8f 90       	pop	r8
    7738:	08 95       	ret

0000773a <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    773a:	cf 93       	push	r28
    773c:	df 93       	push	r29
      pos = 0.5*((steps[A_MOTOR] + steps[B_MOTOR])/settings.steps_per_mm[idx]);
    } else { // (idx==B_MOTOR)
      pos = 0.5*((steps[A_MOTOR] - steps[B_MOTOR])/settings.steps_per_mm[idx]);
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    773e:	c6 2f       	mov	r28, r22
    7740:	d0 e0       	ldi	r29, 0x00	; 0
    7742:	cc 0f       	add	r28, r28
    7744:	dd 1f       	adc	r29, r29
    7746:	cc 0f       	add	r28, r28
    7748:	dd 1f       	adc	r29, r29
    774a:	8c 0f       	add	r24, r28
    774c:	9d 1f       	adc	r25, r29
    774e:	fc 01       	movw	r30, r24
    7750:	60 81       	ld	r22, Z
    7752:	71 81       	ldd	r23, Z+1	; 0x01
    7754:	82 81       	ldd	r24, Z+2	; 0x02
    7756:	93 81       	ldd	r25, Z+3	; 0x03
    7758:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <__floatsisf>
    775c:	c1 50       	subi	r28, 0x01	; 1
    775e:	d7 4f       	sbci	r29, 0xF7	; 247
    7760:	28 81       	ld	r18, Y
    7762:	39 81       	ldd	r19, Y+1	; 0x01
    7764:	4a 81       	ldd	r20, Y+2	; 0x02
    7766:	5b 81       	ldd	r21, Y+3	; 0x03
    7768:	0e 94 b4 3c 	call	0x7968	; 0x7968 <__divsf3>
  #endif
  return(pos);
}
    776c:	df 91       	pop	r29
    776e:	cf 91       	pop	r28
    7770:	08 95       	ret

00007772 <system_convert_array_steps_to_mpos>:
  

void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    7772:	ff 92       	push	r15
    7774:	0f 93       	push	r16
    7776:	1f 93       	push	r17
    7778:	cf 93       	push	r28
    777a:	df 93       	push	r29
    777c:	8b 01       	movw	r16, r22
    777e:	ec 01       	movw	r28, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7780:	f1 2c       	mov	r15, r1
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    7782:	6f 2d       	mov	r22, r15
    7784:	c8 01       	movw	r24, r16
    7786:	0e 94 9d 3b 	call	0x773a	; 0x773a <system_convert_axis_steps_to_mpos>
    778a:	69 93       	st	Y+, r22
    778c:	79 93       	st	Y+, r23
    778e:	89 93       	st	Y+, r24
    7790:	99 93       	st	Y+, r25
  

void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7792:	f3 94       	inc	r15
    7794:	83 e0       	ldi	r24, 0x03	; 3
    7796:	f8 12       	cpse	r15, r24
    7798:	f4 cf       	rjmp	.-24     	; 0x7782 <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    779a:	df 91       	pop	r29
    779c:	cf 91       	pop	r28
    779e:	1f 91       	pop	r17
    77a0:	0f 91       	pop	r16
    77a2:	ff 90       	pop	r15
    77a4:	08 95       	ret

000077a6 <__subsf3>:
    77a6:	50 58       	subi	r21, 0x80	; 128

000077a8 <__addsf3>:
    77a8:	bb 27       	eor	r27, r27
    77aa:	aa 27       	eor	r26, r26
    77ac:	0e d0       	rcall	.+28     	; 0x77ca <__addsf3x>
    77ae:	76 c2       	rjmp	.+1260   	; 0x7c9c <__fp_round>
    77b0:	3f d2       	rcall	.+1150   	; 0x7c30 <__fp_pscA>
    77b2:	30 f0       	brcs	.+12     	; 0x77c0 <__addsf3+0x18>
    77b4:	44 d2       	rcall	.+1160   	; 0x7c3e <__fp_pscB>
    77b6:	20 f0       	brcs	.+8      	; 0x77c0 <__addsf3+0x18>
    77b8:	31 f4       	brne	.+12     	; 0x77c6 <__addsf3+0x1e>
    77ba:	9f 3f       	cpi	r25, 0xFF	; 255
    77bc:	11 f4       	brne	.+4      	; 0x77c2 <__addsf3+0x1a>
    77be:	1e f4       	brtc	.+6      	; 0x77c6 <__addsf3+0x1e>
    77c0:	0f c2       	rjmp	.+1054   	; 0x7be0 <__fp_nan>
    77c2:	0e f4       	brtc	.+2      	; 0x77c6 <__addsf3+0x1e>
    77c4:	e0 95       	com	r30
    77c6:	e7 fb       	bst	r30, 7
    77c8:	dc c1       	rjmp	.+952    	; 0x7b82 <__fp_inf>

000077ca <__addsf3x>:
    77ca:	e9 2f       	mov	r30, r25
    77cc:	89 d2       	rcall	.+1298   	; 0x7ce0 <__fp_split3>
    77ce:	80 f3       	brcs	.-32     	; 0x77b0 <__addsf3+0x8>
    77d0:	ba 17       	cp	r27, r26
    77d2:	62 07       	cpc	r22, r18
    77d4:	73 07       	cpc	r23, r19
    77d6:	84 07       	cpc	r24, r20
    77d8:	95 07       	cpc	r25, r21
    77da:	18 f0       	brcs	.+6      	; 0x77e2 <__addsf3x+0x18>
    77dc:	71 f4       	brne	.+28     	; 0x77fa <__addsf3x+0x30>
    77de:	9e f5       	brtc	.+102    	; 0x7846 <__addsf3x+0x7c>
    77e0:	b8 c2       	rjmp	.+1392   	; 0x7d52 <__fp_zero>
    77e2:	0e f4       	brtc	.+2      	; 0x77e6 <__addsf3x+0x1c>
    77e4:	e0 95       	com	r30
    77e6:	0b 2e       	mov	r0, r27
    77e8:	ba 2f       	mov	r27, r26
    77ea:	a0 2d       	mov	r26, r0
    77ec:	0b 01       	movw	r0, r22
    77ee:	b9 01       	movw	r22, r18
    77f0:	90 01       	movw	r18, r0
    77f2:	0c 01       	movw	r0, r24
    77f4:	ca 01       	movw	r24, r20
    77f6:	a0 01       	movw	r20, r0
    77f8:	11 24       	eor	r1, r1
    77fa:	ff 27       	eor	r31, r31
    77fc:	59 1b       	sub	r21, r25
    77fe:	99 f0       	breq	.+38     	; 0x7826 <__addsf3x+0x5c>
    7800:	59 3f       	cpi	r21, 0xF9	; 249
    7802:	50 f4       	brcc	.+20     	; 0x7818 <__addsf3x+0x4e>
    7804:	50 3e       	cpi	r21, 0xE0	; 224
    7806:	68 f1       	brcs	.+90     	; 0x7862 <__addsf3x+0x98>
    7808:	1a 16       	cp	r1, r26
    780a:	f0 40       	sbci	r31, 0x00	; 0
    780c:	a2 2f       	mov	r26, r18
    780e:	23 2f       	mov	r18, r19
    7810:	34 2f       	mov	r19, r20
    7812:	44 27       	eor	r20, r20
    7814:	58 5f       	subi	r21, 0xF8	; 248
    7816:	f3 cf       	rjmp	.-26     	; 0x77fe <__addsf3x+0x34>
    7818:	46 95       	lsr	r20
    781a:	37 95       	ror	r19
    781c:	27 95       	ror	r18
    781e:	a7 95       	ror	r26
    7820:	f0 40       	sbci	r31, 0x00	; 0
    7822:	53 95       	inc	r21
    7824:	c9 f7       	brne	.-14     	; 0x7818 <__addsf3x+0x4e>
    7826:	7e f4       	brtc	.+30     	; 0x7846 <__addsf3x+0x7c>
    7828:	1f 16       	cp	r1, r31
    782a:	ba 0b       	sbc	r27, r26
    782c:	62 0b       	sbc	r22, r18
    782e:	73 0b       	sbc	r23, r19
    7830:	84 0b       	sbc	r24, r20
    7832:	ba f0       	brmi	.+46     	; 0x7862 <__addsf3x+0x98>
    7834:	91 50       	subi	r25, 0x01	; 1
    7836:	a1 f0       	breq	.+40     	; 0x7860 <__addsf3x+0x96>
    7838:	ff 0f       	add	r31, r31
    783a:	bb 1f       	adc	r27, r27
    783c:	66 1f       	adc	r22, r22
    783e:	77 1f       	adc	r23, r23
    7840:	88 1f       	adc	r24, r24
    7842:	c2 f7       	brpl	.-16     	; 0x7834 <__addsf3x+0x6a>
    7844:	0e c0       	rjmp	.+28     	; 0x7862 <__addsf3x+0x98>
    7846:	ba 0f       	add	r27, r26
    7848:	62 1f       	adc	r22, r18
    784a:	73 1f       	adc	r23, r19
    784c:	84 1f       	adc	r24, r20
    784e:	48 f4       	brcc	.+18     	; 0x7862 <__addsf3x+0x98>
    7850:	87 95       	ror	r24
    7852:	77 95       	ror	r23
    7854:	67 95       	ror	r22
    7856:	b7 95       	ror	r27
    7858:	f7 95       	ror	r31
    785a:	9e 3f       	cpi	r25, 0xFE	; 254
    785c:	08 f0       	brcs	.+2      	; 0x7860 <__addsf3x+0x96>
    785e:	b3 cf       	rjmp	.-154    	; 0x77c6 <__addsf3+0x1e>
    7860:	93 95       	inc	r25
    7862:	88 0f       	add	r24, r24
    7864:	08 f0       	brcs	.+2      	; 0x7868 <__addsf3x+0x9e>
    7866:	99 27       	eor	r25, r25
    7868:	ee 0f       	add	r30, r30
    786a:	97 95       	ror	r25
    786c:	87 95       	ror	r24
    786e:	08 95       	ret
    7870:	df d1       	rcall	.+958    	; 0x7c30 <__fp_pscA>
    7872:	58 f0       	brcs	.+22     	; 0x788a <__addsf3x+0xc0>
    7874:	80 e8       	ldi	r24, 0x80	; 128
    7876:	91 e0       	ldi	r25, 0x01	; 1
    7878:	09 f4       	brne	.+2      	; 0x787c <__addsf3x+0xb2>
    787a:	9e ef       	ldi	r25, 0xFE	; 254
    787c:	e0 d1       	rcall	.+960    	; 0x7c3e <__fp_pscB>
    787e:	28 f0       	brcs	.+10     	; 0x788a <__addsf3x+0xc0>
    7880:	40 e8       	ldi	r20, 0x80	; 128
    7882:	51 e0       	ldi	r21, 0x01	; 1
    7884:	59 f4       	brne	.+22     	; 0x789c <atan2+0xe>
    7886:	5e ef       	ldi	r21, 0xFE	; 254
    7888:	09 c0       	rjmp	.+18     	; 0x789c <atan2+0xe>
    788a:	aa c1       	rjmp	.+852    	; 0x7be0 <__fp_nan>
    788c:	62 c2       	rjmp	.+1220   	; 0x7d52 <__fp_zero>

0000788e <atan2>:
    788e:	e9 2f       	mov	r30, r25
    7890:	e0 78       	andi	r30, 0x80	; 128
    7892:	26 d2       	rcall	.+1100   	; 0x7ce0 <__fp_split3>
    7894:	68 f3       	brcs	.-38     	; 0x7870 <__addsf3x+0xa6>
    7896:	09 2e       	mov	r0, r25
    7898:	05 2a       	or	r0, r21
    789a:	c1 f3       	breq	.-16     	; 0x788c <__addsf3x+0xc2>
    789c:	26 17       	cp	r18, r22
    789e:	37 07       	cpc	r19, r23
    78a0:	48 07       	cpc	r20, r24
    78a2:	59 07       	cpc	r21, r25
    78a4:	38 f0       	brcs	.+14     	; 0x78b4 <atan2+0x26>
    78a6:	0e 2e       	mov	r0, r30
    78a8:	07 f8       	bld	r0, 7
    78aa:	e0 25       	eor	r30, r0
    78ac:	69 f0       	breq	.+26     	; 0x78c8 <atan2+0x3a>
    78ae:	e0 25       	eor	r30, r0
    78b0:	e0 64       	ori	r30, 0x40	; 64
    78b2:	0a c0       	rjmp	.+20     	; 0x78c8 <atan2+0x3a>
    78b4:	ef 63       	ori	r30, 0x3F	; 63
    78b6:	07 f8       	bld	r0, 7
    78b8:	00 94       	com	r0
    78ba:	07 fa       	bst	r0, 7
    78bc:	db 01       	movw	r26, r22
    78be:	b9 01       	movw	r22, r18
    78c0:	9d 01       	movw	r18, r26
    78c2:	dc 01       	movw	r26, r24
    78c4:	ca 01       	movw	r24, r20
    78c6:	ad 01       	movw	r20, r26
    78c8:	ef 93       	push	r30
    78ca:	5d d0       	rcall	.+186    	; 0x7986 <__divsf3_pse>
    78cc:	e7 d1       	rcall	.+974    	; 0x7c9c <__fp_round>
    78ce:	0a d0       	rcall	.+20     	; 0x78e4 <atan>
    78d0:	5f 91       	pop	r21
    78d2:	55 23       	and	r21, r21
    78d4:	31 f0       	breq	.+12     	; 0x78e2 <atan2+0x54>
    78d6:	2b ed       	ldi	r18, 0xDB	; 219
    78d8:	3f e0       	ldi	r19, 0x0F	; 15
    78da:	49 e4       	ldi	r20, 0x49	; 73
    78dc:	50 fd       	sbrc	r21, 0
    78de:	49 ec       	ldi	r20, 0xC9	; 201
    78e0:	63 cf       	rjmp	.-314    	; 0x77a8 <__addsf3>
    78e2:	08 95       	ret

000078e4 <atan>:
    78e4:	df 93       	push	r29
    78e6:	dd 27       	eor	r29, r29
    78e8:	b9 2f       	mov	r27, r25
    78ea:	bf 77       	andi	r27, 0x7F	; 127
    78ec:	40 e8       	ldi	r20, 0x80	; 128
    78ee:	5f e3       	ldi	r21, 0x3F	; 63
    78f0:	16 16       	cp	r1, r22
    78f2:	17 06       	cpc	r1, r23
    78f4:	48 07       	cpc	r20, r24
    78f6:	5b 07       	cpc	r21, r27
    78f8:	10 f4       	brcc	.+4      	; 0x78fe <atan+0x1a>
    78fa:	d9 2f       	mov	r29, r25
    78fc:	35 d2       	rcall	.+1130   	; 0x7d68 <inverse>
    78fe:	9f 93       	push	r25
    7900:	8f 93       	push	r24
    7902:	7f 93       	push	r23
    7904:	6f 93       	push	r22
    7906:	32 d3       	rcall	.+1636   	; 0x7f6c <square>
    7908:	e4 e3       	ldi	r30, 0x34	; 52
    790a:	f2 e0       	ldi	r31, 0x02	; 2
    790c:	6c d1       	rcall	.+728    	; 0x7be6 <__fp_powser>
    790e:	c6 d1       	rcall	.+908    	; 0x7c9c <__fp_round>
    7910:	2f 91       	pop	r18
    7912:	3f 91       	pop	r19
    7914:	4f 91       	pop	r20
    7916:	5f 91       	pop	r21
    7918:	6a d2       	rcall	.+1236   	; 0x7dee <__mulsf3x>
    791a:	dd 23       	and	r29, r29
    791c:	49 f0       	breq	.+18     	; 0x7930 <atan+0x4c>
    791e:	90 58       	subi	r25, 0x80	; 128
    7920:	a2 ea       	ldi	r26, 0xA2	; 162
    7922:	2a ed       	ldi	r18, 0xDA	; 218
    7924:	3f e0       	ldi	r19, 0x0F	; 15
    7926:	49 ec       	ldi	r20, 0xC9	; 201
    7928:	5f e3       	ldi	r21, 0x3F	; 63
    792a:	d0 78       	andi	r29, 0x80	; 128
    792c:	5d 27       	eor	r21, r29
    792e:	4d df       	rcall	.-358    	; 0x77ca <__addsf3x>
    7930:	df 91       	pop	r29
    7932:	b4 c1       	rjmp	.+872    	; 0x7c9c <__fp_round>

00007934 <ceil>:
    7934:	f7 d1       	rcall	.+1006   	; 0x7d24 <__fp_trunc>
    7936:	80 f0       	brcs	.+32     	; 0x7958 <ceil+0x24>
    7938:	9f 37       	cpi	r25, 0x7F	; 127
    793a:	40 f4       	brcc	.+16     	; 0x794c <ceil+0x18>
    793c:	91 11       	cpse	r25, r1
    793e:	0e f4       	brtc	.+2      	; 0x7942 <ceil+0xe>
    7940:	09 c2       	rjmp	.+1042   	; 0x7d54 <__fp_szero>
    7942:	60 e0       	ldi	r22, 0x00	; 0
    7944:	70 e0       	ldi	r23, 0x00	; 0
    7946:	80 e8       	ldi	r24, 0x80	; 128
    7948:	9f e3       	ldi	r25, 0x3F	; 63
    794a:	08 95       	ret
    794c:	26 f0       	brts	.+8      	; 0x7956 <ceil+0x22>
    794e:	1b 16       	cp	r1, r27
    7950:	61 1d       	adc	r22, r1
    7952:	71 1d       	adc	r23, r1
    7954:	81 1d       	adc	r24, r1
    7956:	1b c1       	rjmp	.+566    	; 0x7b8e <__fp_mintl>
    7958:	35 c1       	rjmp	.+618    	; 0x7bc4 <__fp_mpack>

0000795a <__cmpsf2>:
    795a:	ef d0       	rcall	.+478    	; 0x7b3a <__fp_cmp>
    795c:	08 f4       	brcc	.+2      	; 0x7960 <__cmpsf2+0x6>
    795e:	81 e0       	ldi	r24, 0x01	; 1
    7960:	08 95       	ret

00007962 <cos>:
    7962:	75 d1       	rcall	.+746    	; 0x7c4e <__fp_rempio2>
    7964:	e3 95       	inc	r30
    7966:	ab c1       	rjmp	.+854    	; 0x7cbe <__fp_sinus>

00007968 <__divsf3>:
    7968:	0c d0       	rcall	.+24     	; 0x7982 <__divsf3x>
    796a:	98 c1       	rjmp	.+816    	; 0x7c9c <__fp_round>
    796c:	68 d1       	rcall	.+720    	; 0x7c3e <__fp_pscB>
    796e:	40 f0       	brcs	.+16     	; 0x7980 <__divsf3+0x18>
    7970:	5f d1       	rcall	.+702    	; 0x7c30 <__fp_pscA>
    7972:	30 f0       	brcs	.+12     	; 0x7980 <__divsf3+0x18>
    7974:	21 f4       	brne	.+8      	; 0x797e <__divsf3+0x16>
    7976:	5f 3f       	cpi	r21, 0xFF	; 255
    7978:	19 f0       	breq	.+6      	; 0x7980 <__divsf3+0x18>
    797a:	03 c1       	rjmp	.+518    	; 0x7b82 <__fp_inf>
    797c:	51 11       	cpse	r21, r1
    797e:	ea c1       	rjmp	.+980    	; 0x7d54 <__fp_szero>
    7980:	2f c1       	rjmp	.+606    	; 0x7be0 <__fp_nan>

00007982 <__divsf3x>:
    7982:	ae d1       	rcall	.+860    	; 0x7ce0 <__fp_split3>
    7984:	98 f3       	brcs	.-26     	; 0x796c <__divsf3+0x4>

00007986 <__divsf3_pse>:
    7986:	99 23       	and	r25, r25
    7988:	c9 f3       	breq	.-14     	; 0x797c <__divsf3+0x14>
    798a:	55 23       	and	r21, r21
    798c:	b1 f3       	breq	.-20     	; 0x797a <__divsf3+0x12>
    798e:	95 1b       	sub	r25, r21
    7990:	55 0b       	sbc	r21, r21
    7992:	bb 27       	eor	r27, r27
    7994:	aa 27       	eor	r26, r26
    7996:	62 17       	cp	r22, r18
    7998:	73 07       	cpc	r23, r19
    799a:	84 07       	cpc	r24, r20
    799c:	38 f0       	brcs	.+14     	; 0x79ac <__divsf3_pse+0x26>
    799e:	9f 5f       	subi	r25, 0xFF	; 255
    79a0:	5f 4f       	sbci	r21, 0xFF	; 255
    79a2:	22 0f       	add	r18, r18
    79a4:	33 1f       	adc	r19, r19
    79a6:	44 1f       	adc	r20, r20
    79a8:	aa 1f       	adc	r26, r26
    79aa:	a9 f3       	breq	.-22     	; 0x7996 <__divsf3_pse+0x10>
    79ac:	33 d0       	rcall	.+102    	; 0x7a14 <__divsf3_pse+0x8e>
    79ae:	0e 2e       	mov	r0, r30
    79b0:	3a f0       	brmi	.+14     	; 0x79c0 <__divsf3_pse+0x3a>
    79b2:	e0 e8       	ldi	r30, 0x80	; 128
    79b4:	30 d0       	rcall	.+96     	; 0x7a16 <__divsf3_pse+0x90>
    79b6:	91 50       	subi	r25, 0x01	; 1
    79b8:	50 40       	sbci	r21, 0x00	; 0
    79ba:	e6 95       	lsr	r30
    79bc:	00 1c       	adc	r0, r0
    79be:	ca f7       	brpl	.-14     	; 0x79b2 <__divsf3_pse+0x2c>
    79c0:	29 d0       	rcall	.+82     	; 0x7a14 <__divsf3_pse+0x8e>
    79c2:	fe 2f       	mov	r31, r30
    79c4:	27 d0       	rcall	.+78     	; 0x7a14 <__divsf3_pse+0x8e>
    79c6:	66 0f       	add	r22, r22
    79c8:	77 1f       	adc	r23, r23
    79ca:	88 1f       	adc	r24, r24
    79cc:	bb 1f       	adc	r27, r27
    79ce:	26 17       	cp	r18, r22
    79d0:	37 07       	cpc	r19, r23
    79d2:	48 07       	cpc	r20, r24
    79d4:	ab 07       	cpc	r26, r27
    79d6:	b0 e8       	ldi	r27, 0x80	; 128
    79d8:	09 f0       	breq	.+2      	; 0x79dc <__divsf3_pse+0x56>
    79da:	bb 0b       	sbc	r27, r27
    79dc:	80 2d       	mov	r24, r0
    79de:	bf 01       	movw	r22, r30
    79e0:	ff 27       	eor	r31, r31
    79e2:	93 58       	subi	r25, 0x83	; 131
    79e4:	5f 4f       	sbci	r21, 0xFF	; 255
    79e6:	2a f0       	brmi	.+10     	; 0x79f2 <__divsf3_pse+0x6c>
    79e8:	9e 3f       	cpi	r25, 0xFE	; 254
    79ea:	51 05       	cpc	r21, r1
    79ec:	68 f0       	brcs	.+26     	; 0x7a08 <__divsf3_pse+0x82>
    79ee:	c9 c0       	rjmp	.+402    	; 0x7b82 <__fp_inf>
    79f0:	b1 c1       	rjmp	.+866    	; 0x7d54 <__fp_szero>
    79f2:	5f 3f       	cpi	r21, 0xFF	; 255
    79f4:	ec f3       	brlt	.-6      	; 0x79f0 <__divsf3_pse+0x6a>
    79f6:	98 3e       	cpi	r25, 0xE8	; 232
    79f8:	dc f3       	brlt	.-10     	; 0x79f0 <__divsf3_pse+0x6a>
    79fa:	86 95       	lsr	r24
    79fc:	77 95       	ror	r23
    79fe:	67 95       	ror	r22
    7a00:	b7 95       	ror	r27
    7a02:	f7 95       	ror	r31
    7a04:	9f 5f       	subi	r25, 0xFF	; 255
    7a06:	c9 f7       	brne	.-14     	; 0x79fa <__divsf3_pse+0x74>
    7a08:	88 0f       	add	r24, r24
    7a0a:	91 1d       	adc	r25, r1
    7a0c:	96 95       	lsr	r25
    7a0e:	87 95       	ror	r24
    7a10:	97 f9       	bld	r25, 7
    7a12:	08 95       	ret
    7a14:	e1 e0       	ldi	r30, 0x01	; 1
    7a16:	66 0f       	add	r22, r22
    7a18:	77 1f       	adc	r23, r23
    7a1a:	88 1f       	adc	r24, r24
    7a1c:	bb 1f       	adc	r27, r27
    7a1e:	62 17       	cp	r22, r18
    7a20:	73 07       	cpc	r23, r19
    7a22:	84 07       	cpc	r24, r20
    7a24:	ba 07       	cpc	r27, r26
    7a26:	20 f0       	brcs	.+8      	; 0x7a30 <__divsf3_pse+0xaa>
    7a28:	62 1b       	sub	r22, r18
    7a2a:	73 0b       	sbc	r23, r19
    7a2c:	84 0b       	sbc	r24, r20
    7a2e:	ba 0b       	sbc	r27, r26
    7a30:	ee 1f       	adc	r30, r30
    7a32:	88 f7       	brcc	.-30     	; 0x7a16 <__divsf3_pse+0x90>
    7a34:	e0 95       	com	r30
    7a36:	08 95       	ret

00007a38 <__fixsfsi>:
    7a38:	04 d0       	rcall	.+8      	; 0x7a42 <__fixunssfsi>
    7a3a:	68 94       	set
    7a3c:	b1 11       	cpse	r27, r1
    7a3e:	8a c1       	rjmp	.+788    	; 0x7d54 <__fp_szero>
    7a40:	08 95       	ret

00007a42 <__fixunssfsi>:
    7a42:	56 d1       	rcall	.+684    	; 0x7cf0 <__fp_splitA>
    7a44:	88 f0       	brcs	.+34     	; 0x7a68 <__fixunssfsi+0x26>
    7a46:	9f 57       	subi	r25, 0x7F	; 127
    7a48:	90 f0       	brcs	.+36     	; 0x7a6e <__fixunssfsi+0x2c>
    7a4a:	b9 2f       	mov	r27, r25
    7a4c:	99 27       	eor	r25, r25
    7a4e:	b7 51       	subi	r27, 0x17	; 23
    7a50:	a0 f0       	brcs	.+40     	; 0x7a7a <__fixunssfsi+0x38>
    7a52:	d1 f0       	breq	.+52     	; 0x7a88 <__fixunssfsi+0x46>
    7a54:	66 0f       	add	r22, r22
    7a56:	77 1f       	adc	r23, r23
    7a58:	88 1f       	adc	r24, r24
    7a5a:	99 1f       	adc	r25, r25
    7a5c:	1a f0       	brmi	.+6      	; 0x7a64 <__fixunssfsi+0x22>
    7a5e:	ba 95       	dec	r27
    7a60:	c9 f7       	brne	.-14     	; 0x7a54 <__fixunssfsi+0x12>
    7a62:	12 c0       	rjmp	.+36     	; 0x7a88 <__fixunssfsi+0x46>
    7a64:	b1 30       	cpi	r27, 0x01	; 1
    7a66:	81 f0       	breq	.+32     	; 0x7a88 <__fixunssfsi+0x46>
    7a68:	74 d1       	rcall	.+744    	; 0x7d52 <__fp_zero>
    7a6a:	b1 e0       	ldi	r27, 0x01	; 1
    7a6c:	08 95       	ret
    7a6e:	71 c1       	rjmp	.+738    	; 0x7d52 <__fp_zero>
    7a70:	67 2f       	mov	r22, r23
    7a72:	78 2f       	mov	r23, r24
    7a74:	88 27       	eor	r24, r24
    7a76:	b8 5f       	subi	r27, 0xF8	; 248
    7a78:	39 f0       	breq	.+14     	; 0x7a88 <__fixunssfsi+0x46>
    7a7a:	b9 3f       	cpi	r27, 0xF9	; 249
    7a7c:	cc f3       	brlt	.-14     	; 0x7a70 <__fixunssfsi+0x2e>
    7a7e:	86 95       	lsr	r24
    7a80:	77 95       	ror	r23
    7a82:	67 95       	ror	r22
    7a84:	b3 95       	inc	r27
    7a86:	d9 f7       	brne	.-10     	; 0x7a7e <__fixunssfsi+0x3c>
    7a88:	3e f4       	brtc	.+14     	; 0x7a98 <__fixunssfsi+0x56>
    7a8a:	90 95       	com	r25
    7a8c:	80 95       	com	r24
    7a8e:	70 95       	com	r23
    7a90:	61 95       	neg	r22
    7a92:	7f 4f       	sbci	r23, 0xFF	; 255
    7a94:	8f 4f       	sbci	r24, 0xFF	; 255
    7a96:	9f 4f       	sbci	r25, 0xFF	; 255
    7a98:	08 95       	ret

00007a9a <__floatunsisf>:
    7a9a:	e8 94       	clt
    7a9c:	09 c0       	rjmp	.+18     	; 0x7ab0 <__floatsisf+0x12>

00007a9e <__floatsisf>:
    7a9e:	97 fb       	bst	r25, 7
    7aa0:	3e f4       	brtc	.+14     	; 0x7ab0 <__floatsisf+0x12>
    7aa2:	90 95       	com	r25
    7aa4:	80 95       	com	r24
    7aa6:	70 95       	com	r23
    7aa8:	61 95       	neg	r22
    7aaa:	7f 4f       	sbci	r23, 0xFF	; 255
    7aac:	8f 4f       	sbci	r24, 0xFF	; 255
    7aae:	9f 4f       	sbci	r25, 0xFF	; 255
    7ab0:	99 23       	and	r25, r25
    7ab2:	a9 f0       	breq	.+42     	; 0x7ade <__floatsisf+0x40>
    7ab4:	f9 2f       	mov	r31, r25
    7ab6:	96 e9       	ldi	r25, 0x96	; 150
    7ab8:	bb 27       	eor	r27, r27
    7aba:	93 95       	inc	r25
    7abc:	f6 95       	lsr	r31
    7abe:	87 95       	ror	r24
    7ac0:	77 95       	ror	r23
    7ac2:	67 95       	ror	r22
    7ac4:	b7 95       	ror	r27
    7ac6:	f1 11       	cpse	r31, r1
    7ac8:	f8 cf       	rjmp	.-16     	; 0x7aba <__floatsisf+0x1c>
    7aca:	fa f4       	brpl	.+62     	; 0x7b0a <__floatsisf+0x6c>
    7acc:	bb 0f       	add	r27, r27
    7ace:	11 f4       	brne	.+4      	; 0x7ad4 <__floatsisf+0x36>
    7ad0:	60 ff       	sbrs	r22, 0
    7ad2:	1b c0       	rjmp	.+54     	; 0x7b0a <__floatsisf+0x6c>
    7ad4:	6f 5f       	subi	r22, 0xFF	; 255
    7ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    7ad8:	8f 4f       	sbci	r24, 0xFF	; 255
    7ada:	9f 4f       	sbci	r25, 0xFF	; 255
    7adc:	16 c0       	rjmp	.+44     	; 0x7b0a <__floatsisf+0x6c>
    7ade:	88 23       	and	r24, r24
    7ae0:	11 f0       	breq	.+4      	; 0x7ae6 <__floatsisf+0x48>
    7ae2:	96 e9       	ldi	r25, 0x96	; 150
    7ae4:	11 c0       	rjmp	.+34     	; 0x7b08 <__floatsisf+0x6a>
    7ae6:	77 23       	and	r23, r23
    7ae8:	21 f0       	breq	.+8      	; 0x7af2 <__floatsisf+0x54>
    7aea:	9e e8       	ldi	r25, 0x8E	; 142
    7aec:	87 2f       	mov	r24, r23
    7aee:	76 2f       	mov	r23, r22
    7af0:	05 c0       	rjmp	.+10     	; 0x7afc <__floatsisf+0x5e>
    7af2:	66 23       	and	r22, r22
    7af4:	71 f0       	breq	.+28     	; 0x7b12 <__floatsisf+0x74>
    7af6:	96 e8       	ldi	r25, 0x86	; 134
    7af8:	86 2f       	mov	r24, r22
    7afa:	70 e0       	ldi	r23, 0x00	; 0
    7afc:	60 e0       	ldi	r22, 0x00	; 0
    7afe:	2a f0       	brmi	.+10     	; 0x7b0a <__floatsisf+0x6c>
    7b00:	9a 95       	dec	r25
    7b02:	66 0f       	add	r22, r22
    7b04:	77 1f       	adc	r23, r23
    7b06:	88 1f       	adc	r24, r24
    7b08:	da f7       	brpl	.-10     	; 0x7b00 <__floatsisf+0x62>
    7b0a:	88 0f       	add	r24, r24
    7b0c:	96 95       	lsr	r25
    7b0e:	87 95       	ror	r24
    7b10:	97 f9       	bld	r25, 7
    7b12:	08 95       	ret

00007b14 <floor>:
    7b14:	07 d1       	rcall	.+526    	; 0x7d24 <__fp_trunc>
    7b16:	80 f0       	brcs	.+32     	; 0x7b38 <floor+0x24>
    7b18:	9f 37       	cpi	r25, 0x7F	; 127
    7b1a:	40 f4       	brcc	.+16     	; 0x7b2c <floor+0x18>
    7b1c:	91 11       	cpse	r25, r1
    7b1e:	0e f0       	brts	.+2      	; 0x7b22 <floor+0xe>
    7b20:	19 c1       	rjmp	.+562    	; 0x7d54 <__fp_szero>
    7b22:	60 e0       	ldi	r22, 0x00	; 0
    7b24:	70 e0       	ldi	r23, 0x00	; 0
    7b26:	80 e8       	ldi	r24, 0x80	; 128
    7b28:	9f eb       	ldi	r25, 0xBF	; 191
    7b2a:	08 95       	ret
    7b2c:	26 f4       	brtc	.+8      	; 0x7b36 <floor+0x22>
    7b2e:	1b 16       	cp	r1, r27
    7b30:	61 1d       	adc	r22, r1
    7b32:	71 1d       	adc	r23, r1
    7b34:	81 1d       	adc	r24, r1
    7b36:	2b c0       	rjmp	.+86     	; 0x7b8e <__fp_mintl>
    7b38:	45 c0       	rjmp	.+138    	; 0x7bc4 <__fp_mpack>

00007b3a <__fp_cmp>:
    7b3a:	99 0f       	add	r25, r25
    7b3c:	00 08       	sbc	r0, r0
    7b3e:	55 0f       	add	r21, r21
    7b40:	aa 0b       	sbc	r26, r26
    7b42:	e0 e8       	ldi	r30, 0x80	; 128
    7b44:	fe ef       	ldi	r31, 0xFE	; 254
    7b46:	16 16       	cp	r1, r22
    7b48:	17 06       	cpc	r1, r23
    7b4a:	e8 07       	cpc	r30, r24
    7b4c:	f9 07       	cpc	r31, r25
    7b4e:	c0 f0       	brcs	.+48     	; 0x7b80 <__fp_cmp+0x46>
    7b50:	12 16       	cp	r1, r18
    7b52:	13 06       	cpc	r1, r19
    7b54:	e4 07       	cpc	r30, r20
    7b56:	f5 07       	cpc	r31, r21
    7b58:	98 f0       	brcs	.+38     	; 0x7b80 <__fp_cmp+0x46>
    7b5a:	62 1b       	sub	r22, r18
    7b5c:	73 0b       	sbc	r23, r19
    7b5e:	84 0b       	sbc	r24, r20
    7b60:	95 0b       	sbc	r25, r21
    7b62:	39 f4       	brne	.+14     	; 0x7b72 <__fp_cmp+0x38>
    7b64:	0a 26       	eor	r0, r26
    7b66:	61 f0       	breq	.+24     	; 0x7b80 <__fp_cmp+0x46>
    7b68:	23 2b       	or	r18, r19
    7b6a:	24 2b       	or	r18, r20
    7b6c:	25 2b       	or	r18, r21
    7b6e:	21 f4       	brne	.+8      	; 0x7b78 <__fp_cmp+0x3e>
    7b70:	08 95       	ret
    7b72:	0a 26       	eor	r0, r26
    7b74:	09 f4       	brne	.+2      	; 0x7b78 <__fp_cmp+0x3e>
    7b76:	a1 40       	sbci	r26, 0x01	; 1
    7b78:	a6 95       	lsr	r26
    7b7a:	8f ef       	ldi	r24, 0xFF	; 255
    7b7c:	81 1d       	adc	r24, r1
    7b7e:	81 1d       	adc	r24, r1
    7b80:	08 95       	ret

00007b82 <__fp_inf>:
    7b82:	97 f9       	bld	r25, 7
    7b84:	9f 67       	ori	r25, 0x7F	; 127
    7b86:	80 e8       	ldi	r24, 0x80	; 128
    7b88:	70 e0       	ldi	r23, 0x00	; 0
    7b8a:	60 e0       	ldi	r22, 0x00	; 0
    7b8c:	08 95       	ret

00007b8e <__fp_mintl>:
    7b8e:	88 23       	and	r24, r24
    7b90:	71 f4       	brne	.+28     	; 0x7bae <__fp_mintl+0x20>
    7b92:	77 23       	and	r23, r23
    7b94:	21 f0       	breq	.+8      	; 0x7b9e <__fp_mintl+0x10>
    7b96:	98 50       	subi	r25, 0x08	; 8
    7b98:	87 2b       	or	r24, r23
    7b9a:	76 2f       	mov	r23, r22
    7b9c:	07 c0       	rjmp	.+14     	; 0x7bac <__fp_mintl+0x1e>
    7b9e:	66 23       	and	r22, r22
    7ba0:	11 f4       	brne	.+4      	; 0x7ba6 <__fp_mintl+0x18>
    7ba2:	99 27       	eor	r25, r25
    7ba4:	0d c0       	rjmp	.+26     	; 0x7bc0 <__fp_mintl+0x32>
    7ba6:	90 51       	subi	r25, 0x10	; 16
    7ba8:	86 2b       	or	r24, r22
    7baa:	70 e0       	ldi	r23, 0x00	; 0
    7bac:	60 e0       	ldi	r22, 0x00	; 0
    7bae:	2a f0       	brmi	.+10     	; 0x7bba <__fp_mintl+0x2c>
    7bb0:	9a 95       	dec	r25
    7bb2:	66 0f       	add	r22, r22
    7bb4:	77 1f       	adc	r23, r23
    7bb6:	88 1f       	adc	r24, r24
    7bb8:	da f7       	brpl	.-10     	; 0x7bb0 <__fp_mintl+0x22>
    7bba:	88 0f       	add	r24, r24
    7bbc:	96 95       	lsr	r25
    7bbe:	87 95       	ror	r24
    7bc0:	97 f9       	bld	r25, 7
    7bc2:	08 95       	ret

00007bc4 <__fp_mpack>:
    7bc4:	9f 3f       	cpi	r25, 0xFF	; 255
    7bc6:	31 f0       	breq	.+12     	; 0x7bd4 <__fp_mpack_finite+0xc>

00007bc8 <__fp_mpack_finite>:
    7bc8:	91 50       	subi	r25, 0x01	; 1
    7bca:	20 f4       	brcc	.+8      	; 0x7bd4 <__fp_mpack_finite+0xc>
    7bcc:	87 95       	ror	r24
    7bce:	77 95       	ror	r23
    7bd0:	67 95       	ror	r22
    7bd2:	b7 95       	ror	r27
    7bd4:	88 0f       	add	r24, r24
    7bd6:	91 1d       	adc	r25, r1
    7bd8:	96 95       	lsr	r25
    7bda:	87 95       	ror	r24
    7bdc:	97 f9       	bld	r25, 7
    7bde:	08 95       	ret

00007be0 <__fp_nan>:
    7be0:	9f ef       	ldi	r25, 0xFF	; 255
    7be2:	80 ec       	ldi	r24, 0xC0	; 192
    7be4:	08 95       	ret

00007be6 <__fp_powser>:
    7be6:	df 93       	push	r29
    7be8:	cf 93       	push	r28
    7bea:	1f 93       	push	r17
    7bec:	0f 93       	push	r16
    7bee:	ff 92       	push	r15
    7bf0:	ef 92       	push	r14
    7bf2:	df 92       	push	r13
    7bf4:	7b 01       	movw	r14, r22
    7bf6:	8c 01       	movw	r16, r24
    7bf8:	68 94       	set
    7bfa:	05 c0       	rjmp	.+10     	; 0x7c06 <__fp_powser+0x20>
    7bfc:	da 2e       	mov	r13, r26
    7bfe:	ef 01       	movw	r28, r30
    7c00:	f6 d0       	rcall	.+492    	; 0x7dee <__mulsf3x>
    7c02:	fe 01       	movw	r30, r28
    7c04:	e8 94       	clt
    7c06:	a5 91       	lpm	r26, Z+
    7c08:	25 91       	lpm	r18, Z+
    7c0a:	35 91       	lpm	r19, Z+
    7c0c:	45 91       	lpm	r20, Z+
    7c0e:	55 91       	lpm	r21, Z+
    7c10:	ae f3       	brts	.-22     	; 0x7bfc <__fp_powser+0x16>
    7c12:	ef 01       	movw	r28, r30
    7c14:	da dd       	rcall	.-1100   	; 0x77ca <__addsf3x>
    7c16:	fe 01       	movw	r30, r28
    7c18:	97 01       	movw	r18, r14
    7c1a:	a8 01       	movw	r20, r16
    7c1c:	da 94       	dec	r13
    7c1e:	79 f7       	brne	.-34     	; 0x7bfe <__fp_powser+0x18>
    7c20:	df 90       	pop	r13
    7c22:	ef 90       	pop	r14
    7c24:	ff 90       	pop	r15
    7c26:	0f 91       	pop	r16
    7c28:	1f 91       	pop	r17
    7c2a:	cf 91       	pop	r28
    7c2c:	df 91       	pop	r29
    7c2e:	08 95       	ret

00007c30 <__fp_pscA>:
    7c30:	00 24       	eor	r0, r0
    7c32:	0a 94       	dec	r0
    7c34:	16 16       	cp	r1, r22
    7c36:	17 06       	cpc	r1, r23
    7c38:	18 06       	cpc	r1, r24
    7c3a:	09 06       	cpc	r0, r25
    7c3c:	08 95       	ret

00007c3e <__fp_pscB>:
    7c3e:	00 24       	eor	r0, r0
    7c40:	0a 94       	dec	r0
    7c42:	12 16       	cp	r1, r18
    7c44:	13 06       	cpc	r1, r19
    7c46:	14 06       	cpc	r1, r20
    7c48:	05 06       	cpc	r0, r21
    7c4a:	08 95       	ret
    7c4c:	c9 cf       	rjmp	.-110    	; 0x7be0 <__fp_nan>

00007c4e <__fp_rempio2>:
    7c4e:	50 d0       	rcall	.+160    	; 0x7cf0 <__fp_splitA>
    7c50:	e8 f3       	brcs	.-6      	; 0x7c4c <__fp_pscB+0xe>
    7c52:	e8 94       	clt
    7c54:	e0 e0       	ldi	r30, 0x00	; 0
    7c56:	bb 27       	eor	r27, r27
    7c58:	9f 57       	subi	r25, 0x7F	; 127
    7c5a:	f0 f0       	brcs	.+60     	; 0x7c98 <__fp_rempio2+0x4a>
    7c5c:	2a ed       	ldi	r18, 0xDA	; 218
    7c5e:	3f e0       	ldi	r19, 0x0F	; 15
    7c60:	49 ec       	ldi	r20, 0xC9	; 201
    7c62:	06 c0       	rjmp	.+12     	; 0x7c70 <__fp_rempio2+0x22>
    7c64:	ee 0f       	add	r30, r30
    7c66:	bb 0f       	add	r27, r27
    7c68:	66 1f       	adc	r22, r22
    7c6a:	77 1f       	adc	r23, r23
    7c6c:	88 1f       	adc	r24, r24
    7c6e:	28 f0       	brcs	.+10     	; 0x7c7a <__fp_rempio2+0x2c>
    7c70:	b2 3a       	cpi	r27, 0xA2	; 162
    7c72:	62 07       	cpc	r22, r18
    7c74:	73 07       	cpc	r23, r19
    7c76:	84 07       	cpc	r24, r20
    7c78:	28 f0       	brcs	.+10     	; 0x7c84 <__fp_rempio2+0x36>
    7c7a:	b2 5a       	subi	r27, 0xA2	; 162
    7c7c:	62 0b       	sbc	r22, r18
    7c7e:	73 0b       	sbc	r23, r19
    7c80:	84 0b       	sbc	r24, r20
    7c82:	e3 95       	inc	r30
    7c84:	9a 95       	dec	r25
    7c86:	72 f7       	brpl	.-36     	; 0x7c64 <__fp_rempio2+0x16>
    7c88:	80 38       	cpi	r24, 0x80	; 128
    7c8a:	30 f4       	brcc	.+12     	; 0x7c98 <__fp_rempio2+0x4a>
    7c8c:	9a 95       	dec	r25
    7c8e:	bb 0f       	add	r27, r27
    7c90:	66 1f       	adc	r22, r22
    7c92:	77 1f       	adc	r23, r23
    7c94:	88 1f       	adc	r24, r24
    7c96:	d2 f7       	brpl	.-12     	; 0x7c8c <__fp_rempio2+0x3e>
    7c98:	90 48       	sbci	r25, 0x80	; 128
    7c9a:	96 cf       	rjmp	.-212    	; 0x7bc8 <__fp_mpack_finite>

00007c9c <__fp_round>:
    7c9c:	09 2e       	mov	r0, r25
    7c9e:	03 94       	inc	r0
    7ca0:	00 0c       	add	r0, r0
    7ca2:	11 f4       	brne	.+4      	; 0x7ca8 <__fp_round+0xc>
    7ca4:	88 23       	and	r24, r24
    7ca6:	52 f0       	brmi	.+20     	; 0x7cbc <__fp_round+0x20>
    7ca8:	bb 0f       	add	r27, r27
    7caa:	40 f4       	brcc	.+16     	; 0x7cbc <__fp_round+0x20>
    7cac:	bf 2b       	or	r27, r31
    7cae:	11 f4       	brne	.+4      	; 0x7cb4 <__fp_round+0x18>
    7cb0:	60 ff       	sbrs	r22, 0
    7cb2:	04 c0       	rjmp	.+8      	; 0x7cbc <__fp_round+0x20>
    7cb4:	6f 5f       	subi	r22, 0xFF	; 255
    7cb6:	7f 4f       	sbci	r23, 0xFF	; 255
    7cb8:	8f 4f       	sbci	r24, 0xFF	; 255
    7cba:	9f 4f       	sbci	r25, 0xFF	; 255
    7cbc:	08 95       	ret

00007cbe <__fp_sinus>:
    7cbe:	ef 93       	push	r30
    7cc0:	e0 ff       	sbrs	r30, 0
    7cc2:	06 c0       	rjmp	.+12     	; 0x7cd0 <__fp_sinus+0x12>
    7cc4:	a2 ea       	ldi	r26, 0xA2	; 162
    7cc6:	2a ed       	ldi	r18, 0xDA	; 218
    7cc8:	3f e0       	ldi	r19, 0x0F	; 15
    7cca:	49 ec       	ldi	r20, 0xC9	; 201
    7ccc:	5f eb       	ldi	r21, 0xBF	; 191
    7cce:	7d dd       	rcall	.-1286   	; 0x77ca <__addsf3x>
    7cd0:	e5 df       	rcall	.-54     	; 0x7c9c <__fp_round>
    7cd2:	0f 90       	pop	r0
    7cd4:	03 94       	inc	r0
    7cd6:	01 fc       	sbrc	r0, 1
    7cd8:	90 58       	subi	r25, 0x80	; 128
    7cda:	e1 e6       	ldi	r30, 0x61	; 97
    7cdc:	f2 e0       	ldi	r31, 0x02	; 2
    7cde:	57 c1       	rjmp	.+686    	; 0x7f8e <__fp_powsodd>

00007ce0 <__fp_split3>:
    7ce0:	57 fd       	sbrc	r21, 7
    7ce2:	90 58       	subi	r25, 0x80	; 128
    7ce4:	44 0f       	add	r20, r20
    7ce6:	55 1f       	adc	r21, r21
    7ce8:	59 f0       	breq	.+22     	; 0x7d00 <__fp_splitA+0x10>
    7cea:	5f 3f       	cpi	r21, 0xFF	; 255
    7cec:	71 f0       	breq	.+28     	; 0x7d0a <__fp_splitA+0x1a>
    7cee:	47 95       	ror	r20

00007cf0 <__fp_splitA>:
    7cf0:	88 0f       	add	r24, r24
    7cf2:	97 fb       	bst	r25, 7
    7cf4:	99 1f       	adc	r25, r25
    7cf6:	61 f0       	breq	.+24     	; 0x7d10 <__fp_splitA+0x20>
    7cf8:	9f 3f       	cpi	r25, 0xFF	; 255
    7cfa:	79 f0       	breq	.+30     	; 0x7d1a <__fp_splitA+0x2a>
    7cfc:	87 95       	ror	r24
    7cfe:	08 95       	ret
    7d00:	12 16       	cp	r1, r18
    7d02:	13 06       	cpc	r1, r19
    7d04:	14 06       	cpc	r1, r20
    7d06:	55 1f       	adc	r21, r21
    7d08:	f2 cf       	rjmp	.-28     	; 0x7cee <__fp_split3+0xe>
    7d0a:	46 95       	lsr	r20
    7d0c:	f1 df       	rcall	.-30     	; 0x7cf0 <__fp_splitA>
    7d0e:	08 c0       	rjmp	.+16     	; 0x7d20 <__fp_splitA+0x30>
    7d10:	16 16       	cp	r1, r22
    7d12:	17 06       	cpc	r1, r23
    7d14:	18 06       	cpc	r1, r24
    7d16:	99 1f       	adc	r25, r25
    7d18:	f1 cf       	rjmp	.-30     	; 0x7cfc <__fp_splitA+0xc>
    7d1a:	86 95       	lsr	r24
    7d1c:	71 05       	cpc	r23, r1
    7d1e:	61 05       	cpc	r22, r1
    7d20:	08 94       	sec
    7d22:	08 95       	ret

00007d24 <__fp_trunc>:
    7d24:	e5 df       	rcall	.-54     	; 0x7cf0 <__fp_splitA>
    7d26:	a0 f0       	brcs	.+40     	; 0x7d50 <__fp_trunc+0x2c>
    7d28:	be e7       	ldi	r27, 0x7E	; 126
    7d2a:	b9 17       	cp	r27, r25
    7d2c:	88 f4       	brcc	.+34     	; 0x7d50 <__fp_trunc+0x2c>
    7d2e:	bb 27       	eor	r27, r27
    7d30:	9f 38       	cpi	r25, 0x8F	; 143
    7d32:	60 f4       	brcc	.+24     	; 0x7d4c <__fp_trunc+0x28>
    7d34:	16 16       	cp	r1, r22
    7d36:	b1 1d       	adc	r27, r1
    7d38:	67 2f       	mov	r22, r23
    7d3a:	78 2f       	mov	r23, r24
    7d3c:	88 27       	eor	r24, r24
    7d3e:	98 5f       	subi	r25, 0xF8	; 248
    7d40:	f7 cf       	rjmp	.-18     	; 0x7d30 <__fp_trunc+0xc>
    7d42:	86 95       	lsr	r24
    7d44:	77 95       	ror	r23
    7d46:	67 95       	ror	r22
    7d48:	b1 1d       	adc	r27, r1
    7d4a:	93 95       	inc	r25
    7d4c:	96 39       	cpi	r25, 0x96	; 150
    7d4e:	c8 f3       	brcs	.-14     	; 0x7d42 <__fp_trunc+0x1e>
    7d50:	08 95       	ret

00007d52 <__fp_zero>:
    7d52:	e8 94       	clt

00007d54 <__fp_szero>:
    7d54:	bb 27       	eor	r27, r27
    7d56:	66 27       	eor	r22, r22
    7d58:	77 27       	eor	r23, r23
    7d5a:	cb 01       	movw	r24, r22
    7d5c:	97 f9       	bld	r25, 7
    7d5e:	08 95       	ret

00007d60 <__gesf2>:
    7d60:	ec de       	rcall	.-552    	; 0x7b3a <__fp_cmp>
    7d62:	08 f4       	brcc	.+2      	; 0x7d66 <__gesf2+0x6>
    7d64:	8f ef       	ldi	r24, 0xFF	; 255
    7d66:	08 95       	ret

00007d68 <inverse>:
    7d68:	9b 01       	movw	r18, r22
    7d6a:	ac 01       	movw	r20, r24
    7d6c:	60 e0       	ldi	r22, 0x00	; 0
    7d6e:	70 e0       	ldi	r23, 0x00	; 0
    7d70:	80 e8       	ldi	r24, 0x80	; 128
    7d72:	9f e3       	ldi	r25, 0x3F	; 63
    7d74:	f9 cd       	rjmp	.-1038   	; 0x7968 <__divsf3>

00007d76 <lround>:
    7d76:	bc df       	rcall	.-136    	; 0x7cf0 <__fp_splitA>
    7d78:	58 f1       	brcs	.+86     	; 0x7dd0 <lround+0x5a>
    7d7a:	9e 57       	subi	r25, 0x7E	; 126
    7d7c:	58 f1       	brcs	.+86     	; 0x7dd4 <lround+0x5e>
    7d7e:	98 51       	subi	r25, 0x18	; 24
    7d80:	a0 f0       	brcs	.+40     	; 0x7daa <lround+0x34>
    7d82:	e9 f0       	breq	.+58     	; 0x7dbe <lround+0x48>
    7d84:	98 30       	cpi	r25, 0x08	; 8
    7d86:	20 f5       	brcc	.+72     	; 0x7dd0 <lround+0x5a>
    7d88:	09 2e       	mov	r0, r25
    7d8a:	99 27       	eor	r25, r25
    7d8c:	66 0f       	add	r22, r22
    7d8e:	77 1f       	adc	r23, r23
    7d90:	88 1f       	adc	r24, r24
    7d92:	99 1f       	adc	r25, r25
    7d94:	0a 94       	dec	r0
    7d96:	d1 f7       	brne	.-12     	; 0x7d8c <lround+0x16>
    7d98:	12 c0       	rjmp	.+36     	; 0x7dbe <lround+0x48>
    7d9a:	06 2e       	mov	r0, r22
    7d9c:	67 2f       	mov	r22, r23
    7d9e:	78 2f       	mov	r23, r24
    7da0:	88 27       	eor	r24, r24
    7da2:	98 5f       	subi	r25, 0xF8	; 248
    7da4:	11 f4       	brne	.+4      	; 0x7daa <lround+0x34>
    7da6:	00 0c       	add	r0, r0
    7da8:	07 c0       	rjmp	.+14     	; 0x7db8 <lround+0x42>
    7daa:	99 3f       	cpi	r25, 0xF9	; 249
    7dac:	b4 f3       	brlt	.-20     	; 0x7d9a <lround+0x24>
    7dae:	86 95       	lsr	r24
    7db0:	77 95       	ror	r23
    7db2:	67 95       	ror	r22
    7db4:	93 95       	inc	r25
    7db6:	d9 f7       	brne	.-10     	; 0x7dae <lround+0x38>
    7db8:	61 1d       	adc	r22, r1
    7dba:	71 1d       	adc	r23, r1
    7dbc:	81 1d       	adc	r24, r1
    7dbe:	3e f4       	brtc	.+14     	; 0x7dce <lround+0x58>
    7dc0:	90 95       	com	r25
    7dc2:	80 95       	com	r24
    7dc4:	70 95       	com	r23
    7dc6:	61 95       	neg	r22
    7dc8:	7f 4f       	sbci	r23, 0xFF	; 255
    7dca:	8f 4f       	sbci	r24, 0xFF	; 255
    7dcc:	9f 4f       	sbci	r25, 0xFF	; 255
    7dce:	08 95       	ret
    7dd0:	68 94       	set
    7dd2:	c0 cf       	rjmp	.-128    	; 0x7d54 <__fp_szero>
    7dd4:	be cf       	rjmp	.-132    	; 0x7d52 <__fp_zero>

00007dd6 <__mulsf3>:
    7dd6:	0b d0       	rcall	.+22     	; 0x7dee <__mulsf3x>
    7dd8:	61 cf       	rjmp	.-318    	; 0x7c9c <__fp_round>
    7dda:	2a df       	rcall	.-428    	; 0x7c30 <__fp_pscA>
    7ddc:	28 f0       	brcs	.+10     	; 0x7de8 <__mulsf3+0x12>
    7dde:	2f df       	rcall	.-418    	; 0x7c3e <__fp_pscB>
    7de0:	18 f0       	brcs	.+6      	; 0x7de8 <__mulsf3+0x12>
    7de2:	95 23       	and	r25, r21
    7de4:	09 f0       	breq	.+2      	; 0x7de8 <__mulsf3+0x12>
    7de6:	cd ce       	rjmp	.-614    	; 0x7b82 <__fp_inf>
    7de8:	fb ce       	rjmp	.-522    	; 0x7be0 <__fp_nan>
    7dea:	11 24       	eor	r1, r1
    7dec:	b3 cf       	rjmp	.-154    	; 0x7d54 <__fp_szero>

00007dee <__mulsf3x>:
    7dee:	78 df       	rcall	.-272    	; 0x7ce0 <__fp_split3>
    7df0:	a0 f3       	brcs	.-24     	; 0x7dda <__mulsf3+0x4>

00007df2 <__mulsf3_pse>:
    7df2:	95 9f       	mul	r25, r21
    7df4:	d1 f3       	breq	.-12     	; 0x7dea <__mulsf3+0x14>
    7df6:	95 0f       	add	r25, r21
    7df8:	50 e0       	ldi	r21, 0x00	; 0
    7dfa:	55 1f       	adc	r21, r21
    7dfc:	62 9f       	mul	r22, r18
    7dfe:	f0 01       	movw	r30, r0
    7e00:	72 9f       	mul	r23, r18
    7e02:	bb 27       	eor	r27, r27
    7e04:	f0 0d       	add	r31, r0
    7e06:	b1 1d       	adc	r27, r1
    7e08:	63 9f       	mul	r22, r19
    7e0a:	aa 27       	eor	r26, r26
    7e0c:	f0 0d       	add	r31, r0
    7e0e:	b1 1d       	adc	r27, r1
    7e10:	aa 1f       	adc	r26, r26
    7e12:	64 9f       	mul	r22, r20
    7e14:	66 27       	eor	r22, r22
    7e16:	b0 0d       	add	r27, r0
    7e18:	a1 1d       	adc	r26, r1
    7e1a:	66 1f       	adc	r22, r22
    7e1c:	82 9f       	mul	r24, r18
    7e1e:	22 27       	eor	r18, r18
    7e20:	b0 0d       	add	r27, r0
    7e22:	a1 1d       	adc	r26, r1
    7e24:	62 1f       	adc	r22, r18
    7e26:	73 9f       	mul	r23, r19
    7e28:	b0 0d       	add	r27, r0
    7e2a:	a1 1d       	adc	r26, r1
    7e2c:	62 1f       	adc	r22, r18
    7e2e:	83 9f       	mul	r24, r19
    7e30:	a0 0d       	add	r26, r0
    7e32:	61 1d       	adc	r22, r1
    7e34:	22 1f       	adc	r18, r18
    7e36:	74 9f       	mul	r23, r20
    7e38:	33 27       	eor	r19, r19
    7e3a:	a0 0d       	add	r26, r0
    7e3c:	61 1d       	adc	r22, r1
    7e3e:	23 1f       	adc	r18, r19
    7e40:	84 9f       	mul	r24, r20
    7e42:	60 0d       	add	r22, r0
    7e44:	21 1d       	adc	r18, r1
    7e46:	82 2f       	mov	r24, r18
    7e48:	76 2f       	mov	r23, r22
    7e4a:	6a 2f       	mov	r22, r26
    7e4c:	11 24       	eor	r1, r1
    7e4e:	9f 57       	subi	r25, 0x7F	; 127
    7e50:	50 40       	sbci	r21, 0x00	; 0
    7e52:	8a f0       	brmi	.+34     	; 0x7e76 <__mulsf3_pse+0x84>
    7e54:	e1 f0       	breq	.+56     	; 0x7e8e <__mulsf3_pse+0x9c>
    7e56:	88 23       	and	r24, r24
    7e58:	4a f0       	brmi	.+18     	; 0x7e6c <__mulsf3_pse+0x7a>
    7e5a:	ee 0f       	add	r30, r30
    7e5c:	ff 1f       	adc	r31, r31
    7e5e:	bb 1f       	adc	r27, r27
    7e60:	66 1f       	adc	r22, r22
    7e62:	77 1f       	adc	r23, r23
    7e64:	88 1f       	adc	r24, r24
    7e66:	91 50       	subi	r25, 0x01	; 1
    7e68:	50 40       	sbci	r21, 0x00	; 0
    7e6a:	a9 f7       	brne	.-22     	; 0x7e56 <__mulsf3_pse+0x64>
    7e6c:	9e 3f       	cpi	r25, 0xFE	; 254
    7e6e:	51 05       	cpc	r21, r1
    7e70:	70 f0       	brcs	.+28     	; 0x7e8e <__mulsf3_pse+0x9c>
    7e72:	87 ce       	rjmp	.-754    	; 0x7b82 <__fp_inf>
    7e74:	6f cf       	rjmp	.-290    	; 0x7d54 <__fp_szero>
    7e76:	5f 3f       	cpi	r21, 0xFF	; 255
    7e78:	ec f3       	brlt	.-6      	; 0x7e74 <__mulsf3_pse+0x82>
    7e7a:	98 3e       	cpi	r25, 0xE8	; 232
    7e7c:	dc f3       	brlt	.-10     	; 0x7e74 <__mulsf3_pse+0x82>
    7e7e:	86 95       	lsr	r24
    7e80:	77 95       	ror	r23
    7e82:	67 95       	ror	r22
    7e84:	b7 95       	ror	r27
    7e86:	f7 95       	ror	r31
    7e88:	e7 95       	ror	r30
    7e8a:	9f 5f       	subi	r25, 0xFF	; 255
    7e8c:	c1 f7       	brne	.-16     	; 0x7e7e <__mulsf3_pse+0x8c>
    7e8e:	fe 2b       	or	r31, r30
    7e90:	88 0f       	add	r24, r24
    7e92:	91 1d       	adc	r25, r1
    7e94:	96 95       	lsr	r25
    7e96:	87 95       	ror	r24
    7e98:	97 f9       	bld	r25, 7
    7e9a:	08 95       	ret

00007e9c <round>:
    7e9c:	29 df       	rcall	.-430    	; 0x7cf0 <__fp_splitA>
    7e9e:	e0 f0       	brcs	.+56     	; 0x7ed8 <round+0x3c>
    7ea0:	9e 37       	cpi	r25, 0x7E	; 126
    7ea2:	d8 f0       	brcs	.+54     	; 0x7eda <round+0x3e>
    7ea4:	96 39       	cpi	r25, 0x96	; 150
    7ea6:	b8 f4       	brcc	.+46     	; 0x7ed6 <round+0x3a>
    7ea8:	9e 38       	cpi	r25, 0x8E	; 142
    7eaa:	48 f4       	brcc	.+18     	; 0x7ebe <round+0x22>
    7eac:	67 2f       	mov	r22, r23
    7eae:	78 2f       	mov	r23, r24
    7eb0:	88 27       	eor	r24, r24
    7eb2:	98 5f       	subi	r25, 0xF8	; 248
    7eb4:	f9 cf       	rjmp	.-14     	; 0x7ea8 <round+0xc>
    7eb6:	86 95       	lsr	r24
    7eb8:	77 95       	ror	r23
    7eba:	67 95       	ror	r22
    7ebc:	93 95       	inc	r25
    7ebe:	95 39       	cpi	r25, 0x95	; 149
    7ec0:	d0 f3       	brcs	.-12     	; 0x7eb6 <round+0x1a>
    7ec2:	b6 2f       	mov	r27, r22
    7ec4:	b1 70       	andi	r27, 0x01	; 1
    7ec6:	6b 0f       	add	r22, r27
    7ec8:	71 1d       	adc	r23, r1
    7eca:	81 1d       	adc	r24, r1
    7ecc:	20 f4       	brcc	.+8      	; 0x7ed6 <round+0x3a>
    7ece:	87 95       	ror	r24
    7ed0:	77 95       	ror	r23
    7ed2:	67 95       	ror	r22
    7ed4:	93 95       	inc	r25
    7ed6:	5b ce       	rjmp	.-842    	; 0x7b8e <__fp_mintl>
    7ed8:	75 ce       	rjmp	.-790    	; 0x7bc4 <__fp_mpack>
    7eda:	3c cf       	rjmp	.-392    	; 0x7d54 <__fp_szero>

00007edc <sin>:
    7edc:	9f 93       	push	r25
    7ede:	b7 de       	rcall	.-658    	; 0x7c4e <__fp_rempio2>
    7ee0:	0f 90       	pop	r0
    7ee2:	07 fc       	sbrc	r0, 7
    7ee4:	ee 5f       	subi	r30, 0xFE	; 254
    7ee6:	eb ce       	rjmp	.-554    	; 0x7cbe <__fp_sinus>
    7ee8:	11 f4       	brne	.+4      	; 0x7eee <sin+0x12>
    7eea:	0e f4       	brtc	.+2      	; 0x7eee <sin+0x12>
    7eec:	79 ce       	rjmp	.-782    	; 0x7be0 <__fp_nan>
    7eee:	6a ce       	rjmp	.-812    	; 0x7bc4 <__fp_mpack>

00007ef0 <sqrt>:
    7ef0:	ff de       	rcall	.-514    	; 0x7cf0 <__fp_splitA>
    7ef2:	d0 f3       	brcs	.-12     	; 0x7ee8 <sin+0xc>
    7ef4:	99 23       	and	r25, r25
    7ef6:	d9 f3       	breq	.-10     	; 0x7eee <sin+0x12>
    7ef8:	ce f3       	brts	.-14     	; 0x7eec <sin+0x10>
    7efa:	9f 57       	subi	r25, 0x7F	; 127
    7efc:	55 0b       	sbc	r21, r21
    7efe:	87 ff       	sbrs	r24, 7
    7f00:	3f d0       	rcall	.+126    	; 0x7f80 <__fp_norm2>
    7f02:	00 24       	eor	r0, r0
    7f04:	a0 e6       	ldi	r26, 0x60	; 96
    7f06:	40 ea       	ldi	r20, 0xA0	; 160
    7f08:	90 01       	movw	r18, r0
    7f0a:	80 58       	subi	r24, 0x80	; 128
    7f0c:	56 95       	lsr	r21
    7f0e:	97 95       	ror	r25
    7f10:	28 f4       	brcc	.+10     	; 0x7f1c <sqrt+0x2c>
    7f12:	80 5c       	subi	r24, 0xC0	; 192
    7f14:	66 0f       	add	r22, r22
    7f16:	77 1f       	adc	r23, r23
    7f18:	88 1f       	adc	r24, r24
    7f1a:	20 f0       	brcs	.+8      	; 0x7f24 <sqrt+0x34>
    7f1c:	26 17       	cp	r18, r22
    7f1e:	37 07       	cpc	r19, r23
    7f20:	48 07       	cpc	r20, r24
    7f22:	30 f4       	brcc	.+12     	; 0x7f30 <sqrt+0x40>
    7f24:	62 1b       	sub	r22, r18
    7f26:	73 0b       	sbc	r23, r19
    7f28:	84 0b       	sbc	r24, r20
    7f2a:	20 29       	or	r18, r0
    7f2c:	31 29       	or	r19, r1
    7f2e:	4a 2b       	or	r20, r26
    7f30:	a6 95       	lsr	r26
    7f32:	17 94       	ror	r1
    7f34:	07 94       	ror	r0
    7f36:	20 25       	eor	r18, r0
    7f38:	31 25       	eor	r19, r1
    7f3a:	4a 27       	eor	r20, r26
    7f3c:	58 f7       	brcc	.-42     	; 0x7f14 <sqrt+0x24>
    7f3e:	66 0f       	add	r22, r22
    7f40:	77 1f       	adc	r23, r23
    7f42:	88 1f       	adc	r24, r24
    7f44:	20 f0       	brcs	.+8      	; 0x7f4e <sqrt+0x5e>
    7f46:	26 17       	cp	r18, r22
    7f48:	37 07       	cpc	r19, r23
    7f4a:	48 07       	cpc	r20, r24
    7f4c:	30 f4       	brcc	.+12     	; 0x7f5a <sqrt+0x6a>
    7f4e:	62 0b       	sbc	r22, r18
    7f50:	73 0b       	sbc	r23, r19
    7f52:	84 0b       	sbc	r24, r20
    7f54:	20 0d       	add	r18, r0
    7f56:	31 1d       	adc	r19, r1
    7f58:	41 1d       	adc	r20, r1
    7f5a:	a0 95       	com	r26
    7f5c:	81 f7       	brne	.-32     	; 0x7f3e <sqrt+0x4e>
    7f5e:	b9 01       	movw	r22, r18
    7f60:	84 2f       	mov	r24, r20
    7f62:	91 58       	subi	r25, 0x81	; 129
    7f64:	88 0f       	add	r24, r24
    7f66:	96 95       	lsr	r25
    7f68:	87 95       	ror	r24
    7f6a:	08 95       	ret

00007f6c <square>:
    7f6c:	9b 01       	movw	r18, r22
    7f6e:	ac 01       	movw	r20, r24
    7f70:	32 cf       	rjmp	.-412    	; 0x7dd6 <__mulsf3>

00007f72 <trunc>:
    7f72:	d8 de       	rcall	.-592    	; 0x7d24 <__fp_trunc>
    7f74:	20 f0       	brcs	.+8      	; 0x7f7e <trunc+0xc>
    7f76:	9f 37       	cpi	r25, 0x7F	; 127
    7f78:	08 f4       	brcc	.+2      	; 0x7f7c <trunc+0xa>
    7f7a:	ec ce       	rjmp	.-552    	; 0x7d54 <__fp_szero>
    7f7c:	08 ce       	rjmp	.-1008   	; 0x7b8e <__fp_mintl>
    7f7e:	22 ce       	rjmp	.-956    	; 0x7bc4 <__fp_mpack>

00007f80 <__fp_norm2>:
    7f80:	91 50       	subi	r25, 0x01	; 1
    7f82:	50 40       	sbci	r21, 0x00	; 0
    7f84:	66 0f       	add	r22, r22
    7f86:	77 1f       	adc	r23, r23
    7f88:	88 1f       	adc	r24, r24
    7f8a:	d2 f7       	brpl	.-12     	; 0x7f80 <__fp_norm2>
    7f8c:	08 95       	ret

00007f8e <__fp_powsodd>:
    7f8e:	9f 93       	push	r25
    7f90:	8f 93       	push	r24
    7f92:	7f 93       	push	r23
    7f94:	6f 93       	push	r22
    7f96:	ff 93       	push	r31
    7f98:	ef 93       	push	r30
    7f9a:	9b 01       	movw	r18, r22
    7f9c:	ac 01       	movw	r20, r24
    7f9e:	1b df       	rcall	.-458    	; 0x7dd6 <__mulsf3>
    7fa0:	ef 91       	pop	r30
    7fa2:	ff 91       	pop	r31
    7fa4:	20 de       	rcall	.-960    	; 0x7be6 <__fp_powser>
    7fa6:	2f 91       	pop	r18
    7fa8:	3f 91       	pop	r19
    7faa:	4f 91       	pop	r20
    7fac:	5f 91       	pop	r21
    7fae:	13 cf       	rjmp	.-474    	; 0x7dd6 <__mulsf3>

00007fb0 <__udivmodsi4>:
    7fb0:	a1 e2       	ldi	r26, 0x21	; 33
    7fb2:	1a 2e       	mov	r1, r26
    7fb4:	aa 1b       	sub	r26, r26
    7fb6:	bb 1b       	sub	r27, r27
    7fb8:	fd 01       	movw	r30, r26
    7fba:	0d c0       	rjmp	.+26     	; 0x7fd6 <__udivmodsi4_ep>

00007fbc <__udivmodsi4_loop>:
    7fbc:	aa 1f       	adc	r26, r26
    7fbe:	bb 1f       	adc	r27, r27
    7fc0:	ee 1f       	adc	r30, r30
    7fc2:	ff 1f       	adc	r31, r31
    7fc4:	a2 17       	cp	r26, r18
    7fc6:	b3 07       	cpc	r27, r19
    7fc8:	e4 07       	cpc	r30, r20
    7fca:	f5 07       	cpc	r31, r21
    7fcc:	20 f0       	brcs	.+8      	; 0x7fd6 <__udivmodsi4_ep>
    7fce:	a2 1b       	sub	r26, r18
    7fd0:	b3 0b       	sbc	r27, r19
    7fd2:	e4 0b       	sbc	r30, r20
    7fd4:	f5 0b       	sbc	r31, r21

00007fd6 <__udivmodsi4_ep>:
    7fd6:	66 1f       	adc	r22, r22
    7fd8:	77 1f       	adc	r23, r23
    7fda:	88 1f       	adc	r24, r24
    7fdc:	99 1f       	adc	r25, r25
    7fde:	1a 94       	dec	r1
    7fe0:	69 f7       	brne	.-38     	; 0x7fbc <__udivmodsi4_loop>
    7fe2:	60 95       	com	r22
    7fe4:	70 95       	com	r23
    7fe6:	80 95       	com	r24
    7fe8:	90 95       	com	r25
    7fea:	9b 01       	movw	r18, r22
    7fec:	ac 01       	movw	r20, r24
    7fee:	bd 01       	movw	r22, r26
    7ff0:	cf 01       	movw	r24, r30
    7ff2:	08 95       	ret

00007ff4 <__tablejump2__>:
    7ff4:	ee 0f       	add	r30, r30
    7ff6:	ff 1f       	adc	r31, r31

00007ff8 <__tablejump__>:
    7ff8:	05 90       	lpm	r0, Z+
    7ffa:	f4 91       	lpm	r31, Z
    7ffc:	e0 2d       	mov	r30, r0
    7ffe:	09 94       	ijmp

00008000 <__umulhisi3>:
    8000:	a2 9f       	mul	r26, r18
    8002:	b0 01       	movw	r22, r0
    8004:	b3 9f       	mul	r27, r19
    8006:	c0 01       	movw	r24, r0
    8008:	a3 9f       	mul	r26, r19
    800a:	70 0d       	add	r23, r0
    800c:	81 1d       	adc	r24, r1
    800e:	11 24       	eor	r1, r1
    8010:	91 1d       	adc	r25, r1
    8012:	b2 9f       	mul	r27, r18
    8014:	70 0d       	add	r23, r0
    8016:	81 1d       	adc	r24, r1
    8018:	11 24       	eor	r1, r1
    801a:	91 1d       	adc	r25, r1
    801c:	08 95       	ret

0000801e <__muluhisi3>:
    801e:	0e 94 00 40 	call	0x8000	; 0x8000 <__umulhisi3>
    8022:	a5 9f       	mul	r26, r21
    8024:	90 0d       	add	r25, r0
    8026:	b4 9f       	mul	r27, r20
    8028:	90 0d       	add	r25, r0
    802a:	a4 9f       	mul	r26, r20
    802c:	80 0d       	add	r24, r0
    802e:	91 1d       	adc	r25, r1
    8030:	11 24       	eor	r1, r1
    8032:	08 95       	ret

00008034 <_exit>:
    8034:	f8 94       	cli

00008036 <__stop_program>:
    8036:	ff cf       	rjmp	.-2      	; 0x8036 <__stop_program>
