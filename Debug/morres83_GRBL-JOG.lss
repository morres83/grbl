
morres83_GRBL-JOG.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008012  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000855  00800100  00800100  00008086  2**0
                  ALLOC
  2 .comment      00000030  00000000  00000000  00008086  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000568  00000000  00000000  000080b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00008792  00000000  00000000  0000861e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00002087  00000000  00000000  00010db0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000029a1  00000000  00000000  00012e37  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00001238  00000000  00000000  000157d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000173a  00000000  00000000  00016a10  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005e7f  00000000  00000000  0001814a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000568  00000000  00000000  0001dfc9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 db 04 	jmp	0x9b6	; 0x9b6 <__ctors_end>
       4:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
       8:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
       c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      10:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      14:	0c 94 5d 2f 	jmp	0x5eba	; 0x5eba <__vector_5>
      18:	0c 94 a4 39 	jmp	0x7348	; 0x7348 <__vector_6>
      1c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      20:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      24:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      28:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      2c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      30:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      34:	0c 94 87 1b 	jmp	0x370e	; 0x370e <__vector_13>
      38:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      3c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      40:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      44:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      48:	0c 94 9d 1d 	jmp	0x3b3a	; 0x3b3a <__vector_18>
      4c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      50:	0c 94 71 18 	jmp	0x30e2	; 0x30e2 <__vector_20>
      54:	0c 94 33 18 	jmp	0x3066	; 0x3066 <__vector_21>
      58:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      5c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      60:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      64:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      68:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      6c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__bad_interrupt>
      70:	dd 0d       	add	r29, r13
      72:	dd 0d       	add	r29, r13
      74:	dd 0d       	add	r29, r13
      76:	dd 0d       	add	r29, r13
      78:	78 0d       	add	r23, r8
      7a:	2f 17       	cp	r18, r31
      7c:	2f 17       	cp	r18, r31
      7e:	2f 17       	cp	r18, r31
      80:	2f 17       	cp	r18, r31
      82:	2f 17       	cp	r18, r31
      84:	6f 0d       	add	r22, r15
      86:	2f 17       	cp	r18, r31
      88:	2f 17       	cp	r18, r31
      8a:	2f 17       	cp	r18, r31
      8c:	2f 17       	cp	r18, r31
      8e:	2f 17       	cp	r18, r31
      90:	2f 17       	cp	r18, r31
      92:	3e 0e       	add	r3, r30
      94:	3e 0e       	add	r3, r30
      96:	3e 0e       	add	r3, r30
      98:	73 0e       	add	r7, r19
      9a:	73 0e       	add	r7, r19
      9c:	2f 17       	cp	r18, r31
      9e:	2f 17       	cp	r18, r31
      a0:	2f 17       	cp	r18, r31
      a2:	2f 17       	cp	r18, r31
      a4:	2f 17       	cp	r18, r31
      a6:	2f 17       	cp	r18, r31
      a8:	6f 0d       	add	r22, r15
      aa:	2f 17       	cp	r18, r31
      ac:	6f 0d       	add	r22, r15
      ae:	2f 17       	cp	r18, r31
      b0:	2f 17       	cp	r18, r31
      b2:	2f 17       	cp	r18, r31
      b4:	2f 17       	cp	r18, r31
      b6:	2f 17       	cp	r18, r31
      b8:	2f 17       	cp	r18, r31
      ba:	2f 17       	cp	r18, r31
      bc:	dd 0d       	add	r29, r13
      be:	2f 17       	cp	r18, r31
      c0:	a3 0e       	add	r10, r19
      c2:	2f 17       	cp	r18, r31
      c4:	2f 17       	cp	r18, r31
      c6:	81 0e       	add	r8, r17
      c8:	2f 17       	cp	r18, r31
      ca:	2f 17       	cp	r18, r31
      cc:	2f 17       	cp	r18, r31
      ce:	2f 17       	cp	r18, r31
      d0:	2f 17       	cp	r18, r31
      d2:	81 0e       	add	r8, r17
      d4:	2f 17       	cp	r18, r31
      d6:	2f 17       	cp	r18, r31
      d8:	2f 17       	cp	r18, r31
      da:	78 0d       	add	r23, r8
      dc:	9c 0e       	add	r9, r28
      de:	9c 0e       	add	r9, r28
      e0:	9c 0e       	add	r9, r28
      e2:	9c 0e       	add	r9, r28
      e4:	9c 0e       	add	r9, r28
      e6:	9c 0e       	add	r9, r28
      e8:	2f 17       	cp	r18, r31
      ea:	2f 17       	cp	r18, r31
      ec:	2f 17       	cp	r18, r31
      ee:	2f 17       	cp	r18, r31
      f0:	2f 17       	cp	r18, r31
      f2:	2f 17       	cp	r18, r31
      f4:	2f 17       	cp	r18, r31
      f6:	2f 17       	cp	r18, r31
      f8:	2f 17       	cp	r18, r31
      fa:	2f 17       	cp	r18, r31
      fc:	2f 17       	cp	r18, r31
      fe:	2f 17       	cp	r18, r31
     100:	2f 17       	cp	r18, r31
     102:	2f 17       	cp	r18, r31
     104:	2f 17       	cp	r18, r31
     106:	2f 17       	cp	r18, r31
     108:	2f 17       	cp	r18, r31
     10a:	2f 17       	cp	r18, r31
     10c:	2f 17       	cp	r18, r31
     10e:	2f 17       	cp	r18, r31
     110:	e3 0d       	add	r30, r3
     112:	2f 17       	cp	r18, r31
     114:	2f 17       	cp	r18, r31
     116:	2f 17       	cp	r18, r31
     118:	2f 17       	cp	r18, r31
     11a:	2f 17       	cp	r18, r31
     11c:	2f 17       	cp	r18, r31
     11e:	2f 17       	cp	r18, r31
     120:	2f 17       	cp	r18, r31
     122:	2f 17       	cp	r18, r31
     124:	57 0e       	add	r5, r23
     126:	57 0e       	add	r5, r23
     128:	6f 0d       	add	r22, r15
     12a:	65 0e       	add	r6, r21
     12c:	65 0e       	add	r6, r21
     12e:	ce 0e       	add	r12, r30
     130:	ce 0e       	add	r12, r30
     132:	ce 0e       	add	r12, r30
     134:	e0 0e       	add	r14, r16
     136:	e0 0e       	add	r14, r16
     138:	e0 0e       	add	r14, r16
     13a:	47 17       	cp	r20, r23
     13c:	47 17       	cp	r20, r23
     13e:	f7 0e       	add	r15, r23
     140:	f7 0e       	add	r15, r23
     142:	47 17       	cp	r20, r23
     144:	47 17       	cp	r20, r23
     146:	47 17       	cp	r20, r23
     148:	47 17       	cp	r20, r23
     14a:	47 17       	cp	r20, r23
     14c:	47 17       	cp	r20, r23
     14e:	47 17       	cp	r20, r23
     150:	47 17       	cp	r20, r23
     152:	47 17       	cp	r20, r23
     154:	47 17       	cp	r20, r23
     156:	47 17       	cp	r20, r23
     158:	47 17       	cp	r20, r23
     15a:	47 17       	cp	r20, r23
     15c:	47 17       	cp	r20, r23
     15e:	47 17       	cp	r20, r23
     160:	47 17       	cp	r20, r23
     162:	47 17       	cp	r20, r23
     164:	47 17       	cp	r20, r23
     166:	47 17       	cp	r20, r23
     168:	47 17       	cp	r20, r23
     16a:	ce 0e       	add	r12, r30
     16c:	2a 0f       	add	r18, r26
     16e:	4b 17       	cp	r20, r27
     170:	4b 17       	cp	r20, r27
     172:	34 0f       	add	r19, r20
     174:	41 0f       	add	r20, r17
     176:	4e 0f       	add	r20, r30
     178:	5b 0f       	add	r21, r27
     17a:	4b 17       	cp	r20, r27
     17c:	5f 0f       	add	r21, r31
     17e:	4b 17       	cp	r20, r27
     180:	6d 0f       	add	r22, r29
     182:	4b 17       	cp	r20, r27
     184:	77 0f       	add	r23, r23
     186:	81 0f       	add	r24, r17
     188:	b1 0f       	add	r27, r17
     18a:	4b 17       	cp	r20, r27
     18c:	4b 17       	cp	r20, r27
     18e:	4b 17       	cp	r20, r27
     190:	8b 0f       	add	r24, r27
     192:	98 0f       	add	r25, r24
     194:	a5 0f       	add	r26, r21
     196:	fb 15       	cp	r31, r11
     198:	10 16       	cp	r1, r16
     19a:	2f 16       	cp	r2, r31
     19c:	10 16       	cp	r1, r16
     19e:	35 16       	cp	r3, r21
     1a0:	4c 16       	cp	r4, r28
     1a2:	3b 16       	cp	r3, r27
     1a4:	45 16       	cp	r4, r21
     1a6:	61 16       	cp	r6, r17
     1a8:	6b 16       	cp	r6, r27
     1aa:	7a 16       	cp	r7, r26
     1ac:	9f 16       	cp	r9, r31
     1ae:	c3 16       	cp	r12, r19
     1b0:	d4 16       	cp	r13, r20
     1b2:	e6 16       	cp	r14, r22
     1b4:	f7 16       	cp	r15, r23
     1b6:	99 27       	eor	r25, r25
     1b8:	9f 27       	eor	r25, r31
     1ba:	a2 27       	eor	r26, r18
     1bc:	a7 27       	eor	r26, r23
     1be:	ac 27       	eor	r26, r28
     1c0:	ba 27       	eor	r27, r26
     1c2:	c8 27       	eor	r28, r24
     1c4:	65 28       	or	r6, r5
     1c6:	65 28       	or	r6, r5
     1c8:	65 28       	or	r6, r5
     1ca:	d6 27       	eor	r29, r22
     1cc:	d9 27       	eor	r29, r25
     1ce:	e2 27       	eor	r30, r18
     1d0:	eb 27       	eor	r30, r27
     1d2:	65 28       	or	r6, r5
     1d4:	65 28       	or	r6, r5
     1d6:	65 28       	or	r6, r5
     1d8:	65 28       	or	r6, r5
     1da:	65 28       	or	r6, r5
     1dc:	65 28       	or	r6, r5
     1de:	f9 27       	eor	r31, r25
     1e0:	09 28       	or	r0, r9
     1e2:	19 28       	or	r1, r9
     1e4:	27 28       	or	r2, r7
     1e6:	2a 28       	or	r2, r10
     1e8:	33 28       	or	r3, r3
     1ea:	3c 28       	or	r3, r12
     1ec:	43 28       	or	r4, r3
     1ee:	65 28       	or	r6, r5
     1f0:	65 28       	or	r6, r5
     1f2:	4c 28       	or	r4, r12
     1f4:	55 28       	or	r5, r5
     1f6:	68 34       	cpi	r22, 0x48	; 72
     1f8:	6d 34       	cpi	r22, 0x4D	; 77
     1fa:	72 34       	cpi	r23, 0x42	; 66
     1fc:	77 34       	cpi	r23, 0x47	; 71
     1fe:	7c 34       	cpi	r23, 0x4C	; 76
     200:	81 34       	cpi	r24, 0x41	; 65
     202:	86 34       	cpi	r24, 0x46	; 70
     204:	8b 34       	cpi	r24, 0x4B	; 75
     206:	90 34       	cpi	r25, 0x40	; 64
     208:	95 34       	cpi	r25, 0x45	; 69
     20a:	9a 34       	cpi	r25, 0x4A	; 74
     20c:	b3 34       	cpi	r27, 0x43	; 67
     20e:	9f 34       	cpi	r25, 0x4F	; 79
     210:	b3 34       	cpi	r27, 0x43	; 67
     212:	b3 34       	cpi	r27, 0x43	; 67
     214:	b3 34       	cpi	r27, 0x43	; 67
     216:	b3 34       	cpi	r27, 0x43	; 67
     218:	b3 34       	cpi	r27, 0x43	; 67
     21a:	b3 34       	cpi	r27, 0x43	; 67
     21c:	a9 34       	cpi	r26, 0x49	; 73
     21e:	a4 34       	cpi	r26, 0x44	; 68
     220:	ae 34       	cpi	r26, 0x4E	; 78
     222:	9c 37       	cpi	r25, 0x7C	; 124
     224:	a1 37       	cpi	r26, 0x71	; 113
     226:	a6 37       	cpi	r26, 0x76	; 118
     228:	ab 37       	cpi	r26, 0x7B	; 123
     22a:	b0 37       	cpi	r27, 0x70	; 112
     22c:	b5 37       	cpi	r27, 0x75	; 117
     22e:	ba 37       	cpi	r27, 0x7A	; 122
     230:	bf 37       	cpi	r27, 0x7F	; 127
     232:	c4 37       	cpi	r28, 0x74	; 116
     234:	08 4a       	sbci	r16, 0xA8	; 168
     236:	d7 3b       	cpi	r29, 0xB7	; 183
     238:	3b ce       	rjmp	.-906    	; 0xfffffeb0 <__eeprom_end+0xff7efeb0>
     23a:	01 6e       	ori	r16, 0xE1	; 225
     23c:	84 bc       	out	0x24, r8	; 36
     23e:	bf fd       	.word	0xfdbf	; ????
     240:	c1 2f       	mov	r28, r17
     242:	3d 6c       	ori	r19, 0xCD	; 205
     244:	74 31       	cpi	r23, 0x14	; 20
     246:	9a bd       	out	0x2a, r25	; 42
     248:	56 83       	std	Z+6, r21	; 0x06
     24a:	3d da       	rcall	.-2950   	; 0xfffff6c6 <__eeprom_end+0xff7ef6c6>
     24c:	3d 00       	.word	0x003d	; ????
     24e:	c7 7f       	andi	r28, 0xF7	; 247
     250:	11 be       	out	0x31, r1	; 49
     252:	d9 e4       	ldi	r29, 0x49	; 73
     254:	bb 4c       	sbci	r27, 0xCB	; 203
     256:	3e 91       	ld	r19, -X
     258:	6b aa       	std	Y+51, r6	; 0x33
     25a:	aa be       	out	0x3a, r10	; 58
     25c:	00 00       	nop
     25e:	00 80       	ld	r0, Z
     260:	3f 05       	cpc	r19, r15
     262:	a8 4c       	sbci	r26, 0xC8	; 200
     264:	cd b2       	in	r12, 0x1d	; 29
     266:	d4 4e       	sbci	r29, 0xE4	; 228
     268:	b9 38       	cpi	r27, 0x89	; 137
     26a:	36 a9       	ldd	r19, Z+54	; 0x36
     26c:	02 0c       	add	r0, r2
     26e:	50 b9       	out	0x00, r21	; 0
     270:	91 86       	std	Z+9, r9	; 0x09
     272:	88 08       	sbc	r8, r8
     274:	3c a6       	std	Y+44, r3	; 0x2c
     276:	aa aa       	std	Y+50, r10	; 0x32
     278:	2a be       	out	0x3a, r2	; 58
     27a:	00 00       	nop
     27c:	00 80       	ld	r0, Z
     27e:	3f 00       	.word	0x003f	; ????

00000280 <__trampolines_end>:
     280:	4a 6f       	ori	r20, 0xFA	; 250
     282:	67 46       	sbci	r22, 0x67	; 103
     284:	0d 0a       	sbc	r0, r29
	...

00000287 <__c.2349>:
     287:	4a 6f 67 00                                         Jog.

0000028b <__c.2725>:
     28b:	3e 0d 0a 00                                         >...

0000028f <__c.2723>:
     28f:	2c 52 58 3a 00                                      ,RX:.

00000294 <__c.2721>:
     294:	2c 42 75 66 3a 00                                   ,Buf:.

0000029a <__c.2716>:
     29a:	2c 00                                               ,.

0000029c <__c.2714>:
     29c:	2c 57 50 6f 73 3a 00                                ,WPos:.

000002a3 <__c.2709>:
     2a3:	2c 00                                               ,.

000002a5 <__c.2707>:
     2a5:	2c 4d 50 6f 73 3a 00                                ,MPos:.

000002ac <__c.2705>:
     2ac:	3c 4a 6f 67 00                                      <Jog.

000002b1 <__c.2702>:
     2b1:	3c 44 6f 6f 72 00                                   <Door.

000002b7 <__c.2699>:
     2b7:	3c 43 68 65 63 6b 00                                <Check.

000002be <__c.2696>:
     2be:	3c 41 6c 61 72 6d 00                                <Alarm.

000002c5 <__c.2693>:
     2c5:	3c 48 6f 6d 65 00                                   <Home.

000002cb <__c.2690>:
     2cb:	3c 48 6f 6c 64 00                                   <Hold.

000002d1 <__c.2687>:
     2d1:	3c 52 75 6e 00                                      <Run.

000002d6 <__c.2682>:
     2d6:	3c 49 64 6c 65 00                                   <Idle.

000002dc <__c.2674>:
     2dc:	5d 0d 0a 00                                         ]...

000002e0 <__c.2672>:
     2e0:	5b 30 2e 39 68 2f 47 52 42 4c 2d 4a 4f 47 2e 32     [0.9h/GRBL-JOG.2
     2f0:	30 31 35 30 32 31 30 3a 00                          0150210:.

000002f9 <__c.2667>:
     2f9:	0d 0a 00                                            ...

000002fc <__c.2665>:
     2fc:	3d 00                                               =.

000002fe <__c.2663>:
     2fe:	24 4e 00                                            $N.

00000301 <__c.2657>:
     301:	5d 0d 0a 00                                         ]...

00000305 <__c.2655>:
     305:	20 46 00                                             F.

00000308 <__c.2653>:
     308:	20 54 00                                             T.

0000030b <__c.2651>:
     30b:	20 4d 38 00                                          M8.

0000030f <__c.2647>:
     30f:	20 4d 39 00                                          M9.

00000313 <__c.2644>:
     313:	20 4d 35 00                                          M5.

00000317 <__c.2641>:
     317:	20 4d 34 00                                          M4.

0000031b <__c.2637>:
     31b:	20 4d 33 00                                          M3.

0000031f <__c.2634>:
     31f:	20 4d 32 00                                          M2.

00000323 <__c.2631>:
     323:	20 4d 31 00                                          M1.

00000327 <__c.2627>:
     327:	20 4d 30 00                                          M0.

0000032b <__c.2624>:
     32b:	20 47 39 34 00                                       G94.

00000330 <__c.2622>:
     330:	20 47 39 33 00                                       G93.

00000335 <__c.2620>:
     335:	20 47 39 31 00                                       G91.

0000033a <__c.2618>:
     33a:	20 47 39 30 00                                       G90.

0000033f <__c.2616>:
     33f:	20 47 32 30 00                                       G20.

00000344 <__c.2614>:
     344:	20 47 32 31 00                                       G21.

00000349 <__c.2612>:
     349:	20 47 31 39 00                                       G19.

0000034e <__c.2609>:
     34e:	20 47 31 38 00                                       G18.

00000353 <__c.2605>:
     353:	20 47 31 37 00                                       G17.

00000358 <__c.2602>:
     358:	20 47 00                                             G.

0000035b <__c.2600>:
     35b:	47 38 30 00                                         G80.

0000035f <__c.2597>:
     35f:	47 33 38 2e 35 00                                   G38.5.

00000365 <__c.2594>:
     365:	47 33 38 2e 34 00                                   G38.4.

0000036b <__c.2591>:
     36b:	47 33 38 2e 33 00                                   G38.3.

00000371 <__c.2588>:
     371:	47 33 38 2e 32 00                                   G38.2.

00000377 <__c.2585>:
     377:	47 33 00                                            G3.

0000037a <__c.2582>:
     37a:	47 32 00                                            G2.

0000037d <__c.2579>:
     37d:	47 31 00                                            G1.

00000380 <__c.2575>:
     380:	47 30 00                                            G0.

00000383 <__c.2572>:
     383:	5b 00                                               [.

00000385 <__c.2568>:
     385:	5d 0d 0a 00                                         ]...

00000389 <__c.2566>:
     389:	5b 54 4c 4f 3a 00                                   [TLO:.

0000038f <__c.2561>:
     38f:	5d 0d 0a 00                                         ]...

00000393 <__c.2559>:
     393:	2c 00                                               ,.

00000395 <__c.2557>:
     395:	5b 47 39 32 3a 00                                   [G92:.

0000039b <__c.2549>:
     39b:	5d 0d 0a 00                                         ]...

0000039f <__c.2547>:
     39f:	2c 00                                               ,.

000003a1 <__c.2545>:
     3a1:	3a 00                                               :.

000003a3 <__c.2542>:
     3a3:	33 30 00                                            30.

000003a6 <__c.2538>:
     3a6:	32 38 00                                            28.

000003a9 <__c.2535>:
     3a9:	5b 47 00                                            [G.

000003ac <__c.2528>:
     3ac:	5d 0d 0a 00                                         ]...

000003b0 <__c.2526>:
     3b0:	3a 00                                               :.

000003b2 <__c.2521>:
     3b2:	2c 00                                               ,.

000003b4 <__c.2519>:
     3b4:	5b 50 52 42 3a 00                                   [PRB:.

000003ba <__c.2507>:
     3ba:	29 0d 0a 00                                         )...

000003be <__c.2505>:
     3be:	20 6d 61 78 20 74 72 61 76 65 6c 2c 20 6d 6d 00      max travel, mm.

000003ce <__c.2502>:
     3ce:	20 61 63 63 65 6c 2c 20 6d 6d 2f 73 65 63 5e 32      accel, mm/sec^2
	...

000003df <__c.2499>:
     3df:	20 6d 61 78 20 72 61 74 65 2c 20 6d 6d 2f 6d 69      max rate, mm/mi
     3ef:	6e 00                                               n.

000003f1 <__c.2495>:
     3f1:	2c 20 73 74 65 70 2f 6d 6d 00                       , step/mm.

000003fb <__c.2492>:
     3fb:	7a 00                                               z.

000003fd <__c.2489>:
     3fd:	79 00                                               y.

000003ff <__c.2485>:
     3ff:	78 00                                               x.

00000401 <__c.2482>:
     401:	20 28 00                                             (.

00000404 <__c.2475>:
     404:	3d 00                                               =.

00000406 <__c.2473>:
     406:	24 00                                               $.

00000408 <__c.2468>:
     408:	20 28 5a 20 7a 65 72 6f 20 67 61 75 67 65 2c 20      (Z zero gauge, 
     418:	6d 6d 29 0d 0a 00                                   mm)...

0000041e <__c.2466>:
     41e:	20 28 5a 20 7a 65 72 6f 20 70 75 6c 6c 2d 6f 66      (Z zero pull-of
     42e:	66 2c 20 6d 6d 29 0d 0a 24 33 31 3d 00              f, mm)..$31=.

0000043b <__c.2464>:
     43b:	20 28 68 6f 6d 69 6e 67 20 70 75 6c 6c 2d 6f 66      (homing pull-of
     44b:	66 2c 20 6d 6d 29 0d 0a 24 33 30 3d 00              f, mm)..$30=.

00000458 <__c.2462>:
     458:	20 28 68 6f 6d 69 6e 67 20 64 65 62 6f 75 6e 63      (homing debounc
     468:	65 2c 20 6d 73 65 63 29 0d 0a 24 32 37 3d 00        e, msec)..$27=.

00000477 <__c.2460>:
     477:	20 28 68 6f 6d 69 6e 67 20 73 65 65 6b 2c 20 6d      (homing seek, m
     487:	6d 2f 6d 69 6e 29 0d 0a 24 32 36 3d 00              m/min)..$26=.

00000494 <__c.2458>:
     494:	20 28 68 6f 6d 69 6e 67 20 66 65 65 64 2c 20 6d      (homing feed, m
     4a4:	6d 2f 6d 69 6e 29 0d 0a 24 32 35 3d 00              m/min)..$25=.

000004b1 <__c.2456>:
     4b1:	29 0d 0a 24 32 34 3d 00                             )..$24=.

000004b9 <__c.2454>:
     4b9:	20 28 68 6f 6d 69 6e 67 20 64 69 72 20 69 6e 76      (homing dir inv
     4c9:	65 72 74 20 6d 61 73 6b 3a 00                       ert mask:.

000004d3 <__c.2452>:
     4d3:	20 28 68 6f 6d 69 6e 67 20 63 79 63 6c 65 2c 20      (homing cycle, 
     4e3:	62 6f 6f 6c 29 0d 0a 24 32 33 3d 00                 bool)..$23=.

000004ef <__c.2450>:
     4ef:	20 28 68 61 72 64 20 6c 69 6d 69 74 73 2c 20 62      (hard limits, b
     4ff:	6f 6f 6c 29 0d 0a 24 32 32 3d 00                    ool)..$22=.

0000050a <__c.2448>:
     50a:	20 28 73 6f 66 74 20 6c 69 6d 69 74 73 2c 20 62      (soft limits, b
     51a:	6f 6f 6c 29 0d 0a 24 32 31 3d 00                    ool)..$21=.

00000525 <__c.2446>:
     525:	20 28 72 65 70 6f 72 74 20 69 6e 63 68 65 73 2c      (report inches,
     535:	20 62 6f 6f 6c 29 0d 0a 24 32 30 3d 00               bool)..$20=.

00000542 <__c.2444>:
     542:	20 28 61 72 63 20 74 6f 6c 65 72 61 6e 63 65 2c      (arc tolerance,
     552:	20 6d 6d 29 0d 0a 24 31 33 3d 00                     mm)..$13=.

0000055d <__c.2442>:
     55d:	20 28 6a 75 6e 63 74 69 6f 6e 20 64 65 76 69 61      (junction devia
     56d:	74 69 6f 6e 2c 20 6d 6d 29 0d 0a 24 31 32 3d 00     tion, mm)..$12=.

0000057d <__c.2440>:
     57d:	29 0d 0a 24 31 31 3d 00                             )..$11=.

00000585 <__c.2438>:
     585:	20 28 73 74 61 74 75 73 20 72 65 70 6f 72 74 20      (status report 
     595:	6d 61 73 6b 3a 00                                   mask:.

0000059b <__c.2436>:
     59b:	20 28 70 72 6f 62 65 20 70 69 6e 20 69 6e 76 65      (probe pin inve
     5ab:	72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 31 30 3d 00     rt, bool)..$10=.

000005bb <__c.2434>:
     5bb:	20 28 6c 69 6d 69 74 20 70 69 6e 73 20 69 6e 76      (limit pins inv
     5cb:	65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 36 3d 00     ert, bool)..$6=.

000005db <__c.2432>:
     5db:	20 28 73 74 65 70 20 65 6e 61 62 6c 65 20 69 6e      (step enable in
     5eb:	76 65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 35 3d     vert, bool)..$5=
	...

000005fc <__c.2430>:
     5fc:	29 0d 0a 24 34 3d 00                                )..$4=.

00000603 <__c.2428>:
     603:	20 28 64 69 72 20 70 6f 72 74 20 69 6e 76 65 72      (dir port inver
     613:	74 20 6d 61 73 6b 3a 00                             t mask:.

0000061b <__c.2426>:
     61b:	29 0d 0a 24 33 3d 00                                )..$3=.

00000622 <__c.2424>:
     622:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     632:	72 74 20 6d 61 73 6b 3a 00                          rt mask:.

0000063b <__c.2422>:
     63b:	20 28 73 74 65 70 20 69 64 6c 65 20 64 65 6c 61      (step idle dela
     64b:	79 2c 20 6d 73 65 63 29 0d 0a 24 32 3d 00           y, msec)..$2=.

00000659 <__c.2420>:
     659:	20 28 73 74 65 70 20 70 75 6c 73 65 2c 20 75 73      (step pulse, us
     669:	65 63 29 0d 0a 24 31 3d 00                          ec)..$1=.

00000672 <__c.2418>:
     672:	24 30 3d 00                                         $0=.

00000676 <__c.2414>:
     676:	24 24 20 28 76 69 65 77 20 47 72 62 6c 20 73 65     $$ (view Grbl se
     686:	74 74 69 6e 67 73 29 0d 0a 24 23 20 28 76 69 65     ttings)..$# (vie
     696:	77 20 23 20 70 61 72 61 6d 65 74 65 72 73 29 0d     w # parameters).
     6a6:	0a 24 47 20 28 76 69 65 77 20 70 61 72 73 65 72     .$G (view parser
     6b6:	20 73 74 61 74 65 29 0d 0a 24 49 20 28 76 69 65      state)..$I (vie
     6c6:	77 20 62 75 69 6c 64 20 69 6e 66 6f 29 0d 0a 24     w build info)..$
     6d6:	4e 20 28 76 69 65 77 20 73 74 61 72 74 75 70 20     N (view startup 
     6e6:	62 6c 6f 63 6b 73 29 0d 0a 24 78 3d 76 61 6c 75     blocks)..$x=valu
     6f6:	65 20 28 73 61 76 65 20 47 72 62 6c 20 73 65 74     e (save Grbl set
     706:	74 69 6e 67 29 0d 0a 24 4e 78 3d 6c 69 6e 65 20     ting)..$Nx=line 
     716:	28 73 61 76 65 20 73 74 61 72 74 75 70 20 62 6c     (save startup bl
     726:	6f 63 6b 29 0d 0a 24 43 20 28 63 68 65 63 6b 20     ock)..$C (check 
     736:	67 63 6f 64 65 20 6d 6f 64 65 29 0d 0a 24 58 20     gcode mode)..$X 
     746:	28 6b 69 6c 6c 20 61 6c 61 72 6d 20 6c 6f 63 6b     (kill alarm lock
     756:	29 0d 0a 24 48 20 28 72 75 6e 20 68 6f 6d 69 6e     )..$H (run homin
     766:	67 20 63 79 63 6c 65 29 0d 0a 7e 20 28 63 79 63     g cycle)..~ (cyc
     776:	6c 65 20 73 74 61 72 74 29 0d 0a 21 20 28 66 65     le start)..! (fe
     786:	65 64 20 68 6f 6c 64 29 0d 0a 3f 20 28 63 75 72     ed hold)..? (cur
     796:	72 65 6e 74 20 73 74 61 74 75 73 29 0d 0a 63 74     rent status)..ct
     7a6:	72 6c 2d 78 20 28 72 65 73 65 74 20 47 72 62 6c     rl-x (reset Grbl
     7b6:	29 0d 0a 00                                         )...

000007ba <__c.2410>:
     7ba:	0d 0a 47 72 62 6c 20 30 2e 39 68 2f 47 52 42 4c     ..Grbl 0.9h/GRBL
     7ca:	2d 4a 4f 47 20 5b 27 24 27 20 66 6f 72 20 68 65     -JOG ['$' for he
     7da:	6c 70 5d 0d 0a 00                                   lp]...

000007e0 <__c.2406>:
     7e0:	5d 0d 0a 00                                         ]...

000007e4 <__c.2404>:
     7e4:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

000007ef <__c.2401>:
     7ef:	44 69 73 61 62 6c 65 64 00                          Disabled.

000007f8 <__c.2398>:
     7f8:	45 6e 61 62 6c 65 64 00                             Enabled.

00000800 <__c.2395>:
     800:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     810:	64 00                                               d.

00000812 <__c.2392>:
     812:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     822:	6f 63 6b 00                                         ock.

00000826 <__c.2388>:
     826:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     836:	65 00                                               e.

00000838 <__c.2385>:
     838:	5b 00                                               [.

0000083a <__c.2380>:
     83a:	0d 0a 00                                            ...

0000083d <__c.2378>:
     83d:	50 72 6f 62 65 20 66 61 69 6c 00                    Probe fail.

00000848 <__c.2375>:
     848:	41 62 6f 72 74 20 64 75 72 69 6e 67 20 63 79 63     Abort during cyc
     858:	6c 65 00                                            le.

0000085b <__c.2372>:
     85b:	53 6f 66 74 20 6c 69 6d 69 74 00                    Soft limit.

00000866 <__c.2368>:
     866:	48 61 72 64 20 6c 69 6d 69 74 00                    Hard limit.

00000871 <__c.2365>:
     871:	41 4c 41 52 4d 3a 20 00                             ALARM: .

00000879 <__c.2360>:
     879:	0d 0a 00                                            ...

0000087c <__c.2358>:
     87c:	49 6e 76 61 6c 69 64 20 67 63 6f 64 65 20 49 44     Invalid gcode ID
     88c:	3a 00                                               :.

0000088e <__c.2355>:
     88e:	55 6e 64 65 66 69 6e 65 64 20 66 65 65 64 20 72     Undefined feed r
     89e:	61 74 65 00                                         ate.

000008a2 <__c.2352>:
     8a2:	55 6e 73 75 70 70 6f 72 74 65 64 20 63 6f 6d 6d     Unsupported comm
     8b2:	61 6e 64 00                                         and.

000008b6 <__c.2349>:
     8b6:	4d 6f 64 61 6c 20 67 72 6f 75 70 20 76 69 6f 6c     Modal group viol
     8c6:	61 74 69 6f 6e 00                                   ation.

000008cc <__c.2346>:
     8cc:	4a 6f 67 67 69 6e 67 20 6f 6e 67 6f 69 6e 67 3b     Jogging ongoing;
     8dc:	20 49 67 6e 6f 72 69 6e 67 20 47 43 6f 64 65 00      Ignoring GCode.

000008ec <__c.2343>:
     8ec:	4c 69 6e 65 20 6f 76 65 72 66 6c 6f 77 00           Line overflow.

000008fa <__c.2340>:
     8fa:	48 6f 6d 69 6e 67 20 6e 6f 74 20 65 6e 61 62 6c     Homing not enabl
     90a:	65 64 00                                            ed.

0000090d <__c.2337>:
     90d:	41 6c 61 72 6d 20 6c 6f 63 6b 00                    Alarm lock.

00000918 <__c.2334>:
     918:	4e 6f 74 20 69 64 6c 65 00                          Not idle.

00000921 <__c.2331>:
     921:	45 45 50 52 4f 4d 20 72 65 61 64 20 66 61 69 6c     EEPROM read fail
     931:	2e 20 55 73 69 6e 67 20 64 65 66 61 75 6c 74 73     . Using defaults
	...

00000942 <__c.2328>:
     942:	56 61 6c 75 65 20 3c 20 33 20 75 73 65 63 00        Value < 3 usec.

00000951 <__c.2325>:
     951:	53 65 74 74 69 6e 67 20 64 69 73 61 62 6c 65 64     Setting disabled
	...

00000962 <__c.2322>:
     962:	56 61 6c 75 65 20 3c 20 30 00                       Value < 0.

0000096c <__c.2319>:
     96c:	49 6e 76 61 6c 69 64 20 73 74 61 74 65 6d 65 6e     Invalid statemen
     97c:	74 00                                               t.

0000097e <__c.2316>:
     97e:	42 61 64 20 6e 75 6d 62 65 72 20 66 6f 72 6d 61     Bad number forma
     98e:	74 00                                               t.

00000990 <__c.2312>:
     990:	45 78 70 65 63 74 65 64 20 63 6f 6d 6d 61 6e 64     Expected command
     9a0:	20 6c 65 74 74 65 72 00                              letter.

000009a8 <__c.2309>:
     9a8:	65 72 72 6f 72 3a 20 00                             error: .

000009b0 <__c.2307>:
     9b0:	6f 6b 0d 0a 00 00                                   ok....

000009b6 <__ctors_end>:
     9b6:	11 24       	eor	r1, r1
     9b8:	1f be       	out	0x3f, r1	; 63
     9ba:	cf ef       	ldi	r28, 0xFF	; 255
     9bc:	d0 e1       	ldi	r29, 0x10	; 16
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	cd bf       	out	0x3d, r28	; 61

000009c2 <__do_copy_data>:
     9c2:	11 e0       	ldi	r17, 0x01	; 1
     9c4:	a0 e0       	ldi	r26, 0x00	; 0
     9c6:	b1 e0       	ldi	r27, 0x01	; 1
     9c8:	e2 e1       	ldi	r30, 0x12	; 18
     9ca:	f0 e8       	ldi	r31, 0x80	; 128
     9cc:	02 c0       	rjmp	.+4      	; 0x9d2 <__do_copy_data+0x10>
     9ce:	05 90       	lpm	r0, Z+
     9d0:	0d 92       	st	X+, r0
     9d2:	a0 30       	cpi	r26, 0x00	; 0
     9d4:	b1 07       	cpc	r27, r17
     9d6:	d9 f7       	brne	.-10     	; 0x9ce <__do_copy_data+0xc>

000009d8 <__do_clear_bss>:
     9d8:	29 e0       	ldi	r18, 0x09	; 9
     9da:	a0 e0       	ldi	r26, 0x00	; 0
     9dc:	b1 e0       	ldi	r27, 0x01	; 1
     9de:	01 c0       	rjmp	.+2      	; 0x9e2 <.do_clear_bss_start>

000009e0 <.do_clear_bss_loop>:
     9e0:	1d 92       	st	X+, r1

000009e2 <.do_clear_bss_start>:
     9e2:	a5 35       	cpi	r26, 0x55	; 85
     9e4:	b2 07       	cpc	r27, r18
     9e6:	e1 f7       	brne	.-8      	; 0x9e0 <.do_clear_bss_loop>
     9e8:	0e 94 1d 08 	call	0x103a	; 0x103a <main>
     9ec:	0c 94 07 40 	jmp	0x800e	; 0x800e <_exit>

000009f0 <__bad_interrupt>:
     9f0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000009f4 <jog_init>:
#define ADMUX_init  0x20  // ADLAR =1 (left adjusted, 8-Bit-Result on ADCH)

void jog_init() {
	// Initialize jog switch port bits and DDR
	#ifdef LED_PRESENT
	LED_DDR |= ((1<<LED_RUN_BIT) | (1<<LED_ERROR_BIT));
     9f4:	87 b1       	in	r24, 0x07	; 7
     9f6:	80 63       	ori	r24, 0x30	; 48
     9f8:	87 b9       	out	0x07, r24	; 7
	LED_PORT |= ((1<<LED_RUN_BIT) | (1<<LED_ERROR_BIT)); // active low, so set high
     9fa:	88 b1       	in	r24, 0x08	; 8
     9fc:	80 63       	ori	r24, 0x30	; 48
     9fe:	88 b9       	out	0x08, r24	; 8
	#endif
	JOGSW_DDR &= ~(JOGSW_MASK); // Set as input pins
     a00:	81 b1       	in	r24, 0x01	; 1
     a02:	80 78       	andi	r24, 0x80	; 128
     a04:	81 b9       	out	0x01, r24	; 1
	JOGSW_PORT |= (JOGSW_MASK); // Enable internal pull-up resistors. Active low operation.
     a06:	82 b1       	in	r24, 0x02	; 2
     a08:	8f 67       	ori	r24, 0x7F	; 127
     a0a:	82 b9       	out	0x02, r24	; 2

	CONTROL_DDR &= ~(1<<SPIN_TOGGLE);  // Set as input pin
     a0c:	3b 98       	cbi	0x07, 3	; 7
	CONTROL_PORT|= (1<<SPIN_TOGGLE);   // Pullup
     a0e:	43 9a       	sbi	0x08, 3	; 8
	
	ADCSRA = ADCSRA_init;
     a10:	ea e7       	ldi	r30, 0x7A	; 122
     a12:	f0 e0       	ldi	r31, 0x00	; 0
     a14:	83 e8       	ldi	r24, 0x83	; 131
     a16:	80 83       	st	Z, r24
	ADMUX = ADMUX_init | JOG_POT;     // Kanal, ADLAR =1 (left adjustet, 8-Bit-Result on ADCH)
     a18:	87 e2       	ldi	r24, 0x27	; 39
     a1a:	80 93 7c 00 	sts	0x007C, r24
	
	ADCSRA |= (1<<ADSC);
     a1e:	80 81       	ld	r24, Z
     a20:	80 64       	ori	r24, 0x40	; 64
     a22:	80 83       	st	Z, r24
	while (ADCSRA & (1<<ADSC) ) {}         // wait until initial conversion is done
     a24:	80 81       	ld	r24, Z
     a26:	86 fd       	sbrc	r24, 6
     a28:	fd cf       	rjmp	.-6      	; 0xa24 <jog_init+0x30>
	(void) ADCH; // ADCH needs to be read one time
     a2a:	80 91 79 00 	lds	r24, 0x0079
     a2e:	08 95       	ret

00000a30 <jog_btn_release>:
}

void jog_btn_release() {
     a30:	cf 93       	push	r28
	uint8_t jog_bits;
	do {
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     a32:	c0 b1       	in	r28, 0x00	; 0
		protocol_process(); // process the serial protocol while waiting
     a34:	0e 94 3c 1a 	call	0x3478	; 0x3478 <protocol_process>
		protocol_execute_realtime();
     a38:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
}

void jog_btn_release() {
	uint8_t jog_bits;
	do {
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     a3c:	c0 95       	com	r28
     a3e:	cf 77       	andi	r28, 0x7F	; 127
		protocol_process(); // process the serial protocol while waiting
		protocol_execute_realtime();
	}
	while (jog_bits); // until released
     a40:	c1 f7       	brne	.-16     	; 0xa32 <jog_btn_release+0x2>
}
     a42:	cf 91       	pop	r28
     a44:	08 95       	ret

00000a46 <spindle_btn_release>:

void spindle_btn_release() {
     a46:	cf 93       	push	r28
	uint8_t spindle_bits;
	do {
		spindle_bits = (~CONTROL_PIN) & (1<<SPIN_TOGGLE); // active low
     a48:	c6 b1       	in	r28, 0x06	; 6
		protocol_process(); // process the serial protocol while waiting
     a4a:	0e 94 3c 1a 	call	0x3478	; 0x3478 <protocol_process>
		protocol_execute_realtime();
     a4e:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
	}
	while (spindle_bits); // until released
     a52:	c3 ff       	sbrs	r28, 3
     a54:	f9 cf       	rjmp	.-14     	; 0xa48 <spindle_btn_release+0x2>
}
     a56:	cf 91       	pop	r28
     a58:	08 95       	ret

00000a5a <jogging>:

void jogging()
// Tests jog port pins and moves steppers
{
     a5a:	2f 92       	push	r2
     a5c:	3f 92       	push	r3
     a5e:	4f 92       	push	r4
     a60:	5f 92       	push	r5
     a62:	6f 92       	push	r6
     a64:	7f 92       	push	r7
     a66:	8f 92       	push	r8
     a68:	9f 92       	push	r9
     a6a:	af 92       	push	r10
     a6c:	bf 92       	push	r11
     a6e:	cf 92       	push	r12
     a70:	df 92       	push	r13
     a72:	ef 92       	push	r14
     a74:	ff 92       	push	r15
     a76:	0f 93       	push	r16
     a78:	1f 93       	push	r17
     a7a:	cf 93       	push	r28
     a7c:	df 93       	push	r29
     a7e:	cd b7       	in	r28, 0x3d	; 61
     a80:	de b7       	in	r29, 0x3e	; 62
     a82:	69 97       	sbiw	r28, 0x19	; 25
     a84:	0f b6       	in	r0, 0x3f	; 63
     a86:	f8 94       	cli
     a88:	de bf       	out	0x3e, r29	; 62
     a8a:	0f be       	out	0x3f, r0	; 63
     a8c:	cd bf       	out	0x3d, r28	; 61
	uint8_t i, spindle_bits;
	
	uint32_t dest_step_rate, step_rate, step_delay; // Step delay after pulse
	float work_position, mm_per_step;

	switch (sys.state) {
     a8e:	80 90 68 07 	lds	r8, 0x0768
     a92:	8b 8a       	std	Y+19, r8	; 0x13
     a94:	28 2d       	mov	r18, r8
     a96:	24 30       	cpi	r18, 0x04	; 4
     a98:	09 f4       	brne	.+2      	; 0xa9c <jogging+0x42>
     a9a:	b6 c2       	rjmp	.+1388   	; 0x1008 <jogging+0x5ae>
     a9c:	28 30       	cpi	r18, 0x08	; 8
     a9e:	09 f4       	brne	.+2      	; 0xaa2 <jogging+0x48>
     aa0:	b3 c2       	rjmp	.+1382   	; 0x1008 <jogging+0x5ae>
	}
	last_sys_state = sys.state;


	spindle_bits = (~CONTROL_PIN) & (1<<SPIN_TOGGLE); // active low
	if (spindle_bits) {
     aa2:	33 99       	sbic	0x06, 3	; 6
     aa4:	15 c0       	rjmp	.+42     	; 0xad0 <jogging+0x76>
		if (bit_istrue(SPINDLE_ENABLE_PORT,bit(SPINDLE_ENABLE_BIT))) {
     aa6:	47 9b       	sbis	0x08, 7	; 8
     aa8:	07 c0       	rjmp	.+14     	; 0xab8 <jogging+0x5e>
			//      gc.spindle_direction = 0;
			spindle_run(0, 0.0);
     aaa:	40 e0       	ldi	r20, 0x00	; 0
     aac:	50 e0       	ldi	r21, 0x00	; 0
     aae:	ba 01       	movw	r22, r20
     ab0:	80 e0       	ldi	r24, 0x00	; 0
     ab2:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <spindle_run>
     ab6:	06 c0       	rjmp	.+12     	; 0xac4 <jogging+0x6a>
		}
		else {
			//      gc.spindle_direction = 1;   // also update gcode spindle status
			spindle_run(1, 0.0);
     ab8:	40 e0       	ldi	r20, 0x00	; 0
     aba:	50 e0       	ldi	r21, 0x00	; 0
     abc:	ba 01       	movw	r22, r20
     abe:	81 e0       	ldi	r24, 0x01	; 1
     ac0:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <spindle_run>
		}
		spindle_btn_release();
     ac4:	0e 94 23 05 	call	0xa46	; 0xa46 <spindle_btn_release>
		delay_ms(20);
     ac8:	84 e1       	ldi	r24, 0x14	; 20
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <delay_ms>
	}

	jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     ad0:	80 b1       	in	r24, 0x00	; 0
     ad2:	80 95       	com	r24
     ad4:	38 2f       	mov	r19, r24
     ad6:	3f 77       	andi	r19, 0x7F	; 127
     ad8:	3a 8b       	std	Y+18, r19	; 0x12
	if (!jog_bits) { return; }  // nothing pressed
     ada:	33 23       	and	r19, r19
     adc:	09 f4       	brne	.+2      	; 0xae0 <jogging+0x86>
     ade:	94 c2       	rjmp	.+1320   	; 0x1008 <jogging+0x5ae>
	
	// At least one jog/joystick switch is active
	if (jog_bits & (1<<JOG_ZERO)) {     // Zero-Button gedrückt
     ae0:	86 ff       	sbrs	r24, 6
     ae2:	a1 c0       	rjmp	.+322    	; 0xc26 <jogging+0x1cc>
		jog_btn_release();
     ae4:	0e 94 18 05 	call	0xa30	; 0xa30 <jog_btn_release>
		sys.state = last_sys_state;
     ae8:	8b 88       	ldd	r8, Y+19	; 0x13
     aea:	80 92 68 07 	sts	0x0768, r8
		if (bit_isfalse(CONTROL_PIN,bit(RESET_BIT))) { // RESET und zusätzlich ZERO gedrückt: Homing
     aee:	30 99       	sbic	0x06, 0	; 6
     af0:	13 c0       	rjmp	.+38     	; 0xb18 <jogging+0xbe>
			if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) {
     af2:	80 91 3c 09 	lds	r24, 0x093C
     af6:	84 ff       	sbrs	r24, 4
     af8:	87 c2       	rjmp	.+1294   	; 0x1008 <jogging+0x5ae>
				// Only perform homing if Grbl is idle or lost.
				if ( sys.state==STATE_IDLE || sys.state==STATE_ALARM ) {
     afa:	28 2d       	mov	r18, r8
     afc:	22 30       	cpi	r18, 0x02	; 2
     afe:	08 f0       	brcs	.+2      	; 0xb02 <jogging+0xa8>
     b00:	83 c2       	rjmp	.+1286   	; 0x1008 <jogging+0x5ae>
					mc_homing_cycle();
     b02:	0e 94 12 0c 	call	0x1824	; 0x1824 <mc_homing_cycle>
					if (!sys.abort) { 
     b06:	80 91 67 07 	lds	r24, 0x0767
     b0a:	81 11       	cpse	r24, r1
     b0c:	7d c2       	rjmp	.+1274   	; 0x1008 <jogging+0x5ae>
						sys.state = STATE_IDLE; // Set to IDLE when complete.
     b0e:	10 92 68 07 	sts	0x0768, r1
						st_go_idle(); // Set steppers to the settings idle state before returning.
     b12:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <st_go_idle>
     b16:	78 c2       	rjmp	.+1264   	; 0x1008 <jogging+0x5ae>
				}
			}
		} 
		else { // Zero current work position

			plan_sync_position();
     b18:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <plan_sync_position>
			gc_sync_position();
     b1c:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <gc_sync_position>
     b20:	0e e9       	ldi	r16, 0x9E	; 158
     b22:	17 e0       	ldi	r17, 0x07	; 7
     b24:	0f 2e       	mov	r0, r31
     b26:	fa ea       	ldi	r31, 0xAA	; 170
     b28:	ef 2e       	mov	r14, r31
     b2a:	f7 e0       	ldi	r31, 0x07	; 7
     b2c:	ff 2e       	mov	r15, r31
     b2e:	f0 2d       	mov	r31, r0
			//                            position in mm. Loaded from EEPROM when called.
			//      gc.coord_offset[i]    Retains the G92 coordinate offset (work coordinates) relative to
			//                            machine zero in mm. Non-persistent. Cleared upon reset and boot.

			for (i=0; i<=2; i++) { // Axes indices are consistent, so loop may be used.
				gc_state.coord_offset[i] = gc_state.position[i] - gc_state.coord_system[i];
     b30:	f8 01       	movw	r30, r16
     b32:	61 91       	ld	r22, Z+
     b34:	71 91       	ld	r23, Z+
     b36:	81 91       	ld	r24, Z+
     b38:	91 91       	ld	r25, Z+
     b3a:	8f 01       	movw	r16, r30
     b3c:	20 85       	ldd	r18, Z+8	; 0x08
     b3e:	31 85       	ldd	r19, Z+9	; 0x09
     b40:	42 85       	ldd	r20, Z+10	; 0x0a
     b42:	53 85       	ldd	r21, Z+11	; 0x0b
     b44:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
     b48:	f8 01       	movw	r30, r16
     b4a:	64 8b       	std	Z+20, r22	; 0x14
     b4c:	75 8b       	std	Z+21, r23	; 0x15
     b4e:	86 8b       	std	Z+22, r24	; 0x16
     b50:	97 8b       	std	Z+23, r25	; 0x17
			//      gc.coord_system[i]    Current work coordinate system (G54+). Stores offset from absolute machine
			//                            position in mm. Loaded from EEPROM when called.
			//      gc.coord_offset[i]    Retains the G92 coordinate offset (work coordinates) relative to
			//                            machine zero in mm. Non-persistent. Cleared upon reset and boot.

			for (i=0; i<=2; i++) { // Axes indices are consistent, so loop may be used.
     b52:	0e 15       	cp	r16, r14
     b54:	1f 05       	cpc	r17, r15
     b56:	61 f7       	brne	.-40     	; 0xb30 <jogging+0xd6>
				gc_state.coord_offset[i] = gc_state.position[i] - gc_state.coord_system[i];
			}

			// Z-Achse um bestimmten Betrag zurückziehen
			float xyz[3] = {gc_state.position[X_AXIS], gc_state.position[Y_AXIS], gc_state.position[Z_AXIS] + settings.z_zero_pulloff};
     b58:	80 91 9e 07 	lds	r24, 0x079E
     b5c:	90 91 9f 07 	lds	r25, 0x079F
     b60:	a0 91 a0 07 	lds	r26, 0x07A0
     b64:	b0 91 a1 07 	lds	r27, 0x07A1
     b68:	89 83       	std	Y+1, r24	; 0x01
     b6a:	9a 83       	std	Y+2, r25	; 0x02
     b6c:	ab 83       	std	Y+3, r26	; 0x03
     b6e:	bc 83       	std	Y+4, r27	; 0x04
     b70:	80 91 a2 07 	lds	r24, 0x07A2
     b74:	90 91 a3 07 	lds	r25, 0x07A3
     b78:	a0 91 a4 07 	lds	r26, 0x07A4
     b7c:	b0 91 a5 07 	lds	r27, 0x07A5
     b80:	8d 83       	std	Y+5, r24	; 0x05
     b82:	9e 83       	std	Y+6, r25	; 0x06
     b84:	af 83       	std	Y+7, r26	; 0x07
     b86:	b8 87       	std	Y+8, r27	; 0x08
     b88:	06 ea       	ldi	r16, 0xA6	; 166
     b8a:	17 e0       	ldi	r17, 0x07	; 7
     b8c:	20 91 4c 09 	lds	r18, 0x094C
     b90:	30 91 4d 09 	lds	r19, 0x094D
     b94:	40 91 4e 09 	lds	r20, 0x094E
     b98:	50 91 4f 09 	lds	r21, 0x094F
     b9c:	f8 01       	movw	r30, r16
     b9e:	60 81       	ld	r22, Z
     ba0:	71 81       	ldd	r23, Z+1	; 0x01
     ba2:	82 81       	ldd	r24, Z+2	; 0x02
     ba4:	93 81       	ldd	r25, Z+3	; 0x03
     ba6:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
     baa:	69 87       	std	Y+9, r22	; 0x09
     bac:	7a 87       	std	Y+10, r23	; 0x0a
     bae:	8b 87       	std	Y+11, r24	; 0x0b
     bb0:	9c 87       	std	Y+12, r25	; 0x0c
			mc_line(xyz, settings.homing_seek_rate, false);
     bb2:	40 91 42 09 	lds	r20, 0x0942
     bb6:	50 91 43 09 	lds	r21, 0x0943
     bba:	60 91 44 09 	lds	r22, 0x0944
     bbe:	70 91 45 09 	lds	r23, 0x0945
     bc2:	20 e0       	ldi	r18, 0x00	; 0
     bc4:	ce 01       	movw	r24, r28
     bc6:	01 96       	adiw	r24, 0x01	; 1
     bc8:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <mc_line>
			
			protocol_buffer_synchronize(); // Make sure the motion completes
     bcc:	0e 94 fe 1a 	call	0x35fc	; 0x35fc <protocol_buffer_synchronize>
			
			gc_state.position[Z_AXIS] = gc_state.position[Z_AXIS] - (settings.z_zero_gauge);
     bd0:	20 91 50 09 	lds	r18, 0x0950
     bd4:	30 91 51 09 	lds	r19, 0x0951
     bd8:	40 91 52 09 	lds	r20, 0x0952
     bdc:	50 91 53 09 	lds	r21, 0x0953
     be0:	f8 01       	movw	r30, r16
     be2:	60 81       	ld	r22, Z
     be4:	71 81       	ldd	r23, Z+1	; 0x01
     be6:	82 81       	ldd	r24, Z+2	; 0x02
     be8:	93 81       	ldd	r25, Z+3	; 0x03
     bea:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
     bee:	f8 01       	movw	r30, r16
     bf0:	60 83       	st	Z, r22
     bf2:	71 83       	std	Z+1, r23	; 0x01
     bf4:	82 83       	std	Z+2, r24	; 0x02
     bf6:	93 83       	std	Z+3, r25	; 0x03
			gc_state.coord_offset[Z_AXIS] = gc_state.position[Z_AXIS] - gc_state.coord_system[Z_AXIS];
     bf8:	20 91 b2 07 	lds	r18, 0x07B2
     bfc:	30 91 b3 07 	lds	r19, 0x07B3
     c00:	40 91 b4 07 	lds	r20, 0x07B4
     c04:	50 91 b5 07 	lds	r21, 0x07B5
     c08:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
     c0c:	60 93 be 07 	sts	0x07BE, r22
     c10:	70 93 bf 07 	sts	0x07BF, r23
     c14:	80 93 c0 07 	sts	0x07C0, r24
     c18:	90 93 c1 07 	sts	0x07C1, r25
			
			// The gcode parser position circumvented by the pull-off maneuver, so sync position vectors.
			// Sets the planner position vector to current steps. Called by the system abort routine.
			// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
			plan_sync_position();
     c1c:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <plan_sync_position>
			gc_sync_position(); // Syncs all internal position vectors to the current system position.
     c20:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <gc_sync_position>
     c24:	f1 c1       	rjmp	.+994    	; 0x1008 <jogging+0x5ae>
	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
	
	ADCSRA |= (1<<ADSC); //start conversion
     c26:	ea e7       	ldi	r30, 0x7A	; 122
     c28:	f0 e0       	ldi	r31, 0x00	; 0
     c2a:	90 81       	ld	r25, Z
     c2c:	90 64       	ori	r25, 0x40	; 64
     c2e:	90 83       	st	Z, r25
	
	sys.state = STATE_JOG;
     c30:	90 e8       	ldi	r25, 0x80	; 128
     c32:	90 93 68 07 	sts	0x0768, r25
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
     c36:	80 fd       	sbrc	r24, 0
     c38:	0f c0       	rjmp	.+30     	; 0xc58 <jogging+0x1fe>
		out_bits0 ^= (1<<X_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
		reverse_flag = 1;
	}
	else if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
     c3a:	82 fd       	sbrc	r24, 2
     c3c:	15 c0       	rjmp	.+42     	; 0xc68 <jogging+0x20e>
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
	}
	else if (jog_bits & (1<<JOGREV_Z_BIT)) { // Z reverse switch on
     c3e:	84 fd       	sbrc	r24, 4
     c40:	1b c0       	rjmp	.+54     	; 0xc78 <jogging+0x21e>
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
		// reverse_flag = 1; // positive Z dir!
		jog_select = 2;
	}
	// check for forward switches
	else if (jog_bits & (1<<JOGFWD_X_BIT)) { // X forward switch on
     c42:	81 fd       	sbrc	r24, 1
     c44:	20 c0       	rjmp	.+64     	; 0xc86 <jogging+0x22c>
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
	}
	else if (jog_bits & (1<<JOGFWD_Y_BIT)) { // Y forward switch on
     c46:	83 fd       	sbrc	r24, 3
     c48:	23 c0       	rjmp	.+70     	; 0xc90 <jogging+0x236>
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		jog_select = 1;
	}
	else if (jog_bits & (1<<JOGFWD_Z_BIT)) { // Z forward switch on
     c4a:	85 fd       	sbrc	r24, 5
     c4c:	26 c0       	rjmp	.+76     	; 0xc9a <jogging+0x240>
		return;
	}

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
     c4e:	10 e0       	ldi	r17, 0x00	; 0
		}
		return;
	}

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
     c50:	00 e0       	ldi	r16, 0x00	; 0

		}
		return;
	}

	uint8_t reverse_flag = 0;
     c52:	19 8a       	std	Y+17, r1	; 0x11
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
     c54:	e1 2c       	mov	r14, r1
     c56:	26 c0       	rjmp	.+76     	; 0xca4 <jogging+0x24a>
		return;
	}

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
     c58:	10 e0       	ldi	r17, 0x00	; 0
	sys.state = STATE_JOG;
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
		out_bits0 ^= (1<<X_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
     c5a:	00 ec       	ldi	r16, 0xC0	; 192
		reverse_flag = 1;
     c5c:	f1 e0       	ldi	r31, 0x01	; 1
     c5e:	f9 8b       	std	Y+17, r31	; 0x11
	
	sys.state = STATE_JOG;
	
	// check for reverse switches
	if (jog_bits & (1<<JOGREV_X_BIT)) { // X reverse switch on
		out_bits0 ^= (1<<X_DIRECTION_BIT);
     c60:	68 94       	set
     c62:	ee 24       	eor	r14, r14
     c64:	e7 f8       	bld	r14, 7
     c66:	1e c0       	rjmp	.+60     	; 0xca4 <jogging+0x24a>
	}
	else if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
     c68:	11 e0       	ldi	r17, 0x01	; 1
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
		reverse_flag = 1;
	}
	else if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
     c6a:	00 e3       	ldi	r16, 0x30	; 48
		reverse_flag = 1;
     c6c:	21 e0       	ldi	r18, 0x01	; 1
     c6e:	29 8b       	std	Y+17, r18	; 0x11
		out_bits0 ^= (1<<X_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
		reverse_flag = 1;
	}
	else if (jog_bits & (1<<JOGREV_Y_BIT)) { // Y reverse switch on
		out_bits0 ^= (1<<Y_DIRECTION_BIT);
     c70:	68 94       	set
     c72:	ee 24       	eor	r14, r14
     c74:	e5 f8       	bld	r14, 5
     c76:	16 c0       	rjmp	.+44     	; 0xca4 <jogging+0x24a>
	}
	else if (jog_bits & (1<<JOGREV_Z_BIT)) { // Z reverse switch on
		out_bits0 ^= (1<<Z_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
		// reverse_flag = 1; // positive Z dir!
		jog_select = 2;
     c78:	12 e0       	ldi	r17, 0x02	; 2
		reverse_flag = 1;
		jog_select = 1;
	}
	else if (jog_bits & (1<<JOGREV_Z_BIT)) { // Z reverse switch on
		out_bits0 ^= (1<<Z_DIRECTION_BIT);
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
     c7a:	0c e0       	ldi	r16, 0x0C	; 12

		}
		return;
	}

	uint8_t reverse_flag = 0;
     c7c:	19 8a       	std	Y+17, r1	; 0x11
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		reverse_flag = 1;
		jog_select = 1;
	}
	else if (jog_bits & (1<<JOGREV_Z_BIT)) { // Z reverse switch on
		out_bits0 ^= (1<<Z_DIRECTION_BIT);
     c7e:	68 94       	set
     c80:	ee 24       	eor	r14, r14
     c82:	e3 f8       	bld	r14, 3
     c84:	0f c0       	rjmp	.+30     	; 0xca4 <jogging+0x24a>
		return;
	}

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
     c86:	10 e0       	ldi	r17, 0x00	; 0
		// reverse_flag = 1; // positive Z dir!
		jog_select = 2;
	}
	// check for forward switches
	else if (jog_bits & (1<<JOGFWD_X_BIT)) { // X forward switch on
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
     c88:	00 e4       	ldi	r16, 0x40	; 64

		}
		return;
	}

	uint8_t reverse_flag = 0;
     c8a:	19 8a       	std	Y+17, r1	; 0x11
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
     c8c:	e1 2c       	mov	r14, r1
     c8e:	0a c0       	rjmp	.+20     	; 0xca4 <jogging+0x24a>
	else if (jog_bits & (1<<JOGFWD_X_BIT)) { // X forward switch on
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
	}
	else if (jog_bits & (1<<JOGFWD_Y_BIT)) { // Y forward switch on
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		jog_select = 1;
     c90:	11 e0       	ldi	r17, 0x01	; 1
	// check for forward switches
	else if (jog_bits & (1<<JOGFWD_X_BIT)) { // X forward switch on
		out_bits = out_bits0 ^ (1<<X_STEP_BIT);
	}
	else if (jog_bits & (1<<JOGFWD_Y_BIT)) { // Y forward switch on
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
     c92:	00 e1       	ldi	r16, 0x10	; 16

		}
		return;
	}

	uint8_t reverse_flag = 0;
     c94:	19 8a       	std	Y+17, r1	; 0x11
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
     c96:	e1 2c       	mov	r14, r1
     c98:	05 c0       	rjmp	.+10     	; 0xca4 <jogging+0x24a>
		jog_select = 1;
	}
	else if (jog_bits & (1<<JOGFWD_Z_BIT)) { // Z forward switch on
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
		reverse_flag = 1; // positive Z dir!
		jog_select = 2;
     c9a:	12 e0       	ldi	r17, 0x02	; 2
	else if (jog_bits & (1<<JOGFWD_Y_BIT)) { // Y forward switch on
		out_bits = out_bits0 ^ (1<<Y_STEP_BIT);
		jog_select = 1;
	}
	else if (jog_bits & (1<<JOGFWD_Z_BIT)) { // Z forward switch on
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
     c9c:	04 e0       	ldi	r16, 0x04	; 4
		reverse_flag = 1; // positive Z dir!
     c9e:	31 e0       	ldi	r19, 0x01	; 1
     ca0:	39 8b       	std	Y+17, r19	; 0x11
	}

	uint8_t reverse_flag = 0;
	uint8_t out_bits = 0;
	uint8_t jog_select = 0;
	out_bits0 = 0; // no invert anymore!
     ca2:	e1 2c       	mov	r14, r1
		out_bits = out_bits0 ^ (1<<Z_STEP_BIT);
		reverse_flag = 1; // positive Z dir!
		jog_select = 2;
	}

	while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
     ca4:	ea e7       	ldi	r30, 0x7A	; 122
     ca6:	f0 e0       	ldi	r31, 0x00	; 0
     ca8:	80 81       	ld	r24, Z
     caa:	86 fd       	sbrc	r24, 6
     cac:	fd cf       	rjmp	.-6      	; 0xca8 <jogging+0x24e>
	dest_step_rate = ADCH;    // set initial dest_step_rate according to analog input
     cae:	f0 90 79 00 	lds	r15, 0x0079
	dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
	step_rate = JOG_MIN_SPEED;   // set initial step rate
	jog_exit = 0;
	
	uint8_t bits = LIMIT_PIN;
     cb2:	83 b1       	in	r24, 0x03	; 3
	if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { bits ^= LIMIT_MASK; }
     cb4:	90 91 3c 09 	lds	r25, 0x093C
     cb8:	96 fd       	sbrc	r25, 6
     cba:	02 c0       	rjmp	.+4      	; 0xcc0 <jogging+0x266>
     cbc:	9e e0       	ldi	r25, 0x0E	; 14
     cbe:	89 27       	eor	r24, r25
	if (bit_istrue(bits,LIMIT_MASK) && reverse_flag) {
     cc0:	8e 70       	andi	r24, 0x0E	; 14
     cc2:	39 f0       	breq	.+14     	; 0xcd2 <jogging+0x278>
     cc4:	89 88       	ldd	r8, Y+17	; 0x11
     cc6:	88 20       	and	r8, r8
     cc8:	21 f0       	breq	.+8      	; 0xcd2 <jogging+0x278>
		sys.state = last_sys_state;
     cca:	9b 88       	ldd	r9, Y+19	; 0x13
     ccc:	90 92 68 07 	sts	0x0768, r9
		return;
     cd0:	9b c1       	rjmp	.+822    	; 0x1008 <jogging+0x5ae>
	} // do not move towards a limit switch if either one is hit already
	st_wake_up();
     cd2:	0e 94 1a 1b 	call	0x3634	; 0x3634 <st_wake_up>
	
	
	// prepare direction with small delay, direction settle time
	DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (out_bits0 & DIRECTION_MASK);
     cd6:	8b b1       	in	r24, 0x0b	; 11
     cd8:	87 75       	andi	r24, 0x57	; 87
     cda:	e8 2a       	or	r14, r24
     cdc:	eb b8       	out	0x0b, r14	; 11
	//STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits0 & STEP_MASK);
	delay_us(10);
     cde:	6a e0       	ldi	r22, 0x0A	; 10
     ce0:	70 e0       	ldi	r23, 0x00	; 0
     ce2:	80 e0       	ldi	r24, 0x00	; 0
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <delay_us>
	jog_bits_old = jog_bits;
	i = 0;  // now index for sending position data
	
	// Report machine position;
	if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
     cea:	80 91 3c 09 	lds	r24, 0x093C
     cee:	80 ff       	sbrs	r24, 0
     cf0:	1f c0       	rjmp	.+62     	; 0xd30 <jogging+0x2d6>
		mm_per_step = 1/(settings.steps_per_mm[jog_select] * INCH_PER_MM);
     cf2:	e1 2f       	mov	r30, r17
     cf4:	f0 e0       	ldi	r31, 0x00	; 0
     cf6:	ee 0f       	add	r30, r30
     cf8:	ff 1f       	adc	r31, r31
     cfa:	ee 0f       	add	r30, r30
     cfc:	ff 1f       	adc	r31, r31
     cfe:	e1 50       	subi	r30, 0x01	; 1
     d00:	f7 4f       	sbci	r31, 0xF7	; 247
     d02:	2b e8       	ldi	r18, 0x8B	; 139
     d04:	32 e4       	ldi	r19, 0x42	; 66
     d06:	41 e2       	ldi	r20, 0x21	; 33
     d08:	5d e3       	ldi	r21, 0x3D	; 61
     d0a:	60 81       	ld	r22, Z
     d0c:	71 81       	ldd	r23, Z+1	; 0x01
     d0e:	82 81       	ldd	r24, Z+2	; 0x02
     d10:	93 81       	ldd	r25, Z+3	; 0x03
     d12:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
     d16:	9b 01       	movw	r18, r22
     d18:	ac 01       	movw	r20, r24
     d1a:	60 e0       	ldi	r22, 0x00	; 0
     d1c:	70 e0       	ldi	r23, 0x00	; 0
     d1e:	80 e8       	ldi	r24, 0x80	; 128
     d20:	9f e3       	ldi	r25, 0x3F	; 63
     d22:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
     d26:	6c 8b       	std	Y+20, r22	; 0x14
     d28:	7d 8b       	std	Y+21, r23	; 0x15
     d2a:	8e 8b       	std	Y+22, r24	; 0x16
     d2c:	9f 8b       	std	Y+23, r25	; 0x17
     d2e:	16 c0       	rjmp	.+44     	; 0xd5c <jogging+0x302>
		} else {
		mm_per_step = 1/settings.steps_per_mm[jog_select];
     d30:	e1 2f       	mov	r30, r17
     d32:	f0 e0       	ldi	r31, 0x00	; 0
     d34:	ee 0f       	add	r30, r30
     d36:	ff 1f       	adc	r31, r31
     d38:	ee 0f       	add	r30, r30
     d3a:	ff 1f       	adc	r31, r31
     d3c:	e1 50       	subi	r30, 0x01	; 1
     d3e:	f7 4f       	sbci	r31, 0xF7	; 247
     d40:	20 81       	ld	r18, Z
     d42:	31 81       	ldd	r19, Z+1	; 0x01
     d44:	42 81       	ldd	r20, Z+2	; 0x02
     d46:	53 81       	ldd	r21, Z+3	; 0x03
     d48:	60 e0       	ldi	r22, 0x00	; 0
     d4a:	70 e0       	ldi	r23, 0x00	; 0
     d4c:	80 e8       	ldi	r24, 0x80	; 128
     d4e:	9f e3       	ldi	r25, 0x3F	; 63
     d50:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
     d54:	6c 8b       	std	Y+20, r22	; 0x14
     d56:	7d 8b       	std	Y+21, r23	; 0x15
     d58:	8e 8b       	std	Y+22, r24	; 0x16
     d5a:	9f 8b       	std	Y+23, r25	; 0x17
		jog_select = 2;
	}

	while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
	dest_step_rate = ADCH;    // set initial dest_step_rate according to analog input
	dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     d5c:	2f 2d       	mov	r18, r15
     d5e:	30 e0       	ldi	r19, 0x00	; 0
     d60:	a7 e2       	ldi	r26, 0x27	; 39
     d62:	bf e1       	ldi	r27, 0x1F	; 31
     d64:	0e 94 ed 3f 	call	0x7fda	; 0x7fda <__umulhisi3>
     d68:	2f ef       	ldi	r18, 0xFF	; 255
     d6a:	30 e0       	ldi	r19, 0x00	; 0
     d6c:	40 e0       	ldi	r20, 0x00	; 0
     d6e:	50 e0       	ldi	r21, 0x00	; 0
     d70:	0e 94 c5 3f 	call	0x7f8a	; 0x7f8a <__udivmodsi4>
     d74:	49 01       	movw	r8, r18
     d76:	5a 01       	movw	r10, r20
     d78:	89 e1       	ldi	r24, 0x19	; 25
     d7a:	88 0e       	add	r8, r24
     d7c:	91 1c       	adc	r9, r1
     d7e:	a1 1c       	adc	r10, r1
     d80:	b1 1c       	adc	r11, r1
		mm_per_step = 1/(settings.steps_per_mm[jog_select] * INCH_PER_MM);
		} else {
		mm_per_step = 1/settings.steps_per_mm[jog_select];
	}
	
	work_position = sys.position[jog_select] / mm_per_step;
     d82:	e1 2f       	mov	r30, r17
     d84:	f0 e0       	ldi	r31, 0x00	; 0
     d86:	fe 87       	std	Y+14, r31	; 0x0e
     d88:	ed 87       	std	Y+13, r30	; 0x0d
     d8a:	ee 0f       	add	r30, r30
     d8c:	ff 1f       	adc	r31, r31
     d8e:	ee 0f       	add	r30, r30
     d90:	ff 1f       	adc	r31, r31
     d92:	e9 59       	subi	r30, 0x99	; 153
     d94:	f8 4f       	sbci	r31, 0xF8	; 248
     d96:	65 81       	ldd	r22, Z+5	; 0x05
     d98:	76 81       	ldd	r23, Z+6	; 0x06
     d9a:	87 81       	ldd	r24, Z+7	; 0x07
     d9c:	90 85       	ldd	r25, Z+8	; 0x08
     d9e:	0e 94 3c 3d 	call	0x7a78	; 0x7a78 <__floatsisf>
     da2:	2c 89       	ldd	r18, Y+20	; 0x14
     da4:	3d 89       	ldd	r19, Y+21	; 0x15
     da6:	4e 89       	ldd	r20, Y+22	; 0x16
     da8:	5f 89       	ldd	r21, Y+23	; 0x17
     daa:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
     dae:	2b 01       	movw	r4, r22
     db0:	3c 01       	movw	r6, r24
	}

	while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
	dest_step_rate = ADCH;    // set initial dest_step_rate according to analog input
	dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
	step_rate = JOG_MIN_SPEED;   // set initial step rate
     db2:	0f 2e       	mov	r0, r31
     db4:	f9 e1       	ldi	r31, 0x19	; 25
     db6:	cf 2e       	mov	r12, r31
     db8:	d1 2c       	mov	r13, r1
     dba:	e1 2c       	mov	r14, r1
     dbc:	f1 2c       	mov	r15, r1
     dbe:	f0 2d       	mov	r31, r0
			gc_sync_position(); // Syncs all internal position vectors to the current system position.
			return;
		}
		

		ADCSRA |= (1<<ADSC); //start ADC conversion
     dc0:	0f 2e       	mov	r0, r31
     dc2:	fa e7       	ldi	r31, 0x7A	; 122
     dc4:	2f 2e       	mov	r2, r31
     dc6:	31 2c       	mov	r3, r1
     dc8:	f0 2d       	mov	r31, r0
		// Both direction and step pins appropriately inverted and set. Perform one step
		STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits & STEP_MASK); //Step pulse on
     dca:	04 75       	andi	r16, 0x54	; 84
		if (reverse_flag) {
			sys.position[jog_select]--;       // sys.position ist in Steps!
			work_position -= mm_per_step;
		}
		else {
			sys.position[jog_select]++;
     dcc:	8d 85       	ldd	r24, Y+13	; 0x0d
     dce:	9e 85       	ldd	r25, Y+14	; 0x0e
     dd0:	88 0f       	add	r24, r24
     dd2:	99 1f       	adc	r25, r25
     dd4:	88 0f       	add	r24, r24
     dd6:	99 1f       	adc	r25, r25
     dd8:	9c 01       	movw	r18, r24
     dda:	24 59       	subi	r18, 0x94	; 148
     ddc:	38 4f       	sbci	r19, 0xF8	; 248
     dde:	3e 87       	std	Y+14, r19	; 0x0e
     de0:	2d 87       	std	Y+13, r18	; 0x0d
		
		if (sys.rt_exec_state & EXEC_STATUS_REPORT) {
			if (step_delay > 250) {
				// status report requested, print short msg only
				printPgmString(PSTR("Jog"));
				serial_write(88 + jog_select); // 88 = X + 1 = Y etc.
     de2:	18 5a       	subi	r17, 0xA8	; 168
     de4:	19 8f       	std	Y+25, r17	; 0x19
		
		delay_us(step_delay);
		
		while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
		dest_step_rate = ADCH;    // set next dest_step_rate according to analog input
		dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     de6:	a5 01       	movw	r20, r10
     de8:	94 01       	movw	r18, r8
     dea:	08 8f       	std	Y+24, r16	; 0x18
     dec:	0d 85       	ldd	r16, Y+13	; 0x0d
     dee:	1e 85       	ldd	r17, Y+14	; 0x0e
	
	for(;;) { // repeat until button/joystick released
		//    report_realtime_status(); // benötigt viel Zeit!

		// Get limit pin state
		bits = LIMIT_PIN;
     df0:	83 b1       	in	r24, 0x03	; 3
		if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { bits ^= LIMIT_MASK; }
     df2:	ec e3       	ldi	r30, 0x3C	; 60
     df4:	f9 e0       	ldi	r31, 0x09	; 9
     df6:	90 81       	ld	r25, Z
     df8:	96 fd       	sbrc	r25, 6
     dfa:	02 c0       	rjmp	.+4      	; 0xe00 <jogging+0x3a6>
     dfc:	9e e0       	ldi	r25, 0x0E	; 14
     dfe:	89 27       	eor	r24, r25
		if (bit_istrue(bits,LIMIT_MASK) && reverse_flag) { jog_exit = 1; } // immediate stop on any switch
     e00:	8e 70       	andi	r24, 0x0E	; 14
     e02:	39 f0       	breq	.+14     	; 0xe12 <jogging+0x3b8>
     e04:	bb 24       	eor	r11, r11
     e06:	b3 94       	inc	r11
     e08:	89 88       	ldd	r8, Y+17	; 0x11
     e0a:	81 10       	cpse	r8, r1
     e0c:	03 c0       	rjmp	.+6      	; 0xe14 <jogging+0x3ba>
     e0e:	b1 2c       	mov	r11, r1
     e10:	01 c0       	rjmp	.+2      	; 0xe14 <jogging+0x3ba>
     e12:	b1 2c       	mov	r11, r1
		
		jog_bits = (~JOGSW_PIN) & JOGSW_MASK; // active low
     e14:	80 b1       	in	r24, 0x00	; 0
     e16:	80 95       	com	r24
     e18:	8f 77       	andi	r24, 0x7F	; 127
		if (jog_bits == jog_bits_old) { // nothing changed
     e1a:	9a 88       	ldd	r9, Y+18	; 0x12
     e1c:	98 12       	cpse	r9, r24
     e1e:	1f c0       	rjmp	.+62     	; 0xe5e <jogging+0x404>
			if (step_rate < (dest_step_rate - 5)) { // Hysteresis for A/D-conversion
     e20:	da 01       	movw	r26, r20
     e22:	c9 01       	movw	r24, r18
     e24:	05 97       	sbiw	r24, 0x05	; 5
     e26:	a1 09       	sbc	r26, r1
     e28:	b1 09       	sbc	r27, r1
     e2a:	c8 16       	cp	r12, r24
     e2c:	d9 06       	cpc	r13, r25
     e2e:	ea 06       	cpc	r14, r26
     e30:	fb 06       	cpc	r15, r27
     e32:	28 f4       	brcc	.+10     	; 0xe3e <jogging+0x3e4>
				step_rate += JOG_RAMP; // accelerate
     e34:	85 e0       	ldi	r24, 0x05	; 5
     e36:	c8 0e       	add	r12, r24
     e38:	d1 1c       	adc	r13, r1
     e3a:	e1 1c       	adc	r14, r1
     e3c:	f1 1c       	adc	r15, r1
			}
			if (step_rate > (dest_step_rate + 5)) { // Hysteresis for A/D-conversion
     e3e:	da 01       	movw	r26, r20
     e40:	c9 01       	movw	r24, r18
     e42:	05 96       	adiw	r24, 0x05	; 5
     e44:	a1 1d       	adc	r26, r1
     e46:	b1 1d       	adc	r27, r1
     e48:	8c 15       	cp	r24, r12
     e4a:	9d 05       	cpc	r25, r13
     e4c:	ae 05       	cpc	r26, r14
     e4e:	bf 05       	cpc	r27, r15
     e50:	f8 f4       	brcc	.+62     	; 0xe90 <jogging+0x436>
				step_rate -= JOG_RAMP; // brake
     e52:	95 e0       	ldi	r25, 0x05	; 5
     e54:	c9 1a       	sub	r12, r25
     e56:	d1 08       	sbc	r13, r1
     e58:	e1 08       	sbc	r14, r1
     e5a:	f1 08       	sbc	r15, r1
     e5c:	19 c0       	rjmp	.+50     	; 0xe90 <jogging+0x436>
			}
		}
		else {
			if (step_rate > (JOG_MIN_SPEED*2)) {  // switch change happened, fast brake to complete stop
     e5e:	e3 e3       	ldi	r30, 0x33	; 51
     e60:	ce 16       	cp	r12, r30
     e62:	d1 04       	cpc	r13, r1
     e64:	e1 04       	cpc	r14, r1
     e66:	f1 04       	cpc	r15, r1
     e68:	d0 f0       	brcs	.+52     	; 0xe9e <jogging+0x444>
				step_rate = ((step_rate * 99) / 100) - 5;
     e6a:	a3 e6       	ldi	r26, 0x63	; 99
     e6c:	b0 e0       	ldi	r27, 0x00	; 0
     e6e:	a7 01       	movw	r20, r14
     e70:	96 01       	movw	r18, r12
     e72:	0e 94 fc 3f 	call	0x7ff8	; 0x7ff8 <__muluhisi3>
     e76:	24 e6       	ldi	r18, 0x64	; 100
     e78:	30 e0       	ldi	r19, 0x00	; 0
     e7a:	40 e0       	ldi	r20, 0x00	; 0
     e7c:	50 e0       	ldi	r21, 0x00	; 0
     e7e:	0e 94 c5 3f 	call	0x7f8a	; 0x7f8a <__udivmodsi4>
     e82:	69 01       	movw	r12, r18
     e84:	7a 01       	movw	r14, r20
     e86:	f5 e0       	ldi	r31, 0x05	; 5
     e88:	cf 1a       	sub	r12, r31
     e8a:	d1 08       	sbc	r13, r1
     e8c:	e1 08       	sbc	r14, r1
     e8e:	f1 08       	sbc	r15, r1
			}
			else { jog_exit = 1; } // finished to stop and exit
		}
		
		// stop and exit if done
		if (jog_exit || (sys.rt_exec_state & EXEC_RESET)) {
     e90:	b1 10       	cpse	r11, r1
     e92:	05 c0       	rjmp	.+10     	; 0xe9e <jogging+0x444>
     e94:	ea e6       	ldi	r30, 0x6A	; 106
     e96:	f7 e0       	ldi	r31, 0x07	; 7
     e98:	80 81       	ld	r24, Z
     e9a:	84 ff       	sbrs	r24, 4
     e9c:	0a c0       	rjmp	.+20     	; 0xeb2 <jogging+0x458>
			st_go_idle();
     e9e:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <st_go_idle>
			sys.state = last_sys_state;
     ea2:	8b 88       	ldd	r8, Y+19	; 0x13
     ea4:	80 92 68 07 	sts	0x0768, r8
			plan_sync_position();
     ea8:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <plan_sync_position>
			gc_sync_position(); // Syncs all internal position vectors to the current system position.
     eac:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <gc_sync_position>
			return;
     eb0:	ab c0       	rjmp	.+342    	; 0x1008 <jogging+0x5ae>
		}
		

		ADCSRA |= (1<<ADSC); //start ADC conversion
     eb2:	f1 01       	movw	r30, r2
     eb4:	80 81       	ld	r24, Z
     eb6:	80 64       	ori	r24, 0x40	; 64
     eb8:	80 83       	st	Z, r24
		// Both direction and step pins appropriately inverted and set. Perform one step
		STEP_PORT = (STEP_PORT & ~STEP_MASK) | (out_bits & STEP_MASK); //Step pulse on
     eba:	8b b1       	in	r24, 0x0b	; 11
     ebc:	8b 7a       	andi	r24, 0xAB	; 171
     ebe:	88 8c       	ldd	r8, Y+24	; 0x18
     ec0:	88 29       	or	r24, r8
     ec2:	8b b9       	out	0x0b, r24	; 11
		delay_us(settings.pulse_microseconds>>1); //seems okay for little step  pulses
     ec4:	ef e2       	ldi	r30, 0x2F	; 47
     ec6:	f9 e0       	ldi	r31, 0x09	; 9
     ec8:	60 81       	ld	r22, Z
     eca:	66 95       	lsr	r22
     ecc:	70 e0       	ldi	r23, 0x00	; 0
     ece:	80 e0       	ldi	r24, 0x00	; 0
     ed0:	90 e0       	ldi	r25, 0x00	; 0
     ed2:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <delay_us>
		STEP_PORT = (STEP_PORT & ~STEP_MASK);// | (out_bits0 & STEP_MASK); //Step pulse off
     ed6:	8b b1       	in	r24, 0x0b	; 11
     ed8:	8b 7a       	andi	r24, 0xAB	; 171
     eda:	8b b9       	out	0x0b, r24	; 11
		
		step_delay = (1000000/step_rate) - settings.pulse_microseconds - 100; // 100 = fixed value for loop time; this formula needs 30us! on my 18.432 MHz chrystal
     edc:	60 e4       	ldi	r22, 0x40	; 64
     ede:	72 e4       	ldi	r23, 0x42	; 66
     ee0:	8f e0       	ldi	r24, 0x0F	; 15
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	a7 01       	movw	r20, r14
     ee6:	96 01       	movw	r18, r12
     ee8:	0e 94 c5 3f 	call	0x7f8a	; 0x7f8a <__udivmodsi4>
     eec:	ef e2       	ldi	r30, 0x2F	; 47
     eee:	f9 e0       	ldi	r31, 0x09	; 9
     ef0:	80 81       	ld	r24, Z
     ef2:	49 01       	movw	r8, r18
     ef4:	5a 01       	movw	r10, r20
     ef6:	88 1a       	sub	r8, r24
     ef8:	91 08       	sbc	r9, r1
     efa:	a1 08       	sbc	r10, r1
     efc:	b1 08       	sbc	r11, r1
     efe:	8d 86       	std	Y+13, r8	; 0x0d
     f00:	9e 86       	std	Y+14, r9	; 0x0e
     f02:	af 86       	std	Y+15, r10	; 0x0f
     f04:	b8 8a       	std	Y+16, r11	; 0x10
     f06:	24 e6       	ldi	r18, 0x64	; 100
     f08:	82 1a       	sub	r8, r18
     f0a:	91 08       	sbc	r9, r1
     f0c:	a1 08       	sbc	r10, r1
     f0e:	b1 08       	sbc	r11, r1
	
		if (reverse_flag) {
     f10:	39 89       	ldd	r19, Y+17	; 0x11
     f12:	33 23       	and	r19, r19
     f14:	b9 f0       	breq	.+46     	; 0xf44 <jogging+0x4ea>
			sys.position[jog_select]--;       // sys.position ist in Steps!
     f16:	f8 01       	movw	r30, r16
     f18:	80 81       	ld	r24, Z
     f1a:	91 81       	ldd	r25, Z+1	; 0x01
     f1c:	a2 81       	ldd	r26, Z+2	; 0x02
     f1e:	b3 81       	ldd	r27, Z+3	; 0x03
     f20:	01 97       	sbiw	r24, 0x01	; 1
     f22:	a1 09       	sbc	r26, r1
     f24:	b1 09       	sbc	r27, r1
     f26:	80 83       	st	Z, r24
     f28:	91 83       	std	Z+1, r25	; 0x01
     f2a:	a2 83       	std	Z+2, r26	; 0x02
     f2c:	b3 83       	std	Z+3, r27	; 0x03
			work_position -= mm_per_step;
     f2e:	2c 89       	ldd	r18, Y+20	; 0x14
     f30:	3d 89       	ldd	r19, Y+21	; 0x15
     f32:	4e 89       	ldd	r20, Y+22	; 0x16
     f34:	5f 89       	ldd	r21, Y+23	; 0x17
     f36:	c3 01       	movw	r24, r6
     f38:	b2 01       	movw	r22, r4
     f3a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
     f3e:	2b 01       	movw	r4, r22
     f40:	3c 01       	movw	r6, r24
     f42:	16 c0       	rjmp	.+44     	; 0xf70 <jogging+0x516>
		}
		else {
			sys.position[jog_select]++;
     f44:	f8 01       	movw	r30, r16
     f46:	80 81       	ld	r24, Z
     f48:	91 81       	ldd	r25, Z+1	; 0x01
     f4a:	a2 81       	ldd	r26, Z+2	; 0x02
     f4c:	b3 81       	ldd	r27, Z+3	; 0x03
     f4e:	01 96       	adiw	r24, 0x01	; 1
     f50:	a1 1d       	adc	r26, r1
     f52:	b1 1d       	adc	r27, r1
     f54:	80 83       	st	Z, r24
     f56:	91 83       	std	Z+1, r25	; 0x01
     f58:	a2 83       	std	Z+2, r26	; 0x02
     f5a:	b3 83       	std	Z+3, r27	; 0x03
			work_position += mm_per_step;    // relative print_position in mm since last report
     f5c:	2c 89       	ldd	r18, Y+20	; 0x14
     f5e:	3d 89       	ldd	r19, Y+21	; 0x15
     f60:	4e 89       	ldd	r20, Y+22	; 0x16
     f62:	5f 89       	ldd	r21, Y+23	; 0x17
     f64:	c3 01       	movw	r24, r6
     f66:	b2 01       	movw	r22, r4
     f68:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
     f6c:	2b 01       	movw	r4, r22
     f6e:	3c 01       	movw	r6, r24
		}
		
		if (sys.rt_exec_state & EXEC_STATUS_REPORT) {
     f70:	ea e6       	ldi	r30, 0x6A	; 106
     f72:	f7 e0       	ldi	r31, 0x07	; 7
     f74:	80 81       	ld	r24, Z
     f76:	80 ff       	sbrs	r24, 0
     f78:	2d c0       	rjmp	.+90     	; 0xfd4 <jogging+0x57a>
			if (step_delay > 250) {
     f7a:	fb ef       	ldi	r31, 0xFB	; 251
     f7c:	8f 16       	cp	r8, r31
     f7e:	91 04       	cpc	r9, r1
     f80:	a1 04       	cpc	r10, r1
     f82:	b1 04       	cpc	r11, r1
     f84:	00 f1       	brcs	.+64     	; 0xfc6 <jogging+0x56c>
				// status report requested, print short msg only
				printPgmString(PSTR("Jog"));
     f86:	87 e8       	ldi	r24, 0x87	; 135
     f88:	92 e0       	ldi	r25, 0x02	; 2
     f8a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
				serial_write(88 + jog_select); // 88 = X + 1 = Y etc.
     f8e:	89 8d       	ldd	r24, Y+25	; 0x19
     f90:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
				serial_write(44);
     f94:	8c e2       	ldi	r24, 0x2C	; 44
     f96:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
				printFloat(work_position, 3);
     f9a:	43 e0       	ldi	r20, 0x03	; 3
     f9c:	c3 01       	movw	r24, r6
     f9e:	b2 01       	movw	r22, r4
     fa0:	0e 94 36 33 	call	0x666c	; 0x666c <printFloat>
				serial_write(13);
     fa4:	8d e0       	ldi	r24, 0x0D	; 13
     fa6:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
				serial_write(10);
     faa:	8a e0       	ldi	r24, 0x0A	; 10
     fac:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>

				step_delay -= 250;
     fb0:	8d 84       	ldd	r8, Y+13	; 0x0d
     fb2:	9e 84       	ldd	r9, Y+14	; 0x0e
     fb4:	af 84       	ldd	r10, Y+15	; 0x0f
     fb6:	b8 88       	ldd	r11, Y+16	; 0x10
     fb8:	2e e5       	ldi	r18, 0x5E	; 94
     fba:	82 1a       	sub	r8, r18
     fbc:	21 e0       	ldi	r18, 0x01	; 1
     fbe:	92 0a       	sbc	r9, r18
     fc0:	a1 08       	sbc	r10, r1
     fc2:	b1 08       	sbc	r11, r1
     fc4:	04 c0       	rjmp	.+8      	; 0xfce <jogging+0x574>
			}
			else
			{
				printPgmString(PSTR("JogF\r\n"));
     fc6:	80 e8       	ldi	r24, 0x80	; 128
     fc8:	92 e0       	ldi	r25, 0x02	; 2
     fca:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
			}
			sys.rt_exec_state = 0;
     fce:	ea e6       	ldi	r30, 0x6A	; 106
     fd0:	f7 e0       	ldi	r31, 0x07	; 7
     fd2:	10 82       	st	Z, r1
		}
		
		delay_us(step_delay);
     fd4:	c5 01       	movw	r24, r10
     fd6:	b4 01       	movw	r22, r8
     fd8:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <delay_us>
		
		while (ADCSRA & (1<<ADSC)) {} // wait until conversion is finished
     fdc:	f1 01       	movw	r30, r2
     fde:	80 81       	ld	r24, Z
     fe0:	86 fd       	sbrc	r24, 6
     fe2:	fc cf       	rjmp	.-8      	; 0xfdc <jogging+0x582>
		dest_step_rate = ADCH;    // set next dest_step_rate according to analog input
     fe4:	20 91 79 00 	lds	r18, 0x0079
		dest_step_rate = (dest_step_rate * JOG_SPEED_FAC) + JOG_MIN_SPEED;
     fe8:	30 e0       	ldi	r19, 0x00	; 0
     fea:	a7 e2       	ldi	r26, 0x27	; 39
     fec:	bf e1       	ldi	r27, 0x1F	; 31
     fee:	0e 94 ed 3f 	call	0x7fda	; 0x7fda <__umulhisi3>
     ff2:	2f ef       	ldi	r18, 0xFF	; 255
     ff4:	30 e0       	ldi	r19, 0x00	; 0
     ff6:	40 e0       	ldi	r20, 0x00	; 0
     ff8:	50 e0       	ldi	r21, 0x00	; 0
     ffa:	0e 94 c5 3f 	call	0x7f8a	; 0x7f8a <__udivmodsi4>
     ffe:	27 5e       	subi	r18, 0xE7	; 231
    1000:	3f 4f       	sbci	r19, 0xFF	; 255
    1002:	4f 4f       	sbci	r20, 0xFF	; 255
    1004:	5f 4f       	sbci	r21, 0xFF	; 255

	}
    1006:	f4 ce       	rjmp	.-536    	; 0xdf0 <jogging+0x396>
    1008:	69 96       	adiw	r28, 0x19	; 25
    100a:	0f b6       	in	r0, 0x3f	; 63
    100c:	f8 94       	cli
    100e:	de bf       	out	0x3e, r29	; 62
    1010:	0f be       	out	0x3f, r0	; 63
    1012:	cd bf       	out	0x3d, r28	; 61
    1014:	df 91       	pop	r29
    1016:	cf 91       	pop	r28
    1018:	1f 91       	pop	r17
    101a:	0f 91       	pop	r16
    101c:	ff 90       	pop	r15
    101e:	ef 90       	pop	r14
    1020:	df 90       	pop	r13
    1022:	cf 90       	pop	r12
    1024:	bf 90       	pop	r11
    1026:	af 90       	pop	r10
    1028:	9f 90       	pop	r9
    102a:	8f 90       	pop	r8
    102c:	7f 90       	pop	r7
    102e:	6f 90       	pop	r6
    1030:	5f 90       	pop	r5
    1032:	4f 90       	pop	r4
    1034:	3f 90       	pop	r3
    1036:	2f 90       	pop	r2
    1038:	08 95       	ret

0000103a <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
    103a:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
    103e:	0e 94 be 28 	call	0x517c	; 0x517c <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
    1042:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
    1046:	0e 94 93 39 	call	0x7326	; 0x7326 <system_init>
  
  memset(&sys, 0, sizeof(sys));  // Clear all system variables
    104a:	e7 e6       	ldi	r30, 0x67	; 103
    104c:	f7 e0       	ldi	r31, 0x07	; 7
    104e:	80 e2       	ldi	r24, 0x20	; 32
    1050:	df 01       	movw	r26, r30
    1052:	1d 92       	st	X+, r1
    1054:	8a 95       	dec	r24
    1056:	e9 f7       	brne	.-6      	; 0x1052 <main+0x18>
  sys.abort = true;   // Set abort to complete initialization
    1058:	81 e0       	ldi	r24, 0x01	; 1
    105a:	80 83       	st	Z, r24
  sei(); // Enable interrupts
    105c:	78 94       	sei
    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    gc_sync_position();

    // Reset system variables.
    sys.abort = false;
    105e:	6f 01       	movw	r12, r30
    sys.rt_exec_state = 0;
    1060:	0f 2e       	mov	r0, r31
    1062:	fa e6       	ldi	r31, 0x6A	; 106
    1064:	ef 2e       	mov	r14, r31
    1066:	f7 e0       	ldi	r31, 0x07	; 7
    1068:	ff 2e       	mov	r15, r31
    106a:	f0 2d       	mov	r31, r0
    sys.rt_exec_alarm = 0;
    106c:	0b e6       	ldi	r16, 0x6B	; 107
    106e:	17 e0       	ldi	r17, 0x07	; 7
    sys.suspend = false;
    1070:	c9 e6       	ldi	r28, 0x69	; 105
    1072:	d7 e0       	ldi	r29, 0x07	; 7

    // TODO: Separate configure task that require interrupts to be disabled, especially upon
    // a system abort and ensuring any active interrupts are cleanly reset.
  
    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
    1074:	0e 94 da 18 	call	0x31b4	; 0x31b4 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
    1078:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <gc_init>
    spindle_init();
    107c:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <spindle_init>
    coolant_init();
    1080:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <coolant_init>
    limits_init(); 
    1084:	0e 94 45 2f 	call	0x5e8a	; 0x5e8a <limits_init>
    probe_init();
    1088:	0e 94 1b 34 	call	0x6836	; 0x6836 <probe_init>
    plan_reset(); // Clear block buffer and planner variables
    108c:	0e 94 42 2a 	call	0x5484	; 0x5484 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
    1090:	0e 94 fd 1d 	call	0x3bfa	; 0x3bfa <st_reset>
	jog_init();
    1094:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <jog_init>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    1098:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <plan_sync_position>
    gc_sync_position();
    109c:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <gc_sync_position>

    // Reset system variables.
    sys.abort = false;
    10a0:	f6 01       	movw	r30, r12
    10a2:	10 82       	st	Z, r1
    sys.rt_exec_state = 0;
    10a4:	d7 01       	movw	r26, r14
    10a6:	1c 92       	st	X, r1
    sys.rt_exec_alarm = 0;
    10a8:	f8 01       	movw	r30, r16
    10aa:	10 82       	st	Z, r1
    sys.suspend = false;
    10ac:	18 82       	st	Y, r1
          
    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
    10ae:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <protocol_main_loop>
    10b2:	e0 cf       	rjmp	.-64     	; 0x1074 <main+0x3a>

000010b4 <mc_line>:
#ifdef USE_LINE_NUMBERS
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{
    10b4:	bf 92       	push	r11
    10b6:	cf 92       	push	r12
    10b8:	df 92       	push	r13
    10ba:	ef 92       	push	r14
    10bc:	ff 92       	push	r15
    10be:	0f 93       	push	r16
    10c0:	1f 93       	push	r17
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	8c 01       	movw	r16, r24
    10c8:	6a 01       	movw	r12, r20
    10ca:	7b 01       	movw	r14, r22
    10cc:	b2 2e       	mov	r11, r18
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) { limits_soft_check(target); }    
    10ce:	80 91 3c 09 	lds	r24, 0x093C
    10d2:	85 ff       	sbrs	r24, 5
    10d4:	03 c0       	rjmp	.+6      	; 0x10dc <mc_line+0x28>
    10d6:	c8 01       	movw	r24, r16
    10d8:	0e 94 44 32 	call	0x6488	; 0x6488 <limits_soft_check>
      
  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
    10dc:	80 91 68 07 	lds	r24, 0x0768
    10e0:	82 30       	cpi	r24, 0x02	; 2
    10e2:	a1 f0       	breq	.+40     	; 0x110c <__stack+0xd>

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
    10e4:	c7 e6       	ldi	r28, 0x67	; 103
    10e6:	d7 e0       	ldi	r29, 0x07	; 7
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    10e8:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
    10ec:	88 81       	ld	r24, Y
    10ee:	81 11       	cpse	r24, r1
    10f0:	0d c0       	rjmp	.+26     	; 0x110c <__stack+0xd>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
    10f2:	0e 94 92 2a 	call	0x5524	; 0x5524 <plan_check_full_buffer>
    10f6:	88 23       	and	r24, r24
    10f8:	19 f0       	breq	.+6      	; 0x1100 <__stack+0x1>
    10fa:	0e 94 c7 1a 	call	0x358e	; 0x358e <protocol_auto_cycle_start>
    else { break; }
  } while (1);
    10fe:	f4 cf       	rjmp	.-24     	; 0x10e8 <mc_line+0x34>

  // Plan and queue motion into planner buffer
  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    plan_buffer_line(target, feed_rate, invert_feed_rate);
    1100:	2b 2d       	mov	r18, r11
    1102:	b7 01       	movw	r22, r14
    1104:	a6 01       	movw	r20, r12
    1106:	c8 01       	movw	r24, r16
    1108:	0e 94 9a 2a 	call	0x5534	; 0x5534 <plan_buffer_line>
  #endif
}
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	1f 91       	pop	r17
    1112:	0f 91       	pop	r16
    1114:	ff 90       	pop	r15
    1116:	ef 90       	pop	r14
    1118:	df 90       	pop	r13
    111a:	cf 90       	pop	r12
    111c:	bf 90       	pop	r11
    111e:	08 95       	ret

00001120 <mc_arc>:
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc, int32_t line_number)
#else
  void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate,
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
#endif
{
    1120:	2f 92       	push	r2
    1122:	3f 92       	push	r3
    1124:	4f 92       	push	r4
    1126:	5f 92       	push	r5
    1128:	6f 92       	push	r6
    112a:	7f 92       	push	r7
    112c:	8f 92       	push	r8
    112e:	9f 92       	push	r9
    1130:	af 92       	push	r10
    1132:	bf 92       	push	r11
    1134:	cf 92       	push	r12
    1136:	df 92       	push	r13
    1138:	ef 92       	push	r14
    113a:	ff 92       	push	r15
    113c:	0f 93       	push	r16
    113e:	1f 93       	push	r17
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	cd b7       	in	r28, 0x3d	; 61
    1146:	de b7       	in	r29, 0x3e	; 62
    1148:	e9 97       	sbiw	r28, 0x39	; 57
    114a:	0f b6       	in	r0, 0x3f	; 63
    114c:	f8 94       	cli
    114e:	de bf       	out	0x3e, r29	; 62
    1150:	0f be       	out	0x3f, r0	; 63
    1152:	cd bf       	out	0x3d, r28	; 61
    1154:	9a 8b       	std	Y+18, r25	; 0x12
    1156:	89 8b       	std	Y+17, r24	; 0x11
    1158:	79 af       	std	Y+57, r23	; 0x39
    115a:	68 af       	std	Y+56, r22	; 0x38
    115c:	3a 01       	movw	r6, r20
    115e:	09 87       	std	Y+9, r16	; 0x09
    1160:	1a 87       	std	Y+10, r17	; 0x0a
    1162:	2b 87       	std	Y+11, r18	; 0x0b
    1164:	3c 87       	std	Y+12, r19	; 0x0c
    1166:	ab 8a       	std	Y+19, r10	; 0x13
  float center_axis0 = position[axis_0] + offset[axis_0];
    1168:	48 2c       	mov	r4, r8
    116a:	51 2c       	mov	r5, r1
    116c:	12 01       	movw	r2, r4
    116e:	22 0c       	add	r2, r2
    1170:	33 1c       	adc	r3, r3
    1172:	22 0c       	add	r2, r2
    1174:	33 1c       	adc	r3, r3
    1176:	82 0d       	add	r24, r2
    1178:	93 1d       	adc	r25, r3
    117a:	9d 8b       	std	Y+21, r25	; 0x15
    117c:	8c 8b       	std	Y+20, r24	; 0x14
    117e:	9a 01       	movw	r18, r20
    1180:	22 0d       	add	r18, r2
    1182:	33 1d       	adc	r19, r3
    1184:	3d ab       	std	Y+53, r19	; 0x35
    1186:	2c ab       	std	Y+52, r18	; 0x34
    1188:	d9 01       	movw	r26, r18
    118a:	8d 90       	ld	r8, X+
    118c:	9d 90       	ld	r9, X+
    118e:	ad 90       	ld	r10, X+
    1190:	bc 90       	ld	r11, X
    1192:	fc 01       	movw	r30, r24
    1194:	20 81       	ld	r18, Z
    1196:	31 81       	ldd	r19, Z+1	; 0x01
    1198:	42 81       	ldd	r20, Z+2	; 0x02
    119a:	53 81       	ldd	r21, Z+3	; 0x03
    119c:	c5 01       	movw	r24, r10
    119e:	b4 01       	movw	r22, r8
    11a0:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    11a4:	6e 8b       	std	Y+22, r22	; 0x16
    11a6:	7f 8b       	std	Y+23, r23	; 0x17
    11a8:	88 8f       	std	Y+24, r24	; 0x18
    11aa:	99 8f       	std	Y+25, r25	; 0x19
  float center_axis1 = position[axis_1] + offset[axis_1];
    11ac:	2f 96       	adiw	r28, 0x0f	; 15
    11ae:	0f ad       	ldd	r16, Y+63	; 0x3f
    11b0:	2f 97       	sbiw	r28, 0x0f	; 15
    11b2:	10 e0       	ldi	r17, 0x00	; 0
    11b4:	00 0f       	add	r16, r16
    11b6:	11 1f       	adc	r17, r17
    11b8:	00 0f       	add	r16, r16
    11ba:	11 1f       	adc	r17, r17
    11bc:	29 89       	ldd	r18, Y+17	; 0x11
    11be:	3a 89       	ldd	r19, Y+18	; 0x12
    11c0:	20 0f       	add	r18, r16
    11c2:	31 1f       	adc	r19, r17
    11c4:	3b 8f       	std	Y+27, r19	; 0x1b
    11c6:	2a 8f       	std	Y+26, r18	; 0x1a
    11c8:	a3 01       	movw	r20, r6
    11ca:	40 0f       	add	r20, r16
    11cc:	51 1f       	adc	r21, r17
    11ce:	5f ab       	std	Y+55, r21	; 0x37
    11d0:	4e ab       	std	Y+54, r20	; 0x36
    11d2:	da 01       	movw	r26, r20
    11d4:	8d 91       	ld	r24, X+
    11d6:	9d 91       	ld	r25, X+
    11d8:	0d 90       	ld	r0, X+
    11da:	bc 91       	ld	r27, X
    11dc:	a0 2d       	mov	r26, r0
    11de:	89 83       	std	Y+1, r24	; 0x01
    11e0:	9a 83       	std	Y+2, r25	; 0x02
    11e2:	ab 83       	std	Y+3, r26	; 0x03
    11e4:	bc 83       	std	Y+4, r27	; 0x04
    11e6:	f9 01       	movw	r30, r18
    11e8:	20 81       	ld	r18, Z
    11ea:	31 81       	ldd	r19, Z+1	; 0x01
    11ec:	42 81       	ldd	r20, Z+2	; 0x02
    11ee:	53 81       	ldd	r21, Z+3	; 0x03
    11f0:	bc 01       	movw	r22, r24
    11f2:	cd 01       	movw	r24, r26
    11f4:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    11f8:	6c 8f       	std	Y+28, r22	; 0x1c
    11fa:	7d 8f       	std	Y+29, r23	; 0x1d
    11fc:	8e 8f       	std	Y+30, r24	; 0x1e
    11fe:	9f 8f       	std	Y+31, r25	; 0x1f
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
    1200:	24 01       	movw	r4, r8
    1202:	35 01       	movw	r6, r10
    1204:	77 fa       	bst	r7, 7
    1206:	70 94       	com	r7
    1208:	77 f8       	bld	r7, 7
    120a:	70 94       	com	r7
  float r_axis1 = -offset[axis_1];
    120c:	89 80       	ldd	r8, Y+1	; 0x01
    120e:	9a 80       	ldd	r9, Y+2	; 0x02
    1210:	ab 80       	ldd	r10, Y+3	; 0x03
    1212:	bc 80       	ldd	r11, Y+4	; 0x04
    1214:	b7 fa       	bst	r11, 7
    1216:	b0 94       	com	r11
    1218:	b7 f8       	bld	r11, 7
    121a:	b0 94       	com	r11
  float rt_axis0 = target[axis_0] - center_axis0;
    121c:	e8 ad       	ldd	r30, Y+56	; 0x38
    121e:	f9 ad       	ldd	r31, Y+57	; 0x39
    1220:	e2 0d       	add	r30, r2
    1222:	f3 1d       	adc	r31, r3
    1224:	2e 89       	ldd	r18, Y+22	; 0x16
    1226:	3f 89       	ldd	r19, Y+23	; 0x17
    1228:	48 8d       	ldd	r20, Y+24	; 0x18
    122a:	59 8d       	ldd	r21, Y+25	; 0x19
    122c:	60 81       	ld	r22, Z
    122e:	71 81       	ldd	r23, Z+1	; 0x01
    1230:	82 81       	ldd	r24, Z+2	; 0x02
    1232:	93 81       	ldd	r25, Z+3	; 0x03
    1234:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    1238:	69 83       	std	Y+1, r22	; 0x01
    123a:	7a 83       	std	Y+2, r23	; 0x02
    123c:	8b 83       	std	Y+3, r24	; 0x03
    123e:	9c 83       	std	Y+4, r25	; 0x04
  float rt_axis1 = target[axis_1] - center_axis1;
    1240:	e8 ad       	ldd	r30, Y+56	; 0x38
    1242:	f9 ad       	ldd	r31, Y+57	; 0x39
    1244:	e0 0f       	add	r30, r16
    1246:	f1 1f       	adc	r31, r17
    1248:	2c 8d       	ldd	r18, Y+28	; 0x1c
    124a:	3d 8d       	ldd	r19, Y+29	; 0x1d
    124c:	4e 8d       	ldd	r20, Y+30	; 0x1e
    124e:	5f 8d       	ldd	r21, Y+31	; 0x1f
    1250:	60 81       	ld	r22, Z
    1252:	71 81       	ldd	r23, Z+1	; 0x01
    1254:	82 81       	ldd	r24, Z+2	; 0x02
    1256:	93 81       	ldd	r25, Z+3	; 0x03
    1258:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    125c:	6d 83       	std	Y+5, r22	; 0x05
    125e:	7e 83       	std	Y+6, r23	; 0x06
    1260:	8f 83       	std	Y+7, r24	; 0x07
    1262:	98 87       	std	Y+8, r25	; 0x08
  
  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
    1264:	29 81       	ldd	r18, Y+1	; 0x01
    1266:	3a 81       	ldd	r19, Y+2	; 0x02
    1268:	4b 81       	ldd	r20, Y+3	; 0x03
    126a:	5c 81       	ldd	r21, Y+4	; 0x04
    126c:	c3 01       	movw	r24, r6
    126e:	b2 01       	movw	r22, r4
    1270:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    1274:	6d 87       	std	Y+13, r22	; 0x0d
    1276:	7e 87       	std	Y+14, r23	; 0x0e
    1278:	8f 87       	std	Y+15, r24	; 0x0f
    127a:	98 8b       	std	Y+16, r25	; 0x10
    127c:	2d 81       	ldd	r18, Y+5	; 0x05
    127e:	3e 81       	ldd	r19, Y+6	; 0x06
    1280:	4f 81       	ldd	r20, Y+7	; 0x07
    1282:	58 85       	ldd	r21, Y+8	; 0x08
    1284:	c5 01       	movw	r24, r10
    1286:	b4 01       	movw	r22, r8
    1288:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    128c:	9b 01       	movw	r18, r22
    128e:	ac 01       	movw	r20, r24
    1290:	6d 85       	ldd	r22, Y+13	; 0x0d
    1292:	7e 85       	ldd	r23, Y+14	; 0x0e
    1294:	8f 85       	ldd	r24, Y+15	; 0x0f
    1296:	98 89       	ldd	r25, Y+16	; 0x10
    1298:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    129c:	6d 87       	std	Y+13, r22	; 0x0d
    129e:	7e 87       	std	Y+14, r23	; 0x0e
    12a0:	8f 87       	std	Y+15, r24	; 0x0f
    12a2:	98 8b       	std	Y+16, r25	; 0x10
    12a4:	2d 81       	ldd	r18, Y+5	; 0x05
    12a6:	3e 81       	ldd	r19, Y+6	; 0x06
    12a8:	4f 81       	ldd	r20, Y+7	; 0x07
    12aa:	58 85       	ldd	r21, Y+8	; 0x08
    12ac:	c3 01       	movw	r24, r6
    12ae:	b2 01       	movw	r22, r4
    12b0:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    12b4:	6d 83       	std	Y+5, r22	; 0x05
    12b6:	7e 83       	std	Y+6, r23	; 0x06
    12b8:	8f 83       	std	Y+7, r24	; 0x07
    12ba:	98 87       	std	Y+8, r25	; 0x08
    12bc:	29 81       	ldd	r18, Y+1	; 0x01
    12be:	3a 81       	ldd	r19, Y+2	; 0x02
    12c0:	4b 81       	ldd	r20, Y+3	; 0x03
    12c2:	5c 81       	ldd	r21, Y+4	; 0x04
    12c4:	c5 01       	movw	r24, r10
    12c6:	b4 01       	movw	r22, r8
    12c8:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    12cc:	9b 01       	movw	r18, r22
    12ce:	ac 01       	movw	r20, r24
    12d0:	6d 81       	ldd	r22, Y+5	; 0x05
    12d2:	7e 81       	ldd	r23, Y+6	; 0x06
    12d4:	8f 81       	ldd	r24, Y+7	; 0x07
    12d6:	98 85       	ldd	r25, Y+8	; 0x08
    12d8:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    12dc:	2d 85       	ldd	r18, Y+13	; 0x0d
    12de:	3e 85       	ldd	r19, Y+14	; 0x0e
    12e0:	4f 85       	ldd	r20, Y+15	; 0x0f
    12e2:	58 89       	ldd	r21, Y+16	; 0x10
    12e4:	0e 94 34 3c 	call	0x7868	; 0x7868 <atan2>
    12e8:	69 83       	std	Y+1, r22	; 0x01
    12ea:	7a 83       	std	Y+2, r23	; 0x02
    12ec:	8b 83       	std	Y+3, r24	; 0x03
    12ee:	9c 83       	std	Y+4, r25	; 0x04
  if (is_clockwise_arc) { // Correct atan2 output per direction
    12f0:	61 96       	adiw	r28, 0x11	; 17
    12f2:	8f ad       	ldd	r24, Y+63	; 0x3f
    12f4:	61 97       	sbiw	r28, 0x11	; 17
    12f6:	88 23       	and	r24, r24
    12f8:	d1 f0       	breq	.+52     	; 0x132e <mc_arc+0x20e>
    if (angular_travel >= 0) { angular_travel -= 2*M_PI; }
    12fa:	20 e0       	ldi	r18, 0x00	; 0
    12fc:	30 e0       	ldi	r19, 0x00	; 0
    12fe:	a9 01       	movw	r20, r18
    1300:	69 81       	ldd	r22, Y+1	; 0x01
    1302:	7a 81       	ldd	r23, Y+2	; 0x02
    1304:	8b 81       	ldd	r24, Y+3	; 0x03
    1306:	9c 81       	ldd	r25, Y+4	; 0x04
    1308:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    130c:	88 23       	and	r24, r24
    130e:	44 f1       	brlt	.+80     	; 0x1360 <mc_arc+0x240>
    1310:	2b ed       	ldi	r18, 0xDB	; 219
    1312:	3f e0       	ldi	r19, 0x0F	; 15
    1314:	49 ec       	ldi	r20, 0xC9	; 201
    1316:	50 e4       	ldi	r21, 0x40	; 64
    1318:	69 81       	ldd	r22, Y+1	; 0x01
    131a:	7a 81       	ldd	r23, Y+2	; 0x02
    131c:	8b 81       	ldd	r24, Y+3	; 0x03
    131e:	9c 81       	ldd	r25, Y+4	; 0x04
    1320:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    1324:	69 83       	std	Y+1, r22	; 0x01
    1326:	7a 83       	std	Y+2, r23	; 0x02
    1328:	8b 83       	std	Y+3, r24	; 0x03
    132a:	9c 83       	std	Y+4, r25	; 0x04
    132c:	19 c0       	rjmp	.+50     	; 0x1360 <mc_arc+0x240>
  } else {
    if (angular_travel <= 0) { angular_travel += 2*M_PI; }
    132e:	20 e0       	ldi	r18, 0x00	; 0
    1330:	30 e0       	ldi	r19, 0x00	; 0
    1332:	a9 01       	movw	r20, r18
    1334:	69 81       	ldd	r22, Y+1	; 0x01
    1336:	7a 81       	ldd	r23, Y+2	; 0x02
    1338:	8b 81       	ldd	r24, Y+3	; 0x03
    133a:	9c 81       	ldd	r25, Y+4	; 0x04
    133c:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    1340:	18 16       	cp	r1, r24
    1342:	74 f0       	brlt	.+28     	; 0x1360 <mc_arc+0x240>
    1344:	2b ed       	ldi	r18, 0xDB	; 219
    1346:	3f e0       	ldi	r19, 0x0F	; 15
    1348:	49 ec       	ldi	r20, 0xC9	; 201
    134a:	50 e4       	ldi	r21, 0x40	; 64
    134c:	69 81       	ldd	r22, Y+1	; 0x01
    134e:	7a 81       	ldd	r23, Y+2	; 0x02
    1350:	8b 81       	ldd	r24, Y+3	; 0x03
    1352:	9c 81       	ldd	r25, Y+4	; 0x04
    1354:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    1358:	69 83       	std	Y+1, r22	; 0x01
    135a:	7a 83       	std	Y+2, r23	; 0x02
    135c:	8b 83       	std	Y+3, r24	; 0x03
    135e:	9c 83       	std	Y+4, r25	; 0x04
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
    1360:	20 91 38 09 	lds	r18, 0x0938
    1364:	30 91 39 09 	lds	r19, 0x0939
    1368:	40 91 3a 09 	lds	r20, 0x093A
    136c:	50 91 3b 09 	lds	r21, 0x093B
    1370:	2d 83       	std	Y+5, r18	; 0x05
    1372:	3e 83       	std	Y+6, r19	; 0x06
    1374:	4f 83       	std	Y+7, r20	; 0x07
    1376:	58 87       	std	Y+8, r21	; 0x08
    1378:	29 85       	ldd	r18, Y+9	; 0x09
    137a:	3a 85       	ldd	r19, Y+10	; 0x0a
    137c:	4b 85       	ldd	r20, Y+11	; 0x0b
    137e:	5c 85       	ldd	r21, Y+12	; 0x0c
    1380:	ca 01       	movw	r24, r20
    1382:	b9 01       	movw	r22, r18
    1384:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    1388:	2d 81       	ldd	r18, Y+5	; 0x05
    138a:	3e 81       	ldd	r19, Y+6	; 0x06
    138c:	4f 81       	ldd	r20, Y+7	; 0x07
    138e:	58 85       	ldd	r21, Y+8	; 0x08
    1390:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    1394:	9b 01       	movw	r18, r22
    1396:	ac 01       	movw	r20, r24
    1398:	6d 81       	ldd	r22, Y+5	; 0x05
    139a:	7e 81       	ldd	r23, Y+6	; 0x06
    139c:	8f 81       	ldd	r24, Y+7	; 0x07
    139e:	98 85       	ldd	r25, Y+8	; 0x08
    13a0:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    13a4:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    13a8:	6d 83       	std	Y+5, r22	; 0x05
    13aa:	7e 83       	std	Y+6, r23	; 0x06
    13ac:	8f 83       	std	Y+7, r24	; 0x07
    13ae:	98 87       	std	Y+8, r25	; 0x08

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
    13b0:	20 e0       	ldi	r18, 0x00	; 0
    13b2:	30 e0       	ldi	r19, 0x00	; 0
    13b4:	40 e0       	ldi	r20, 0x00	; 0
    13b6:	5f e3       	ldi	r21, 0x3F	; 63
    13b8:	69 81       	ldd	r22, Y+1	; 0x01
    13ba:	7a 81       	ldd	r23, Y+2	; 0x02
    13bc:	8b 81       	ldd	r24, Y+3	; 0x03
    13be:	9c 81       	ldd	r25, Y+4	; 0x04
    13c0:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    13c4:	29 85       	ldd	r18, Y+9	; 0x09
    13c6:	3a 85       	ldd	r19, Y+10	; 0x0a
    13c8:	4b 85       	ldd	r20, Y+11	; 0x0b
    13ca:	5c 85       	ldd	r21, Y+12	; 0x0c
    13cc:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    13d0:	9f 77       	andi	r25, 0x7F	; 127
    13d2:	2d 81       	ldd	r18, Y+5	; 0x05
    13d4:	3e 81       	ldd	r19, Y+6	; 0x06
    13d6:	4f 81       	ldd	r20, Y+7	; 0x07
    13d8:	58 85       	ldd	r21, Y+8	; 0x08
    13da:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    13de:	0e 94 77 3d 	call	0x7aee	; 0x7aee <floor>
    13e2:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
    13e6:	69 87       	std	Y+9, r22	; 0x09
    13e8:	7a 87       	std	Y+10, r23	; 0x0a
    13ea:	8b 87       	std	Y+11, r24	; 0x0b
    13ec:	9c 87       	std	Y+12, r25	; 0x0c
    13ee:	49 85       	ldd	r20, Y+9	; 0x09
    13f0:	5a 85       	ldd	r21, Y+10	; 0x0a
    13f2:	5e 87       	std	Y+14, r21	; 0x0e
    13f4:	4d 87       	std	Y+13, r20	; 0x0d
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
  
  if (segments) { 
    13f6:	45 2b       	or	r20, r21
    13f8:	09 f4       	brne	.+2      	; 0x13fc <mc_arc+0x2dc>
    13fa:	8e c1       	rjmp	.+796    	; 0x1718 <mc_arc+0x5f8>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of 
    // all segments.
    if (invert_feed_rate) { feed_rate *= segments; }
    13fc:	5b 89       	ldd	r21, Y+19	; 0x13
    13fe:	55 23       	and	r21, r21
    1400:	79 f0       	breq	.+30     	; 0x1420 <mc_arc+0x300>
    1402:	a9 85       	ldd	r26, Y+9	; 0x09
    1404:	ba 85       	ldd	r27, Y+10	; 0x0a
    1406:	bd 01       	movw	r22, r26
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	0e 94 3a 3d 	call	0x7a74	; 0x7a74 <__floatunsisf>
    1410:	9b 01       	movw	r18, r22
    1412:	ac 01       	movw	r20, r24
    1414:	c7 01       	movw	r24, r14
    1416:	b6 01       	movw	r22, r12
    1418:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    141c:	6b 01       	movw	r12, r22
    141e:	7c 01       	movw	r14, r24
   
    float theta_per_segment = angular_travel/segments;
    1420:	e9 85       	ldd	r30, Y+9	; 0x09
    1422:	fa 85       	ldd	r31, Y+10	; 0x0a
    1424:	bf 01       	movw	r22, r30
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	0e 94 3a 3d 	call	0x7a74	; 0x7a74 <__floatunsisf>
    142e:	69 87       	std	Y+9, r22	; 0x09
    1430:	7a 87       	std	Y+10, r23	; 0x0a
    1432:	8b 87       	std	Y+11, r24	; 0x0b
    1434:	9c 87       	std	Y+12, r25	; 0x0c
    1436:	9b 01       	movw	r18, r22
    1438:	ac 01       	movw	r20, r24
    143a:	69 81       	ldd	r22, Y+1	; 0x01
    143c:	7a 81       	ldd	r23, Y+2	; 0x02
    143e:	8b 81       	ldd	r24, Y+3	; 0x03
    1440:	9c 81       	ldd	r25, Y+4	; 0x04
    1442:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    1446:	68 ab       	std	Y+48, r22	; 0x30
    1448:	79 ab       	std	Y+49, r23	; 0x31
    144a:	8a ab       	std	Y+50, r24	; 0x32
    144c:	9b ab       	std	Y+51, r25	; 0x33
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
    144e:	60 96       	adiw	r28, 0x10	; 16
    1450:	8f ad       	ldd	r24, Y+63	; 0x3f
    1452:	60 97       	sbiw	r28, 0x10	; 16
    1454:	90 e0       	ldi	r25, 0x00	; 0
    1456:	88 0f       	add	r24, r24
    1458:	99 1f       	adc	r25, r25
    145a:	88 0f       	add	r24, r24
    145c:	99 1f       	adc	r25, r25
    145e:	29 89       	ldd	r18, Y+17	; 0x11
    1460:	3a 89       	ldd	r19, Y+18	; 0x12
    1462:	28 0f       	add	r18, r24
    1464:	39 1f       	adc	r19, r25
    1466:	3a 83       	std	Y+2, r19	; 0x02
    1468:	29 83       	std	Y+1, r18	; 0x01
    146a:	e8 ad       	ldd	r30, Y+56	; 0x38
    146c:	f9 ad       	ldd	r31, Y+57	; 0x39
    146e:	e8 0f       	add	r30, r24
    1470:	f9 1f       	adc	r31, r25
    1472:	d9 01       	movw	r26, r18
    1474:	2d 91       	ld	r18, X+
    1476:	3d 91       	ld	r19, X+
    1478:	4d 91       	ld	r20, X+
    147a:	5c 91       	ld	r21, X
    147c:	60 81       	ld	r22, Z
    147e:	71 81       	ldd	r23, Z+1	; 0x01
    1480:	82 81       	ldd	r24, Z+2	; 0x02
    1482:	93 81       	ldd	r25, Z+3	; 0x03
    1484:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    1488:	29 85       	ldd	r18, Y+9	; 0x09
    148a:	3a 85       	ldd	r19, Y+10	; 0x0a
    148c:	4b 85       	ldd	r20, Y+11	; 0x0b
    148e:	5c 85       	ldd	r21, Y+12	; 0x0c
    1490:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    1494:	6c a3       	std	Y+36, r22	; 0x24
    1496:	7d a3       	std	Y+37, r23	; 0x25
    1498:	8e a3       	std	Y+38, r24	; 0x26
    149a:	9f a3       	std	Y+39, r25	; 0x27
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. 
       This is important when there are successive arc motions. 
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
    149c:	28 a9       	ldd	r18, Y+48	; 0x30
    149e:	39 a9       	ldd	r19, Y+49	; 0x31
    14a0:	4a a9       	ldd	r20, Y+50	; 0x32
    14a2:	5b a9       	ldd	r21, Y+51	; 0x33
    14a4:	ca 01       	movw	r24, r20
    14a6:	b9 01       	movw	r22, r18
    14a8:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    14ac:	9b 01       	movw	r18, r22
    14ae:	ac 01       	movw	r20, r24
    14b0:	60 e0       	ldi	r22, 0x00	; 0
    14b2:	70 e0       	ldi	r23, 0x00	; 0
    14b4:	80 e0       	ldi	r24, 0x00	; 0
    14b6:	90 e4       	ldi	r25, 0x40	; 64
    14b8:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    14bc:	69 87       	std	Y+9, r22	; 0x09
    14be:	7a 87       	std	Y+10, r23	; 0x0a
    14c0:	8b 87       	std	Y+11, r24	; 0x0b
    14c2:	9c 87       	std	Y+12, r25	; 0x0c
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
    14c4:	2b ea       	ldi	r18, 0xAB	; 171
    14c6:	3a ea       	ldi	r19, 0xAA	; 170
    14c8:	4a e2       	ldi	r20, 0x2A	; 42
    14ca:	5e e3       	ldi	r21, 0x3E	; 62
    14cc:	68 a9       	ldd	r22, Y+48	; 0x30
    14ce:	79 a9       	ldd	r23, Y+49	; 0x31
    14d0:	8a a9       	ldd	r24, Y+50	; 0x32
    14d2:	9b a9       	ldd	r25, Y+51	; 0x33
    14d4:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    14d8:	6d 83       	std	Y+5, r22	; 0x05
    14da:	7e 83       	std	Y+6, r23	; 0x06
    14dc:	8f 83       	std	Y+7, r24	; 0x07
    14de:	98 87       	std	Y+8, r25	; 0x08
    14e0:	20 e0       	ldi	r18, 0x00	; 0
    14e2:	30 e0       	ldi	r19, 0x00	; 0
    14e4:	40 e8       	ldi	r20, 0x80	; 128
    14e6:	50 e4       	ldi	r21, 0x40	; 64
    14e8:	69 85       	ldd	r22, Y+9	; 0x09
    14ea:	7a 85       	ldd	r23, Y+10	; 0x0a
    14ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    14ee:	9c 85       	ldd	r25, Y+12	; 0x0c
    14f0:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    14f4:	9b 01       	movw	r18, r22
    14f6:	ac 01       	movw	r20, r24
    14f8:	6d 81       	ldd	r22, Y+5	; 0x05
    14fa:	7e 81       	ldd	r23, Y+6	; 0x06
    14fc:	8f 81       	ldd	r24, Y+7	; 0x07
    14fe:	98 85       	ldd	r25, Y+8	; 0x08
    1500:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    1504:	68 a7       	std	Y+40, r22	; 0x28
    1506:	79 a7       	std	Y+41, r23	; 0x29
    1508:	8a a7       	std	Y+42, r24	; 0x2a
    150a:	9b a7       	std	Y+43, r25	; 0x2b
    cos_T *= 0.5;
    150c:	20 e0       	ldi	r18, 0x00	; 0
    150e:	30 e0       	ldi	r19, 0x00	; 0
    1510:	40 e0       	ldi	r20, 0x00	; 0
    1512:	5f e3       	ldi	r21, 0x3F	; 63
    1514:	69 85       	ldd	r22, Y+9	; 0x09
    1516:	7a 85       	ldd	r23, Y+10	; 0x0a
    1518:	8b 85       	ldd	r24, Y+11	; 0x0b
    151a:	9c 85       	ldd	r25, Y+12	; 0x0c
    151c:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    1520:	6c a7       	std	Y+44, r22	; 0x2c
    1522:	7d a7       	std	Y+45, r23	; 0x2d
    1524:	8e a7       	std	Y+46, r24	; 0x2e
    1526:	9f a7       	std	Y+47, r25	; 0x2f
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    1528:	ed 85       	ldd	r30, Y+13	; 0x0d
    152a:	fe 85       	ldd	r31, Y+14	; 0x0e
    152c:	32 97       	sbiw	r30, 0x02	; 2
    152e:	08 f4       	brcc	.+2      	; 0x1532 <mc_arc+0x412>
    1530:	f3 c0       	rjmp	.+486    	; 0x1718 <mc_arc+0x5f8>

    float sin_Ti;
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
    1532:	10 e0       	ldi	r17, 0x00	; 0
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    1534:	22 24       	eor	r2, r2
    1536:	23 94       	inc	r2
    1538:	31 2c       	mov	r3, r1
      #else
        mc_line(position, feed_rate, invert_feed_rate);
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    153a:	c8 a2       	std	Y+32, r12	; 0x20
    153c:	d9 a2       	std	Y+33, r13	; 0x21
    153e:	ea a2       	std	Y+34, r14	; 0x22
    1540:	fb a2       	std	Y+35, r15	; 0x23
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
      
      if (count < N_ARC_CORRECTION) {
    1542:	1c 30       	cpi	r17, 0x0C	; 12
    1544:	d0 f5       	brcc	.+116    	; 0x15ba <mc_arc+0x49a>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
    1546:	2c a5       	ldd	r18, Y+44	; 0x2c
    1548:	3d a5       	ldd	r19, Y+45	; 0x2d
    154a:	4e a5       	ldd	r20, Y+46	; 0x2e
    154c:	5f a5       	ldd	r21, Y+47	; 0x2f
    154e:	c5 01       	movw	r24, r10
    1550:	b4 01       	movw	r22, r8
    1552:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    1556:	6b 01       	movw	r12, r22
    1558:	7c 01       	movw	r14, r24
    155a:	28 a5       	ldd	r18, Y+40	; 0x28
    155c:	39 a5       	ldd	r19, Y+41	; 0x29
    155e:	4a a5       	ldd	r20, Y+42	; 0x2a
    1560:	5b a5       	ldd	r21, Y+43	; 0x2b
    1562:	c3 01       	movw	r24, r6
    1564:	b2 01       	movw	r22, r4
    1566:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    156a:	a7 01       	movw	r20, r14
    156c:	96 01       	movw	r18, r12
    156e:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    1572:	d6 2e       	mov	r13, r22
    1574:	e7 2e       	mov	r14, r23
    1576:	f8 2e       	mov	r15, r24
    1578:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
    157a:	2c a5       	ldd	r18, Y+44	; 0x2c
    157c:	3d a5       	ldd	r19, Y+45	; 0x2d
    157e:	4e a5       	ldd	r20, Y+46	; 0x2e
    1580:	5f a5       	ldd	r21, Y+47	; 0x2f
    1582:	c3 01       	movw	r24, r6
    1584:	b2 01       	movw	r22, r4
    1586:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    158a:	2b 01       	movw	r4, r22
    158c:	3c 01       	movw	r6, r24
    158e:	28 a5       	ldd	r18, Y+40	; 0x28
    1590:	39 a5       	ldd	r19, Y+41	; 0x29
    1592:	4a a5       	ldd	r20, Y+42	; 0x2a
    1594:	5b a5       	ldd	r21, Y+43	; 0x2b
    1596:	c5 01       	movw	r24, r10
    1598:	b4 01       	movw	r22, r8
    159a:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    159e:	9b 01       	movw	r18, r22
    15a0:	ac 01       	movw	r20, r24
    15a2:	c3 01       	movw	r24, r6
    15a4:	b2 01       	movw	r22, r4
    15a6:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    15aa:	2b 01       	movw	r4, r22
    15ac:	3c 01       	movw	r6, r24
        r_axis1 = r_axisi;
        count++;
    15ae:	1f 5f       	subi	r17, 0xFF	; 255
      
      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
    15b0:	8d 2c       	mov	r8, r13
    15b2:	9e 2c       	mov	r9, r14
    15b4:	af 2c       	mov	r10, r15
    15b6:	b0 2e       	mov	r11, r16
    15b8:	64 c0       	rjmp	.+200    	; 0x1682 <mc_arc+0x562>
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
    15ba:	b1 01       	movw	r22, r2
    15bc:	80 e0       	ldi	r24, 0x00	; 0
    15be:	90 e0       	ldi	r25, 0x00	; 0
    15c0:	0e 94 3a 3d 	call	0x7a74	; 0x7a74 <__floatunsisf>
    15c4:	28 a9       	ldd	r18, Y+48	; 0x30
    15c6:	39 a9       	ldd	r19, Y+49	; 0x31
    15c8:	4a a9       	ldd	r20, Y+50	; 0x32
    15ca:	5b a9       	ldd	r21, Y+51	; 0x33
    15cc:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    15d0:	4b 01       	movw	r8, r22
    15d2:	5c 01       	movw	r10, r24
    15d4:	0e 94 9e 3c 	call	0x793c	; 0x793c <cos>
    15d8:	6b 01       	movw	r12, r22
    15da:	7c 01       	movw	r14, r24
        sin_Ti = sin(i*theta_per_segment);
    15dc:	c5 01       	movw	r24, r10
    15de:	b4 01       	movw	r22, r8
    15e0:	0e 94 5b 3f 	call	0x7eb6	; 0x7eb6 <sin>
    15e4:	4b 01       	movw	r8, r22
    15e6:	5c 01       	movw	r10, r24
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
    15e8:	ec a9       	ldd	r30, Y+52	; 0x34
    15ea:	fd a9       	ldd	r31, Y+53	; 0x35
    15ec:	80 81       	ld	r24, Z
    15ee:	91 81       	ldd	r25, Z+1	; 0x01
    15f0:	a2 81       	ldd	r26, Z+2	; 0x02
    15f2:	b3 81       	ldd	r27, Z+3	; 0x03
    15f4:	9c 01       	movw	r18, r24
    15f6:	ad 01       	movw	r20, r26
    15f8:	50 58       	subi	r21, 0x80	; 128
    15fa:	29 87       	std	Y+9, r18	; 0x09
    15fc:	3a 87       	std	Y+10, r19	; 0x0a
    15fe:	4b 87       	std	Y+11, r20	; 0x0b
    1600:	5c 87       	std	Y+12, r21	; 0x0c
    1602:	ae a9       	ldd	r26, Y+54	; 0x36
    1604:	bf a9       	ldd	r27, Y+55	; 0x37
    1606:	8d 91       	ld	r24, X+
    1608:	9d 91       	ld	r25, X+
    160a:	0d 90       	ld	r0, X+
    160c:	bc 91       	ld	r27, X
    160e:	a0 2d       	mov	r26, r0
    1610:	8d 83       	std	Y+5, r24	; 0x05
    1612:	9e 83       	std	Y+6, r25	; 0x06
    1614:	af 83       	std	Y+7, r26	; 0x07
    1616:	b8 87       	std	Y+8, r27	; 0x08
    1618:	a7 01       	movw	r20, r14
    161a:	96 01       	movw	r18, r12
    161c:	69 85       	ldd	r22, Y+9	; 0x09
    161e:	7a 85       	ldd	r23, Y+10	; 0x0a
    1620:	8b 85       	ldd	r24, Y+11	; 0x0b
    1622:	9c 85       	ldd	r25, Y+12	; 0x0c
    1624:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    1628:	2b 01       	movw	r4, r22
    162a:	3c 01       	movw	r6, r24
    162c:	a5 01       	movw	r20, r10
    162e:	94 01       	movw	r18, r8
    1630:	6d 81       	ldd	r22, Y+5	; 0x05
    1632:	7e 81       	ldd	r23, Y+6	; 0x06
    1634:	8f 81       	ldd	r24, Y+7	; 0x07
    1636:	98 85       	ldd	r25, Y+8	; 0x08
    1638:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    163c:	9b 01       	movw	r18, r22
    163e:	ac 01       	movw	r20, r24
    1640:	c3 01       	movw	r24, r6
    1642:	b2 01       	movw	r22, r4
    1644:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    1648:	2b 01       	movw	r4, r22
    164a:	3c 01       	movw	r6, r24
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
    164c:	29 85       	ldd	r18, Y+9	; 0x09
    164e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1650:	4b 85       	ldd	r20, Y+11	; 0x0b
    1652:	5c 85       	ldd	r21, Y+12	; 0x0c
    1654:	c5 01       	movw	r24, r10
    1656:	b4 01       	movw	r22, r8
    1658:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    165c:	4b 01       	movw	r8, r22
    165e:	5c 01       	movw	r10, r24
    1660:	2d 81       	ldd	r18, Y+5	; 0x05
    1662:	3e 81       	ldd	r19, Y+6	; 0x06
    1664:	4f 81       	ldd	r20, Y+7	; 0x07
    1666:	58 85       	ldd	r21, Y+8	; 0x08
    1668:	c7 01       	movw	r24, r14
    166a:	b6 01       	movw	r22, r12
    166c:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    1670:	9b 01       	movw	r18, r22
    1672:	ac 01       	movw	r20, r24
    1674:	c5 01       	movw	r24, r10
    1676:	b4 01       	movw	r22, r8
    1678:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    167c:	4b 01       	movw	r8, r22
    167e:	5c 01       	movw	r10, r24
        count = 0;
    1680:	10 e0       	ldi	r17, 0x00	; 0
      }
  
      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
    1682:	a3 01       	movw	r20, r6
    1684:	92 01       	movw	r18, r4
    1686:	6e 89       	ldd	r22, Y+22	; 0x16
    1688:	7f 89       	ldd	r23, Y+23	; 0x17
    168a:	88 8d       	ldd	r24, Y+24	; 0x18
    168c:	99 8d       	ldd	r25, Y+25	; 0x19
    168e:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    1692:	ec 89       	ldd	r30, Y+20	; 0x14
    1694:	fd 89       	ldd	r31, Y+21	; 0x15
    1696:	60 83       	st	Z, r22
    1698:	71 83       	std	Z+1, r23	; 0x01
    169a:	82 83       	std	Z+2, r24	; 0x02
    169c:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
    169e:	a5 01       	movw	r20, r10
    16a0:	94 01       	movw	r18, r8
    16a2:	6c 8d       	ldd	r22, Y+28	; 0x1c
    16a4:	7d 8d       	ldd	r23, Y+29	; 0x1d
    16a6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16a8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    16aa:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    16ae:	aa 8d       	ldd	r26, Y+26	; 0x1a
    16b0:	bb 8d       	ldd	r27, Y+27	; 0x1b
    16b2:	6d 93       	st	X+, r22
    16b4:	7d 93       	st	X+, r23
    16b6:	8d 93       	st	X+, r24
    16b8:	9c 93       	st	X, r25
    16ba:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
    16bc:	2c a1       	ldd	r18, Y+36	; 0x24
    16be:	3d a1       	ldd	r19, Y+37	; 0x25
    16c0:	4e a1       	ldd	r20, Y+38	; 0x26
    16c2:	5f a1       	ldd	r21, Y+39	; 0x27
    16c4:	e9 81       	ldd	r30, Y+1	; 0x01
    16c6:	fa 81       	ldd	r31, Y+2	; 0x02
    16c8:	60 81       	ld	r22, Z
    16ca:	71 81       	ldd	r23, Z+1	; 0x01
    16cc:	82 81       	ldd	r24, Z+2	; 0x02
    16ce:	93 81       	ldd	r25, Z+3	; 0x03
    16d0:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    16d4:	a9 81       	ldd	r26, Y+1	; 0x01
    16d6:	ba 81       	ldd	r27, Y+2	; 0x02
    16d8:	6d 93       	st	X+, r22
    16da:	7d 93       	st	X+, r23
    16dc:	8d 93       	st	X+, r24
    16de:	9c 93       	st	X, r25
    16e0:	13 97       	sbiw	r26, 0x03	; 3
      
      #ifdef USE_LINE_NUMBERS
        mc_line(position, feed_rate, invert_feed_rate, line_number);
      #else
        mc_line(position, feed_rate, invert_feed_rate);
    16e2:	2b 89       	ldd	r18, Y+19	; 0x13
    16e4:	48 a1       	ldd	r20, Y+32	; 0x20
    16e6:	59 a1       	ldd	r21, Y+33	; 0x21
    16e8:	6a a1       	ldd	r22, Y+34	; 0x22
    16ea:	7b a1       	ldd	r23, Y+35	; 0x23
    16ec:	89 89       	ldd	r24, Y+17	; 0x11
    16ee:	9a 89       	ldd	r25, Y+18	; 0x12
    16f0:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <mc_line>
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    16f4:	e7 e6       	ldi	r30, 0x67	; 103
    16f6:	f7 e0       	ldi	r31, 0x07	; 7
    16f8:	80 81       	ld	r24, Z
    16fa:	81 11       	cpse	r24, r1
    16fc:	14 c0       	rjmp	.+40     	; 0x1726 <mc_arc+0x606>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    16fe:	ff ef       	ldi	r31, 0xFF	; 255
    1700:	2f 1a       	sub	r2, r31
    1702:	3f 0a       	sbc	r3, r31
    1704:	2d 85       	ldd	r18, Y+13	; 0x0d
    1706:	3e 85       	ldd	r19, Y+14	; 0x0e
    1708:	22 16       	cp	r2, r18
    170a:	33 06       	cpc	r3, r19
    170c:	09 f0       	breq	.+2      	; 0x1710 <mc_arc+0x5f0>
    170e:	19 cf       	rjmp	.-462    	; 0x1542 <mc_arc+0x422>
    1710:	c8 a0       	ldd	r12, Y+32	; 0x20
    1712:	d9 a0       	ldd	r13, Y+33	; 0x21
    1714:	ea a0       	ldd	r14, Y+34	; 0x22
    1716:	fb a0       	ldd	r15, Y+35	; 0x23
  }
  // Ensure last segment arrives at target location.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    1718:	2b 89       	ldd	r18, Y+19	; 0x13
    171a:	b7 01       	movw	r22, r14
    171c:	a6 01       	movw	r20, r12
    171e:	88 ad       	ldd	r24, Y+56	; 0x38
    1720:	99 ad       	ldd	r25, Y+57	; 0x39
    1722:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <mc_line>
  #endif
}
    1726:	e9 96       	adiw	r28, 0x39	; 57
    1728:	0f b6       	in	r0, 0x3f	; 63
    172a:	f8 94       	cli
    172c:	de bf       	out	0x3e, r29	; 62
    172e:	0f be       	out	0x3f, r0	; 63
    1730:	cd bf       	out	0x3d, r28	; 61
    1732:	df 91       	pop	r29
    1734:	cf 91       	pop	r28
    1736:	1f 91       	pop	r17
    1738:	0f 91       	pop	r16
    173a:	ff 90       	pop	r15
    173c:	ef 90       	pop	r14
    173e:	df 90       	pop	r13
    1740:	cf 90       	pop	r12
    1742:	bf 90       	pop	r11
    1744:	af 90       	pop	r10
    1746:	9f 90       	pop	r9
    1748:	8f 90       	pop	r8
    174a:	7f 90       	pop	r7
    174c:	6f 90       	pop	r6
    174e:	5f 90       	pop	r5
    1750:	4f 90       	pop	r4
    1752:	3f 90       	pop	r3
    1754:	2f 90       	pop	r2
    1756:	08 95       	ret

00001758 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
    1758:	8f 92       	push	r8
    175a:	9f 92       	push	r9
    175c:	af 92       	push	r10
    175e:	bf 92       	push	r11
    1760:	cf 92       	push	r12
    1762:	df 92       	push	r13
    1764:	ef 92       	push	r14
    1766:	ff 92       	push	r15
    1768:	cf 93       	push	r28
    176a:	df 93       	push	r29
    176c:	4b 01       	movw	r8, r22
    176e:	5c 01       	movw	r10, r24
   if (sys.state == STATE_CHECK_MODE) { return; }
    1770:	80 91 68 07 	lds	r24, 0x0768
    1774:	82 30       	cpi	r24, 0x02	; 2
    1776:	09 f4       	brne	.+2      	; 0x177a <mc_dwell+0x22>
    1778:	4a c0       	rjmp	.+148    	; 0x180e <mc_dwell+0xb6>
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
    177a:	20 e0       	ldi	r18, 0x00	; 0
    177c:	30 e0       	ldi	r19, 0x00	; 0
    177e:	40 ea       	ldi	r20, 0xA0	; 160
    1780:	51 e4       	ldi	r21, 0x41	; 65
    1782:	c5 01       	movw	r24, r10
    1784:	b4 01       	movw	r22, r8
    1786:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    178a:	0e 94 77 3d 	call	0x7aee	; 0x7aee <floor>
    178e:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
    1792:	6b 01       	movw	r12, r22
    1794:	7c 01       	movw	r14, r24
    1796:	eb 01       	movw	r28, r22
   protocol_buffer_synchronize();
    1798:	0e 94 fe 1a 	call	0x35fc	; 0x35fc <protocol_buffer_synchronize>
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
    179c:	20 e0       	ldi	r18, 0x00	; 0
    179e:	30 e0       	ldi	r19, 0x00	; 0
    17a0:	4a e7       	ldi	r20, 0x7A	; 122
    17a2:	54 e4       	ldi	r21, 0x44	; 68
    17a4:	c5 01       	movw	r24, r10
    17a6:	b4 01       	movw	r22, r8
    17a8:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    17ac:	4b 01       	movw	r8, r22
    17ae:	5c 01       	movw	r10, r24
    17b0:	82 e3       	ldi	r24, 0x32	; 50
    17b2:	8c 9d       	mul	r24, r12
    17b4:	b0 01       	movw	r22, r0
    17b6:	8d 9d       	mul	r24, r13
    17b8:	70 0d       	add	r23, r0
    17ba:	11 24       	eor	r1, r1
    17bc:	80 e0       	ldi	r24, 0x00	; 0
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	0e 94 3a 3d 	call	0x7a74	; 0x7a74 <__floatunsisf>
    17c4:	9b 01       	movw	r18, r22
    17c6:	ac 01       	movw	r20, r24
    17c8:	c5 01       	movw	r24, r10
    17ca:	b4 01       	movw	r22, r8
    17cc:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    17d0:	0e 94 77 3d 	call	0x7aee	; 0x7aee <floor>
    17d4:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
    17d8:	cb 01       	movw	r24, r22
    17da:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <delay_ms>
   while (i-- > 0) {
    17de:	cd 2b       	or	r28, r29
    17e0:	b1 f0       	breq	.+44     	; 0x180e <mc_dwell+0xb6>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
    17e2:	c7 e6       	ldi	r28, 0x67	; 103
    17e4:	d7 e0       	ldi	r29, 0x07	; 7
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
    17e6:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
     if (sys.abort) { return; }
    17ea:	88 81       	ld	r24, Y
    17ec:	81 11       	cpse	r24, r1
    17ee:	0f c0       	rjmp	.+30     	; 0x180e <mc_dwell+0xb6>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17f0:	2f ef       	ldi	r18, 0xFF	; 255
    17f2:	8f ec       	ldi	r24, 0xCF	; 207
    17f4:	92 e0       	ldi	r25, 0x02	; 2
    17f6:	21 50       	subi	r18, 0x01	; 1
    17f8:	80 40       	sbci	r24, 0x00	; 0
    17fa:	90 40       	sbci	r25, 0x00	; 0
    17fc:	e1 f7       	brne	.-8      	; 0x17f6 <mc_dwell+0x9e>
    17fe:	00 c0       	rjmp	.+0      	; 0x1800 <mc_dwell+0xa8>
    1800:	00 00       	nop
    1802:	21 e0       	ldi	r18, 0x01	; 1
    1804:	c2 1a       	sub	r12, r18
    1806:	d1 08       	sbc	r13, r1
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
    1808:	c1 14       	cp	r12, r1
    180a:	d1 04       	cpc	r13, r1
    180c:	61 f7       	brne	.-40     	; 0x17e6 <mc_dwell+0x8e>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   }
}
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	ff 90       	pop	r15
    1814:	ef 90       	pop	r14
    1816:	df 90       	pop	r13
    1818:	cf 90       	pop	r12
    181a:	bf 90       	pop	r11
    181c:	af 90       	pop	r10
    181e:	9f 90       	pop	r9
    1820:	8f 90       	pop	r8
    1822:	08 95       	ret

00001824 <mc_homing_cycle>:
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT));
      return;
    }
  #endif
   
  limits_disable(); // Disable hard limits pin change register for cycle duration
    1824:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <limits_disable>
    
  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  // Search to engage all axes limit switches at faster homing seek rate.
  limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    1828:	84 e0       	ldi	r24, 0x04	; 4
    182a:	0e 94 91 2f 	call	0x5f22	; 0x5f22 <limits_go_home>
  #ifdef HOMING_CYCLE_1
    limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
    182e:	83 e0       	ldi	r24, 0x03	; 3
    1830:	0e 94 91 2f 	call	0x5f22	; 0x5f22 <limits_go_home>
  #endif
  #ifdef HOMING_CYCLE_2
    limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
  #endif
    
  protocol_execute_realtime(); // Check for reset and set system abort.
    1834:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
    1838:	80 91 67 07 	lds	r24, 0x0767
    183c:	81 11       	cpse	r24, r1
    183e:	04 c0       	rjmp	.+8      	; 0x1848 <mc_homing_cycle+0x24>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Gcode parser position was circumvented by the limits_go_home() routine, so sync position now.
  gc_sync_position();
    1840:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <gc_sync_position>
  
  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
    1844:	0e 94 45 2f 	call	0x5e8a	; 0x5e8a <limits_init>
    1848:	08 95       	ret

0000184a <mc_probe_cycle>:
    uint8_t is_no_error, int32_t line_number)
#else
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate, uint8_t is_probe_away,
    uint8_t is_no_error)
#endif
{ 
    184a:	8f 92       	push	r8
    184c:	9f 92       	push	r9
    184e:	af 92       	push	r10
    1850:	bf 92       	push	r11
    1852:	cf 92       	push	r12
    1854:	df 92       	push	r13
    1856:	ef 92       	push	r14
    1858:	0f 93       	push	r16
    185a:	1f 93       	push	r17
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29
    1860:	6c 01       	movw	r12, r24
    1862:	4a 01       	movw	r8, r20
    1864:	5b 01       	movw	r10, r22
    1866:	c2 2f       	mov	r28, r18
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return; }
    1868:	90 91 68 07 	lds	r25, 0x0768
    186c:	92 30       	cpi	r25, 0x02	; 2
    186e:	09 f4       	brne	.+2      	; 0x1872 <mc_probe_cycle+0x28>
    1870:	68 c0       	rjmp	.+208    	; 0x1942 <mc_probe_cycle+0xf8>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
    1872:	0e 94 fe 1a 	call	0x35fc	; 0x35fc <protocol_buffer_synchronize>

  // Initialize probing control variables
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.  
    1876:	10 92 86 07 	sts	0x0786, r1
  probe_configure_invert_mask(is_probe_away);
    187a:	80 2f       	mov	r24, r16
    187c:	0e 94 1e 34 	call	0x683c	; 0x683c <probe_configure_invert_mask>
  
  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
    1880:	0e 94 30 34 	call	0x6860	; 0x6860 <probe_get_state>
    1884:	88 23       	and	r24, r24
    1886:	51 f0       	breq	.+20     	; 0x189c <mc_probe_cycle+0x52>
    bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_PROBE_FAIL);
    1888:	8f b7       	in	r24, 0x3f	; 63
    188a:	f8 94       	cli
    188c:	eb e6       	ldi	r30, 0x6B	; 107
    188e:	f7 e0       	ldi	r31, 0x07	; 7
    1890:	90 81       	ld	r25, Z
    1892:	90 61       	ori	r25, 0x10	; 16
    1894:	90 83       	st	Z, r25
    1896:	8f bf       	out	0x3f, r24	; 63
    protocol_execute_realtime();
    1898:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
  }
  if (sys.abort) { return; } // Return if system reset has been issued.
    189c:	80 91 67 07 	lds	r24, 0x0767
    18a0:	81 11       	cpse	r24, r1
    18a2:	4f c0       	rjmp	.+158    	; 0x1942 <mc_probe_cycle+0xf8>

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    18a4:	2c 2f       	mov	r18, r28
    18a6:	b5 01       	movw	r22, r10
    18a8:	a4 01       	movw	r20, r8
    18aa:	c6 01       	movw	r24, r12
    18ac:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <mc_line>
  #endif
  
  // Activate the probing state monitor in the stepper module.
  sys.probe_state = PROBE_ACTIVE;
    18b0:	81 e0       	ldi	r24, 0x01	; 1
    18b2:	80 93 79 07 	sts	0x0779, r24

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
    18b6:	8f b7       	in	r24, 0x3f	; 63
    18b8:	f8 94       	cli
    18ba:	ea e6       	ldi	r30, 0x6A	; 106
    18bc:	f7 e0       	ldi	r31, 0x07	; 7
    18be:	90 81       	ld	r25, Z
    18c0:	92 60       	ori	r25, 0x02	; 2
    18c2:	90 83       	st	Z, r25
    18c4:	8f bf       	out	0x3f, r24	; 63
  do {
    protocol_execute_realtime(); 
    if (sys.abort) { return; } // Check for system abort
    18c6:	c7 e6       	ldi	r28, 0x67	; 103
    18c8:	d7 e0       	ldi	r29, 0x07	; 7
  } while (sys.state != STATE_IDLE);
    18ca:	08 e6       	ldi	r16, 0x68	; 104
    18cc:	17 e0       	ldi	r17, 0x07	; 7
  sys.probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
  do {
    protocol_execute_realtime(); 
    18ce:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    18d2:	88 81       	ld	r24, Y
    18d4:	81 11       	cpse	r24, r1
    18d6:	35 c0       	rjmp	.+106    	; 0x1942 <mc_probe_cycle+0xf8>
  } while (sys.state != STATE_IDLE);
    18d8:	f8 01       	movw	r30, r16
    18da:	80 81       	ld	r24, Z
    18dc:	81 11       	cpse	r24, r1
    18de:	f7 cf       	rjmp	.-18     	; 0x18ce <mc_probe_cycle+0x84>
  
  // Probing cycle complete!
  
  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys.probe_state == PROBE_ACTIVE) {
    18e0:	80 91 79 07 	lds	r24, 0x0779
    18e4:	81 30       	cpi	r24, 0x01	; 1
    18e6:	a9 f4       	brne	.+42     	; 0x1912 <mc_probe_cycle+0xc8>
    if (is_no_error) { memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS); }
    18e8:	ee 20       	and	r14, r14
    18ea:	51 f0       	breq	.+20     	; 0x1900 <mc_probe_cycle+0xb6>
    18ec:	8c e0       	ldi	r24, 0x0C	; 12
    18ee:	ec e6       	ldi	r30, 0x6C	; 108
    18f0:	f7 e0       	ldi	r31, 0x07	; 7
    18f2:	aa e7       	ldi	r26, 0x7A	; 122
    18f4:	b7 e0       	ldi	r27, 0x07	; 7
    18f6:	01 90       	ld	r0, Z+
    18f8:	0d 92       	st	X+, r0
    18fa:	8a 95       	dec	r24
    18fc:	e1 f7       	brne	.-8      	; 0x18f6 <mc_probe_cycle+0xac>
    18fe:	0c c0       	rjmp	.+24     	; 0x1918 <mc_probe_cycle+0xce>
    else { bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_PROBE_FAIL); }
    1900:	8f b7       	in	r24, 0x3f	; 63
    1902:	f8 94       	cli
    1904:	eb e6       	ldi	r30, 0x6B	; 107
    1906:	f7 e0       	ldi	r31, 0x07	; 7
    1908:	90 81       	ld	r25, Z
    190a:	90 61       	ori	r25, 0x10	; 16
    190c:	90 83       	st	Z, r25
    190e:	8f bf       	out	0x3f, r24	; 63
    1910:	03 c0       	rjmp	.+6      	; 0x1918 <mc_probe_cycle+0xce>
  } else { 
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
    1912:	81 e0       	ldi	r24, 0x01	; 1
    1914:	80 93 86 07 	sts	0x0786, r24
  }
  sys.probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
    1918:	10 92 79 07 	sts	0x0779, r1
  protocol_execute_realtime();   // Check and execute run-time commands
    191c:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
  if (sys.abort) { return; } // Check for system abort
    1920:	80 91 67 07 	lds	r24, 0x0767
    1924:	81 11       	cpse	r24, r1
    1926:	0d c0       	rjmp	.+26     	; 0x1942 <mc_probe_cycle+0xf8>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reest step segment buffer.
    1928:	0e 94 fd 1d 	call	0x3bfa	; 0x3bfa <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
    192c:	0e 94 42 2a 	call	0x5484	; 0x5484 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    1930:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <plan_sync_position>

  // TODO: Update the g-code parser code to not require this target calculation but uses a gc_sync_position() call.
  // NOTE: The target[] variable updated here will be sent back and synced with the g-code parser.
  system_convert_array_steps_to_mpos(target, sys.position);
    1934:	6c e6       	ldi	r22, 0x6C	; 108
    1936:	77 e0       	ldi	r23, 0x07	; 7
    1938:	c6 01       	movw	r24, r12
    193a:	0e 94 a6 3b 	call	0x774c	; 0x774c <system_convert_array_steps_to_mpos>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
    193e:	0e 94 ce 36 	call	0x6d9c	; 0x6d9c <report_probe_parameters>
  #endif
}
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	1f 91       	pop	r17
    1948:	0f 91       	pop	r16
    194a:	ef 90       	pop	r14
    194c:	df 90       	pop	r13
    194e:	cf 90       	pop	r12
    1950:	bf 90       	pop	r11
    1952:	af 90       	pop	r10
    1954:	9f 90       	pop	r9
    1956:	8f 90       	pop	r8
    1958:	08 95       	ret

0000195a <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
    195a:	80 91 6a 07 	lds	r24, 0x076A
    195e:	84 fd       	sbrc	r24, 4
    1960:	1e c0       	rjmp	.+60     	; 0x199e <mc_reset+0x44>
    bit_true_atomic(sys.rt_exec_state, EXEC_RESET);
    1962:	8f b7       	in	r24, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	ea e6       	ldi	r30, 0x6A	; 106
    1968:	f7 e0       	ldi	r31, 0x07	; 7
    196a:	90 81       	ld	r25, Z
    196c:	90 61       	ori	r25, 0x10	; 16
    196e:	90 83       	st	Z, r25
    1970:	8f bf       	out	0x3f, r24	; 63

    // Kill spindle and coolant.   
    spindle_stop();
    1972:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <spindle_stop>
    coolant_stop();
    1976:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING)) || (sys.suspend == SUSPEND_ENABLE_HOLD)) {
    197a:	80 91 68 07 	lds	r24, 0x0768
    197e:	8c 70       	andi	r24, 0x0C	; 12
    1980:	21 f4       	brne	.+8      	; 0x198a <mc_reset+0x30>
    1982:	80 91 69 07 	lds	r24, 0x0769
    1986:	81 30       	cpi	r24, 0x01	; 1
    1988:	51 f4       	brne	.+20     	; 0x199e <mc_reset+0x44>
      bit_true_atomic(sys.rt_exec_alarm, EXEC_ALARM_ABORT_CYCLE);
    198a:	8f b7       	in	r24, 0x3f	; 63
    198c:	f8 94       	cli
    198e:	eb e6       	ldi	r30, 0x6B	; 107
    1990:	f7 e0       	ldi	r31, 0x07	; 7
    1992:	90 81       	ld	r25, Z
    1994:	98 60       	ori	r25, 0x08	; 8
    1996:	90 83       	st	Z, r25
    1998:	8f bf       	out	0x3f, r24	; 63
      st_go_idle(); // Force kill steppers. Position has likely been lost.
    199a:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <st_go_idle>
    199e:	08 95       	ret

000019a0 <gc_init>:
#define FAIL(status) return(status);


void gc_init() 
{
  memset(&gc_state, 0, sizeof(gc_state));
    19a0:	8f e3       	ldi	r24, 0x3F	; 63
    19a2:	e7 e8       	ldi	r30, 0x87	; 135
    19a4:	f7 e0       	ldi	r31, 0x07	; 7
    19a6:	df 01       	movw	r26, r30
    19a8:	1d 92       	st	X+, r1
    19aa:	8a 95       	dec	r24
    19ac:	e9 f7       	brne	.-6      	; 0x19a8 <gc_init+0x8>
  
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
    19ae:	6a ea       	ldi	r22, 0xAA	; 170
    19b0:	77 e0       	ldi	r23, 0x07	; 7
    19b2:	80 e0       	ldi	r24, 0x00	; 0
    19b4:	0e 94 28 27 	call	0x4e50	; 0x4e50 <settings_read_coord_data>
    19b8:	81 11       	cpse	r24, r1
    19ba:	03 c0       	rjmp	.+6      	; 0x19c2 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL); 
    19bc:	87 e0       	ldi	r24, 0x07	; 7
    19be:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
    19c2:	08 95       	ret

000019c4 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
    19c4:	6c e6       	ldi	r22, 0x6C	; 108
    19c6:	77 e0       	ldi	r23, 0x07	; 7
    19c8:	8e e9       	ldi	r24, 0x9E	; 158
    19ca:	97 e0       	ldi	r25, 0x07	; 7
    19cc:	0e 94 a6 3b 	call	0x774c	; 0x774c <system_convert_array_steps_to_mpos>
    19d0:	08 95       	ret

000019d2 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and 
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine 
// coordinates, respectively.
uint8_t gc_execute_line(char *line) 
{
    19d2:	2f 92       	push	r2
    19d4:	3f 92       	push	r3
    19d6:	4f 92       	push	r4
    19d8:	5f 92       	push	r5
    19da:	6f 92       	push	r6
    19dc:	7f 92       	push	r7
    19de:	8f 92       	push	r8
    19e0:	9f 92       	push	r9
    19e2:	af 92       	push	r10
    19e4:	bf 92       	push	r11
    19e6:	cf 92       	push	r12
    19e8:	df 92       	push	r13
    19ea:	ef 92       	push	r14
    19ec:	ff 92       	push	r15
    19ee:	0f 93       	push	r16
    19f0:	1f 93       	push	r17
    19f2:	cf 93       	push	r28
    19f4:	df 93       	push	r29
    19f6:	cd b7       	in	r28, 0x3d	; 61
    19f8:	de b7       	in	r29, 0x3e	; 62
    19fa:	ab 97       	sbiw	r28, 0x2b	; 43
    19fc:	0f b6       	in	r0, 0x3f	; 63
    19fe:	f8 94       	cli
    1a00:	de bf       	out	0x3e, r29	; 62
    1a02:	0f be       	out	0x3f, r0	; 63
    1a04:	cd bf       	out	0x3d, r28	; 61
    1a06:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
    1a08:	89 e3       	ldi	r24, 0x39	; 57
    1a0a:	e6 ec       	ldi	r30, 0xC6	; 198
    1a0c:	f7 e0       	ldi	r31, 0x07	; 7
    1a0e:	df 01       	movw	r26, r30
    1a10:	1d 92       	st	X+, r1
    1a12:	8a 95       	dec	r24
    1a14:	e9 f7       	brne	.-6      	; 0x1a10 <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
    1a16:	8a e0       	ldi	r24, 0x0A	; 10
    1a18:	e7 e8       	ldi	r30, 0x87	; 135
    1a1a:	f7 e0       	ldi	r31, 0x07	; 7
    1a1c:	a7 ec       	ldi	r26, 0xC7	; 199
    1a1e:	b7 e0       	ldi	r27, 0x07	; 7
    1a20:	01 90       	ld	r0, Z+
    1a22:	0d 92       	st	X+, r0
    1a24:	8a 95       	dec	r24
    1a26:	e1 f7       	brne	.-8      	; 0x1a20 <gc_execute_line+0x4e>
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also, 
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */
     
  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter = 0;  
    1a28:	19 8e       	std	Y+25, r1	; 0x19
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Value words. 
    1a2a:	21 2c       	mov	r2, r1
    1a2c:	31 2c       	mov	r3, r1
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
    1a2e:	e1 2c       	mov	r14, r1
    1a30:	f1 2c       	mov	r15, r1
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 
    1a32:	1b a2       	std	Y+35, r1	; 0x23
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
    1a34:	1f 8e       	std	Y+31, r1	; 0x1f
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
    1a36:	1e 8e       	std	Y+30, r1	; 0x1e
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1a38:	cc 24       	eor	r12, r12
    1a3a:	c3 94       	inc	r12
    1a3c:	d1 2c       	mov	r13, r1
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1a3e:	0f 2e       	mov	r0, r31
    1a40:	f1 e6       	ldi	r31, 0x61	; 97
    1a42:	8f 2e       	mov	r8, r31
    1a44:	f3 e0       	ldi	r31, 0x03	; 3
    1a46:	9f 2e       	mov	r9, r31
    1a48:	f0 2d       	mov	r31, r0
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1a4a:	ad c2       	rjmp	.+1370   	; 0x1fa6 <gc_execute_line+0x5d4>
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    1a4c:	9f eb       	ldi	r25, 0xBF	; 191
    1a4e:	9b 0d       	add	r25, r11
    1a50:	9a 31       	cpi	r25, 0x1A	; 26
    1a52:	10 f0       	brcs	.+4      	; 0x1a58 <gc_execute_line+0x86>
    1a54:	0c 94 2b 17 	jmp	0x2e56	; 0x2e56 <gc_execute_line+0x1484>
    char_counter++;
    1a58:	8f 5f       	subi	r24, 0xFF	; 255
    1a5a:	89 8f       	std	Y+25, r24	; 0x19
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    1a5c:	ae 01       	movw	r20, r28
    1a5e:	46 5e       	subi	r20, 0xE6	; 230
    1a60:	5f 4f       	sbci	r21, 0xFF	; 255
    1a62:	be 01       	movw	r22, r28
    1a64:	67 5e       	subi	r22, 0xE7	; 231
    1a66:	7f 4f       	sbci	r23, 0xFF	; 255
    1a68:	c8 01       	movw	r24, r16
    1a6a:	0e 94 f9 2d 	call	0x5bf2	; 0x5bf2 <read_float>
    1a6e:	88 23       	and	r24, r24
    1a70:	11 f4       	brne	.+4      	; 0x1a76 <gc_execute_line+0xa4>
    1a72:	0c 94 2d 17 	jmp	0x2e5a	; 0x2e5a <gc_execute_line+0x1488>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant, 
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later. 
    int_value = trunc(value);
    1a76:	4a 8c       	ldd	r4, Y+26	; 0x1a
    1a78:	5b 8c       	ldd	r5, Y+27	; 0x1b
    1a7a:	6c 8c       	ldd	r6, Y+28	; 0x1c
    1a7c:	7d 8c       	ldd	r7, Y+29	; 0x1d
    1a7e:	c3 01       	movw	r24, r6
    1a80:	b2 01       	movw	r22, r4
    1a82:	0e 94 a6 3f 	call	0x7f4c	; 0x7f4c <trunc>
    1a86:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
    1a8a:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
    1a8c:	70 e0       	ldi	r23, 0x00	; 0
    1a8e:	80 e0       	ldi	r24, 0x00	; 0
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	0e 94 3c 3d 	call	0x7a78	; 0x7a78 <__floatsisf>
    1a96:	9b 01       	movw	r18, r22
    1a98:	ac 01       	movw	r20, r24
    1a9a:	c3 01       	movw	r24, r6
    1a9c:	b2 01       	movw	r22, r4
    1a9e:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    1aa2:	20 e0       	ldi	r18, 0x00	; 0
    1aa4:	30 e0       	ldi	r19, 0x00	; 0
    1aa6:	48 ec       	ldi	r20, 0xC8	; 200
    1aa8:	52 e4       	ldi	r21, 0x42	; 66
    1aaa:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    1aae:	0e 94 3b 3f 	call	0x7e76	; 0x7e76 <round>
    1ab2:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
        // NOTE: Rounding must be used to catch small floating point errors. 

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
    1ab6:	b7 e4       	ldi	r27, 0x47	; 71
    1ab8:	bb 16       	cp	r11, r27
    1aba:	29 f0       	breq	.+10     	; 0x1ac6 <gc_execute_line+0xf4>
    1abc:	ed e4       	ldi	r30, 0x4D	; 77
    1abe:	be 16       	cp	r11, r30
    1ac0:	09 f4       	brne	.+2      	; 0x1ac4 <gc_execute_line+0xf2>
    1ac2:	5c c1       	rjmp	.+696    	; 0x1d7c <gc_execute_line+0x3aa>
    1ac4:	b9 c1       	rjmp	.+882    	; 0x1e38 <gc_execute_line+0x466>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
         
      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
    1ac6:	8a 2d       	mov	r24, r10
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	8f 35       	cpi	r24, 0x5F	; 95
    1acc:	91 05       	cpc	r25, r1
    1ace:	10 f0       	brcs	.+4      	; 0x1ad4 <gc_execute_line+0x102>
    1ad0:	0c 94 2f 17 	jmp	0x2e5e	; 0x2e5e <gc_execute_line+0x148c>
    1ad4:	fc 01       	movw	r30, r24
    1ad6:	e8 5c       	subi	r30, 0xC8	; 200
    1ad8:	ff 4f       	sbci	r31, 0xFF	; 255
    1ada:	0c 94 e7 3f 	jmp	0x7fce	; 0x7fce <__tablejump2__>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
    1ade:	61 15       	cp	r22, r1
    1ae0:	71 05       	cpc	r23, r1
    1ae2:	31 f4       	brne	.+12     	; 0x1af0 <gc_execute_line+0x11e>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1ae4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1ae6:	f1 11       	cpse	r31, r1
    1ae8:	0c 94 31 17 	jmp	0x2e62	; 0x2e62 <gc_execute_line+0x1490>
              axis_command = AXIS_COMMAND_NON_MODAL;
    1aec:	21 e0       	ldi	r18, 0x01	; 1
    1aee:	2e 8f       	std	Y+30, r18	; 0x1e
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
    1af0:	3c e1       	ldi	r19, 0x1C	; 28
    1af2:	a3 16       	cp	r10, r19
    1af4:	01 f1       	breq	.+64     	; 0x1b36 <gc_execute_line+0x164>
    1af6:	3a 15       	cp	r19, r10
    1af8:	38 f0       	brcs	.+14     	; 0x1b08 <gc_execute_line+0x136>
    1afa:	84 e0       	ldi	r24, 0x04	; 4
    1afc:	a8 16       	cp	r10, r24
    1afe:	79 f0       	breq	.+30     	; 0x1b1e <gc_execute_line+0x14c>
    1b00:	9a e0       	ldi	r25, 0x0A	; 10
    1b02:	a9 16       	cp	r10, r25
    1b04:	91 f0       	breq	.+36     	; 0x1b2a <gc_execute_line+0x158>
    1b06:	21 c1       	rjmp	.+578    	; 0x1d4a <gc_execute_line+0x378>
    1b08:	a5 e3       	ldi	r26, 0x35	; 53
    1b0a:	aa 16       	cp	r10, r26
    1b0c:	e1 f1       	breq	.+120    	; 0x1b86 <gc_execute_line+0x1b4>
    1b0e:	bc e5       	ldi	r27, 0x5C	; 92
    1b10:	ab 16       	cp	r10, r27
    1b12:	09 f4       	brne	.+2      	; 0x1b16 <gc_execute_line+0x144>
    1b14:	3e c0       	rjmp	.+124    	; 0x1b92 <gc_execute_line+0x1c0>
    1b16:	ee e1       	ldi	r30, 0x1E	; 30
    1b18:	ae 12       	cpse	r10, r30
    1b1a:	17 c1       	rjmp	.+558    	; 0x1d4a <gc_execute_line+0x378>
    1b1c:	20 c0       	rjmp	.+64     	; 0x1b5e <gc_execute_line+0x18c>
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
    1b1e:	81 e0       	ldi	r24, 0x01	; 1
    1b20:	a6 ec       	ldi	r26, 0xC6	; 198
    1b22:	b7 e0       	ldi	r27, 0x07	; 7
    1b24:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b26:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
    1b28:	15 c1       	rjmp	.+554    	; 0x1d54 <gc_execute_line+0x382>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
    1b2a:	82 e0       	ldi	r24, 0x02	; 2
    1b2c:	e6 ec       	ldi	r30, 0xC6	; 198
    1b2e:	f7 e0       	ldi	r31, 0x07	; 7
    1b30:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b32:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
    1b34:	0f c1       	rjmp	.+542    	; 0x1d54 <gc_execute_line+0x382>
              case 28:
                switch(mantissa) {
    1b36:	61 15       	cp	r22, r1
    1b38:	71 05       	cpc	r23, r1
    1b3a:	29 f0       	breq	.+10     	; 0x1b46 <gc_execute_line+0x174>
    1b3c:	6a 30       	cpi	r22, 0x0A	; 10
    1b3e:	71 05       	cpc	r23, r1
    1b40:	41 f0       	breq	.+16     	; 0x1b52 <gc_execute_line+0x180>
    1b42:	0c 94 33 17 	jmp	0x2e66	; 0x2e66 <gc_execute_line+0x1494>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
    1b46:	83 e0       	ldi	r24, 0x03	; 3
    1b48:	a6 ec       	ldi	r26, 0xC6	; 198
    1b4a:	b7 e0       	ldi	r27, 0x07	; 7
    1b4c:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b4e:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
    1b50:	05 c1       	rjmp	.+522    	; 0x1d5c <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
    1b52:	84 e0       	ldi	r24, 0x04	; 4
    1b54:	e6 ec       	ldi	r30, 0xC6	; 198
    1b56:	f7 e0       	ldi	r31, 0x07	; 7
    1b58:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
    1b5c:	ff c0       	rjmp	.+510    	; 0x1d5c <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
    1b5e:	61 15       	cp	r22, r1
    1b60:	71 05       	cpc	r23, r1
    1b62:	29 f0       	breq	.+10     	; 0x1b6e <gc_execute_line+0x19c>
    1b64:	6a 30       	cpi	r22, 0x0A	; 10
    1b66:	71 05       	cpc	r23, r1
    1b68:	41 f0       	breq	.+16     	; 0x1b7a <gc_execute_line+0x1a8>
    1b6a:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <gc_execute_line+0x1498>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
    1b6e:	85 e0       	ldi	r24, 0x05	; 5
    1b70:	a6 ec       	ldi	r26, 0xC6	; 198
    1b72:	b7 e0       	ldi	r27, 0x07	; 7
    1b74:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b76:	80 e0       	ldi	r24, 0x00	; 0
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
    1b78:	f1 c0       	rjmp	.+482    	; 0x1d5c <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
    1b7a:	86 e0       	ldi	r24, 0x06	; 6
    1b7c:	e6 ec       	ldi	r30, 0xC6	; 198
    1b7e:	f7 e0       	ldi	r31, 0x07	; 7
    1b80:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b82:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
    1b84:	eb c0       	rjmp	.+470    	; 0x1d5c <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
    1b86:	87 e0       	ldi	r24, 0x07	; 7
    1b88:	a6 ec       	ldi	r26, 0xC6	; 198
    1b8a:	b7 e0       	ldi	r27, 0x07	; 7
    1b8c:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1b8e:	80 e0       	ldi	r24, 0x00	; 0
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
    1b90:	e1 c0       	rjmp	.+450    	; 0x1d54 <gc_execute_line+0x382>
              case 92: 
                switch(mantissa) {
    1b92:	61 15       	cp	r22, r1
    1b94:	71 05       	cpc	r23, r1
    1b96:	29 f0       	breq	.+10     	; 0x1ba2 <gc_execute_line+0x1d0>
    1b98:	6a 30       	cpi	r22, 0x0A	; 10
    1b9a:	71 05       	cpc	r23, r1
    1b9c:	41 f0       	breq	.+16     	; 0x1bae <gc_execute_line+0x1dc>
    1b9e:	0c 94 37 17 	jmp	0x2e6e	; 0x2e6e <gc_execute_line+0x149c>
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
    1ba2:	88 e0       	ldi	r24, 0x08	; 8
    1ba4:	e6 ec       	ldi	r30, 0xC6	; 198
    1ba6:	f7 e0       	ldi	r31, 0x07	; 7
    1ba8:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1baa:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
    1bac:	d7 c0       	rjmp	.+430    	; 0x1d5c <gc_execute_line+0x38a>
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
    1bae:	89 e0       	ldi	r24, 0x09	; 9
    1bb0:	a6 ec       	ldi	r26, 0xC6	; 198
    1bb2:	b7 e0       	ldi	r27, 0x07	; 7
    1bb4:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1bb6:	80 e0       	ldi	r24, 0x00	; 0
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
    1bb8:	d1 c0       	rjmp	.+418    	; 0x1d5c <gc_execute_line+0x38a>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1bba:	be 8d       	ldd	r27, Y+30	; 0x1e
    1bbc:	b1 11       	cpse	r27, r1
    1bbe:	0c 94 39 17 	jmp	0x2e72	; 0x2e72 <gc_execute_line+0x14a0>
            axis_command = AXIS_COMMAND_MOTION_MODE; 
    1bc2:	e2 e0       	ldi	r30, 0x02	; 2
    1bc4:	ee 8f       	std	Y+30, r30	; 0x1e
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
            switch(int_value) {
    1bc6:	f2 e0       	ldi	r31, 0x02	; 2
    1bc8:	af 16       	cp	r10, r31
    1bca:	e9 f0       	breq	.+58     	; 0x1c06 <gc_execute_line+0x234>
    1bcc:	fa 15       	cp	r31, r10
    1bce:	30 f0       	brcs	.+12     	; 0x1bdc <gc_execute_line+0x20a>
    1bd0:	aa 20       	and	r10, r10
    1bd2:	79 f0       	breq	.+30     	; 0x1bf2 <gc_execute_line+0x220>
    1bd4:	21 e0       	ldi	r18, 0x01	; 1
    1bd6:	a2 16       	cp	r10, r18
    1bd8:	89 f0       	breq	.+34     	; 0x1bfc <gc_execute_line+0x22a>
    1bda:	b9 c0       	rjmp	.+370    	; 0x1d4e <gc_execute_line+0x37c>
    1bdc:	36 e2       	ldi	r19, 0x26	; 38
    1bde:	a3 16       	cp	r10, r19
    1be0:	f1 f0       	breq	.+60     	; 0x1c1e <gc_execute_line+0x24c>
    1be2:	80 e5       	ldi	r24, 0x50	; 80
    1be4:	a8 16       	cp	r10, r24
    1be6:	09 f4       	brne	.+2      	; 0x1bea <gc_execute_line+0x218>
    1be8:	43 c0       	rjmp	.+134    	; 0x1c70 <gc_execute_line+0x29e>
    1bea:	93 e0       	ldi	r25, 0x03	; 3
    1bec:	a9 12       	cpse	r10, r25
    1bee:	af c0       	rjmp	.+350    	; 0x1d4e <gc_execute_line+0x37c>
    1bf0:	10 c0       	rjmp	.+32     	; 0x1c12 <gc_execute_line+0x240>
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
    1bf2:	a7 ec       	ldi	r26, 0xC7	; 199
    1bf4:	b7 e0       	ldi	r27, 0x07	; 7
    1bf6:	1c 92       	st	X, r1
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
    1bfa:	ac c0       	rjmp	.+344    	; 0x1d54 <gc_execute_line+0x382>
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	e7 ec       	ldi	r30, 0xC7	; 199
    1c00:	f7 e0       	ldi	r31, 0x07	; 7
    1c02:	80 83       	st	Z, r24
    1c04:	a7 c0       	rjmp	.+334    	; 0x1d54 <gc_execute_line+0x382>
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
    1c06:	82 e0       	ldi	r24, 0x02	; 2
    1c08:	a7 ec       	ldi	r26, 0xC7	; 199
    1c0a:	b7 e0       	ldi	r27, 0x07	; 7
    1c0c:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c0e:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
    1c10:	a1 c0       	rjmp	.+322    	; 0x1d54 <gc_execute_line+0x382>
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
    1c12:	83 e0       	ldi	r24, 0x03	; 3
    1c14:	e7 ec       	ldi	r30, 0xC7	; 199
    1c16:	f7 e0       	ldi	r31, 0x07	; 7
    1c18:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
    1c1c:	9b c0       	rjmp	.+310    	; 0x1d54 <gc_execute_line+0x382>
              case 38: 
                switch(mantissa) {
    1c1e:	6e 31       	cpi	r22, 0x1E	; 30
    1c20:	71 05       	cpc	r23, r1
    1c22:	a1 f0       	breq	.+40     	; 0x1c4c <gc_execute_line+0x27a>
    1c24:	28 f4       	brcc	.+10     	; 0x1c30 <gc_execute_line+0x25e>
    1c26:	64 31       	cpi	r22, 0x14	; 20
    1c28:	71 05       	cpc	r23, r1
    1c2a:	51 f0       	breq	.+20     	; 0x1c40 <gc_execute_line+0x26e>
    1c2c:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <gc_execute_line+0x14a4>
    1c30:	68 32       	cpi	r22, 0x28	; 40
    1c32:	71 05       	cpc	r23, r1
    1c34:	89 f0       	breq	.+34     	; 0x1c58 <gc_execute_line+0x286>
    1c36:	62 33       	cpi	r22, 0x32	; 50
    1c38:	71 05       	cpc	r23, r1
    1c3a:	a1 f0       	breq	.+40     	; 0x1c64 <gc_execute_line+0x292>
    1c3c:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <gc_execute_line+0x14a4>
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
    1c40:	84 e0       	ldi	r24, 0x04	; 4
    1c42:	a7 ec       	ldi	r26, 0xC7	; 199
    1c44:	b7 e0       	ldi	r27, 0x07	; 7
    1c46:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c48:	81 e0       	ldi	r24, 0x01	; 1
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
    1c4a:	88 c0       	rjmp	.+272    	; 0x1d5c <gc_execute_line+0x38a>
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
    1c4c:	85 e0       	ldi	r24, 0x05	; 5
    1c4e:	e7 ec       	ldi	r30, 0xC7	; 199
    1c50:	f7 e0       	ldi	r31, 0x07	; 7
    1c52:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c54:	81 e0       	ldi	r24, 0x01	; 1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
    1c56:	82 c0       	rjmp	.+260    	; 0x1d5c <gc_execute_line+0x38a>
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
    1c58:	86 e0       	ldi	r24, 0x06	; 6
    1c5a:	a7 ec       	ldi	r26, 0xC7	; 199
    1c5c:	b7 e0       	ldi	r27, 0x07	; 7
    1c5e:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c60:	81 e0       	ldi	r24, 0x01	; 1
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
    1c62:	7c c0       	rjmp	.+248    	; 0x1d5c <gc_execute_line+0x38a>
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
    1c64:	87 e0       	ldi	r24, 0x07	; 7
    1c66:	e7 ec       	ldi	r30, 0xC7	; 199
    1c68:	f7 e0       	ldi	r31, 0x07	; 7
    1c6a:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
    1c6e:	76 c0       	rjmp	.+236    	; 0x1d5c <gc_execute_line+0x38a>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
    1c70:	88 e0       	ldi	r24, 0x08	; 8
    1c72:	a7 ec       	ldi	r26, 0xC7	; 199
    1c74:	b7 e0       	ldi	r27, 0x07	; 7
    1c76:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1c78:	81 e0       	ldi	r24, 0x01	; 1
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
    1c7a:	6c c0       	rjmp	.+216    	; 0x1d54 <gc_execute_line+0x382>
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
            switch(int_value) {
    1c7c:	b2 e1       	ldi	r27, 0x12	; 18
    1c7e:	ab 16       	cp	r10, r27
    1c80:	59 f0       	breq	.+22     	; 0x1c98 <gc_execute_line+0x2c6>
    1c82:	e3 e1       	ldi	r30, 0x13	; 19
    1c84:	ae 16       	cp	r10, r30
    1c86:	71 f0       	breq	.+28     	; 0x1ca4 <gc_execute_line+0x2d2>
    1c88:	f1 e1       	ldi	r31, 0x11	; 17
    1c8a:	af 12       	cpse	r10, r31
    1c8c:	62 c0       	rjmp	.+196    	; 0x1d52 <gc_execute_line+0x380>
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
    1c8e:	ab ec       	ldi	r26, 0xCB	; 203
    1c90:	b7 e0       	ldi	r27, 0x07	; 7
    1c92:	1c 92       	st	X, r1
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1c94:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
    1c96:	5e c0       	rjmp	.+188    	; 0x1d54 <gc_execute_line+0x382>
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
    1c98:	81 e0       	ldi	r24, 0x01	; 1
    1c9a:	eb ec       	ldi	r30, 0xCB	; 203
    1c9c:	f7 e0       	ldi	r31, 0x07	; 7
    1c9e:	80 83       	st	Z, r24
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1ca0:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
    1ca2:	58 c0       	rjmp	.+176    	; 0x1d54 <gc_execute_line+0x382>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
    1ca4:	82 e0       	ldi	r24, 0x02	; 2
    1ca6:	ab ec       	ldi	r26, 0xCB	; 203
    1ca8:	b7 e0       	ldi	r27, 0x07	; 7
    1caa:	8c 93       	st	X, r24
    1cac:	53 c0       	rjmp	.+166    	; 0x1d54 <gc_execute_line+0x382>
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
    1cae:	ba e5       	ldi	r27, 0x5A	; 90
    1cb0:	ab 12       	cpse	r10, r27
    1cb2:	05 c0       	rjmp	.+10     	; 0x1cbe <gc_execute_line+0x2ec>
    1cb4:	ea ec       	ldi	r30, 0xCA	; 202
    1cb6:	f7 e0       	ldi	r31, 0x07	; 7
    1cb8:	10 82       	st	Z, r1
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
    1cba:	83 e0       	ldi	r24, 0x03	; 3
    1cbc:	4b c0       	rjmp	.+150    	; 0x1d54 <gc_execute_line+0x382>
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	aa ec       	ldi	r26, 0xCA	; 202
    1cc2:	b7 e0       	ldi	r27, 0x07	; 7
    1cc4:	8c 93       	st	X, r24
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
    1cc6:	83 e0       	ldi	r24, 0x03	; 3
    1cc8:	45 c0       	rjmp	.+138    	; 0x1d54 <gc_execute_line+0x382>
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
    1cca:	bd e5       	ldi	r27, 0x5D	; 93
    1ccc:	ab 12       	cpse	r10, r27
    1cce:	06 c0       	rjmp	.+12     	; 0x1cdc <gc_execute_line+0x30a>
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	e8 ec       	ldi	r30, 0xC8	; 200
    1cd4:	f7 e0       	ldi	r31, 0x07	; 7
    1cd6:	80 83       	st	Z, r24
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
    1cd8:	84 e0       	ldi	r24, 0x04	; 4
    1cda:	3c c0       	rjmp	.+120    	; 0x1d54 <gc_execute_line+0x382>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
    1cdc:	a8 ec       	ldi	r26, 0xC8	; 200
    1cde:	b7 e0       	ldi	r27, 0x07	; 7
    1ce0:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
    1ce2:	84 e0       	ldi	r24, 0x04	; 4
    1ce4:	37 c0       	rjmp	.+110    	; 0x1d54 <gc_execute_line+0x382>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
    1ce6:	b4 e1       	ldi	r27, 0x14	; 20
    1ce8:	ab 12       	cpse	r10, r27
    1cea:	06 c0       	rjmp	.+12     	; 0x1cf8 <gc_execute_line+0x326>
    1cec:	81 e0       	ldi	r24, 0x01	; 1
    1cee:	e9 ec       	ldi	r30, 0xC9	; 201
    1cf0:	f7 e0       	ldi	r31, 0x07	; 7
    1cf2:	80 83       	st	Z, r24
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
    1cf4:	85 e0       	ldi	r24, 0x05	; 5
    1cf6:	2e c0       	rjmp	.+92     	; 0x1d54 <gc_execute_line+0x382>
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
    1cf8:	a9 ec       	ldi	r26, 0xC9	; 201
    1cfa:	b7 e0       	ldi	r27, 0x07	; 7
    1cfc:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
    1cfe:	85 e0       	ldi	r24, 0x05	; 5
    1d00:	29 c0       	rjmp	.+82     	; 0x1d54 <gc_execute_line+0x382>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    1d02:	be 8d       	ldd	r27, Y+30	; 0x1e
    1d04:	b1 11       	cpse	r27, r1
    1d06:	0c 94 3d 17 	jmp	0x2e7a	; 0x2e7a <gc_execute_line+0x14a8>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
    1d0a:	e1 e3       	ldi	r30, 0x31	; 49
    1d0c:	ae 12       	cpse	r10, r30
    1d0e:	07 c0       	rjmp	.+14     	; 0x1d1e <gc_execute_line+0x34c>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
    1d10:	ac ec       	ldi	r26, 0xCC	; 204
    1d12:	b7 e0       	ldi	r27, 0x07	; 7
    1d14:	1c 92       	st	X, r1
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1d16:	87 e0       	ldi	r24, 0x07	; 7
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1d18:	b3 e0       	ldi	r27, 0x03	; 3
    1d1a:	be 8f       	std	Y+30, r27	; 0x1e
    1d1c:	1f c0       	rjmp	.+62     	; 0x1d5c <gc_execute_line+0x38a>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
    1d1e:	6a 30       	cpi	r22, 0x0A	; 10
    1d20:	71 05       	cpc	r23, r1
    1d22:	11 f0       	breq	.+4      	; 0x1d28 <gc_execute_line+0x356>
    1d24:	0c 94 3f 17 	jmp	0x2e7e	; 0x2e7e <gc_execute_line+0x14ac>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    1d28:	81 e0       	ldi	r24, 0x01	; 1
    1d2a:	ec ec       	ldi	r30, 0xCC	; 204
    1d2c:	f7 e0       	ldi	r31, 0x07	; 7
    1d2e:	80 83       	st	Z, r24
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1d30:	87 e0       	ldi	r24, 0x07	; 7
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1d32:	f3 e0       	ldi	r31, 0x03	; 3
    1d34:	fe 8f       	std	Y+30, r31	; 0x1e
    1d36:	12 c0       	rjmp	.+36     	; 0x1d5c <gc_execute_line+0x38a>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
    1d38:	8a ec       	ldi	r24, 0xCA	; 202
    1d3a:	8a 0d       	add	r24, r10
    1d3c:	ad ec       	ldi	r26, 0xCD	; 205
    1d3e:	b7 e0       	ldi	r27, 0x07	; 7
    1d40:	8c 93       	st	X, r24
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    1d42:	88 e0       	ldi	r24, 0x08	; 8
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
    1d44:	07 c0       	rjmp	.+14     	; 0x1d54 <gc_execute_line+0x382>
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
    1d46:	86 e0       	ldi	r24, 0x06	; 6
    1d48:	05 c0       	rjmp	.+10     	; 0x1d54 <gc_execute_line+0x382>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1d4a:	80 e0       	ldi	r24, 0x00	; 0
    1d4c:	03 c0       	rjmp	.+6      	; 0x1d54 <gc_execute_line+0x382>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	01 c0       	rjmp	.+2      	; 0x1d54 <gc_execute_line+0x382>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1d52:	82 e0       	ldi	r24, 0x02	; 2
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1d54:	67 2b       	or	r22, r23
    1d56:	11 f0       	breq	.+4      	; 0x1d5c <gc_execute_line+0x38a>
    1d58:	0c 94 41 17 	jmp	0x2e82	; 0x2e82 <gc_execute_line+0x14b0>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1d5c:	f6 01       	movw	r30, r12
    1d5e:	02 c0       	rjmp	.+4      	; 0x1d64 <gc_execute_line+0x392>
    1d60:	ee 0f       	add	r30, r30
    1d62:	ff 1f       	adc	r31, r31
    1d64:	8a 95       	dec	r24
    1d66:	e2 f7       	brpl	.-8      	; 0x1d60 <gc_execute_line+0x38e>
    1d68:	9f 01       	movw	r18, r30
    1d6a:	2e 21       	and	r18, r14
    1d6c:	3f 21       	and	r19, r15
    1d6e:	23 2b       	or	r18, r19
    1d70:	11 f0       	breq	.+4      	; 0x1d76 <gc_execute_line+0x3a4>
    1d72:	0c 94 43 17 	jmp	0x2e86	; 0x2e86 <gc_execute_line+0x14b4>
        command_words |= bit(word_bit);
    1d76:	ee 2a       	or	r14, r30
    1d78:	ff 2a       	or	r15, r31
        break;
    1d7a:	15 c1       	rjmp	.+554    	; 0x1fa6 <gc_execute_line+0x5d4>
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    1d7c:	67 2b       	or	r22, r23
    1d7e:	11 f0       	breq	.+4      	; 0x1d84 <gc_execute_line+0x3b2>
    1d80:	0c 94 45 17 	jmp	0x2e8a	; 0x2e8a <gc_execute_line+0x14b8>
        switch(int_value) {
    1d84:	8a 2d       	mov	r24, r10
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	8f 31       	cpi	r24, 0x1F	; 31
    1d8a:	91 05       	cpc	r25, r1
    1d8c:	10 f0       	brcs	.+4      	; 0x1d92 <gc_execute_line+0x3c0>
    1d8e:	0c 94 47 17 	jmp	0x2e8e	; 0x2e8e <gc_execute_line+0x14bc>
    1d92:	fc 01       	movw	r30, r24
    1d94:	e9 56       	subi	r30, 0x69	; 105
    1d96:	ff 4f       	sbci	r31, 0xFF	; 255
    1d98:	0c 94 e7 3f 	jmp	0x7fce	; 0x7fce <__tablejump2__>
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
            switch(int_value) {
    1d9c:	f2 e0       	ldi	r31, 0x02	; 2
    1d9e:	af 16       	cp	r10, r31
    1da0:	51 f0       	breq	.+20     	; 0x1db6 <gc_execute_line+0x3e4>
    1da2:	2e e1       	ldi	r18, 0x1E	; 30
    1da4:	a2 16       	cp	r10, r18
    1da6:	39 f0       	breq	.+14     	; 0x1db6 <gc_execute_line+0x3e4>
    1da8:	a1 10       	cpse	r10, r1
    1daa:	31 c0       	rjmp	.+98     	; 0x1e0e <gc_execute_line+0x43c>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1dac:	81 e0       	ldi	r24, 0x01	; 1
    1dae:	80 93 ce 07 	sts	0x07CE, r24
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1db2:	89 e0       	ldi	r24, 0x09	; 9
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1db4:	31 c0       	rjmp	.+98     	; 0x1e18 <gc_execute_line+0x446>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1db6:	82 e0       	ldi	r24, 0x02	; 2
    1db8:	80 93 ce 07 	sts	0x07CE, r24
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1dbc:	89 e0       	ldi	r24, 0x09	; 9
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1dbe:	2c c0       	rjmp	.+88     	; 0x1e18 <gc_execute_line+0x446>
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
            switch(int_value) {
    1dc0:	34 e0       	ldi	r19, 0x04	; 4
    1dc2:	a3 16       	cp	r10, r19
    1dc4:	59 f0       	breq	.+22     	; 0x1ddc <gc_execute_line+0x40a>
    1dc6:	85 e0       	ldi	r24, 0x05	; 5
    1dc8:	a8 16       	cp	r10, r24
    1dca:	69 f0       	breq	.+26     	; 0x1de6 <gc_execute_line+0x414>
    1dcc:	93 e0       	ldi	r25, 0x03	; 3
    1dce:	a9 12       	cpse	r10, r25
    1dd0:	20 c0       	rjmp	.+64     	; 0x1e12 <gc_execute_line+0x440>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1dd2:	81 e0       	ldi	r24, 0x01	; 1
    1dd4:	80 93 d0 07 	sts	0x07D0, r24
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1dd8:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1dda:	1e c0       	rjmp	.+60     	; 0x1e18 <gc_execute_line+0x446>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1ddc:	82 e0       	ldi	r24, 0x02	; 2
    1dde:	80 93 d0 07 	sts	0x07D0, r24
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1de2:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1de4:	19 c0       	rjmp	.+50     	; 0x1e18 <gc_execute_line+0x446>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1de6:	10 92 d0 07 	sts	0x07D0, r1
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1dea:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1dec:	15 c0       	rjmp	.+42     	; 0x1e18 <gc_execute_line+0x446>
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    1dee:	a8 e0       	ldi	r26, 0x08	; 8
    1df0:	aa 16       	cp	r10, r26
    1df2:	21 f0       	breq	.+8      	; 0x1dfc <gc_execute_line+0x42a>
    1df4:	b9 e0       	ldi	r27, 0x09	; 9
    1df6:	ab 16       	cp	r10, r27
    1df8:	31 f0       	breq	.+12     	; 0x1e06 <gc_execute_line+0x434>
    1dfa:	0d c0       	rjmp	.+26     	; 0x1e16 <gc_execute_line+0x444>
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1dfc:	82 e0       	ldi	r24, 0x02	; 2
    1dfe:	80 93 cf 07 	sts	0x07CF, r24
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1e02:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1e04:	09 c0       	rjmp	.+18     	; 0x1e18 <gc_execute_line+0x446>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1e06:	10 92 cf 07 	sts	0x07CF, r1
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1e0a:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1e0c:	05 c0       	rjmp	.+10     	; 0x1e18 <gc_execute_line+0x446>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1e0e:	89 e0       	ldi	r24, 0x09	; 9
    1e10:	03 c0       	rjmp	.+6      	; 0x1e18 <gc_execute_line+0x446>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
          case 3: case 4: case 5: 
            word_bit = MODAL_GROUP_M7; 
    1e12:	8a e0       	ldi	r24, 0x0A	; 10
    1e14:	01 c0       	rjmp	.+2      	; 0x1e18 <gc_execute_line+0x446>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1e16:	8b e0       	ldi	r24, 0x0B	; 11
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1e18:	f6 01       	movw	r30, r12
    1e1a:	02 c0       	rjmp	.+4      	; 0x1e20 <gc_execute_line+0x44e>
    1e1c:	ee 0f       	add	r30, r30
    1e1e:	ff 1f       	adc	r31, r31
    1e20:	8a 95       	dec	r24
    1e22:	e2 f7       	brpl	.-8      	; 0x1e1c <gc_execute_line+0x44a>
    1e24:	9f 01       	movw	r18, r30
    1e26:	2e 21       	and	r18, r14
    1e28:	3f 21       	and	r19, r15
    1e2a:	23 2b       	or	r18, r19
    1e2c:	11 f0       	breq	.+4      	; 0x1e32 <gc_execute_line+0x460>
    1e2e:	0c 94 49 17 	jmp	0x2e92	; 0x2e92 <gc_execute_line+0x14c0>
        command_words |= bit(word_bit);
    1e32:	ee 2a       	or	r14, r30
    1e34:	ff 2a       	or	r15, r31
        break;
    1e36:	b7 c0       	rjmp	.+366    	; 0x1fa6 <gc_execute_line+0x5d4>
      default: 
  
        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    1e38:	8b 2d       	mov	r24, r11
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
    1e3c:	fc 01       	movw	r30, r24
    1e3e:	e6 54       	subi	r30, 0x46	; 70
    1e40:	f1 09       	sbc	r31, r1
    1e42:	e5 31       	cpi	r30, 0x15	; 21
    1e44:	f1 05       	cpc	r31, r1
    1e46:	10 f0       	brcs	.+4      	; 0x1e4c <gc_execute_line+0x47a>
    1e48:	0c 94 4b 17 	jmp	0x2e96	; 0x2e96 <gc_execute_line+0x14c4>
    1e4c:	ea 54       	subi	r30, 0x4A	; 74
    1e4e:	ff 4f       	sbci	r31, 0xFF	; 255
    1e50:	0c 94 e7 3f 	jmp	0x7fce	; 0x7fce <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    1e54:	40 92 d1 07 	sts	0x07D1, r4
    1e58:	50 92 d2 07 	sts	0x07D2, r5
    1e5c:	60 92 d3 07 	sts	0x07D3, r6
    1e60:	70 92 d4 07 	sts	0x07D4, r7
    1e64:	20 e0       	ldi	r18, 0x00	; 0
    1e66:	7e c0       	rjmp	.+252    	; 0x1f64 <gc_execute_line+0x592>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    1e68:	40 92 d5 07 	sts	0x07D5, r4
    1e6c:	50 92 d6 07 	sts	0x07D6, r5
    1e70:	60 92 d7 07 	sts	0x07D7, r6
    1e74:	70 92 d8 07 	sts	0x07D8, r7
    1e78:	fb a1       	ldd	r31, Y+35	; 0x23
    1e7a:	f1 60       	ori	r31, 0x01	; 1
    1e7c:	fb a3       	std	Y+35, r31	; 0x23
    1e7e:	21 e0       	ldi	r18, 0x01	; 1
    1e80:	71 c0       	rjmp	.+226    	; 0x1f64 <gc_execute_line+0x592>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    1e82:	40 92 d9 07 	sts	0x07D9, r4
    1e86:	50 92 da 07 	sts	0x07DA, r5
    1e8a:	60 92 db 07 	sts	0x07DB, r6
    1e8e:	70 92 dc 07 	sts	0x07DC, r7
    1e92:	2b a1       	ldd	r18, Y+35	; 0x23
    1e94:	22 60       	ori	r18, 0x02	; 2
    1e96:	2b a3       	std	Y+35, r18	; 0x23
    1e98:	22 e0       	ldi	r18, 0x02	; 2
    1e9a:	64 c0       	rjmp	.+200    	; 0x1f64 <gc_execute_line+0x592>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    1e9c:	40 92 dd 07 	sts	0x07DD, r4
    1ea0:	50 92 de 07 	sts	0x07DE, r5
    1ea4:	60 92 df 07 	sts	0x07DF, r6
    1ea8:	70 92 e0 07 	sts	0x07E0, r7
    1eac:	3b a1       	ldd	r19, Y+35	; 0x23
    1eae:	34 60       	ori	r19, 0x04	; 4
    1eb0:	3b a3       	std	Y+35, r19	; 0x23
    1eb2:	23 e0       	ldi	r18, 0x03	; 3
    1eb4:	57 c0       	rjmp	.+174    	; 0x1f64 <gc_execute_line+0x592>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    1eb6:	a0 92 e1 07 	sts	0x07E1, r10
    1eba:	24 e0       	ldi	r18, 0x04	; 4
    1ebc:	53 c0       	rjmp	.+166    	; 0x1f64 <gc_execute_line+0x592>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    1ebe:	c3 01       	movw	r24, r6
    1ec0:	b2 01       	movw	r22, r4
    1ec2:	0e 94 09 3d 	call	0x7a12	; 0x7a12 <__fixsfsi>
    1ec6:	60 93 e2 07 	sts	0x07E2, r22
    1eca:	70 93 e3 07 	sts	0x07E3, r23
    1ece:	80 93 e4 07 	sts	0x07E4, r24
    1ed2:	90 93 e5 07 	sts	0x07E5, r25
    1ed6:	25 e0       	ldi	r18, 0x05	; 5
    1ed8:	45 c0       	rjmp	.+138    	; 0x1f64 <gc_execute_line+0x592>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    1eda:	40 92 e6 07 	sts	0x07E6, r4
    1ede:	50 92 e7 07 	sts	0x07E7, r5
    1ee2:	60 92 e8 07 	sts	0x07E8, r6
    1ee6:	70 92 e9 07 	sts	0x07E9, r7
    1eea:	26 e0       	ldi	r18, 0x06	; 6
    1eec:	3b c0       	rjmp	.+118    	; 0x1f64 <gc_execute_line+0x592>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1eee:	40 92 ea 07 	sts	0x07EA, r4
    1ef2:	50 92 eb 07 	sts	0x07EB, r5
    1ef6:	60 92 ec 07 	sts	0x07EC, r6
    1efa:	70 92 ed 07 	sts	0x07ED, r7
    1efe:	27 e0       	ldi	r18, 0x07	; 7
    1f00:	31 c0       	rjmp	.+98     	; 0x1f64 <gc_execute_line+0x592>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    1f02:	40 92 ee 07 	sts	0x07EE, r4
    1f06:	50 92 ef 07 	sts	0x07EF, r5
    1f0a:	60 92 f0 07 	sts	0x07F0, r6
    1f0e:	70 92 f1 07 	sts	0x07F1, r7
    1f12:	28 e0       	ldi	r18, 0x08	; 8
    1f14:	27 c0       	rjmp	.+78     	; 0x1f64 <gc_execute_line+0x592>
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    1f16:	40 92 f3 07 	sts	0x07F3, r4
    1f1a:	50 92 f4 07 	sts	0x07F4, r5
    1f1e:	60 92 f5 07 	sts	0x07F5, r6
    1f22:	70 92 f6 07 	sts	0x07F6, r7
    1f26:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1f28:	81 60       	ori	r24, 0x01	; 1
    1f2a:	8f 8f       	std	Y+31, r24	; 0x1f
    1f2c:	2a e0       	ldi	r18, 0x0A	; 10
    1f2e:	1a c0       	rjmp	.+52     	; 0x1f64 <gc_execute_line+0x592>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    1f30:	40 92 f7 07 	sts	0x07F7, r4
    1f34:	50 92 f8 07 	sts	0x07F8, r5
    1f38:	60 92 f9 07 	sts	0x07F9, r6
    1f3c:	70 92 fa 07 	sts	0x07FA, r7
    1f40:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1f42:	92 60       	ori	r25, 0x02	; 2
    1f44:	9f 8f       	std	Y+31, r25	; 0x1f
    1f46:	2b e0       	ldi	r18, 0x0B	; 11
    1f48:	0d c0       	rjmp	.+26     	; 0x1f64 <gc_execute_line+0x592>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    1f4a:	ab ef       	ldi	r26, 0xFB	; 251
    1f4c:	b7 e0       	ldi	r27, 0x07	; 7
    1f4e:	4d 92       	st	X+, r4
    1f50:	5d 92       	st	X+, r5
    1f52:	6d 92       	st	X+, r6
    1f54:	7c 92       	st	X, r7
    1f56:	13 97       	sbiw	r26, 0x03	; 3
    1f58:	bf 8d       	ldd	r27, Y+31	; 0x1f
    1f5a:	b4 60       	ori	r27, 0x04	; 4
    1f5c:	bf 8f       	std	Y+31, r27	; 0x1f
    1f5e:	2c e0       	ldi	r18, 0x0C	; 12
    1f60:	01 c0       	rjmp	.+2      	; 0x1f64 <gc_execute_line+0x592>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
    1f62:	29 e0       	ldi	r18, 0x09	; 9
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1f64:	56 01       	movw	r10, r12
    1f66:	02 2e       	mov	r0, r18
    1f68:	02 c0       	rjmp	.+4      	; 0x1f6e <gc_execute_line+0x59c>
    1f6a:	aa 0c       	add	r10, r10
    1f6c:	bb 1c       	adc	r11, r11
    1f6e:	0a 94       	dec	r0
    1f70:	e2 f7       	brpl	.-8      	; 0x1f6a <gc_execute_line+0x598>
    1f72:	c5 01       	movw	r24, r10
    1f74:	82 21       	and	r24, r2
    1f76:	93 21       	and	r25, r3
    1f78:	89 2b       	or	r24, r25
    1f7a:	09 f0       	breq	.+2      	; 0x1f7e <gc_execute_line+0x5ac>
    1f7c:	8e c7       	rjmp	.+3868   	; 0x2e9a <gc_execute_line+0x14c8>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1f7e:	c4 01       	movw	r24, r8
    1f80:	02 c0       	rjmp	.+4      	; 0x1f86 <gc_execute_line+0x5b4>
    1f82:	95 95       	asr	r25
    1f84:	87 95       	ror	r24
    1f86:	2a 95       	dec	r18
    1f88:	e2 f7       	brpl	.-8      	; 0x1f82 <gc_execute_line+0x5b0>
    1f8a:	80 ff       	sbrs	r24, 0
    1f8c:	0a c0       	rjmp	.+20     	; 0x1fa2 <gc_execute_line+0x5d0>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    1f8e:	20 e0       	ldi	r18, 0x00	; 0
    1f90:	30 e0       	ldi	r19, 0x00	; 0
    1f92:	a9 01       	movw	r20, r18
    1f94:	c3 01       	movw	r24, r6
    1f96:	b2 01       	movw	r22, r4
    1f98:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    1f9c:	88 23       	and	r24, r24
    1f9e:	0c f4       	brge	.+2      	; 0x1fa2 <gc_execute_line+0x5d0>
    1fa0:	7e c7       	rjmp	.+3836   	; 0x2e9e <gc_execute_line+0x14cc>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    1fa2:	2a 28       	or	r2, r10
    1fa4:	3b 28       	or	r3, r11
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1fa6:	89 8d       	ldd	r24, Y+25	; 0x19
    1fa8:	f8 01       	movw	r30, r16
    1faa:	e8 0f       	add	r30, r24
    1fac:	f1 1d       	adc	r31, r1
    1fae:	b0 80       	ld	r11, Z
    1fb0:	b1 10       	cpse	r11, r1
    1fb2:	4c cd       	rjmp	.-1384   	; 0x1a4c <gc_execute_line+0x7a>
    1fb4:	81 01       	movw	r16, r2
    1fb6:	8e 8d       	ldd	r24, Y+30	; 0x1e
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  
  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    1fb8:	ef 8d       	ldd	r30, Y+31	; 0x1f
    1fba:	ee 23       	and	r30, r30
    1fbc:	21 f0       	breq	.+8      	; 0x1fc6 <gc_execute_line+0x5f4>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    1fbe:	81 11       	cpse	r24, r1
    1fc0:	02 c0       	rjmp	.+4      	; 0x1fc6 <gc_execute_line+0x5f4>
    1fc2:	f2 e0       	ldi	r31, 0x02	; 2
    1fc4:	fe 8f       	std	Y+30, r31	; 0x1e
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1fc6:	05 ff       	sbrs	r16, 5
    1fc8:	0e c0       	rjmp	.+28     	; 0x1fe6 <gc_execute_line+0x614>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1fca:	80 91 e2 07 	lds	r24, 0x07E2
    1fce:	90 91 e3 07 	lds	r25, 0x07E3
    1fd2:	a0 91 e4 07 	lds	r26, 0x07E4
    1fd6:	b0 91 e5 07 	lds	r27, 0x07E5
    1fda:	80 38       	cpi	r24, 0x80	; 128
    1fdc:	96 49       	sbci	r25, 0x96	; 150
    1fde:	a8 49       	sbci	r26, 0x98	; 152
    1fe0:	b1 05       	cpc	r27, r1
    1fe2:	0c f0       	brlt	.+2      	; 0x1fe6 <gc_execute_line+0x614>
    1fe4:	5e c7       	rjmp	.+3772   	; 0x2ea2 <gc_execute_line+0x14d0>
  
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
  
  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1fe6:	80 91 c8 07 	lds	r24, 0x07C8
    1fea:	81 30       	cpi	r24, 0x01	; 1
    1fec:	31 f4       	brne	.+12     	; 0x1ffa <gc_execute_line+0x628>
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
    1fee:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1ff0:	32 30       	cpi	r19, 0x02	; 2
    1ff2:	a1 f5       	brne	.+104    	; 0x205c <gc_execute_line+0x68a>
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1ff4:	00 ff       	sbrs	r16, 0
    1ff6:	57 c7       	rjmp	.+3758   	; 0x2ea6 <gc_execute_line+0x14d4>
    1ff8:	31 c0       	rjmp	.+98     	; 0x205c <gc_execute_line+0x68a>
    // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error 
    // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
  } else { // = G94
    // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    1ffa:	80 91 88 07 	lds	r24, 0x0788
    1ffe:	81 11       	cpse	r24, r1
    2000:	2d c0       	rjmp	.+90     	; 0x205c <gc_execute_line+0x68a>
      if (bit_istrue(value_words,bit(WORD_F))) {
    2002:	00 ff       	sbrs	r16, 0
    2004:	1b c0       	rjmp	.+54     	; 0x203c <gc_execute_line+0x66a>
        if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    2006:	80 91 c9 07 	lds	r24, 0x07C9
    200a:	81 30       	cpi	r24, 0x01	; 1
    200c:	39 f5       	brne	.+78     	; 0x205c <gc_execute_line+0x68a>
    200e:	0f 2e       	mov	r0, r31
    2010:	f1 ed       	ldi	r31, 0xD1	; 209
    2012:	cf 2e       	mov	r12, r31
    2014:	f7 e0       	ldi	r31, 0x07	; 7
    2016:	df 2e       	mov	r13, r31
    2018:	f0 2d       	mov	r31, r0
    201a:	23 e3       	ldi	r18, 0x33	; 51
    201c:	33 e3       	ldi	r19, 0x33	; 51
    201e:	4b ec       	ldi	r20, 0xCB	; 203
    2020:	51 e4       	ldi	r21, 0x41	; 65
    2022:	d6 01       	movw	r26, r12
    2024:	6d 91       	ld	r22, X+
    2026:	7d 91       	ld	r23, X+
    2028:	8d 91       	ld	r24, X+
    202a:	9c 91       	ld	r25, X
    202c:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    2030:	f6 01       	movw	r30, r12
    2032:	60 83       	st	Z, r22
    2034:	71 83       	std	Z+1, r23	; 0x01
    2036:	82 83       	std	Z+2, r24	; 0x02
    2038:	93 83       	std	Z+3, r25	; 0x03
    203a:	10 c0       	rjmp	.+32     	; 0x205c <gc_execute_line+0x68a>
      } else {
        gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    203c:	80 91 95 07 	lds	r24, 0x0795
    2040:	90 91 96 07 	lds	r25, 0x0796
    2044:	a0 91 97 07 	lds	r26, 0x0797
    2048:	b0 91 98 07 	lds	r27, 0x0798
    204c:	80 93 d1 07 	sts	0x07D1, r24
    2050:	90 93 d2 07 	sts	0x07D2, r25
    2054:	a0 93 d3 07 	sts	0x07D3, r26
    2058:	b0 93 d4 07 	sts	0x07D4, r27
    } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
  } 
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
  
  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    205c:	10 fd       	sbrc	r17, 0
    205e:	10 c0       	rjmp	.+32     	; 0x2080 <gc_execute_line+0x6ae>
    2060:	80 91 91 07 	lds	r24, 0x0791
    2064:	90 91 92 07 	lds	r25, 0x0792
    2068:	a0 91 93 07 	lds	r26, 0x0793
    206c:	b0 91 94 07 	lds	r27, 0x0794
    2070:	80 93 ee 07 	sts	0x07EE, r24
    2074:	90 93 ef 07 	sts	0x07EF, r25
    2078:	a0 93 f0 07 	sts	0x07F0, r26
    207c:	b0 93 f1 07 	sts	0x07F1, r27
  // [7. Spindle control ]: N/A
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    2080:	80 91 c6 07 	lds	r24, 0x07C6
    2084:	81 30       	cpi	r24, 0x01	; 1
    2086:	29 f4       	brne	.+10     	; 0x2092 <gc_execute_line+0x6c0>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2088:	06 ff       	sbrs	r16, 6
    208a:	0f c7       	rjmp	.+3614   	; 0x2eaa <gc_execute_line+0x14d8>
    bit_false(value_words,bit(WORD_P));
    208c:	18 01       	movw	r2, r16
    208e:	e8 94       	clt
    2090:	26 f8       	bld	r2, 6
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    2092:	80 91 cb 07 	lds	r24, 0x07CB
    2096:	88 23       	and	r24, r24
    2098:	19 f0       	breq	.+6      	; 0x20a0 <gc_execute_line+0x6ce>
    209a:	81 30       	cpi	r24, 0x01	; 1
    209c:	69 f0       	breq	.+26     	; 0x20b8 <gc_execute_line+0x6e6>
    209e:	06 c0       	rjmp	.+12     	; 0x20ac <gc_execute_line+0x6da>
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    20a0:	f2 e0       	ldi	r31, 0x02	; 2
    20a2:	fe a3       	std	Y+38, r31	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    20a4:	21 e0       	ldi	r18, 0x01	; 1
    20a6:	2d a3       	std	Y+37, r18	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    20a8:	1c a2       	std	Y+36, r1	; 0x24
    20aa:	0b c0       	rjmp	.+22     	; 0x20c2 <gc_execute_line+0x6f0>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    20ac:	1e a2       	std	Y+38, r1	; 0x26
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    20ae:	32 e0       	ldi	r19, 0x02	; 2
    20b0:	3d a3       	std	Y+37, r19	; 0x25
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    20b2:	81 e0       	ldi	r24, 0x01	; 1
    20b4:	8c a3       	std	Y+36, r24	; 0x24
    20b6:	05 c0       	rjmp	.+10     	; 0x20c2 <gc_execute_line+0x6f0>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    20b8:	91 e0       	ldi	r25, 0x01	; 1
    20ba:	9e a3       	std	Y+38, r25	; 0x26
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    20bc:	1d a2       	std	Y+37, r1	; 0x25
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    20be:	a2 e0       	ldi	r26, 0x02	; 2
    20c0:	ac a3       	std	Y+36, r26	; 0x24
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    20c2:	80 91 c9 07 	lds	r24, 0x07C9
    20c6:	81 30       	cpi	r24, 0x01	; 1
    20c8:	69 f5       	brne	.+90     	; 0x2124 <gc_execute_line+0x752>
    20ca:	0f 2e       	mov	r0, r31
    20cc:	f3 ef       	ldi	r31, 0xF3	; 243
    20ce:	af 2e       	mov	r10, r31
    20d0:	f7 e0       	ldi	r31, 0x07	; 7
    20d2:	bf 2e       	mov	r11, r31
    20d4:	f0 2d       	mov	r31, r0
    20d6:	00 e0       	ldi	r16, 0x00	; 0
    20d8:	10 e0       	ldi	r17, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    20da:	bf 8d       	ldd	r27, Y+31	; 0x1f
    20dc:	cb 2e       	mov	r12, r27
    20de:	d1 2c       	mov	r13, r1
    20e0:	c6 01       	movw	r24, r12
    20e2:	00 2e       	mov	r0, r16
    20e4:	02 c0       	rjmp	.+4      	; 0x20ea <gc_execute_line+0x718>
    20e6:	95 95       	asr	r25
    20e8:	87 95       	ror	r24
    20ea:	0a 94       	dec	r0
    20ec:	e2 f7       	brpl	.-8      	; 0x20e6 <gc_execute_line+0x714>
    20ee:	80 ff       	sbrs	r24, 0
    20f0:	11 c0       	rjmp	.+34     	; 0x2114 <gc_execute_line+0x742>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    20f2:	23 e3       	ldi	r18, 0x33	; 51
    20f4:	33 e3       	ldi	r19, 0x33	; 51
    20f6:	4b ec       	ldi	r20, 0xCB	; 203
    20f8:	51 e4       	ldi	r21, 0x41	; 65
    20fa:	f5 01       	movw	r30, r10
    20fc:	60 81       	ld	r22, Z
    20fe:	71 81       	ldd	r23, Z+1	; 0x01
    2100:	82 81       	ldd	r24, Z+2	; 0x02
    2102:	93 81       	ldd	r25, Z+3	; 0x03
    2104:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    2108:	d5 01       	movw	r26, r10
    210a:	6d 93       	st	X+, r22
    210c:	7d 93       	st	X+, r23
    210e:	8d 93       	st	X+, r24
    2110:	9c 93       	st	X, r25
    2112:	13 97       	sbiw	r26, 0x03	; 3
    2114:	0f 5f       	subi	r16, 0xFF	; 255
    2116:	1f 4f       	sbci	r17, 0xFF	; 255
    2118:	b4 e0       	ldi	r27, 0x04	; 4
    211a:	ab 0e       	add	r10, r27
    211c:	b1 1c       	adc	r11, r1
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    211e:	03 30       	cpi	r16, 0x03	; 3
    2120:	11 05       	cpc	r17, r1
    2122:	f1 f6       	brne	.-68     	; 0x20e0 <gc_execute_line+0x70e>
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are. 
  // [G43.1 Errors]: Motion command in same line. 
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    2124:	ee 8d       	ldd	r30, Y+30	; 0x1e
    2126:	e3 30       	cpi	r30, 0x03	; 3
    2128:	41 f4       	brne	.+16     	; 0x213a <gc_execute_line+0x768>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    212a:	80 91 cc 07 	lds	r24, 0x07CC
    212e:	81 30       	cpi	r24, 0x01	; 1
    2130:	21 f4       	brne	.+8      	; 0x213a <gc_execute_line+0x768>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    2132:	ff 8d       	ldd	r31, Y+31	; 0x1f
    2134:	f4 30       	cpi	r31, 0x04	; 4
    2136:	09 f0       	breq	.+2      	; 0x213a <gc_execute_line+0x768>
    2138:	ba c6       	rjmp	.+3444   	; 0x2eae <gc_execute_line+0x14dc>
  // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
    213a:	8c e0       	ldi	r24, 0x0C	; 12
    213c:	ea ea       	ldi	r30, 0xAA	; 170
    213e:	f7 e0       	ldi	r31, 0x07	; 7
    2140:	de 01       	movw	r26, r28
    2142:	11 96       	adiw	r26, 0x01	; 1
    2144:	01 90       	ld	r0, Z+
    2146:	0d 92       	st	X+, r0
    2148:	8a 95       	dec	r24
    214a:	e1 f7       	brne	.-8      	; 0x2144 <gc_execute_line+0x772>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    214c:	f0 fe       	sbrs	r15, 0
    214e:	11 c0       	rjmp	.+34     	; 0x2172 <gc_execute_line+0x7a0>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2150:	80 91 cd 07 	lds	r24, 0x07CD
    2154:	87 30       	cpi	r24, 0x07	; 7
    2156:	08 f0       	brcs	.+2      	; 0x215a <gc_execute_line+0x788>
    2158:	ac c6       	rjmp	.+3416   	; 0x2eb2 <gc_execute_line+0x14e0>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    215a:	90 91 8d 07 	lds	r25, 0x078D
    215e:	89 17       	cp	r24, r25
    2160:	41 f0       	breq	.+16     	; 0x2172 <gc_execute_line+0x7a0>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2162:	be 01       	movw	r22, r28
    2164:	6f 5f       	subi	r22, 0xFF	; 255
    2166:	7f 4f       	sbci	r23, 0xFF	; 255
    2168:	0e 94 28 27 	call	0x4e50	; 0x4e50 <settings_read_coord_data>
    216c:	88 23       	and	r24, r24
    216e:	09 f4       	brne	.+2      	; 0x2172 <gc_execute_line+0x7a0>
    2170:	a2 c6       	rjmp	.+3396   	; 0x2eb6 <gc_execute_line+0x14e4>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets. 
  switch (gc_block.non_modal_command) {
    2172:	50 90 c6 07 	lds	r5, 0x07C6
    2176:	22 e0       	ldi	r18, 0x02	; 2
    2178:	52 16       	cp	r5, r18
    217a:	29 f0       	breq	.+10     	; 0x2186 <gc_execute_line+0x7b4>
    217c:	38 e0       	ldi	r19, 0x08	; 8
    217e:	53 16       	cp	r5, r19
    2180:	09 f4       	brne	.+2      	; 0x2184 <gc_execute_line+0x7b2>
    2182:	a2 c0       	rjmp	.+324    	; 0x22c8 <gc_execute_line+0x8f6>
    2184:	0d c1       	rjmp	.+538    	; 0x23a0 <gc_execute_line+0x9ce>
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2186:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2188:	88 23       	and	r24, r24
    218a:	09 f4       	brne	.+2      	; 0x218e <gc_execute_line+0x7bc>
    218c:	96 c6       	rjmp	.+3372   	; 0x2eba <gc_execute_line+0x14e8>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    218e:	c1 01       	movw	r24, r2
    2190:	80 75       	andi	r24, 0x50	; 80
    2192:	99 27       	eor	r25, r25
    2194:	89 2b       	or	r24, r25
    2196:	09 f4       	brne	.+2      	; 0x219a <gc_execute_line+0x7c8>
    2198:	92 c6       	rjmp	.+3364   	; 0x2ebe <gc_execute_line+0x14ec>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    219a:	60 91 e6 07 	lds	r22, 0x07E6
    219e:	70 91 e7 07 	lds	r23, 0x07E7
    21a2:	80 91 e8 07 	lds	r24, 0x07E8
    21a6:	90 91 e9 07 	lds	r25, 0x07E9
    21aa:	0e 94 a6 3f 	call	0x7f4c	; 0x7f4c <trunc>
    21ae:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    21b2:	67 30       	cpi	r22, 0x07	; 7
    21b4:	08 f0       	brcs	.+2      	; 0x21b8 <gc_execute_line+0x7e6>
    21b6:	85 c6       	rjmp	.+3338   	; 0x2ec2 <gc_execute_line+0x14f0>
      if (gc_block.values.l != 20) {
    21b8:	80 91 e1 07 	lds	r24, 0x07E1
    21bc:	84 31       	cpi	r24, 0x14	; 20
    21be:	29 f0       	breq	.+10     	; 0x21ca <gc_execute_line+0x7f8>
        if (gc_block.values.l == 2) {
    21c0:	82 30       	cpi	r24, 0x02	; 2
    21c2:	09 f0       	breq	.+2      	; 0x21c6 <gc_execute_line+0x7f4>
    21c4:	80 c6       	rjmp	.+3328   	; 0x2ec6 <gc_execute_line+0x14f4>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    21c6:	27 fc       	sbrc	r2, 7
    21c8:	80 c6       	rjmp	.+3328   	; 0x2eca <gc_execute_line+0x14f8>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    21ca:	9f ea       	ldi	r25, 0xAF	; 175
    21cc:	29 22       	and	r2, r25
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    21ce:	66 23       	and	r22, r22
    21d0:	19 f0       	breq	.+6      	; 0x21d8 <gc_execute_line+0x806>
    21d2:	61 50       	subi	r22, 0x01	; 1
    21d4:	6f a3       	std	Y+39, r22	; 0x27
    21d6:	03 c0       	rjmp	.+6      	; 0x21de <gc_execute_line+0x80c>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    21d8:	a0 91 cd 07 	lds	r26, 0x07CD
    21dc:	af a3       	std	Y+39, r26	; 0x27
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    21de:	be 01       	movw	r22, r28
    21e0:	63 5f       	subi	r22, 0xF3	; 243
    21e2:	7f 4f       	sbci	r23, 0xFF	; 255
    21e4:	8f a1       	ldd	r24, Y+39	; 0x27
    21e6:	0e 94 28 27 	call	0x4e50	; 0x4e50 <settings_read_coord_data>
    21ea:	88 23       	and	r24, r24
    21ec:	09 f4       	brne	.+2      	; 0x21f0 <gc_execute_line+0x81e>
    21ee:	6f c6       	rjmp	.+3294   	; 0x2ece <gc_execute_line+0x14fc>
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    21f0:	b0 91 e1 07 	lds	r27, 0x07E1
    21f4:	b8 a7       	std	Y+40, r27	; 0x28
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    21f6:	c0 90 c2 07 	lds	r12, 0x07C2
    21fa:	d0 90 c3 07 	lds	r13, 0x07C3
    21fe:	e0 90 c4 07 	lds	r14, 0x07C4
    2202:	f0 90 c5 07 	lds	r15, 0x07C5
    2206:	5e 01       	movw	r10, r28
    2208:	ed e0       	ldi	r30, 0x0D	; 13
    220a:	ae 0e       	add	r10, r30
    220c:	b1 1c       	adc	r11, r1
    220e:	0f 2e       	mov	r0, r31
    2210:	f3 ef       	ldi	r31, 0xF3	; 243
    2212:	8f 2e       	mov	r8, r31
    2214:	f7 e0       	ldi	r31, 0x07	; 7
    2216:	9f 2e       	mov	r9, r31
    2218:	f0 2d       	mov	r31, r0
    221a:	0f 2e       	mov	r0, r31
    221c:	fe e9       	ldi	r31, 0x9E	; 158
    221e:	6f 2e       	mov	r6, r31
    2220:	f7 e0       	ldi	r31, 0x07	; 7
    2222:	7f 2e       	mov	r7, r31
    2224:	f0 2d       	mov	r31, r0
    2226:	00 e0       	ldi	r16, 0x00	; 0
    2228:	10 e0       	ldi	r17, 0x00	; 0
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    222a:	ff 8d       	ldd	r31, Y+31	; 0x1f
    222c:	4f 2e       	mov	r4, r31
    222e:	51 2c       	mov	r5, r1
    2230:	c2 01       	movw	r24, r4
    2232:	00 2e       	mov	r0, r16
    2234:	02 c0       	rjmp	.+4      	; 0x223a <gc_execute_line+0x868>
    2236:	95 95       	asr	r25
    2238:	87 95       	ror	r24
    223a:	0a 94       	dec	r0
    223c:	e2 f7       	brpl	.-8      	; 0x2236 <gc_execute_line+0x864>
    223e:	80 ff       	sbrs	r24, 0
    2240:	33 c0       	rjmp	.+102    	; 0x22a8 <gc_execute_line+0x8d6>
          if (gc_block.values.l == 20) {
    2242:	28 a5       	ldd	r18, Y+40	; 0x28
    2244:	24 31       	cpi	r18, 0x14	; 20
    2246:	31 f5       	brne	.+76     	; 0x2294 <gc_execute_line+0x8c2>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    2248:	d3 01       	movw	r26, r6
    224a:	58 96       	adiw	r26, 0x18	; 24
    224c:	2d 91       	ld	r18, X+
    224e:	3d 91       	ld	r19, X+
    2250:	4d 91       	ld	r20, X+
    2252:	5c 91       	ld	r21, X
    2254:	5b 97       	sbiw	r26, 0x1b	; 27
    2256:	6d 91       	ld	r22, X+
    2258:	7d 91       	ld	r23, X+
    225a:	8d 91       	ld	r24, X+
    225c:	9c 91       	ld	r25, X
    225e:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    2262:	f4 01       	movw	r30, r8
    2264:	20 81       	ld	r18, Z
    2266:	31 81       	ldd	r19, Z+1	; 0x01
    2268:	42 81       	ldd	r20, Z+2	; 0x02
    226a:	53 81       	ldd	r21, Z+3	; 0x03
    226c:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    2270:	d5 01       	movw	r26, r10
    2272:	6d 93       	st	X+, r22
    2274:	7d 93       	st	X+, r23
    2276:	8d 93       	st	X+, r24
    2278:	9c 93       	st	X, r25
    227a:	13 97       	sbiw	r26, 0x03	; 3
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    227c:	02 30       	cpi	r16, 0x02	; 2
    227e:	a1 f4       	brne	.+40     	; 0x22a8 <gc_execute_line+0x8d6>
    2280:	a7 01       	movw	r20, r14
    2282:	96 01       	movw	r18, r12
    2284:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    2288:	f5 01       	movw	r30, r10
    228a:	60 83       	st	Z, r22
    228c:	71 83       	std	Z+1, r23	; 0x01
    228e:	82 83       	std	Z+2, r24	; 0x02
    2290:	93 83       	std	Z+3, r25	; 0x03
    2292:	0a c0       	rjmp	.+20     	; 0x22a8 <gc_execute_line+0x8d6>
          } else {
            // L2: Update coordinate system axis to programmed value.
            parameter_data[idx] = gc_block.values.xyz[idx]; 
    2294:	f4 01       	movw	r30, r8
    2296:	80 81       	ld	r24, Z
    2298:	91 81       	ldd	r25, Z+1	; 0x01
    229a:	a2 81       	ldd	r26, Z+2	; 0x02
    229c:	b3 81       	ldd	r27, Z+3	; 0x03
    229e:	f5 01       	movw	r30, r10
    22a0:	80 83       	st	Z, r24
    22a2:	91 83       	std	Z+1, r25	; 0x01
    22a4:	a2 83       	std	Z+2, r26	; 0x02
    22a6:	b3 83       	std	Z+3, r27	; 0x03
    22a8:	0f 5f       	subi	r16, 0xFF	; 255
    22aa:	1f 4f       	sbci	r17, 0xFF	; 255
    22ac:	f4 e0       	ldi	r31, 0x04	; 4
    22ae:	af 0e       	add	r10, r31
    22b0:	b1 1c       	adc	r11, r1
    22b2:	24 e0       	ldi	r18, 0x04	; 4
    22b4:	82 0e       	add	r8, r18
    22b6:	91 1c       	adc	r9, r1
    22b8:	34 e0       	ldi	r19, 0x04	; 4
    22ba:	63 0e       	add	r6, r19
    22bc:	71 1c       	adc	r7, r1
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    22be:	03 30       	cpi	r16, 0x03	; 3
    22c0:	11 05       	cpc	r17, r1
    22c2:	09 f0       	breq	.+2      	; 0x22c6 <gc_execute_line+0x8f4>
    22c4:	b5 cf       	rjmp	.-150    	; 0x2230 <gc_execute_line+0x85e>
    22c6:	24 c6       	rjmp	.+3144   	; 0x2f10 <gc_execute_line+0x153e>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    22c8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    22ca:	88 23       	and	r24, r24
    22cc:	09 f4       	brne	.+2      	; 0x22d0 <gc_execute_line+0x8fe>
    22ce:	01 c6       	rjmp	.+3074   	; 0x2ed2 <gc_execute_line+0x1500>
    22d0:	0f 2e       	mov	r0, r31
    22d2:	fe e9       	ldi	r31, 0x9E	; 158
    22d4:	cf 2e       	mov	r12, r31
    22d6:	f7 e0       	ldi	r31, 0x07	; 7
    22d8:	df 2e       	mov	r13, r31
    22da:	f0 2d       	mov	r31, r0
    22dc:	de 01       	movw	r26, r28
    22de:	11 96       	adiw	r26, 0x01	; 1
    22e0:	5d 01       	movw	r10, r26
    22e2:	0f 2e       	mov	r0, r31
    22e4:	f3 ef       	ldi	r31, 0xF3	; 243
    22e6:	ef 2e       	mov	r14, r31
    22e8:	f7 e0       	ldi	r31, 0x07	; 7
    22ea:	ff 2e       	mov	r15, r31
    22ec:	f0 2d       	mov	r31, r0
    22ee:	00 e0       	ldi	r16, 0x00	; 0
    22f0:	10 e0       	ldi	r17, 0x00	; 0
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    22f2:	88 2e       	mov	r8, r24
    22f4:	91 2c       	mov	r9, r1
    22f6:	c4 01       	movw	r24, r8
    22f8:	00 2e       	mov	r0, r16
    22fa:	02 c0       	rjmp	.+4      	; 0x2300 <gc_execute_line+0x92e>
    22fc:	95 95       	asr	r25
    22fe:	87 95       	ror	r24
    2300:	0a 94       	dec	r0
    2302:	e2 f7       	brpl	.-8      	; 0x22fc <gc_execute_line+0x92a>
    2304:	80 ff       	sbrs	r24, 0
    2306:	32 c0       	rjmp	.+100    	; 0x236c <gc_execute_line+0x99a>
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
    2308:	f5 01       	movw	r30, r10
    230a:	20 81       	ld	r18, Z
    230c:	31 81       	ldd	r19, Z+1	; 0x01
    230e:	42 81       	ldd	r20, Z+2	; 0x02
    2310:	53 81       	ldd	r21, Z+3	; 0x03
    2312:	d6 01       	movw	r26, r12
    2314:	6d 91       	ld	r22, X+
    2316:	7d 91       	ld	r23, X+
    2318:	8d 91       	ld	r24, X+
    231a:	9c 91       	ld	r25, X
    231c:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    2320:	f7 01       	movw	r30, r14
    2322:	20 81       	ld	r18, Z
    2324:	31 81       	ldd	r19, Z+1	; 0x01
    2326:	42 81       	ldd	r20, Z+2	; 0x02
    2328:	53 81       	ldd	r21, Z+3	; 0x03
    232a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    232e:	d7 01       	movw	r26, r14
    2330:	6d 93       	st	X+, r22
    2332:	7d 93       	st	X+, r23
    2334:	8d 93       	st	X+, r24
    2336:	9c 93       	st	X, r25
    2338:	13 97       	sbiw	r26, 0x03	; 3
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    233a:	02 30       	cpi	r16, 0x02	; 2
    233c:	09 f5       	brne	.+66     	; 0x2380 <gc_execute_line+0x9ae>
    233e:	00 0f       	add	r16, r16
    2340:	11 1f       	adc	r17, r17
    2342:	00 0f       	add	r16, r16
    2344:	11 1f       	adc	r17, r17
    2346:	0a 53       	subi	r16, 0x3A	; 58
    2348:	18 4f       	sbci	r17, 0xF8	; 248
    234a:	20 91 c2 07 	lds	r18, 0x07C2
    234e:	30 91 c3 07 	lds	r19, 0x07C3
    2352:	40 91 c4 07 	lds	r20, 0x07C4
    2356:	50 91 c5 07 	lds	r21, 0x07C5
    235a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    235e:	f8 01       	movw	r30, r16
    2360:	65 a7       	std	Z+45, r22	; 0x2d
    2362:	76 a7       	std	Z+46, r23	; 0x2e
    2364:	87 a7       	std	Z+47, r24	; 0x2f
    2366:	90 ab       	std	Z+48, r25	; 0x30
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    2368:	1f a2       	std	Y+39, r1	; 0x27
    236a:	d2 c5       	rjmp	.+2980   	; 0x2f10 <gc_execute_line+0x153e>
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    236c:	f6 01       	movw	r30, r12
    236e:	80 8d       	ldd	r24, Z+24	; 0x18
    2370:	91 8d       	ldd	r25, Z+25	; 0x19
    2372:	a2 8d       	ldd	r26, Z+26	; 0x1a
    2374:	b3 8d       	ldd	r27, Z+27	; 0x1b
    2376:	f7 01       	movw	r30, r14
    2378:	80 83       	st	Z, r24
    237a:	91 83       	std	Z+1, r25	; 0x01
    237c:	a2 83       	std	Z+2, r26	; 0x02
    237e:	b3 83       	std	Z+3, r27	; 0x03
    2380:	0f 5f       	subi	r16, 0xFF	; 255
    2382:	1f 4f       	sbci	r17, 0xFF	; 255
    2384:	f4 e0       	ldi	r31, 0x04	; 4
    2386:	cf 0e       	add	r12, r31
    2388:	d1 1c       	adc	r13, r1
    238a:	24 e0       	ldi	r18, 0x04	; 4
    238c:	a2 0e       	add	r10, r18
    238e:	b1 1c       	adc	r11, r1
    2390:	34 e0       	ldi	r19, 0x04	; 4
    2392:	e3 0e       	add	r14, r19
    2394:	f1 1c       	adc	r15, r1
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    2396:	03 30       	cpi	r16, 0x03	; 3
    2398:	11 05       	cpc	r17, r1
    239a:	09 f0       	breq	.+2      	; 0x239e <gc_execute_line+0x9cc>
    239c:	ac cf       	rjmp	.-168    	; 0x22f6 <gc_execute_line+0x924>
    239e:	b7 c5       	rjmp	.+2926   	; 0x2f0e <gc_execute_line+0x153c>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    23a0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23a2:	83 30       	cpi	r24, 0x03	; 3
    23a4:	09 f4       	brne	.+2      	; 0x23a8 <gc_execute_line+0x9d6>
    23a6:	87 c0       	rjmp	.+270    	; 0x24b6 <gc_execute_line+0xae4>
        if (axis_words) {
    23a8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    23aa:	99 23       	and	r25, r25
    23ac:	09 f4       	brne	.+2      	; 0x23b0 <gc_execute_line+0x9de>
    23ae:	83 c0       	rjmp	.+262    	; 0x24b6 <gc_execute_line+0xae4>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    23b0:	40 90 ca 07 	lds	r4, 0x07CA
    23b4:	0f 2e       	mov	r0, r31
    23b6:	fe e9       	ldi	r31, 0x9E	; 158
    23b8:	cf 2e       	mov	r12, r31
    23ba:	f7 e0       	ldi	r31, 0x07	; 7
    23bc:	df 2e       	mov	r13, r31
    23be:	f0 2d       	mov	r31, r0
    23c0:	0f 2e       	mov	r0, r31
    23c2:	f3 ef       	ldi	r31, 0xF3	; 243
    23c4:	ef 2e       	mov	r14, r31
    23c6:	f7 e0       	ldi	r31, 0x07	; 7
    23c8:	ff 2e       	mov	r15, r31
    23ca:	f0 2d       	mov	r31, r0
    23cc:	de 01       	movw	r26, r28
    23ce:	11 96       	adiw	r26, 0x01	; 1
    23d0:	5d 01       	movw	r10, r26
    23d2:	00 e0       	ldi	r16, 0x00	; 0
    23d4:	10 e0       	ldi	r17, 0x00	; 0
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    23d6:	89 2e       	mov	r8, r25
    23d8:	91 2c       	mov	r9, r1
    23da:	c4 01       	movw	r24, r8
    23dc:	00 2e       	mov	r0, r16
    23de:	02 c0       	rjmp	.+4      	; 0x23e4 <gc_execute_line+0xa12>
    23e0:	95 95       	asr	r25
    23e2:	87 95       	ror	r24
    23e4:	0a 94       	dec	r0
    23e6:	e2 f7       	brpl	.-8      	; 0x23e0 <gc_execute_line+0xa0e>
    23e8:	80 fd       	sbrc	r24, 0
    23ea:	0b c0       	rjmp	.+22     	; 0x2402 <gc_execute_line+0xa30>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    23ec:	f6 01       	movw	r30, r12
    23ee:	80 81       	ld	r24, Z
    23f0:	91 81       	ldd	r25, Z+1	; 0x01
    23f2:	a2 81       	ldd	r26, Z+2	; 0x02
    23f4:	b3 81       	ldd	r27, Z+3	; 0x03
    23f6:	f7 01       	movw	r30, r14
    23f8:	80 83       	st	Z, r24
    23fa:	91 83       	std	Z+1, r25	; 0x01
    23fc:	a2 83       	std	Z+2, r26	; 0x02
    23fe:	b3 83       	std	Z+3, r27	; 0x03
    2400:	4b c0       	rjmp	.+150    	; 0x2498 <gc_execute_line+0xac6>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    2402:	f7 e0       	ldi	r31, 0x07	; 7
    2404:	5f 16       	cp	r5, r31
    2406:	09 f4       	brne	.+2      	; 0x240a <gc_execute_line+0xa38>
    2408:	47 c0       	rjmp	.+142    	; 0x2498 <gc_execute_line+0xac6>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    240a:	41 10       	cpse	r4, r1
    240c:	34 c0       	rjmp	.+104    	; 0x2476 <gc_execute_line+0xaa4>
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
    240e:	d6 01       	movw	r26, r12
    2410:	58 96       	adiw	r26, 0x18	; 24
    2412:	2d 91       	ld	r18, X+
    2414:	3d 91       	ld	r19, X+
    2416:	4d 91       	ld	r20, X+
    2418:	5c 91       	ld	r21, X
    241a:	5b 97       	sbiw	r26, 0x1b	; 27
    241c:	f5 01       	movw	r30, r10
    241e:	60 81       	ld	r22, Z
    2420:	71 81       	ldd	r23, Z+1	; 0x01
    2422:	82 81       	ldd	r24, Z+2	; 0x02
    2424:	93 81       	ldd	r25, Z+3	; 0x03
    2426:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    242a:	d7 01       	movw	r26, r14
    242c:	2d 91       	ld	r18, X+
    242e:	3d 91       	ld	r19, X+
    2430:	4d 91       	ld	r20, X+
    2432:	5c 91       	ld	r21, X
    2434:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    2438:	f7 01       	movw	r30, r14
    243a:	60 83       	st	Z, r22
    243c:	71 83       	std	Z+1, r23	; 0x01
    243e:	82 83       	std	Z+2, r24	; 0x02
    2440:	93 83       	std	Z+3, r25	; 0x03
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    2442:	02 30       	cpi	r16, 0x02	; 2
    2444:	49 f5       	brne	.+82     	; 0x2498 <gc_execute_line+0xac6>
    2446:	00 0f       	add	r16, r16
    2448:	11 1f       	adc	r17, r17
    244a:	00 0f       	add	r16, r16
    244c:	11 1f       	adc	r17, r17
    244e:	0a 53       	subi	r16, 0x3A	; 58
    2450:	18 4f       	sbci	r17, 0xF8	; 248
    2452:	20 91 c2 07 	lds	r18, 0x07C2
    2456:	30 91 c3 07 	lds	r19, 0x07C3
    245a:	40 91 c4 07 	lds	r20, 0x07C4
    245e:	50 91 c5 07 	lds	r21, 0x07C5
    2462:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    2466:	d8 01       	movw	r26, r16
    2468:	9d 96       	adiw	r26, 0x2d	; 45
    246a:	6d 93       	st	X+, r22
    246c:	7d 93       	st	X+, r23
    246e:	8d 93       	st	X+, r24
    2470:	9c 93       	st	X, r25
    2472:	d0 97       	sbiw	r26, 0x30	; 48
    2474:	20 c0       	rjmp	.+64     	; 0x24b6 <gc_execute_line+0xae4>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    2476:	f6 01       	movw	r30, r12
    2478:	20 81       	ld	r18, Z
    247a:	31 81       	ldd	r19, Z+1	; 0x01
    247c:	42 81       	ldd	r20, Z+2	; 0x02
    247e:	53 81       	ldd	r21, Z+3	; 0x03
    2480:	d7 01       	movw	r26, r14
    2482:	6d 91       	ld	r22, X+
    2484:	7d 91       	ld	r23, X+
    2486:	8d 91       	ld	r24, X+
    2488:	9c 91       	ld	r25, X
    248a:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    248e:	f7 01       	movw	r30, r14
    2490:	60 83       	st	Z, r22
    2492:	71 83       	std	Z+1, r23	; 0x01
    2494:	82 83       	std	Z+2, r24	; 0x02
    2496:	93 83       	std	Z+3, r25	; 0x03
    2498:	0f 5f       	subi	r16, 0xFF	; 255
    249a:	1f 4f       	sbci	r17, 0xFF	; 255
    249c:	f4 e0       	ldi	r31, 0x04	; 4
    249e:	cf 0e       	add	r12, r31
    24a0:	d1 1c       	adc	r13, r1
    24a2:	24 e0       	ldi	r18, 0x04	; 4
    24a4:	e2 0e       	add	r14, r18
    24a6:	f1 1c       	adc	r15, r1
    24a8:	34 e0       	ldi	r19, 0x04	; 4
    24aa:	a3 0e       	add	r10, r19
    24ac:	b1 1c       	adc	r11, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    24ae:	03 30       	cpi	r16, 0x03	; 3
    24b0:	11 05       	cpc	r17, r1
    24b2:	09 f0       	breq	.+2      	; 0x24b6 <gc_execute_line+0xae4>
    24b4:	92 cf       	rjmp	.-220    	; 0x23da <gc_execute_line+0xa08>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    24b6:	85 e0       	ldi	r24, 0x05	; 5
    24b8:	58 16       	cp	r5, r24
    24ba:	a1 f0       	breq	.+40     	; 0x24e4 <gc_execute_line+0xb12>
    24bc:	97 e0       	ldi	r25, 0x07	; 7
    24be:	59 16       	cp	r5, r25
    24c0:	f9 f0       	breq	.+62     	; 0x2500 <gc_execute_line+0xb2e>
    24c2:	a3 e0       	ldi	r26, 0x03	; 3
    24c4:	5a 12       	cpse	r5, r26
    24c6:	21 c0       	rjmp	.+66     	; 0x250a <gc_execute_line+0xb38>
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    24c8:	bf 8d       	ldd	r27, Y+31	; 0x1f
    24ca:	b1 11       	cpse	r27, r1
    24cc:	01 c0       	rjmp	.+2      	; 0x24d0 <gc_execute_line+0xafe>
    24ce:	1e 8e       	std	Y+30, r1	; 0x1e
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    24d0:	be 01       	movw	r22, r28
    24d2:	63 5f       	subi	r22, 0xF3	; 243
    24d4:	7f 4f       	sbci	r23, 0xFF	; 255
    24d6:	86 e0       	ldi	r24, 0x06	; 6
    24d8:	0e 94 28 27 	call	0x4e50	; 0x4e50 <settings_read_coord_data>
    24dc:	88 23       	and	r24, r24
    24de:	09 f4       	brne	.+2      	; 0x24e2 <gc_execute_line+0xb10>
    24e0:	fa c4       	rjmp	.+2548   	; 0x2ed6 <gc_execute_line+0x1504>
    24e2:	13 c0       	rjmp	.+38     	; 0x250a <gc_execute_line+0xb38>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    24e4:	ef 8d       	ldd	r30, Y+31	; 0x1f
    24e6:	e1 11       	cpse	r30, r1
    24e8:	01 c0       	rjmp	.+2      	; 0x24ec <gc_execute_line+0xb1a>
    24ea:	1e 8e       	std	Y+30, r1	; 0x1e
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    24ec:	be 01       	movw	r22, r28
    24ee:	63 5f       	subi	r22, 0xF3	; 243
    24f0:	7f 4f       	sbci	r23, 0xFF	; 255
    24f2:	87 e0       	ldi	r24, 0x07	; 7
    24f4:	0e 94 28 27 	call	0x4e50	; 0x4e50 <settings_read_coord_data>
    24f8:	88 23       	and	r24, r24
    24fa:	09 f4       	brne	.+2      	; 0x24fe <gc_execute_line+0xb2c>
    24fc:	ee c4       	rjmp	.+2524   	; 0x2eda <gc_execute_line+0x1508>
    24fe:	05 c0       	rjmp	.+10     	; 0x250a <gc_execute_line+0xb38>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    2500:	80 91 c7 07 	lds	r24, 0x07C7
    2504:	82 30       	cpi	r24, 0x02	; 2
    2506:	08 f0       	brcs	.+2      	; 0x250a <gc_execute_line+0xb38>
    2508:	ea c4       	rjmp	.+2516   	; 0x2ede <gc_execute_line+0x150c>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    250a:	10 91 c7 07 	lds	r17, 0x07C7
    250e:	18 30       	cpi	r17, 0x08	; 8
    2510:	51 f4       	brne	.+20     	; 0x2526 <gc_execute_line+0xb54>
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    2512:	ff 8d       	ldd	r31, Y+31	; 0x1f
    2514:	ff 23       	and	r31, r31
    2516:	09 f4       	brne	.+2      	; 0x251a <gc_execute_line+0xb48>
    2518:	8e c2       	rjmp	.+1308   	; 0x2a36 <gc_execute_line+0x1064>
    251a:	1f a2       	std	Y+39, r1	; 0x27
    251c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    251e:	21 30       	cpi	r18, 0x01	; 1
    2520:	09 f0       	breq	.+2      	; 0x2524 <gc_execute_line+0xb52>
    2522:	df c4       	rjmp	.+2494   	; 0x2ee2 <gc_execute_line+0x1510>
    2524:	91 c2       	rjmp	.+1314   	; 0x2a48 <gc_execute_line+0x1076>
    2526:	1f a2       	std	Y+39, r1	; 0x27
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    }

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or 
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    2528:	3e 8d       	ldd	r19, Y+30	; 0x1e
    252a:	32 30       	cpi	r19, 0x02	; 2
    252c:	09 f0       	breq	.+2      	; 0x2530 <gc_execute_line+0xb5e>
    252e:	84 c2       	rjmp	.+1288   	; 0x2a38 <gc_execute_line+0x1066>
  
    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    2530:	11 11       	cpse	r17, r1
    2532:	05 c0       	rjmp	.+10     	; 0x253e <gc_execute_line+0xb6c>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    2534:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2536:	88 23       	and	r24, r24
    2538:	09 f4       	brne	.+2      	; 0x253c <gc_execute_line+0xb6a>
    253a:	f6 c4       	rjmp	.+2540   	; 0x2f28 <gc_execute_line+0x1556>
    253c:	85 c2       	rjmp	.+1290   	; 0x2a48 <gc_execute_line+0x1076>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    253e:	20 e0       	ldi	r18, 0x00	; 0
    2540:	30 e0       	ldi	r19, 0x00	; 0
    2542:	a9 01       	movw	r20, r18
    2544:	60 91 d1 07 	lds	r22, 0x07D1
    2548:	70 91 d2 07 	lds	r23, 0x07D2
    254c:	80 91 d3 07 	lds	r24, 0x07D3
    2550:	90 91 d4 07 	lds	r25, 0x07D4
    2554:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    2558:	88 23       	and	r24, r24
    255a:	09 f4       	brne	.+2      	; 0x255e <gc_execute_line+0xb8c>
    255c:	c4 c4       	rjmp	.+2440   	; 0x2ee6 <gc_execute_line+0x1514>
     
      switch (gc_block.modal.motion) {
    255e:	14 30       	cpi	r17, 0x04	; 4
    2560:	28 f4       	brcc	.+10     	; 0x256c <gc_execute_line+0xb9a>
    2562:	12 30       	cpi	r17, 0x02	; 2
    2564:	60 f4       	brcc	.+24     	; 0x257e <gc_execute_line+0xbac>
    2566:	11 30       	cpi	r17, 0x01	; 1
    2568:	29 f0       	breq	.+10     	; 0x2574 <gc_execute_line+0xba2>
    256a:	66 c2       	rjmp	.+1228   	; 0x2a38 <gc_execute_line+0x1066>
    256c:	18 30       	cpi	r17, 0x08	; 8
    256e:	08 f4       	brcc	.+2      	; 0x2572 <gc_execute_line+0xba0>
    2570:	20 c2       	rjmp	.+1088   	; 0x29b2 <gc_execute_line+0xfe0>
    2572:	62 c2       	rjmp	.+1220   	; 0x2a38 <gc_execute_line+0x1066>
        case MOTION_MODE_LINEAR: 
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    2574:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2576:	99 23       	and	r25, r25
    2578:	09 f4       	brne	.+2      	; 0x257c <gc_execute_line+0xbaa>
    257a:	d6 c4       	rjmp	.+2476   	; 0x2f28 <gc_execute_line+0x1556>
    257c:	65 c2       	rjmp	.+1226   	; 0x2a48 <gc_execute_line+0x1076>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    257e:	af 8d       	ldd	r26, Y+31	; 0x1f
    2580:	aa 23       	and	r26, r26
    2582:	09 f4       	brne	.+2      	; 0x2586 <gc_execute_line+0xbb4>
    2584:	b2 c4       	rjmp	.+2404   	; 0x2eea <gc_execute_line+0x1518>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    2586:	fc a1       	ldd	r31, Y+36	; 0x24
    2588:	ef 2f       	mov	r30, r31
    258a:	f0 e0       	ldi	r31, 0x00	; 0
    258c:	f9 a7       	std	Y+41, r31	; 0x29
    258e:	e8 a7       	std	Y+40, r30	; 0x28
    2590:	3d a1       	ldd	r19, Y+37	; 0x25
    2592:	23 2f       	mov	r18, r19
    2594:	30 e0       	ldi	r19, 0x00	; 0
    2596:	3b a7       	std	Y+43, r19	; 0x2b
    2598:	2a a7       	std	Y+42, r18	; 0x2a
    259a:	81 e0       	ldi	r24, 0x01	; 1
    259c:	90 e0       	ldi	r25, 0x00	; 0
    259e:	9c 01       	movw	r18, r24
    25a0:	0d a0       	ldd	r0, Y+37	; 0x25
    25a2:	02 c0       	rjmp	.+4      	; 0x25a8 <gc_execute_line+0xbd6>
    25a4:	22 0f       	add	r18, r18
    25a6:	33 1f       	adc	r19, r19
    25a8:	0a 94       	dec	r0
    25aa:	e2 f7       	brpl	.-8      	; 0x25a4 <gc_execute_line+0xbd2>
    25ac:	0c a0       	ldd	r0, Y+36	; 0x24
    25ae:	02 c0       	rjmp	.+4      	; 0x25b4 <gc_execute_line+0xbe2>
    25b0:	88 0f       	add	r24, r24
    25b2:	99 1f       	adc	r25, r25
    25b4:	0a 94       	dec	r0
    25b6:	e2 f7       	brpl	.-8      	; 0x25b0 <gc_execute_line+0xbde>
    25b8:	89 01       	movw	r16, r18
    25ba:	08 2b       	or	r16, r24
    25bc:	19 2b       	or	r17, r25
    25be:	8a 2f       	mov	r24, r26
    25c0:	90 e0       	ldi	r25, 0x00	; 0
    25c2:	80 23       	and	r24, r16
    25c4:	91 23       	and	r25, r17
    25c6:	89 2b       	or	r24, r25
    25c8:	09 f4       	brne	.+2      	; 0x25cc <gc_execute_line+0xbfa>
    25ca:	91 c4       	rjmp	.+2338   	; 0x2eee <gc_execute_line+0x151c>
        
          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    25cc:	cf 01       	movw	r24, r30
    25ce:	88 0f       	add	r24, r24
    25d0:	99 1f       	adc	r25, r25
    25d2:	88 0f       	add	r24, r24
    25d4:	99 1f       	adc	r25, r25
    25d6:	fc 01       	movw	r30, r24
    25d8:	ea 53       	subi	r30, 0x3A	; 58
    25da:	f8 4f       	sbci	r31, 0xF8	; 248
    25dc:	dc 01       	movw	r26, r24
    25de:	a9 57       	subi	r26, 0x79	; 121
    25e0:	b8 4f       	sbci	r27, 0xF8	; 248
    25e2:	57 96       	adiw	r26, 0x17	; 23
    25e4:	2d 91       	ld	r18, X+
    25e6:	3d 91       	ld	r19, X+
    25e8:	4d 91       	ld	r20, X+
    25ea:	5c 91       	ld	r21, X
    25ec:	5a 97       	sbiw	r26, 0x1a	; 26
    25ee:	65 a5       	ldd	r22, Z+45	; 0x2d
    25f0:	76 a5       	ldd	r23, Z+46	; 0x2e
    25f2:	87 a5       	ldd	r24, Z+47	; 0x2f
    25f4:	90 a9       	ldd	r25, Z+48	; 0x30
    25f6:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    25fa:	6b 01       	movw	r12, r22
    25fc:	7c 01       	movw	r14, r24
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    25fe:	8a a5       	ldd	r24, Y+42	; 0x2a
    2600:	9b a5       	ldd	r25, Y+43	; 0x2b
    2602:	88 0f       	add	r24, r24
    2604:	99 1f       	adc	r25, r25
    2606:	88 0f       	add	r24, r24
    2608:	99 1f       	adc	r25, r25
    260a:	fc 01       	movw	r30, r24
    260c:	ea 53       	subi	r30, 0x3A	; 58
    260e:	f8 4f       	sbci	r31, 0xF8	; 248
    2610:	dc 01       	movw	r26, r24
    2612:	a9 57       	subi	r26, 0x79	; 121
    2614:	b8 4f       	sbci	r27, 0xF8	; 248
    2616:	57 96       	adiw	r26, 0x17	; 23
    2618:	2d 91       	ld	r18, X+
    261a:	3d 91       	ld	r19, X+
    261c:	4d 91       	ld	r20, X+
    261e:	5c 91       	ld	r21, X
    2620:	5a 97       	sbiw	r26, 0x1a	; 26
    2622:	65 a5       	ldd	r22, Z+45	; 0x2d
    2624:	76 a5       	ldd	r23, Z+46	; 0x2e
    2626:	87 a5       	ldd	r24, Z+47	; 0x2f
    2628:	90 a9       	ldd	r25, Z+48	; 0x30
    262a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    262e:	4b 01       	movw	r8, r22
    2630:	5c 01       	movw	r10, r24

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
    2632:	27 fe       	sbrs	r2, 7
    2634:	10 c1       	rjmp	.+544    	; 0x2856 <gc_execute_line+0xe84>
            bit_false(value_words,bit(WORD_R));
    2636:	e8 94       	clt
    2638:	27 f8       	bld	r2, 7

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
    263a:	20 91 f3 07 	lds	r18, 0x07F3
    263e:	30 91 f4 07 	lds	r19, 0x07F4
    2642:	40 91 f5 07 	lds	r20, 0x07F5
    2646:	50 91 f6 07 	lds	r21, 0x07F6
    264a:	60 91 9e 07 	lds	r22, 0x079E
    264e:	70 91 9f 07 	lds	r23, 0x079F
    2652:	80 91 a0 07 	lds	r24, 0x07A0
    2656:	90 91 a1 07 	lds	r25, 0x07A1
    265a:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    265e:	81 11       	cpse	r24, r1
    2660:	5d c4       	rjmp	.+2234   	; 0x2f1c <gc_execute_line+0x154a>
    2662:	20 91 f7 07 	lds	r18, 0x07F7
    2666:	30 91 f8 07 	lds	r19, 0x07F8
    266a:	40 91 f9 07 	lds	r20, 0x07F9
    266e:	50 91 fa 07 	lds	r21, 0x07FA
    2672:	60 91 a2 07 	lds	r22, 0x07A2
    2676:	70 91 a3 07 	lds	r23, 0x07A3
    267a:	80 91 a4 07 	lds	r24, 0x07A4
    267e:	90 91 a5 07 	lds	r25, 0x07A5
    2682:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    2686:	81 11       	cpse	r24, r1
    2688:	49 c4       	rjmp	.+2194   	; 0x2f1c <gc_execute_line+0x154a>
    268a:	20 91 fb 07 	lds	r18, 0x07FB
    268e:	30 91 fc 07 	lds	r19, 0x07FC
    2692:	40 91 fd 07 	lds	r20, 0x07FD
    2696:	50 91 fe 07 	lds	r21, 0x07FE
    269a:	60 91 a6 07 	lds	r22, 0x07A6
    269e:	70 91 a7 07 	lds	r23, 0x07A7
    26a2:	80 91 a8 07 	lds	r24, 0x07A8
    26a6:	90 91 a9 07 	lds	r25, 0x07A9
    26aa:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    26ae:	81 11       	cpse	r24, r1
    26b0:	35 c4       	rjmp	.+2154   	; 0x2f1c <gc_execute_line+0x154a>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    26b2:	81 e2       	ldi	r24, 0x21	; 33
    26b4:	3f c4       	rjmp	.+2174   	; 0x2f34 <gc_execute_line+0x1562>
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    26b6:	0a ee       	ldi	r16, 0xEA	; 234
    26b8:	17 e0       	ldi	r17, 0x07	; 7
    26ba:	23 e3       	ldi	r18, 0x33	; 51
    26bc:	33 e3       	ldi	r19, 0x33	; 51
    26be:	4b ec       	ldi	r20, 0xCB	; 203
    26c0:	51 e4       	ldi	r21, 0x41	; 65
    26c2:	d8 01       	movw	r26, r16
    26c4:	6d 91       	ld	r22, X+
    26c6:	7d 91       	ld	r23, X+
    26c8:	8d 91       	ld	r24, X+
    26ca:	9c 91       	ld	r25, X
    26cc:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    26d0:	f8 01       	movw	r30, r16
    26d2:	60 83       	st	Z, r22
    26d4:	71 83       	std	Z+1, r23	; 0x01
    26d6:	82 83       	std	Z+2, r24	; 0x02
    26d8:	93 83       	std	Z+3, r25	; 0x03
                j = (y + (x * h_x2_div_d))/2       
            */      

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    26da:	40 90 ea 07 	lds	r4, 0x07EA
    26de:	50 90 eb 07 	lds	r5, 0x07EB
    26e2:	60 90 ec 07 	lds	r6, 0x07EC
    26e6:	70 90 ed 07 	lds	r7, 0x07ED
    26ea:	20 e0       	ldi	r18, 0x00	; 0
    26ec:	30 e0       	ldi	r19, 0x00	; 0
    26ee:	40 e8       	ldi	r20, 0x80	; 128
    26f0:	50 e4       	ldi	r21, 0x40	; 64
    26f2:	c3 01       	movw	r24, r6
    26f4:	b2 01       	movw	r22, r4
    26f6:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    26fa:	9b 01       	movw	r18, r22
    26fc:	ac 01       	movw	r20, r24
    26fe:	c3 01       	movw	r24, r6
    2700:	b2 01       	movw	r22, r4
    2702:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    2706:	2b 01       	movw	r4, r22
    2708:	3c 01       	movw	r6, r24
    270a:	a7 01       	movw	r20, r14
    270c:	96 01       	movw	r18, r12
    270e:	c7 01       	movw	r24, r14
    2710:	b6 01       	movw	r22, r12
    2712:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    2716:	9b 01       	movw	r18, r22
    2718:	ac 01       	movw	r20, r24
    271a:	c3 01       	movw	r24, r6
    271c:	b2 01       	movw	r22, r4
    271e:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    2722:	2b 01       	movw	r4, r22
    2724:	3c 01       	movw	r6, r24
    2726:	a5 01       	movw	r20, r10
    2728:	94 01       	movw	r18, r8
    272a:	c5 01       	movw	r24, r10
    272c:	b4 01       	movw	r22, r8
    272e:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    2732:	9b 01       	movw	r18, r22
    2734:	ac 01       	movw	r20, r24
    2736:	c3 01       	movw	r24, r6
    2738:	b2 01       	movw	r22, r4
    273a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    273e:	2b 01       	movw	r4, r22
    2740:	3c 01       	movw	r6, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2742:	20 e0       	ldi	r18, 0x00	; 0
    2744:	30 e0       	ldi	r19, 0x00	; 0
    2746:	a9 01       	movw	r20, r18
    2748:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    274c:	88 23       	and	r24, r24
    274e:	0c f4       	brge	.+2      	; 0x2752 <gc_execute_line+0xd80>
    2750:	d0 c3       	rjmp	.+1952   	; 0x2ef2 <gc_execute_line+0x1520>
    
            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    2752:	c3 01       	movw	r24, r6
    2754:	b2 01       	movw	r22, r4
    2756:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    275a:	2b 01       	movw	r4, r22
    275c:	3c 01       	movw	r6, r24
    275e:	a5 01       	movw	r20, r10
    2760:	94 01       	movw	r18, r8
    2762:	c7 01       	movw	r24, r14
    2764:	b6 01       	movw	r22, r12
    2766:	0e 94 13 2f 	call	0x5e26	; 0x5e26 <hypot_f>
    276a:	9b 01       	movw	r18, r22
    276c:	ac 01       	movw	r20, r24
    276e:	c3 01       	movw	r24, r6
    2770:	b2 01       	movw	r22, r4
    2772:	90 58       	subi	r25, 0x80	; 128
    2774:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    2778:	2b 01       	movw	r4, r22
    277a:	3c 01       	movw	r6, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }  
    277c:	80 91 c7 07 	lds	r24, 0x07C7
    2780:	83 30       	cpi	r24, 0x03	; 3
    2782:	21 f4       	brne	.+8      	; 0x278c <gc_execute_line+0xdba>
    2784:	77 fa       	bst	r7, 7
    2786:	70 94       	com	r7
    2788:	77 f8       	bld	r7, 7
    278a:	70 94       	com	r7
            */  
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
            // even though it is advised against ever generating such circles in a single line of g-code. By 
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) { 
    278c:	80 91 ea 07 	lds	r24, 0x07EA
    2790:	90 91 eb 07 	lds	r25, 0x07EB
    2794:	a0 91 ec 07 	lds	r26, 0x07EC
    2798:	b0 91 ed 07 	lds	r27, 0x07ED
    279c:	8f 8f       	std	Y+31, r24	; 0x1f
    279e:	98 a3       	std	Y+32, r25	; 0x20
    27a0:	a9 a3       	std	Y+33, r26	; 0x21
    27a2:	ba a3       	std	Y+34, r27	; 0x22
    27a4:	20 e0       	ldi	r18, 0x00	; 0
    27a6:	30 e0       	ldi	r19, 0x00	; 0
    27a8:	a9 01       	movw	r20, r18
    27aa:	bc 01       	movw	r22, r24
    27ac:	cd 01       	movw	r24, r26
    27ae:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    27b2:	88 23       	and	r24, r24
    27b4:	8c f4       	brge	.+34     	; 0x27d8 <gc_execute_line+0xe06>
                h_x2_div_d = -h_x2_div_d; 
    27b6:	77 fa       	bst	r7, 7
    27b8:	70 94       	com	r7
    27ba:	77 f8       	bld	r7, 7
    27bc:	70 94       	com	r7
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    27be:	8f 8d       	ldd	r24, Y+31	; 0x1f
    27c0:	98 a1       	ldd	r25, Y+32	; 0x20
    27c2:	a9 a1       	ldd	r26, Y+33	; 0x21
    27c4:	ba a1       	ldd	r27, Y+34	; 0x22
    27c6:	b0 58       	subi	r27, 0x80	; 128
    27c8:	80 93 ea 07 	sts	0x07EA, r24
    27cc:	90 93 eb 07 	sts	0x07EB, r25
    27d0:	a0 93 ec 07 	sts	0x07EC, r26
    27d4:	b0 93 ed 07 	sts	0x07ED, r27
            }        
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    27d8:	08 a5       	ldd	r16, Y+40	; 0x28
    27da:	19 a5       	ldd	r17, Y+41	; 0x29
    27dc:	00 0f       	add	r16, r16
    27de:	11 1f       	adc	r17, r17
    27e0:	00 0f       	add	r16, r16
    27e2:	11 1f       	adc	r17, r17
    27e4:	06 53       	subi	r16, 0x36	; 54
    27e6:	18 4f       	sbci	r17, 0xF8	; 248
    27e8:	a3 01       	movw	r20, r6
    27ea:	92 01       	movw	r18, r4
    27ec:	c5 01       	movw	r24, r10
    27ee:	b4 01       	movw	r22, r8
    27f0:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    27f4:	9b 01       	movw	r18, r22
    27f6:	ac 01       	movw	r20, r24
    27f8:	c7 01       	movw	r24, r14
    27fa:	b6 01       	movw	r22, r12
    27fc:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    2800:	20 e0       	ldi	r18, 0x00	; 0
    2802:	30 e0       	ldi	r19, 0x00	; 0
    2804:	40 e0       	ldi	r20, 0x00	; 0
    2806:	5f e3       	ldi	r21, 0x3F	; 63
    2808:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    280c:	d8 01       	movw	r26, r16
    280e:	1b 96       	adiw	r26, 0x0b	; 11
    2810:	6d 93       	st	X+, r22
    2812:	7d 93       	st	X+, r23
    2814:	8d 93       	st	X+, r24
    2816:	9c 93       	st	X, r25
    2818:	1e 97       	sbiw	r26, 0x0e	; 14
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    281a:	0a a5       	ldd	r16, Y+42	; 0x2a
    281c:	1b a5       	ldd	r17, Y+43	; 0x2b
    281e:	00 0f       	add	r16, r16
    2820:	11 1f       	adc	r17, r17
    2822:	00 0f       	add	r16, r16
    2824:	11 1f       	adc	r17, r17
    2826:	06 53       	subi	r16, 0x36	; 54
    2828:	18 4f       	sbci	r17, 0xF8	; 248
    282a:	a3 01       	movw	r20, r6
    282c:	92 01       	movw	r18, r4
    282e:	c7 01       	movw	r24, r14
    2830:	b6 01       	movw	r22, r12
    2832:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    2836:	a5 01       	movw	r20, r10
    2838:	94 01       	movw	r18, r8
    283a:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    283e:	20 e0       	ldi	r18, 0x00	; 0
    2840:	30 e0       	ldi	r19, 0x00	; 0
    2842:	40 e0       	ldi	r20, 0x00	; 0
    2844:	5f e3       	ldi	r21, 0x3F	; 63
    2846:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    284a:	f8 01       	movw	r30, r16
    284c:	63 87       	std	Z+11, r22	; 0x0b
    284e:	74 87       	std	Z+12, r23	; 0x0c
    2850:	85 87       	std	Z+13, r24	; 0x0d
    2852:	96 87       	std	Z+14, r25	; 0x0e
    2854:	f9 c0       	rjmp	.+498    	; 0x2a48 <gc_execute_line+0x1076>
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2856:	fb a1       	ldd	r31, Y+35	; 0x23
    2858:	4f 2e       	mov	r4, r31
    285a:	51 2c       	mov	r5, r1
    285c:	04 21       	and	r16, r4
    285e:	15 21       	and	r17, r5
    2860:	01 2b       	or	r16, r17
    2862:	09 f4       	brne	.+2      	; 0x2866 <gc_execute_line+0xe94>
    2864:	48 c3       	rjmp	.+1680   	; 0x2ef6 <gc_execute_line+0x1524>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
    2866:	21 ef       	ldi	r18, 0xF1	; 241
    2868:	22 22       	and	r2, r18
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    286a:	80 91 c9 07 	lds	r24, 0x07C9
    286e:	81 30       	cpi	r24, 0x01	; 1
    2870:	49 f5       	brne	.+82     	; 0x28c4 <gc_execute_line+0xef2>
    2872:	0f 2e       	mov	r0, r31
    2874:	f5 ed       	ldi	r31, 0xD5	; 213
    2876:	6f 2e       	mov	r6, r31
    2878:	f7 e0       	ldi	r31, 0x07	; 7
    287a:	7f 2e       	mov	r7, r31
    287c:	f0 2d       	mov	r31, r0
    287e:	00 e0       	ldi	r16, 0x00	; 0
    2880:	10 e0       	ldi	r17, 0x00	; 0
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    2882:	c2 01       	movw	r24, r4
    2884:	00 2e       	mov	r0, r16
    2886:	02 c0       	rjmp	.+4      	; 0x288c <gc_execute_line+0xeba>
    2888:	95 95       	asr	r25
    288a:	87 95       	ror	r24
    288c:	0a 94       	dec	r0
    288e:	e2 f7       	brpl	.-8      	; 0x2888 <gc_execute_line+0xeb6>
    2890:	80 ff       	sbrs	r24, 0
    2892:	10 c0       	rjmp	.+32     	; 0x28b4 <gc_execute_line+0xee2>
    2894:	23 e3       	ldi	r18, 0x33	; 51
    2896:	33 e3       	ldi	r19, 0x33	; 51
    2898:	4b ec       	ldi	r20, 0xCB	; 203
    289a:	51 e4       	ldi	r21, 0x41	; 65
    289c:	d3 01       	movw	r26, r6
    289e:	6d 91       	ld	r22, X+
    28a0:	7d 91       	ld	r23, X+
    28a2:	8d 91       	ld	r24, X+
    28a4:	9c 91       	ld	r25, X
    28a6:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    28aa:	f3 01       	movw	r30, r6
    28ac:	60 83       	st	Z, r22
    28ae:	71 83       	std	Z+1, r23	; 0x01
    28b0:	82 83       	std	Z+2, r24	; 0x02
    28b2:	93 83       	std	Z+3, r25	; 0x03
    28b4:	0f 5f       	subi	r16, 0xFF	; 255
    28b6:	1f 4f       	sbci	r17, 0xFF	; 255
    28b8:	f4 e0       	ldi	r31, 0x04	; 4
    28ba:	6f 0e       	add	r6, r31
    28bc:	71 1c       	adc	r7, r1
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    28be:	03 30       	cpi	r16, 0x03	; 3
    28c0:	11 05       	cpc	r17, r1
    28c2:	f9 f6       	brne	.-66     	; 0x2882 <gc_execute_line+0xeb0>
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    28c4:	0a a5       	ldd	r16, Y+42	; 0x2a
    28c6:	1b a5       	ldd	r17, Y+43	; 0x2b
    28c8:	00 0f       	add	r16, r16
    28ca:	11 1f       	adc	r17, r17
    28cc:	00 0f       	add	r16, r16
    28ce:	11 1f       	adc	r17, r17
    28d0:	06 53       	subi	r16, 0x36	; 54
    28d2:	18 4f       	sbci	r17, 0xF8	; 248
    28d4:	d8 01       	movw	r26, r16
    28d6:	1b 96       	adiw	r26, 0x0b	; 11
    28d8:	2d 91       	ld	r18, X+
    28da:	3d 91       	ld	r19, X+
    28dc:	4d 91       	ld	r20, X+
    28de:	5c 91       	ld	r21, X
    28e0:	1e 97       	sbiw	r26, 0x0e	; 14
    28e2:	c5 01       	movw	r24, r10
    28e4:	b4 01       	movw	r22, r8
    28e6:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    28ea:	2b 01       	movw	r4, r22
    28ec:	3c 01       	movw	r6, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    28ee:	88 a5       	ldd	r24, Y+40	; 0x28
    28f0:	99 a5       	ldd	r25, Y+41	; 0x29
    28f2:	88 0f       	add	r24, r24
    28f4:	99 1f       	adc	r25, r25
    28f6:	88 0f       	add	r24, r24
    28f8:	99 1f       	adc	r25, r25
    28fa:	fc 01       	movw	r30, r24
    28fc:	e6 53       	subi	r30, 0x36	; 54
    28fe:	f8 4f       	sbci	r31, 0xF8	; 248
    2900:	5f 01       	movw	r10, r30
    2902:	23 85       	ldd	r18, Z+11	; 0x0b
    2904:	34 85       	ldd	r19, Z+12	; 0x0c
    2906:	45 85       	ldd	r20, Z+13	; 0x0d
    2908:	56 85       	ldd	r21, Z+14	; 0x0e
    290a:	c7 01       	movw	r24, r14
    290c:	b6 01       	movw	r22, r12
    290e:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y); 
    2912:	a3 01       	movw	r20, r6
    2914:	92 01       	movw	r18, r4
    2916:	0e 94 13 2f 	call	0x5e26	; 0x5e26 <hypot_f>
    291a:	6b 01       	movw	r12, r22
    291c:	7c 01       	movw	r14, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
    291e:	d8 01       	movw	r26, r16
    2920:	1b 96       	adiw	r26, 0x0b	; 11
    2922:	2d 91       	ld	r18, X+
    2924:	3d 91       	ld	r19, X+
    2926:	4d 91       	ld	r20, X+
    2928:	5c 91       	ld	r21, X
    292a:	1e 97       	sbiw	r26, 0x0e	; 14
    292c:	f5 01       	movw	r30, r10
    292e:	63 85       	ldd	r22, Z+11	; 0x0b
    2930:	74 85       	ldd	r23, Z+12	; 0x0c
    2932:	85 85       	ldd	r24, Z+13	; 0x0d
    2934:	96 85       	ldd	r25, Z+14	; 0x0e
    2936:	0e 94 13 2f 	call	0x5e26	; 0x5e26 <hypot_f>
    293a:	4b 01       	movw	r8, r22
    293c:	5c 01       	movw	r10, r24
    293e:	60 93 ea 07 	sts	0x07EA, r22
    2942:	70 93 eb 07 	sts	0x07EB, r23
    2946:	80 93 ec 07 	sts	0x07EC, r24
    294a:	90 93 ed 07 	sts	0x07ED, r25
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    294e:	9b 01       	movw	r18, r22
    2950:	ac 01       	movw	r20, r24
    2952:	c7 01       	movw	r24, r14
    2954:	b6 01       	movw	r22, r12
    2956:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    295a:	6b 01       	movw	r12, r22
    295c:	7c 01       	movw	r14, r24
    295e:	e8 94       	clt
    2960:	f7 f8       	bld	r15, 7
            if (delta_r > 0.005) { 
    2962:	2a e0       	ldi	r18, 0x0A	; 10
    2964:	37 ed       	ldi	r19, 0xD7	; 215
    2966:	43 ea       	ldi	r20, 0xA3	; 163
    2968:	5b e3       	ldi	r21, 0x3B	; 59
    296a:	c7 01       	movw	r24, r14
    296c:	b6 01       	movw	r22, r12
    296e:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    2972:	18 16       	cp	r1, r24
    2974:	0c f0       	brlt	.+2      	; 0x2978 <gc_execute_line+0xfa6>
    2976:	68 c0       	rjmp	.+208    	; 0x2a48 <gc_execute_line+0x1076>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    2978:	20 e0       	ldi	r18, 0x00	; 0
    297a:	30 e0       	ldi	r19, 0x00	; 0
    297c:	40 e0       	ldi	r20, 0x00	; 0
    297e:	5f e3       	ldi	r21, 0x3F	; 63
    2980:	c7 01       	movw	r24, r14
    2982:	b6 01       	movw	r22, r12
    2984:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    2988:	18 16       	cp	r1, r24
    298a:	0c f4       	brge	.+2      	; 0x298e <gc_execute_line+0xfbc>
    298c:	b6 c2       	rjmp	.+1388   	; 0x2efa <gc_execute_line+0x1528>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    298e:	2f e6       	ldi	r18, 0x6F	; 111
    2990:	32 e1       	ldi	r19, 0x12	; 18
    2992:	43 e8       	ldi	r20, 0x83	; 131
    2994:	5a e3       	ldi	r21, 0x3A	; 58
    2996:	c5 01       	movw	r24, r10
    2998:	b4 01       	movw	r22, r8
    299a:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    299e:	9b 01       	movw	r18, r22
    29a0:	ac 01       	movw	r20, r24
    29a2:	c7 01       	movw	r24, r14
    29a4:	b6 01       	movw	r22, r12
    29a6:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    29aa:	18 16       	cp	r1, r24
    29ac:	0c f4       	brge	.+2      	; 0x29b0 <gc_execute_line+0xfde>
    29ae:	a7 c2       	rjmp	.+1358   	; 0x2efe <gc_execute_line+0x152c>
    29b0:	4b c0       	rjmp	.+150    	; 0x2a48 <gc_execute_line+0x1076>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    29b2:	ff 8d       	ldd	r31, Y+31	; 0x1f
    29b4:	ff 23       	and	r31, r31
    29b6:	09 f4       	brne	.+2      	; 0x29ba <gc_execute_line+0xfe8>
    29b8:	a4 c2       	rjmp	.+1352   	; 0x2f02 <gc_execute_line+0x1530>

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
    29ba:	20 91 f3 07 	lds	r18, 0x07F3
    29be:	30 91 f4 07 	lds	r19, 0x07F4
    29c2:	40 91 f5 07 	lds	r20, 0x07F5
    29c6:	50 91 f6 07 	lds	r21, 0x07F6
    29ca:	60 91 9e 07 	lds	r22, 0x079E
    29ce:	70 91 9f 07 	lds	r23, 0x079F
    29d2:	80 91 a0 07 	lds	r24, 0x07A0
    29d6:	90 91 a1 07 	lds	r25, 0x07A1
    29da:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    29de:	81 11       	cpse	r24, r1
    29e0:	33 c0       	rjmp	.+102    	; 0x2a48 <gc_execute_line+0x1076>
    29e2:	20 91 f7 07 	lds	r18, 0x07F7
    29e6:	30 91 f8 07 	lds	r19, 0x07F8
    29ea:	40 91 f9 07 	lds	r20, 0x07F9
    29ee:	50 91 fa 07 	lds	r21, 0x07FA
    29f2:	60 91 a2 07 	lds	r22, 0x07A2
    29f6:	70 91 a3 07 	lds	r23, 0x07A3
    29fa:	80 91 a4 07 	lds	r24, 0x07A4
    29fe:	90 91 a5 07 	lds	r25, 0x07A5
    2a02:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    2a06:	81 11       	cpse	r24, r1
    2a08:	1f c0       	rjmp	.+62     	; 0x2a48 <gc_execute_line+0x1076>
    2a0a:	20 91 fb 07 	lds	r18, 0x07FB
    2a0e:	30 91 fc 07 	lds	r19, 0x07FC
    2a12:	40 91 fd 07 	lds	r20, 0x07FD
    2a16:	50 91 fe 07 	lds	r21, 0x07FE
    2a1a:	60 91 a6 07 	lds	r22, 0x07A6
    2a1e:	70 91 a7 07 	lds	r23, 0x07A7
    2a22:	80 91 a8 07 	lds	r24, 0x07A8
    2a26:	90 91 a9 07 	lds	r25, 0x07A9
    2a2a:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    2a2e:	81 11       	cpse	r24, r1
    2a30:	0b c0       	rjmp	.+22     	; 0x2a48 <gc_execute_line+0x1076>
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2a32:	81 e2       	ldi	r24, 0x21	; 33
    2a34:	7f c2       	rjmp	.+1278   	; 0x2f34 <gc_execute_line+0x1562>
    2a36:	1f a2       	std	Y+39, r1	; 0x27
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    2a38:	2e 8d       	ldd	r18, Y+30	; 0x1e
    2a3a:	21 11       	cpse	r18, r1
    2a3c:	05 c0       	rjmp	.+10     	; 0x2a48 <gc_execute_line+0x1076>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    2a3e:	3e ed       	ldi	r19, 0xDE	; 222
    2a40:	23 22       	and	r2, r19
    2a42:	3c ef       	ldi	r19, 0xFC	; 252
    2a44:	33 22       	and	r3, r19
    2a46:	04 c0       	rjmp	.+8      	; 0x2a50 <gc_execute_line+0x107e>
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    2a48:	8e ed       	ldi	r24, 0xDE	; 222
    2a4a:	28 22       	and	r2, r24
    2a4c:	80 ee       	ldi	r24, 0xE0	; 224
    2a4e:	38 22       	and	r3, r24
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2a50:	23 28       	or	r2, r3
    2a52:	09 f0       	breq	.+2      	; 0x2a56 <gc_execute_line+0x1084>
    2a54:	58 c2       	rjmp	.+1200   	; 0x2f06 <gc_execute_line+0x1534>
     Assumes that all error-checking has been completed and no failure modes exist. We just
     need to update the state and execute the block according to the order-of-execution.
  */ 
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  gc_state.line_number = gc_block.values.n;
    2a56:	80 91 e2 07 	lds	r24, 0x07E2
    2a5a:	90 91 e3 07 	lds	r25, 0x07E3
    2a5e:	a0 91 e4 07 	lds	r26, 0x07E4
    2a62:	b0 91 e5 07 	lds	r27, 0x07E5
    2a66:	80 93 9a 07 	sts	0x079A, r24
    2a6a:	90 93 9b 07 	sts	0x079B, r25
    2a6e:	a0 93 9c 07 	sts	0x079C, r26
    2a72:	b0 93 9d 07 	sts	0x079D, r27
  
  // [1. Comments feedback ]:  NOT SUPPORTED
  
  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    2a76:	80 91 c8 07 	lds	r24, 0x07C8
    2a7a:	80 93 88 07 	sts	0x0788, r24
  
  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    2a7e:	80 91 d1 07 	lds	r24, 0x07D1
    2a82:	90 91 d2 07 	lds	r25, 0x07D2
    2a86:	a0 91 d3 07 	lds	r26, 0x07D3
    2a8a:	b0 91 d4 07 	lds	r27, 0x07D4
    2a8e:	80 93 95 07 	sts	0x0795, r24
    2a92:	90 93 96 07 	sts	0x0796, r25
    2a96:	a0 93 97 07 	sts	0x0797, r26
    2a9a:	b0 93 98 07 	sts	0x0798, r27

  // [4. Set spindle speed ]:
  if (gc_state.spindle_speed != gc_block.values.s) { 
    2a9e:	c0 90 ee 07 	lds	r12, 0x07EE
    2aa2:	d0 90 ef 07 	lds	r13, 0x07EF
    2aa6:	e0 90 f0 07 	lds	r14, 0x07F0
    2aaa:	f0 90 f1 07 	lds	r15, 0x07F1
    2aae:	a7 01       	movw	r20, r14
    2ab0:	96 01       	movw	r18, r12
    2ab2:	60 91 91 07 	lds	r22, 0x0791
    2ab6:	70 91 92 07 	lds	r23, 0x0792
    2aba:	80 91 93 07 	lds	r24, 0x0793
    2abe:	90 91 94 07 	lds	r25, 0x0794
    2ac2:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    2ac6:	88 23       	and	r24, r24
    2ac8:	c1 f0       	breq	.+48     	; 0x2afa <gc_execute_line+0x1128>
    // Update running spindle only if not in check mode and not already enabled.
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { spindle_run(gc_state.modal.spindle, gc_block.values.s); }
    2aca:	80 91 90 07 	lds	r24, 0x0790
    2ace:	88 23       	and	r24, r24
    2ad0:	21 f0       	breq	.+8      	; 0x2ada <gc_execute_line+0x1108>
    2ad2:	b7 01       	movw	r22, r14
    2ad4:	a6 01       	movw	r20, r12
    2ad6:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <spindle_run>
    gc_state.spindle_speed = gc_block.values.s; 
    2ada:	80 91 ee 07 	lds	r24, 0x07EE
    2ade:	90 91 ef 07 	lds	r25, 0x07EF
    2ae2:	a0 91 f0 07 	lds	r26, 0x07F0
    2ae6:	b0 91 f1 07 	lds	r27, 0x07F1
    2aea:	80 93 91 07 	sts	0x0791, r24
    2aee:	90 93 92 07 	sts	0x0792, r25
    2af2:	a0 93 93 07 	sts	0x0793, r26
    2af6:	b0 93 94 07 	sts	0x0794, r27
  }
    
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    2afa:	80 91 f2 07 	lds	r24, 0x07F2
    2afe:	80 93 99 07 	sts	0x0799, r24

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    2b02:	80 91 d0 07 	lds	r24, 0x07D0
    2b06:	90 91 90 07 	lds	r25, 0x0790
    2b0a:	98 17       	cp	r25, r24
    2b0c:	71 f0       	breq	.+28     	; 0x2b2a <gc_execute_line+0x1158>
    // Update spindle control and apply spindle speed when enabling it in this block.    
    spindle_run(gc_block.modal.spindle, gc_state.spindle_speed);
    2b0e:	40 91 91 07 	lds	r20, 0x0791
    2b12:	50 91 92 07 	lds	r21, 0x0792
    2b16:	60 91 93 07 	lds	r22, 0x0793
    2b1a:	70 91 94 07 	lds	r23, 0x0794
    2b1e:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <spindle_run>
    gc_state.modal.spindle = gc_block.modal.spindle;    
    2b22:	80 91 d0 07 	lds	r24, 0x07D0
    2b26:	80 93 90 07 	sts	0x0790, r24
  }

  // [8. Coolant control ]:  
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    2b2a:	80 91 cf 07 	lds	r24, 0x07CF
    2b2e:	90 91 8f 07 	lds	r25, 0x078F
    2b32:	98 17       	cp	r25, r24
    2b34:	31 f0       	breq	.+12     	; 0x2b42 <gc_execute_line+0x1170>
    coolant_run(gc_block.modal.coolant);
    2b36:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <coolant_run>
    gc_state.modal.coolant = gc_block.modal.coolant;
    2b3a:	80 91 cf 07 	lds	r24, 0x07CF
    2b3e:	80 93 8f 07 	sts	0x078F, r24
  }
  
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    2b42:	80 91 c6 07 	lds	r24, 0x07C6
    2b46:	81 30       	cpi	r24, 0x01	; 1
    2b48:	51 f4       	brne	.+20     	; 0x2b5e <gc_execute_line+0x118c>
    2b4a:	60 91 e6 07 	lds	r22, 0x07E6
    2b4e:	70 91 e7 07 	lds	r23, 0x07E7
    2b52:	80 91 e8 07 	lds	r24, 0x07E8
    2b56:	90 91 e9 07 	lds	r25, 0x07E9
    2b5a:	0e 94 ac 0b 	call	0x1758	; 0x1758 <mc_dwell>
  
  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;  
    2b5e:	80 91 cb 07 	lds	r24, 0x07CB
    2b62:	80 93 8b 07 	sts	0x078B, r24

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    2b66:	80 91 c9 07 	lds	r24, 0x07C9
    2b6a:	80 93 89 07 	sts	0x0789, r24

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array. 
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    2b6e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2b70:	93 30       	cpi	r25, 0x03	; 3
    2b72:	f9 f4       	brne	.+62     	; 0x2bb2 <gc_execute_line+0x11e0>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    2b74:	80 91 cc 07 	lds	r24, 0x07CC
    2b78:	80 93 8c 07 	sts	0x078C, r24
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) { // G43.1
    2b7c:	81 30       	cpi	r24, 0x01	; 1
    2b7e:	89 f4       	brne	.+34     	; 0x2ba2 <gc_execute_line+0x11d0>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    2b80:	80 91 fb 07 	lds	r24, 0x07FB
    2b84:	90 91 fc 07 	lds	r25, 0x07FC
    2b88:	a0 91 fd 07 	lds	r26, 0x07FD
    2b8c:	b0 91 fe 07 	lds	r27, 0x07FE
    2b90:	80 93 c2 07 	sts	0x07C2, r24
    2b94:	90 93 c3 07 	sts	0x07C3, r25
    2b98:	a0 93 c4 07 	sts	0x07C4, r26
    2b9c:	b0 93 c5 07 	sts	0x07C5, r27
    2ba0:	08 c0       	rjmp	.+16     	; 0x2bb2 <gc_execute_line+0x11e0>
    } else { // G49
      gc_state.tool_length_offset = 0.0;
    2ba2:	10 92 c2 07 	sts	0x07C2, r1
    2ba6:	10 92 c3 07 	sts	0x07C3, r1
    2baa:	10 92 c4 07 	sts	0x07C4, r1
    2bae:	10 92 c5 07 	sts	0x07C5, r1
    }
  }
  
  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    2bb2:	80 91 cd 07 	lds	r24, 0x07CD
    2bb6:	90 91 8d 07 	lds	r25, 0x078D
    2bba:	98 17       	cp	r25, r24
    2bbc:	59 f0       	breq	.+22     	; 0x2bd4 <gc_execute_line+0x1202>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    2bbe:	80 93 8d 07 	sts	0x078D, r24
    memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    2bc2:	8c e0       	ldi	r24, 0x0C	; 12
    2bc4:	fe 01       	movw	r30, r28
    2bc6:	31 96       	adiw	r30, 0x01	; 1
    2bc8:	aa ea       	ldi	r26, 0xAA	; 170
    2bca:	b7 e0       	ldi	r27, 0x07	; 7
    2bcc:	01 90       	ld	r0, Z+
    2bce:	0d 92       	st	X+, r0
    2bd0:	8a 95       	dec	r24
    2bd2:	e1 f7       	brne	.-8      	; 0x2bcc <gc_execute_line+0x11fa>
  }
  
  // [16. Set path control mode ]: NOT SUPPORTED
  
  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    2bd4:	80 91 ca 07 	lds	r24, 0x07CA
    2bd8:	80 93 8a 07 	sts	0x078A, r24
  
  // [18. Set retract mode ]: NOT SUPPORTED
    
  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    2bdc:	80 91 c6 07 	lds	r24, 0x07C6
    2be0:	90 e0       	ldi	r25, 0x00	; 0
    2be2:	fc 01       	movw	r30, r24
    2be4:	32 97       	sbiw	r30, 0x02	; 2
    2be6:	e8 30       	cpi	r30, 0x08	; 8
    2be8:	f1 05       	cpc	r31, r1
    2bea:	08 f0       	brcs	.+2      	; 0x2bee <gc_execute_line+0x121c>
    2bec:	55 c0       	rjmp	.+170    	; 0x2c98 <gc_execute_line+0x12c6>
    2bee:	e5 53       	subi	r30, 0x35	; 53
    2bf0:	ff 4f       	sbci	r31, 0xFF	; 255
    2bf2:	0c 94 e7 3f 	jmp	0x7fce	; 0x7fce <__tablejump2__>
    case NON_MODAL_SET_COORDINATE_DATA:    
      settings_write_coord_data(coord_select,parameter_data);
    2bf6:	be 01       	movw	r22, r28
    2bf8:	63 5f       	subi	r22, 0xF3	; 243
    2bfa:	7f 4f       	sbci	r23, 0xFF	; 255
    2bfc:	8f a1       	ldd	r24, Y+39	; 0x27
    2bfe:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) { memcpy(gc_state.coord_system,parameter_data,sizeof(parameter_data)); }
    2c02:	80 91 8d 07 	lds	r24, 0x078D
    2c06:	af a1       	ldd	r26, Y+39	; 0x27
    2c08:	8a 13       	cpse	r24, r26
    2c0a:	46 c0       	rjmp	.+140    	; 0x2c98 <gc_execute_line+0x12c6>
    2c0c:	8c e0       	ldi	r24, 0x0C	; 12
    2c0e:	fe 01       	movw	r30, r28
    2c10:	3d 96       	adiw	r30, 0x0d	; 13
    2c12:	aa ea       	ldi	r26, 0xAA	; 170
    2c14:	b7 e0       	ldi	r27, 0x07	; 7
    2c16:	01 90       	ld	r0, Z+
    2c18:	0d 92       	st	X+, r0
    2c1a:	8a 95       	dec	r24
    2c1c:	e1 f7       	brne	.-8      	; 0x2c16 <gc_execute_line+0x1244>
    2c1e:	3c c0       	rjmp	.+120    	; 0x2c98 <gc_execute_line+0x12c6>
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1: 
      // Move to intermediate position before going home. Obeys current coordinate system and offsets 
      // and absolute and incremental modes.
      if (axis_command) {
    2c20:	be 8d       	ldd	r27, Y+30	; 0x1e
    2c22:	bb 23       	and	r27, r27
    2c24:	49 f0       	breq	.+18     	; 0x2c38 <gc_execute_line+0x1266>
        #ifdef USE_LINE_NUMBERS
          mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
        #else
          mc_line(gc_block.values.xyz, -1.0, false);
    2c26:	20 e0       	ldi	r18, 0x00	; 0
    2c28:	40 e0       	ldi	r20, 0x00	; 0
    2c2a:	50 e0       	ldi	r21, 0x00	; 0
    2c2c:	60 e8       	ldi	r22, 0x80	; 128
    2c2e:	7f eb       	ldi	r23, 0xBF	; 191
    2c30:	83 ef       	ldi	r24, 0xF3	; 243
    2c32:	97 e0       	ldi	r25, 0x07	; 7
    2c34:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <mc_line>
        #endif
      }
      #ifdef USE_LINE_NUMBERS
        mc_line(parameter_data, -1.0, false, gc_state.line_number); 
      #else
        mc_line(parameter_data, -1.0, false); 
    2c38:	20 e0       	ldi	r18, 0x00	; 0
    2c3a:	40 e0       	ldi	r20, 0x00	; 0
    2c3c:	50 e0       	ldi	r21, 0x00	; 0
    2c3e:	60 e8       	ldi	r22, 0x80	; 128
    2c40:	7f eb       	ldi	r23, 0xBF	; 191
    2c42:	ce 01       	movw	r24, r28
    2c44:	0d 96       	adiw	r24, 0x0d	; 13
    2c46:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <mc_line>
      #endif
      memcpy(gc_state.position, parameter_data, sizeof(parameter_data));
    2c4a:	8c e0       	ldi	r24, 0x0C	; 12
    2c4c:	fe 01       	movw	r30, r28
    2c4e:	3d 96       	adiw	r30, 0x0d	; 13
    2c50:	ae e9       	ldi	r26, 0x9E	; 158
    2c52:	b7 e0       	ldi	r27, 0x07	; 7
    2c54:	01 90       	ld	r0, Z+
    2c56:	0d 92       	st	X+, r0
    2c58:	8a 95       	dec	r24
    2c5a:	e1 f7       	brne	.-8      	; 0x2c54 <gc_execute_line+0x1282>
      break;
    2c5c:	1d c0       	rjmp	.+58     	; 0x2c98 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_HOME_0: 
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    2c5e:	6e e9       	ldi	r22, 0x9E	; 158
    2c60:	77 e0       	ldi	r23, 0x07	; 7
    2c62:	86 e0       	ldi	r24, 0x06	; 6
    2c64:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <settings_write_coord_data>
      break;
    2c68:	17 c0       	rjmp	.+46     	; 0x2c98 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    2c6a:	6e e9       	ldi	r22, 0x9E	; 158
    2c6c:	77 e0       	ldi	r23, 0x07	; 7
    2c6e:	87 e0       	ldi	r24, 0x07	; 7
    2c70:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <settings_write_coord_data>
      break;
    2c74:	11 c0       	rjmp	.+34     	; 0x2c98 <gc_execute_line+0x12c6>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    2c76:	8c e0       	ldi	r24, 0x0C	; 12
    2c78:	e3 ef       	ldi	r30, 0xF3	; 243
    2c7a:	f7 e0       	ldi	r31, 0x07	; 7
    2c7c:	a6 eb       	ldi	r26, 0xB6	; 182
    2c7e:	b7 e0       	ldi	r27, 0x07	; 7
    2c80:	01 90       	ld	r0, Z+
    2c82:	0d 92       	st	X+, r0
    2c84:	8a 95       	dec	r24
    2c86:	e1 f7       	brne	.-8      	; 0x2c80 <gc_execute_line+0x12ae>
      break;
    2c88:	07 c0       	rjmp	.+14     	; 0x2c98 <gc_execute_line+0x12c6>
    case NON_MODAL_RESET_COORDINATE_OFFSET: 
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    2c8a:	8c e0       	ldi	r24, 0x0C	; 12
    2c8c:	e6 eb       	ldi	r30, 0xB6	; 182
    2c8e:	f7 e0       	ldi	r31, 0x07	; 7
    2c90:	df 01       	movw	r26, r30
    2c92:	1d 92       	st	X+, r1
    2c94:	8a 95       	dec	r24
    2c96:	e9 f7       	brne	.-6      	; 0x2c92 <gc_execute_line+0x12c0>

  
  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes. 
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    2c98:	80 91 c7 07 	lds	r24, 0x07C7
    2c9c:	80 93 87 07 	sts	0x0787, r24
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    2ca0:	88 30       	cpi	r24, 0x08	; 8
    2ca2:	09 f4       	brne	.+2      	; 0x2ca6 <gc_execute_line+0x12d4>
    2ca4:	be c0       	rjmp	.+380    	; 0x2e22 <gc_execute_line+0x1450>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    2ca6:	be 8d       	ldd	r27, Y+30	; 0x1e
    2ca8:	b2 30       	cpi	r27, 0x02	; 2
    2caa:	09 f0       	breq	.+2      	; 0x2cae <gc_execute_line+0x12dc>
    2cac:	ba c0       	rjmp	.+372    	; 0x2e22 <gc_execute_line+0x1450>
      switch (gc_state.modal.motion) {
    2cae:	90 e0       	ldi	r25, 0x00	; 0
    2cb0:	88 30       	cpi	r24, 0x08	; 8
    2cb2:	91 05       	cpc	r25, r1
    2cb4:	08 f0       	brcs	.+2      	; 0x2cb8 <gc_execute_line+0x12e6>
    2cb6:	ac c0       	rjmp	.+344    	; 0x2e10 <gc_execute_line+0x143e>
    2cb8:	fc 01       	movw	r30, r24
    2cba:	ed 52       	subi	r30, 0x2D	; 45
    2cbc:	ff 4f       	sbci	r31, 0xFF	; 255
    2cbe:	0c 94 e7 3f 	jmp	0x7fce	; 0x7fce <__tablejump2__>
        case MOTION_MODE_SEEK:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, -1.0, false);
    2cc2:	20 e0       	ldi	r18, 0x00	; 0
    2cc4:	40 e0       	ldi	r20, 0x00	; 0
    2cc6:	50 e0       	ldi	r21, 0x00	; 0
    2cc8:	60 e8       	ldi	r22, 0x80	; 128
    2cca:	7f eb       	ldi	r23, 0xBF	; 191
    2ccc:	83 ef       	ldi	r24, 0xF3	; 243
    2cce:	97 e0       	ldi	r25, 0x07	; 7
    2cd0:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <mc_line>
          #endif
          break;
    2cd4:	9d c0       	rjmp	.+314    	; 0x2e10 <gc_execute_line+0x143e>
        case MOTION_MODE_LINEAR:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
    2cd6:	40 91 95 07 	lds	r20, 0x0795
    2cda:	50 91 96 07 	lds	r21, 0x0796
    2cde:	60 91 97 07 	lds	r22, 0x0797
    2ce2:	70 91 98 07 	lds	r23, 0x0798
    2ce6:	20 91 88 07 	lds	r18, 0x0788
    2cea:	83 ef       	ldi	r24, 0xF3	; 243
    2cec:	97 e0       	ldi	r25, 0x07	; 7
    2cee:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <mc_line>
          #endif
          break;
    2cf2:	8e c0       	rjmp	.+284    	; 0x2e10 <gc_execute_line+0x143e>
        case MOTION_MODE_CW_ARC: 
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    2cf4:	c0 90 95 07 	lds	r12, 0x0795
    2cf8:	d0 90 96 07 	lds	r13, 0x0796
    2cfc:	e0 90 97 07 	lds	r14, 0x0797
    2d00:	f0 90 98 07 	lds	r15, 0x0798
    2d04:	00 91 ea 07 	lds	r16, 0x07EA
    2d08:	10 91 eb 07 	lds	r17, 0x07EB
    2d0c:	20 91 ec 07 	lds	r18, 0x07EC
    2d10:	30 91 ed 07 	lds	r19, 0x07ED
    2d14:	81 e0       	ldi	r24, 0x01	; 1
    2d16:	8f 93       	push	r24
    2d18:	ee a1       	ldd	r30, Y+38	; 0x26
    2d1a:	ef 93       	push	r30
    2d1c:	fd a1       	ldd	r31, Y+37	; 0x25
    2d1e:	ff 93       	push	r31
    2d20:	8c a0       	ldd	r8, Y+36	; 0x24
    2d22:	a0 90 88 07 	lds	r10, 0x0788
    2d26:	45 ed       	ldi	r20, 0xD5	; 213
    2d28:	57 e0       	ldi	r21, 0x07	; 7
    2d2a:	63 ef       	ldi	r22, 0xF3	; 243
    2d2c:	77 e0       	ldi	r23, 0x07	; 7
    2d2e:	8e e9       	ldi	r24, 0x9E	; 158
    2d30:	97 e0       	ldi	r25, 0x07	; 7
    2d32:	0e 94 90 08 	call	0x1120	; 0x1120 <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true); 
          #endif
          break;        
    2d36:	0f 90       	pop	r0
    2d38:	0f 90       	pop	r0
    2d3a:	0f 90       	pop	r0
    2d3c:	69 c0       	rjmp	.+210    	; 0x2e10 <gc_execute_line+0x143e>
        case MOTION_MODE_CCW_ARC:
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    2d3e:	c0 90 95 07 	lds	r12, 0x0795
    2d42:	d0 90 96 07 	lds	r13, 0x0796
    2d46:	e0 90 97 07 	lds	r14, 0x0797
    2d4a:	f0 90 98 07 	lds	r15, 0x0798
    2d4e:	00 91 ea 07 	lds	r16, 0x07EA
    2d52:	10 91 eb 07 	lds	r17, 0x07EB
    2d56:	20 91 ec 07 	lds	r18, 0x07EC
    2d5a:	30 91 ed 07 	lds	r19, 0x07ED
    2d5e:	1f 92       	push	r1
    2d60:	8e a1       	ldd	r24, Y+38	; 0x26
    2d62:	8f 93       	push	r24
    2d64:	9d a1       	ldd	r25, Y+37	; 0x25
    2d66:	9f 93       	push	r25
    2d68:	8c a0       	ldd	r8, Y+36	; 0x24
    2d6a:	a0 90 88 07 	lds	r10, 0x0788
    2d6e:	45 ed       	ldi	r20, 0xD5	; 213
    2d70:	57 e0       	ldi	r21, 0x07	; 7
    2d72:	63 ef       	ldi	r22, 0xF3	; 243
    2d74:	77 e0       	ldi	r23, 0x07	; 7
    2d76:	8e e9       	ldi	r24, 0x9E	; 158
    2d78:	97 e0       	ldi	r25, 0x07	; 7
    2d7a:	0e 94 90 08 	call	0x1120	; 0x1120 <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false); 
          #endif
          break;
    2d7e:	0f 90       	pop	r0
    2d80:	0f 90       	pop	r0
    2d82:	0f 90       	pop	r0
    2d84:	45 c0       	rjmp	.+138    	; 0x2e10 <gc_execute_line+0x143e>
          // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
          // upon a successful probing cycle, the machine position and the returned value should be the same.
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false);
    2d86:	40 91 95 07 	lds	r20, 0x0795
    2d8a:	50 91 96 07 	lds	r21, 0x0796
    2d8e:	60 91 97 07 	lds	r22, 0x0797
    2d92:	70 91 98 07 	lds	r23, 0x0798
    2d96:	e1 2c       	mov	r14, r1
    2d98:	00 e0       	ldi	r16, 0x00	; 0
    2d9a:	20 91 88 07 	lds	r18, 0x0788
    2d9e:	83 ef       	ldi	r24, 0xF3	; 243
    2da0:	97 e0       	ldi	r25, 0x07	; 7
    2da2:	0e 94 25 0c 	call	0x184a	; 0x184a <mc_probe_cycle>
          #endif
          break;
    2da6:	34 c0       	rjmp	.+104    	; 0x2e10 <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true);
    2da8:	40 91 95 07 	lds	r20, 0x0795
    2dac:	50 91 96 07 	lds	r21, 0x0796
    2db0:	60 91 97 07 	lds	r22, 0x0797
    2db4:	70 91 98 07 	lds	r23, 0x0798
    2db8:	ee 24       	eor	r14, r14
    2dba:	e3 94       	inc	r14
    2dbc:	00 e0       	ldi	r16, 0x00	; 0
    2dbe:	20 91 88 07 	lds	r18, 0x0788
    2dc2:	83 ef       	ldi	r24, 0xF3	; 243
    2dc4:	97 e0       	ldi	r25, 0x07	; 7
    2dc6:	0e 94 25 0c 	call	0x184a	; 0x184a <mc_probe_cycle>
          #endif
          break;
    2dca:	22 c0       	rjmp	.+68     	; 0x2e10 <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_AWAY:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false);
    2dcc:	40 91 95 07 	lds	r20, 0x0795
    2dd0:	50 91 96 07 	lds	r21, 0x0796
    2dd4:	60 91 97 07 	lds	r22, 0x0797
    2dd8:	70 91 98 07 	lds	r23, 0x0798
    2ddc:	e1 2c       	mov	r14, r1
    2dde:	01 e0       	ldi	r16, 0x01	; 1
    2de0:	20 91 88 07 	lds	r18, 0x0788
    2de4:	83 ef       	ldi	r24, 0xF3	; 243
    2de6:	97 e0       	ldi	r25, 0x07	; 7
    2de8:	0e 94 25 0c 	call	0x184a	; 0x184a <mc_probe_cycle>
          #endif
          break;
    2dec:	11 c0       	rjmp	.+34     	; 0x2e10 <gc_execute_line+0x143e>
        case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true, gc_state.line_number);
          #else        
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true);
    2dee:	40 91 95 07 	lds	r20, 0x0795
    2df2:	50 91 96 07 	lds	r21, 0x0796
    2df6:	60 91 97 07 	lds	r22, 0x0797
    2dfa:	70 91 98 07 	lds	r23, 0x0798
    2dfe:	ee 24       	eor	r14, r14
    2e00:	e3 94       	inc	r14
    2e02:	01 e0       	ldi	r16, 0x01	; 1
    2e04:	20 91 88 07 	lds	r18, 0x0788
    2e08:	83 ef       	ldi	r24, 0xF3	; 243
    2e0a:	97 e0       	ldi	r25, 0x07	; 7
    2e0c:	0e 94 25 0c 	call	0x184a	; 0x184a <mc_probe_cycle>
      }
    
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    2e10:	8c e0       	ldi	r24, 0x0C	; 12
    2e12:	e3 ef       	ldi	r30, 0xF3	; 243
    2e14:	f7 e0       	ldi	r31, 0x07	; 7
    2e16:	ae e9       	ldi	r26, 0x9E	; 158
    2e18:	b7 e0       	ldi	r27, 0x07	; 7
    2e1a:	01 90       	ld	r0, Z+
    2e1c:	0d 92       	st	X+, r0
    2e1e:	8a 95       	dec	r24
    2e20:	e1 f7       	brne	.-8      	; 0x2e1a <gc_execute_line+0x1448>
  }
  
  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may 
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    2e22:	80 91 ce 07 	lds	r24, 0x07CE
    2e26:	80 93 8e 07 	sts	0x078E, r24
  if (gc_state.modal.program_flow) { 
    2e2a:	88 23       	and	r24, r24
    2e2c:	09 f4       	brne	.+2      	; 0x2e30 <gc_execute_line+0x145e>
    2e2e:	6d c0       	rjmp	.+218    	; 0x2f0a <gc_execute_line+0x1538>
    protocol_buffer_synchronize(); // Finish all remaining buffered motions. Program paused when complete.
    2e30:	0e 94 fe 1a 	call	0x35fc	; 0x35fc <protocol_buffer_synchronize>

    sys.suspend = true;
    2e34:	81 e0       	ldi	r24, 0x01	; 1
    2e36:	80 93 69 07 	sts	0x0769, r24
    protocol_execute_realtime(); // Suspend execution. For both program pause or program end.
    2e3a:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
  
    // If complete, reset to reload defaults (G92.2,G54,G17,G90,G94,M48,G40,M5,M9). Otherwise,
    // re-enable program flow after pause complete, where cycle start will resume the program.
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    2e3e:	80 91 8e 07 	lds	r24, 0x078E
    2e42:	82 30       	cpi	r24, 0x02	; 2
    2e44:	21 f4       	brne	.+8      	; 0x2e4e <gc_execute_line+0x147c>
    2e46:	0e 94 ad 0c 	call	0x195a	; 0x195a <mc_reset>
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2e4a:	80 e0       	ldi	r24, 0x00	; 0
    2e4c:	73 c0       	rjmp	.+230    	; 0x2f34 <gc_execute_line+0x1562>
    protocol_execute_realtime(); // Suspend execution. For both program pause or program end.
  
    // If complete, reset to reload defaults (G92.2,G54,G17,G90,G94,M48,G40,M5,M9). Otherwise,
    // re-enable program flow after pause complete, where cycle start will resume the program.
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
    2e4e:	10 92 8e 07 	sts	0x078E, r1
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2e52:	80 e0       	ldi	r24, 0x00	; 0
    2e54:	6f c0       	rjmp	.+222    	; 0x2f34 <gc_execute_line+0x1562>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2e56:	81 e0       	ldi	r24, 0x01	; 1
    2e58:	6d c0       	rjmp	.+218    	; 0x2f34 <gc_execute_line+0x1562>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2e5a:	82 e0       	ldi	r24, 0x02	; 2
    2e5c:	6b c0       	rjmp	.+214    	; 0x2f34 <gc_execute_line+0x1562>
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    2e5e:	84 e1       	ldi	r24, 0x14	; 20
    2e60:	69 c0       	rjmp	.+210    	; 0x2f34 <gc_execute_line+0x1562>
        switch(int_value) {
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2e62:	88 e1       	ldi	r24, 0x18	; 24
    2e64:	67 c0       	rjmp	.+206    	; 0x2f34 <gc_execute_line+0x1562>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
    2e66:	84 e1       	ldi	r24, 0x14	; 20
    2e68:	65 c0       	rjmp	.+202    	; 0x2f34 <gc_execute_line+0x1562>
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
    2e6a:	84 e1       	ldi	r24, 0x14	; 20
    2e6c:	63 c0       	rjmp	.+198    	; 0x2f34 <gc_execute_line+0x1562>
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G92.x command]
    2e6e:	84 e1       	ldi	r24, 0x14	; 20
    2e70:	61 c0       	rjmp	.+194    	; 0x2f34 <gc_execute_line+0x1562>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2e72:	88 e1       	ldi	r24, 0x18	; 24
    2e74:	5f c0       	rjmp	.+190    	; 0x2f34 <gc_execute_line+0x1562>
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    2e76:	84 e1       	ldi	r24, 0x14	; 20
    2e78:	5d c0       	rjmp	.+186    	; 0x2f34 <gc_execute_line+0x1562>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    2e7a:	88 e1       	ldi	r24, 0x18	; 24
    2e7c:	5b c0       	rjmp	.+182    	; 0x2f34 <gc_execute_line+0x1562>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    2e7e:	84 e1       	ldi	r24, 0x14	; 20
    2e80:	59 c0       	rjmp	.+178    	; 0x2f34 <gc_execute_line+0x1562>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2e82:	87 e1       	ldi	r24, 0x17	; 23
    2e84:	57 c0       	rjmp	.+174    	; 0x2f34 <gc_execute_line+0x1562>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2e86:	85 e1       	ldi	r24, 0x15	; 21
    2e88:	55 c0       	rjmp	.+170    	; 0x2f34 <gc_execute_line+0x1562>
        break;
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    2e8a:	87 e1       	ldi	r24, 0x17	; 23
    2e8c:	53 c0       	rjmp	.+166    	; 0x2f34 <gc_execute_line+0x1562>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    2e8e:	84 e1       	ldi	r24, 0x14	; 20
    2e90:	51 c0       	rjmp	.+162    	; 0x2f34 <gc_execute_line+0x1562>
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2e92:	85 e1       	ldi	r24, 0x15	; 21
    2e94:	4f c0       	rjmp	.+158    	; 0x2f34 <gc_execute_line+0x1562>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2e96:	84 e1       	ldi	r24, 0x14	; 20
    2e98:	4d c0       	rjmp	.+154    	; 0x2f34 <gc_execute_line+0x1562>
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    2e9a:	89 e1       	ldi	r24, 0x19	; 25
    2e9c:	4b c0       	rjmp	.+150    	; 0x2f34 <gc_execute_line+0x1562>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    2e9e:	84 e0       	ldi	r24, 0x04	; 4
    2ea0:	49 c0       	rjmp	.+146    	; 0x2f34 <gc_execute_line+0x1562>
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    2ea2:	8b e1       	ldi	r24, 0x1B	; 27
    2ea4:	47 c0       	rjmp	.+142    	; 0x2f34 <gc_execute_line+0x1562>
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    2ea6:	86 e1       	ldi	r24, 0x16	; 22
    2ea8:	45 c0       	rjmp	.+138    	; 0x2f34 <gc_execute_line+0x1562>
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2eaa:	8c e1       	ldi	r24, 0x1C	; 28
    2eac:	43 c0       	rjmp	.+134    	; 0x2f34 <gc_execute_line+0x1562>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    2eae:	85 e2       	ldi	r24, 0x25	; 37
    2eb0:	41 c0       	rjmp	.+130    	; 0x2f34 <gc_execute_line+0x1562>
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2eb2:	8d e1       	ldi	r24, 0x1D	; 29
    2eb4:	3f c0       	rjmp	.+126    	; 0x2f34 <gc_execute_line+0x1562>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2eb6:	87 e0       	ldi	r24, 0x07	; 7
    2eb8:	3d c0       	rjmp	.+122    	; 0x2f34 <gc_execute_line+0x1562>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2eba:	8a e1       	ldi	r24, 0x1A	; 26
    2ebc:	3b c0       	rjmp	.+118    	; 0x2f34 <gc_execute_line+0x1562>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    2ebe:	8c e1       	ldi	r24, 0x1C	; 28
    2ec0:	39 c0       	rjmp	.+114    	; 0x2f34 <gc_execute_line+0x1562>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2ec2:	8d e1       	ldi	r24, 0x1D	; 29
    2ec4:	37 c0       	rjmp	.+110    	; 0x2f34 <gc_execute_line+0x1562>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    2ec6:	84 e1       	ldi	r24, 0x14	; 20
    2ec8:	35 c0       	rjmp	.+106    	; 0x2f34 <gc_execute_line+0x1562>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    2eca:	84 e1       	ldi	r24, 0x14	; 20
    2ecc:	33 c0       	rjmp	.+102    	; 0x2f34 <gc_execute_line+0x1562>
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    2ece:	87 e0       	ldi	r24, 0x07	; 7
    2ed0:	31 c0       	rjmp	.+98     	; 0x2f34 <gc_execute_line+0x1562>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2ed2:	8a e1       	ldi	r24, 0x1A	; 26
    2ed4:	2f c0       	rjmp	.+94     	; 0x2f34 <gc_execute_line+0x1562>
      switch (gc_block.non_modal_command) {        
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2ed6:	87 e0       	ldi	r24, 0x07	; 7
    2ed8:	2d c0       	rjmp	.+90     	; 0x2f34 <gc_execute_line+0x1562>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2eda:	87 e0       	ldi	r24, 0x07	; 7
    2edc:	2b c0       	rjmp	.+86     	; 0x2f34 <gc_execute_line+0x1562>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    2ede:	8e e1       	ldi	r24, 0x1E	; 30
    2ee0:	29 c0       	rjmp	.+82     	; 0x2f34 <gc_execute_line+0x1562>
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    2ee2:	8f e1       	ldi	r24, 0x1F	; 31
    2ee4:	27 c0       	rjmp	.+78     	; 0x2f34 <gc_execute_line+0x1562>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2ee6:	86 e1       	ldi	r24, 0x16	; 22
    2ee8:	25 c0       	rjmp	.+74     	; 0x2f34 <gc_execute_line+0x1562>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2eea:	8a e1       	ldi	r24, 0x1A	; 26
    2eec:	23 c0       	rjmp	.+70     	; 0x2f34 <gc_execute_line+0x1562>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    2eee:	80 e2       	ldi	r24, 0x20	; 32
    2ef0:	21 c0       	rjmp	.+66     	; 0x2f34 <gc_execute_line+0x1562>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2ef2:	82 e2       	ldi	r24, 0x22	; 34
    2ef4:	1f c0       	rjmp	.+62     	; 0x2f34 <gc_execute_line+0x1562>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2ef6:	83 e2       	ldi	r24, 0x23	; 35
    2ef8:	1d c0       	rjmp	.+58     	; 0x2f34 <gc_execute_line+0x1562>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) { 
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    2efa:	81 e2       	ldi	r24, 0x21	; 33
    2efc:	1b c0       	rjmp	.+54     	; 0x2f34 <gc_execute_line+0x1562>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    2efe:	81 e2       	ldi	r24, 0x21	; 33
    2f00:	19 c0       	rjmp	.+50     	; 0x2f34 <gc_execute_line+0x1562>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2f02:	8a e1       	ldi	r24, 0x1A	; 26
    2f04:	17 c0       	rjmp	.+46     	; 0x2f34 <gc_execute_line+0x1562>

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2f06:	84 e2       	ldi	r24, 0x24	; 36
    2f08:	15 c0       	rjmp	.+42     	; 0x2f34 <gc_execute_line+0x1562>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2f0a:	80 e0       	ldi	r24, 0x00	; 0
    2f0c:	13 c0       	rjmp	.+38     	; 0x2f34 <gc_execute_line+0x1562>
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    2f0e:	1f a2       	std	Y+39, r1	; 0x27
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    2f10:	10 91 c7 07 	lds	r17, 0x07C7
    2f14:	18 30       	cpi	r17, 0x08	; 8
    2f16:	09 f0       	breq	.+2      	; 0x2f1a <gc_execute_line+0x1548>
    2f18:	07 cb       	rjmp	.-2546   	; 0x2528 <gc_execute_line+0xb56>
    2f1a:	00 cb       	rjmp	.-2560   	; 0x251c <gc_execute_line+0xb4a>
          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    2f1c:	80 91 c9 07 	lds	r24, 0x07C9
    2f20:	81 30       	cpi	r24, 0x01	; 1
    2f22:	09 f0       	breq	.+2      	; 0x2f26 <gc_execute_line+0x1554>
    2f24:	da cb       	rjmp	.-2124   	; 0x26da <gc_execute_line+0xd08>
    2f26:	c7 cb       	rjmp	.-2162   	; 0x26b6 <gc_execute_line+0xce4>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    2f28:	ae ed       	ldi	r26, 0xDE	; 222
    2f2a:	2a 22       	and	r2, r26
    2f2c:	ac ef       	ldi	r26, 0xFC	; 252
    2f2e:	3a 22       	and	r3, r26
    2f30:	1e 8e       	std	Y+30, r1	; 0x1e
    2f32:	8e cd       	rjmp	.-1252   	; 0x2a50 <gc_execute_line+0x107e>
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; } // Resume from program pause.
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
}
    2f34:	ab 96       	adiw	r28, 0x2b	; 43
    2f36:	0f b6       	in	r0, 0x3f	; 63
    2f38:	f8 94       	cli
    2f3a:	de bf       	out	0x3e, r29	; 62
    2f3c:	0f be       	out	0x3f, r0	; 63
    2f3e:	cd bf       	out	0x3d, r28	; 61
    2f40:	df 91       	pop	r29
    2f42:	cf 91       	pop	r28
    2f44:	1f 91       	pop	r17
    2f46:	0f 91       	pop	r16
    2f48:	ff 90       	pop	r15
    2f4a:	ef 90       	pop	r14
    2f4c:	df 90       	pop	r13
    2f4e:	cf 90       	pop	r12
    2f50:	bf 90       	pop	r11
    2f52:	af 90       	pop	r10
    2f54:	9f 90       	pop	r9
    2f56:	8f 90       	pop	r8
    2f58:	7f 90       	pop	r7
    2f5a:	6f 90       	pop	r6
    2f5c:	5f 90       	pop	r5
    2f5e:	4f 90       	pop	r4
    2f60:	3f 90       	pop	r3
    2f62:	2f 90       	pop	r2
    2f64:	08 95       	ret

00002f66 <spindle_stop>:
    TCCRA_REGISTER &= ~(1<<COMB_BIT); // Disable PWM. Output voltage is zero.
    #ifndef CPU_MAP_ATMEGA328P 
      SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low.
    #endif
  #else
    SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low.
    2f66:	47 98       	cbi	0x08, 7	; 8
    2f68:	08 95       	ret

00002f6a <spindle_init>:
    SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    #ifndef CPU_MAP_ATMEGA328P 
      SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    #endif     
  #else
    SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    2f6a:	3f 9a       	sbi	0x07, 7	; 7
  #endif
  #ifdef SPINDLE_DIRECTION_PRESENT
  SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
  #endif
  spindle_stop();
    2f6c:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <spindle_stop>
    2f70:	08 95       	ret

00002f72 <spindle_set_state>:


void spindle_set_state(uint8_t state, float rpm)
{
  // Halt or set spindle direction and rpm. 
  if (state == SPINDLE_DISABLE) {
    2f72:	81 11       	cpse	r24, r1
    2f74:	03 c0       	rjmp	.+6      	; 0x2f7c <spindle_set_state+0xa>

    spindle_stop();
    2f76:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <spindle_stop>
    2f7a:	08 95       	ret
    
      #ifdef CPU_MAP_ATMEGA2560 // On the Uno, spindle enable and PWM are shared.
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    #else   
      SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
    2f7c:	47 9a       	sbi	0x08, 7	; 8
    2f7e:	08 95       	ret

00002f80 <spindle_run>:
  }
}


void spindle_run(uint8_t state, float rpm)
{
    2f80:	cf 92       	push	r12
    2f82:	df 92       	push	r13
    2f84:	ef 92       	push	r14
    2f86:	ff 92       	push	r15
    2f88:	cf 93       	push	r28
    2f8a:	c8 2f       	mov	r28, r24
    2f8c:	6a 01       	movw	r12, r20
    2f8e:	7b 01       	movw	r14, r22
  if (sys.state == STATE_CHECK_MODE) { return; }
    2f90:	90 91 68 07 	lds	r25, 0x0768
    2f94:	92 30       	cpi	r25, 0x02	; 2
    2f96:	39 f0       	breq	.+14     	; 0x2fa6 <spindle_run+0x26>
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.  
    2f98:	0e 94 fe 1a 	call	0x35fc	; 0x35fc <protocol_buffer_synchronize>
  spindle_set_state(state, rpm);
    2f9c:	b7 01       	movw	r22, r14
    2f9e:	a6 01       	movw	r20, r12
    2fa0:	8c 2f       	mov	r24, r28
    2fa2:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <spindle_set_state>
}
    2fa6:	cf 91       	pop	r28
    2fa8:	ff 90       	pop	r15
    2faa:	ef 90       	pop	r14
    2fac:	df 90       	pop	r13
    2fae:	cf 90       	pop	r12
    2fb0:	08 95       	ret

00002fb2 <coolant_stop>:
}


void coolant_stop()
{
  COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2fb2:	46 98       	cbi	0x08, 6	; 8
    2fb4:	08 95       	ret

00002fb6 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT);
    2fb6:	3e 9a       	sbi	0x07, 6	; 7
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
    2fb8:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <coolant_stop>
    2fbc:	08 95       	ret

00002fbe <coolant_set_state>:
}


void coolant_set_state(uint8_t mode)
{
  if (mode == COOLANT_FLOOD_ENABLE) {
    2fbe:	82 30       	cpi	r24, 0x02	; 2
    2fc0:	11 f4       	brne	.+4      	; 0x2fc6 <coolant_set_state+0x8>
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    2fc2:	46 9a       	sbi	0x08, 6	; 8
    2fc4:	08 95       	ret
    } else if (mode == COOLANT_MIST_ENABLE) {
      COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #endif

  } else {
    coolant_stop();
    2fc6:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <coolant_stop>
    2fca:	08 95       	ret

00002fcc <coolant_run>:
  }
}


void coolant_run(uint8_t mode)
{
    2fcc:	cf 93       	push	r28
    2fce:	c8 2f       	mov	r28, r24
  if (sys.state == STATE_CHECK_MODE) { return; }
    2fd0:	90 91 68 07 	lds	r25, 0x0768
    2fd4:	92 30       	cpi	r25, 0x02	; 2
    2fd6:	29 f0       	breq	.+10     	; 0x2fe2 <coolant_run+0x16>
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.  
    2fd8:	0e 94 fe 1a 	call	0x35fc	; 0x35fc <protocol_buffer_synchronize>
  coolant_set_state(mode);
    2fdc:	8c 2f       	mov	r24, r28
    2fde:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <coolant_set_state>
}
    2fe2:	cf 91       	pop	r28
    2fe4:	08 95       	ret

00002fe6 <serial_get_rx_buffer_count>:
  

// Returns the number of bytes used in the RX serial buffer.
uint8_t serial_get_rx_buffer_count()
{
  uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
    2fe6:	90 91 02 01 	lds	r25, 0x0102
  if (serial_rx_buffer_head >= rtail) { return(serial_rx_buffer_head-rtail); }
    2fea:	80 91 03 01 	lds	r24, 0x0103
    2fee:	89 17       	cp	r24, r25
    2ff0:	10 f0       	brcs	.+4      	; 0x2ff6 <serial_get_rx_buffer_count+0x10>
    2ff2:	89 1b       	sub	r24, r25
    2ff4:	08 95       	ret
  return (RX_BUFFER_SIZE - (rtail-serial_rx_buffer_head));
    2ff6:	80 58       	subi	r24, 0x80	; 128
    2ff8:	89 1b       	sub	r24, r25
}
    2ffa:	08 95       	ret

00002ffc <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    2ffc:	e0 ec       	ldi	r30, 0xC0	; 192
    2ffe:	f0 e0       	ldi	r31, 0x00	; 0
    3000:	80 81       	ld	r24, Z
    3002:	82 60       	ori	r24, 0x02	; 2
    3004:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    3006:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = UBRR0_value;
    300a:	83 e1       	ldi	r24, 0x13	; 19
    300c:	80 93 c4 00 	sts	0x00C4, r24
            
  // enable rx and tx
  UCSR0B |= 1<<RXEN0;
    3010:	e1 ec       	ldi	r30, 0xC1	; 193
    3012:	f0 e0       	ldi	r31, 0x00	; 0
    3014:	80 81       	ld	r24, Z
    3016:	80 61       	ori	r24, 0x10	; 16
    3018:	80 83       	st	Z, r24
  UCSR0B |= 1<<TXEN0;
    301a:	80 81       	ld	r24, Z
    301c:	88 60       	ori	r24, 0x08	; 8
    301e:	80 83       	st	Z, r24
	
  // enable interrupt on complete reception of a byte
  UCSR0B |= 1<<RXCIE0;
    3020:	80 81       	ld	r24, Z
    3022:	80 68       	ori	r24, 0x80	; 128
    3024:	80 83       	st	Z, r24
    3026:	08 95       	ret

00003028 <serial_write>:

// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    3028:	30 91 01 01 	lds	r19, 0x0101
    302c:	21 e0       	ldi	r18, 0x01	; 1
    302e:	23 0f       	add	r18, r19
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    3030:	20 38       	cpi	r18, 0x80	; 128
    3032:	31 f4       	brne	.+12     	; 0x3040 <serial_write+0x18>
    3034:	04 c0       	rjmp	.+8      	; 0x303e <serial_write+0x16>

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    3036:	90 81       	ld	r25, Z
    3038:	94 ff       	sbrs	r25, 4
    303a:	04 c0       	rjmp	.+8      	; 0x3044 <serial_write+0x1c>
    303c:	08 95       	ret
// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    303e:	20 e0       	ldi	r18, 0x00	; 0

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    3040:	ea e6       	ldi	r30, 0x6A	; 106
    3042:	f7 e0       	ldi	r31, 0x07	; 7
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    3044:	90 91 00 01 	lds	r25, 0x0100
    3048:	92 17       	cp	r25, r18
    304a:	a9 f3       	breq	.-22     	; 0x3036 <serial_write+0xe>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys.rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    304c:	e3 2f       	mov	r30, r19
    304e:	f0 e0       	ldi	r31, 0x00	; 0
    3050:	e1 50       	subi	r30, 0x01	; 1
    3052:	f8 4f       	sbci	r31, 0xF8	; 248
    3054:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    3056:	20 93 01 01 	sts	0x0101, r18
  
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0); 
    305a:	e1 ec       	ldi	r30, 0xC1	; 193
    305c:	f0 e0       	ldi	r31, 0x00	; 0
    305e:	80 81       	ld	r24, Z
    3060:	80 62       	ori	r24, 0x20	; 32
    3062:	80 83       	st	Z, r24
    3064:	08 95       	ret

00003066 <__vector_21>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    3066:	1f 92       	push	r1
    3068:	0f 92       	push	r0
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	0f 92       	push	r0
    306e:	11 24       	eor	r1, r1
    3070:	8f 93       	push	r24
    3072:	9f 93       	push	r25
    3074:	ef 93       	push	r30
    3076:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    3078:	80 91 00 01 	lds	r24, 0x0100
      flow_ctrl = XON_SENT; 
    } else
  #endif
  { 
    // Send a byte from the buffer	
    UDR0 = serial_tx_buffer[tail];
    307c:	e8 2f       	mov	r30, r24
    307e:	f0 e0       	ldi	r31, 0x00	; 0
    3080:	e1 50       	subi	r30, 0x01	; 1
    3082:	f8 4f       	sbci	r31, 0xF8	; 248
    3084:	90 81       	ld	r25, Z
    3086:	90 93 c6 00 	sts	0x00C6, r25
  
    // Update tail position
    tail++;
    308a:	8f 5f       	subi	r24, 0xFF	; 255
    if (tail == TX_BUFFER_SIZE) { tail = 0; }
    308c:	80 38       	cpi	r24, 0x80	; 128
    308e:	09 f4       	brne	.+2      	; 0x3092 <__vector_21+0x2c>
    3090:	80 e0       	ldi	r24, 0x00	; 0
  
    serial_tx_buffer_tail = tail;
    3092:	80 93 00 01 	sts	0x0100, r24
  }
  
  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    3096:	90 91 01 01 	lds	r25, 0x0101
    309a:	89 13       	cpse	r24, r25
    309c:	05 c0       	rjmp	.+10     	; 0x30a8 <__vector_21+0x42>
    309e:	e1 ec       	ldi	r30, 0xC1	; 193
    30a0:	f0 e0       	ldi	r31, 0x00	; 0
    30a2:	80 81       	ld	r24, Z
    30a4:	8f 7d       	andi	r24, 0xDF	; 223
    30a6:	80 83       	st	Z, r24
}
    30a8:	ff 91       	pop	r31
    30aa:	ef 91       	pop	r30
    30ac:	9f 91       	pop	r25
    30ae:	8f 91       	pop	r24
    30b0:	0f 90       	pop	r0
    30b2:	0f be       	out	0x3f, r0	; 63
    30b4:	0f 90       	pop	r0
    30b6:	1f 90       	pop	r1
    30b8:	18 95       	reti

000030ba <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    30ba:	90 91 02 01 	lds	r25, 0x0102
  if (serial_rx_buffer_head == tail) {
    30be:	80 91 03 01 	lds	r24, 0x0103
    30c2:	89 17       	cp	r24, r25
    30c4:	61 f0       	breq	.+24     	; 0x30de <serial_read+0x24>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    30c6:	e9 2f       	mov	r30, r25
    30c8:	f0 e0       	ldi	r31, 0x00	; 0
    30ca:	e1 58       	subi	r30, 0x81	; 129
    30cc:	f7 4f       	sbci	r31, 0xF7	; 247
    30ce:	80 81       	ld	r24, Z
    
    tail++;
    30d0:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_BUFFER_SIZE) { tail = 0; }
    30d2:	90 38       	cpi	r25, 0x80	; 128
    30d4:	09 f4       	brne	.+2      	; 0x30d8 <serial_read+0x1e>
    30d6:	90 e0       	ldi	r25, 0x00	; 0
    serial_rx_buffer_tail = tail;
    30d8:	90 93 02 01 	sts	0x0102, r25
        flow_ctrl = SEND_XON;
        UCSR0B |=  (1 << UDRIE0); // Force TX
      }
    #endif
    
    return data;
    30dc:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    30de:	8f ef       	ldi	r24, 0xFF	; 255
      }
    #endif
    
    return data;
  }
}
    30e0:	08 95       	ret

000030e2 <__vector_20>:


ISR(SERIAL_RX)
{
    30e2:	1f 92       	push	r1
    30e4:	0f 92       	push	r0
    30e6:	0f b6       	in	r0, 0x3f	; 63
    30e8:	0f 92       	push	r0
    30ea:	11 24       	eor	r1, r1
    30ec:	2f 93       	push	r18
    30ee:	3f 93       	push	r19
    30f0:	4f 93       	push	r20
    30f2:	5f 93       	push	r21
    30f4:	6f 93       	push	r22
    30f6:	7f 93       	push	r23
    30f8:	8f 93       	push	r24
    30fa:	9f 93       	push	r25
    30fc:	af 93       	push	r26
    30fe:	bf 93       	push	r27
    3100:	ef 93       	push	r30
    3102:	ff 93       	push	r31
  uint8_t data = UDR0;
    3104:	80 91 c6 00 	lds	r24, 0x00C6
  uint8_t next_head;
  
  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    3108:	8f 33       	cpi	r24, 0x3F	; 63
    310a:	59 f0       	breq	.+22     	; 0x3122 <__vector_20+0x40>
    310c:	28 f4       	brcc	.+10     	; 0x3118 <__vector_20+0x36>
    310e:	88 31       	cpi	r24, 0x18	; 24
    3110:	61 f1       	breq	.+88     	; 0x316a <__vector_20+0x88>
    3112:	81 32       	cpi	r24, 0x21	; 33
    3114:	c1 f0       	breq	.+48     	; 0x3146 <__vector_20+0x64>
    3116:	2c c0       	rjmp	.+88     	; 0x3170 <__vector_20+0x8e>
    3118:	80 34       	cpi	r24, 0x40	; 64
    311a:	f1 f0       	breq	.+60     	; 0x3158 <__vector_20+0x76>
    311c:	8e 37       	cpi	r24, 0x7E	; 126
    311e:	51 f0       	breq	.+20     	; 0x3134 <__vector_20+0x52>
    3120:	27 c0       	rjmp	.+78     	; 0x3170 <__vector_20+0x8e>
    case CMD_STATUS_REPORT: bit_true_atomic(sys.rt_exec_state, EXEC_STATUS_REPORT); break; // Set as true
    3122:	8f b7       	in	r24, 0x3f	; 63
    3124:	f8 94       	cli
    3126:	ea e6       	ldi	r30, 0x6A	; 106
    3128:	f7 e0       	ldi	r31, 0x07	; 7
    312a:	90 81       	ld	r25, Z
    312c:	91 60       	ori	r25, 0x01	; 1
    312e:	90 83       	st	Z, r25
    3130:	8f bf       	out	0x3f, r24	; 63
    3132:	2f c0       	rjmp	.+94     	; 0x3192 <__vector_20+0xb0>
    case CMD_CYCLE_START:   bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START); break; // Set as true
    3134:	8f b7       	in	r24, 0x3f	; 63
    3136:	f8 94       	cli
    3138:	ea e6       	ldi	r30, 0x6A	; 106
    313a:	f7 e0       	ldi	r31, 0x07	; 7
    313c:	90 81       	ld	r25, Z
    313e:	92 60       	ori	r25, 0x02	; 2
    3140:	90 83       	st	Z, r25
    3142:	8f bf       	out	0x3f, r24	; 63
    3144:	26 c0       	rjmp	.+76     	; 0x3192 <__vector_20+0xb0>
    case CMD_FEED_HOLD:     bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD); break; // Set as true
    3146:	8f b7       	in	r24, 0x3f	; 63
    3148:	f8 94       	cli
    314a:	ea e6       	ldi	r30, 0x6A	; 106
    314c:	f7 e0       	ldi	r31, 0x07	; 7
    314e:	90 81       	ld	r25, Z
    3150:	98 60       	ori	r25, 0x08	; 8
    3152:	90 83       	st	Z, r25
    3154:	8f bf       	out	0x3f, r24	; 63
    3156:	1d c0       	rjmp	.+58     	; 0x3192 <__vector_20+0xb0>
    case CMD_SAFETY_DOOR:   bit_true_atomic(sys.rt_exec_state, EXEC_SAFETY_DOOR); break; // Set as true
    3158:	8f b7       	in	r24, 0x3f	; 63
    315a:	f8 94       	cli
    315c:	ea e6       	ldi	r30, 0x6A	; 106
    315e:	f7 e0       	ldi	r31, 0x07	; 7
    3160:	90 81       	ld	r25, Z
    3162:	90 62       	ori	r25, 0x20	; 32
    3164:	90 83       	st	Z, r25
    3166:	8f bf       	out	0x3f, r24	; 63
    3168:	14 c0       	rjmp	.+40     	; 0x3192 <__vector_20+0xb0>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    316a:	0e 94 ad 0c 	call	0x195a	; 0x195a <mc_reset>
    316e:	11 c0       	rjmp	.+34     	; 0x3192 <__vector_20+0xb0>
    default: // Write character to buffer    
      next_head = serial_rx_buffer_head + 1;
    3170:	e0 91 03 01 	lds	r30, 0x0103
    3174:	91 e0       	ldi	r25, 0x01	; 1
    3176:	9e 0f       	add	r25, r30
      if (next_head == RX_BUFFER_SIZE) { next_head = 0; }
    3178:	90 38       	cpi	r25, 0x80	; 128
    317a:	09 f4       	brne	.+2      	; 0x317e <__vector_20+0x9c>
    317c:	90 e0       	ldi	r25, 0x00	; 0
    
      // Write data to buffer unless it is full.
      if (next_head != serial_rx_buffer_tail) {
    317e:	20 91 02 01 	lds	r18, 0x0102
    3182:	92 17       	cp	r25, r18
    3184:	31 f0       	breq	.+12     	; 0x3192 <__vector_20+0xb0>
        serial_rx_buffer[serial_rx_buffer_head] = data;
    3186:	f0 e0       	ldi	r31, 0x00	; 0
    3188:	e1 58       	subi	r30, 0x81	; 129
    318a:	f7 4f       	sbci	r31, 0xF7	; 247
    318c:	80 83       	st	Z, r24
        serial_rx_buffer_head = next_head;    
    318e:	90 93 03 01 	sts	0x0103, r25
        #endif
        
      }
      //TODO: else alarm on overflow?
  }
}
    3192:	ff 91       	pop	r31
    3194:	ef 91       	pop	r30
    3196:	bf 91       	pop	r27
    3198:	af 91       	pop	r26
    319a:	9f 91       	pop	r25
    319c:	8f 91       	pop	r24
    319e:	7f 91       	pop	r23
    31a0:	6f 91       	pop	r22
    31a2:	5f 91       	pop	r21
    31a4:	4f 91       	pop	r20
    31a6:	3f 91       	pop	r19
    31a8:	2f 91       	pop	r18
    31aa:	0f 90       	pop	r0
    31ac:	0f be       	out	0x3f, r0	; 63
    31ae:	0f 90       	pop	r0
    31b0:	1f 90       	pop	r1
    31b2:	18 95       	reti

000031b4 <serial_reset_read_buffer>:


void serial_reset_read_buffer() 
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    31b4:	80 91 03 01 	lds	r24, 0x0103
    31b8:	80 93 02 01 	sts	0x0102, r24
    31bc:	08 95       	ret

000031be <protocol_execute_realtime>:
// execute certain tasks without having two or more instances of the same task, such as the planner
// recalculating the buffer upon a feedhold or override.
// NOTE: The sys.rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    31be:	2f 92       	push	r2
    31c0:	3f 92       	push	r3
    31c2:	4f 92       	push	r4
    31c4:	5f 92       	push	r5
    31c6:	6f 92       	push	r6
    31c8:	7f 92       	push	r7
    31ca:	8f 92       	push	r8
    31cc:	9f 92       	push	r9
    31ce:	af 92       	push	r10
    31d0:	bf 92       	push	r11
    31d2:	cf 92       	push	r12
    31d4:	df 92       	push	r13
    31d6:	ef 92       	push	r14
    31d8:	ff 92       	push	r15
    31da:	0f 93       	push	r16
    31dc:	1f 93       	push	r17
    31de:	cf 93       	push	r28
    31e0:	df 93       	push	r29
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys.rt_exec_alarm; // Copy volatile sys.rt_exec_alarm.
    31e2:	0f 2e       	mov	r0, r31
    31e4:	fb e6       	ldi	r31, 0x6B	; 107
    31e6:	ef 2e       	mov	r14, r31
    31e8:	f7 e0       	ldi	r31, 0x07	; 7
    31ea:	ff 2e       	mov	r15, r31
    31ec:	f0 2d       	mov	r31, r0
  if (rt_exec) { // Enter only if any bit flag is true
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    31ee:	0f 2e       	mov	r0, r31
    31f0:	f8 e6       	ldi	r31, 0x68	; 104
    31f2:	8f 2e       	mov	r8, r31
    31f4:	f7 e0       	ldi	r31, 0x07	; 7
    31f6:	9f 2e       	mov	r9, r31
    31f8:	f0 2d       	mov	r31, r0
    31fa:	44 24       	eor	r4, r4
    31fc:	43 94       	inc	r4
      report_alarm_message(ALARM_PROBE_FAIL);
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
      bit_false_atomic(sys.rt_exec_state,EXEC_RESET); // Disable any existing reset
    31fe:	ca e6       	ldi	r28, 0x6A	; 106
    3200:	d7 e0       	ldi	r29, 0x07	; 7
          coolant_stop();
          // TODO: Install parking motion here.
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY); //Problem in Bezug auf Jogging?
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    3202:	09 e6       	ldi	r16, 0x69	; 105
    3204:	17 e0       	ldi	r17, 0x07	; 7
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    3206:	0f 2e       	mov	r0, r31
    3208:	f0 e9       	ldi	r31, 0x90	; 144
    320a:	af 2e       	mov	r10, r31
    320c:	f7 e0       	ldi	r31, 0x07	; 7
    320e:	bf 2e       	mov	r11, r31
    3210:	f0 2d       	mov	r31, r0
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    3212:	0f 2e       	mov	r0, r31
    3214:	ff e8       	ldi	r31, 0x8F	; 143
    3216:	cf 2e       	mov	r12, r31
    3218:	f7 e0       	ldi	r31, 0x07	; 7
    321a:	df 2e       	mov	r13, r31
    321c:	f0 2d       	mov	r31, r0
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    321e:	0f 2e       	mov	r0, r31
    3220:	f1 e9       	ldi	r31, 0x91	; 145
    3222:	6f 2e       	mov	r6, r31
    3224:	f7 e0       	ldi	r31, 0x07	; 7
    3226:	7f 2e       	mov	r7, r31
    3228:	f0 2d       	mov	r31, r0
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    322a:	68 94       	set
    322c:	22 24       	eor	r2, r2
    322e:	24 f8       	bld	r2, 4
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    3230:	68 94       	set
    3232:	33 24       	eor	r3, r3
    3234:	31 f8       	bld	r3, 1
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys.rt_exec_alarm; // Copy volatile sys.rt_exec_alarm.
    3236:	f7 01       	movw	r30, r14
    3238:	50 80       	ld	r5, Z
  if (rt_exec) { // Enter only if any bit flag is true
    323a:	55 20       	and	r5, r5
    323c:	71 f1       	breq	.+92     	; 0x329a <protocol_execute_realtime+0xdc>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    323e:	f4 01       	movw	r30, r8
    3240:	40 82       	st	Z, r4
	#ifdef LED_PRESENT
	LED_PORT &= ~(1<<LED_ERROR_BIT);
    3242:	45 98       	cbi	0x08, 5	; 8
    #endif
	if (rt_exec & EXEC_ALARM_HARD_LIMIT) {
    3244:	51 fe       	sbrs	r5, 1
    3246:	04 c0       	rjmp	.+8      	; 0x3250 <protocol_execute_realtime+0x92>
      report_alarm_message(ALARM_HARD_LIMIT_ERROR); 
    3248:	8f ef       	ldi	r24, 0xFF	; 255
    324a:	0e 94 c0 34 	call	0x6980	; 0x6980 <report_alarm_message>
    324e:	11 c0       	rjmp	.+34     	; 0x3272 <protocol_execute_realtime+0xb4>
    } else if (rt_exec & EXEC_ALARM_SOFT_LIMIT) {
    3250:	52 fe       	sbrs	r5, 2
    3252:	04 c0       	rjmp	.+8      	; 0x325c <protocol_execute_realtime+0x9e>
      report_alarm_message(ALARM_SOFT_LIMIT_ERROR);
    3254:	8e ef       	ldi	r24, 0xFE	; 254
    3256:	0e 94 c0 34 	call	0x6980	; 0x6980 <report_alarm_message>
    325a:	0b c0       	rjmp	.+22     	; 0x3272 <protocol_execute_realtime+0xb4>
    } else if (rt_exec & EXEC_ALARM_ABORT_CYCLE) {      
    325c:	53 fe       	sbrs	r5, 3
    325e:	04 c0       	rjmp	.+8      	; 0x3268 <protocol_execute_realtime+0xaa>
      report_alarm_message(ALARM_ABORT_CYCLE);
    3260:	8d ef       	ldi	r24, 0xFD	; 253
    3262:	0e 94 c0 34 	call	0x6980	; 0x6980 <report_alarm_message>
    3266:	05 c0       	rjmp	.+10     	; 0x3272 <protocol_execute_realtime+0xb4>
    } else if (rt_exec & EXEC_ALARM_PROBE_FAIL) {
    3268:	54 fe       	sbrs	r5, 4
    326a:	03 c0       	rjmp	.+6      	; 0x3272 <protocol_execute_realtime+0xb4>
      report_alarm_message(ALARM_PROBE_FAIL);
    326c:	8c ef       	ldi	r24, 0xFC	; 252
    326e:	0e 94 c0 34 	call	0x6980	; 0x6980 <report_alarm_message>
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
    3272:	50 fe       	sbrs	r5, 0
    3274:	0c c0       	rjmp	.+24     	; 0x328e <protocol_execute_realtime+0xd0>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    3276:	84 2d       	mov	r24, r4
    3278:	0e 94 ed 34 	call	0x69da	; 0x69da <report_feedback_message>
      bit_false_atomic(sys.rt_exec_state,EXEC_RESET); // Disable any existing reset
    327c:	8f b7       	in	r24, 0x3f	; 63
    327e:	f8 94       	cli
    3280:	98 81       	ld	r25, Y
    3282:	9f 7e       	andi	r25, 0xEF	; 239
    3284:	98 83       	st	Y, r25
    3286:	8f bf       	out	0x3f, r24	; 63
        // Nothing. Block EVERYTHING until user issues reset or power cycles. Hard limits
        // typically occur while unattended or not paying attention. Gives the user time
        // to do what is needed before resetting, like killing the incoming stream. The 
        // same could be said about soft limits. While the position is not lost, the incoming
        // stream could be still engaged and cause a serious crash if it continues afterwards.
      } while (bit_isfalse(sys.rt_exec_state,EXEC_RESET));
    3288:	88 81       	ld	r24, Y
    328a:	84 ff       	sbrs	r24, 4
    328c:	fd cf       	rjmp	.-6      	; 0x3288 <protocol_execute_realtime+0xca>
    }
    bit_false_atomic(sys.rt_exec_alarm,0xFF); // Clear all alarm flags
    328e:	8f b7       	in	r24, 0x3f	; 63
    3290:	f8 94       	cli
    3292:	f7 01       	movw	r30, r14
    3294:	90 81       	ld	r25, Z
    3296:	10 82       	st	Z, r1
    3298:	8f bf       	out	0x3f, r24	; 63
  }
  
  #ifdef LED_PRESENT
  if (sys.state != STATE_ALARM) LED_PORT |= (1<<LED_ERROR_BIT);
    329a:	f4 01       	movw	r30, r8
    329c:	80 81       	ld	r24, Z
    329e:	81 30       	cpi	r24, 0x01	; 1
    32a0:	09 f0       	breq	.+2      	; 0x32a4 <protocol_execute_realtime+0xe6>
    32a2:	45 9a       	sbi	0x08, 5	; 8
  #endif
  
  // Check and execute realtime commands
  rt_exec = sys.rt_exec_state; // Copy volatile sys.rt_exec_state.
    32a4:	58 80       	ld	r5, Y
  if (rt_exec) { // Enter only if any bit flag is true
    32a6:	55 20       	and	r5, r5
    32a8:	09 f4       	brne	.+2      	; 0x32ac <protocol_execute_realtime+0xee>
    32aa:	b7 c0       	rjmp	.+366    	; 0x341a <protocol_execute_realtime+0x25c>
  
    // Execute system abort. 
    if (rt_exec & EXEC_RESET) {
    32ac:	54 fe       	sbrs	r5, 4
    32ae:	04 c0       	rjmp	.+8      	; 0x32b8 <protocol_execute_realtime+0xfa>
      sys.abort = true;  // Only place this is set true.
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	80 93 67 07 	sts	0x0767, r24
      return; // Nothing else to do but exit.
    32b6:	cd c0       	rjmp	.+410    	; 0x3452 <protocol_execute_realtime+0x294>
    }
    
    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) { 
    32b8:	50 fe       	sbrs	r5, 0
    32ba:	08 c0       	rjmp	.+16     	; 0x32cc <protocol_execute_realtime+0x10e>
      report_realtime_status();
    32bc:	0e 94 91 38 	call	0x7122	; 0x7122 <report_realtime_status>
      bit_false_atomic(sys.rt_exec_state,EXEC_STATUS_REPORT);
    32c0:	8f b7       	in	r24, 0x3f	; 63
    32c2:	f8 94       	cli
    32c4:	98 81       	ld	r25, Y
    32c6:	9e 7f       	andi	r25, 0xFE	; 254
    32c8:	98 83       	st	Y, r25
    32ca:	8f bf       	out	0x3f, r24	; 63
  
    // Execute hold states.
    // NOTE: The math involved to calculate the hold should be low enough for most, if not all, 
    // operational scenarios. Once hold is initiated, the system enters a suspend state to block
    // all main program processes until either reset or resumed.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR)) {
    32cc:	85 2d       	mov	r24, r5
    32ce:	88 76       	andi	r24, 0x68	; 104
    32d0:	09 f4       	brne	.+2      	; 0x32d4 <protocol_execute_realtime+0x116>
    32d2:	40 c0       	rjmp	.+128    	; 0x3354 <protocol_execute_realtime+0x196>
      
      // TODO: CHECK MODE? How to handle this? Likely nothing, since it only works when IDLE and then resets Grbl.
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {
    32d4:	f4 01       	movw	r30, r8
    32d6:	80 81       	ld	r24, Z
    32d8:	88 23       	and	r24, r24
    32da:	71 f0       	breq	.+28     	; 0x32f8 <protocol_execute_realtime+0x13a>
    32dc:	98 2f       	mov	r25, r24
    32de:	9c 77       	andi	r25, 0x7C	; 124
    32e0:	99 f1       	breq	.+102    	; 0x3348 <protocol_execute_realtime+0x18a>

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
    32e2:	88 30       	cpi	r24, 0x08	; 8
    32e4:	09 f0       	breq	.+2      	; 0x32e8 <protocol_execute_realtime+0x12a>
    32e6:	b2 c0       	rjmp	.+356    	; 0x344c <protocol_execute_realtime+0x28e>
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    32e8:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <st_update_plan_block_parameters>
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
    32ec:	f8 01       	movw	r30, r16
    32ee:	40 82       	st	Z, r4
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    32f0:	f4 01       	movw	r30, r8
    32f2:	80 81       	ld	r24, Z
    32f4:	81 11       	cpse	r24, r1
    32f6:	05 c0       	rjmp	.+10     	; 0x3302 <protocol_execute_realtime+0x144>
    32f8:	f8 01       	movw	r30, r16
    32fa:	30 82       	st	Z, r3
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    32fc:	56 fc       	sbrc	r5, 6
    32fe:	08 c0       	rjmp	.+16     	; 0x3310 <protocol_execute_realtime+0x152>
    3300:	0b c0       	rjmp	.+22     	; 0x3318 <protocol_execute_realtime+0x15a>
    3302:	56 fe       	sbrs	r5, 6
    3304:	09 c0       	rjmp	.+18     	; 0x3318 <protocol_execute_realtime+0x15a>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    3306:	88 30       	cpi	r24, 0x08	; 8
    3308:	19 f4       	brne	.+6      	; 0x3310 <protocol_execute_realtime+0x152>
    330a:	80 e4       	ldi	r24, 0x40	; 64
    330c:	f4 01       	movw	r30, r8
    330e:	80 83       	st	Z, r24
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
    3310:	f8 01       	movw	r30, r16
    3312:	80 81       	ld	r24, Z
    3314:	88 60       	ori	r24, 0x08	; 8
    3316:	80 83       	st	Z, r24
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    3318:	53 fe       	sbrs	r5, 3
    331a:	04 c0       	rjmp	.+8      	; 0x3324 <protocol_execute_realtime+0x166>
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    331c:	f4 01       	movw	r30, r8
    331e:	80 81       	ld	r24, Z
    3320:	85 ff       	sbrs	r24, 5
    3322:	20 82       	st	Z, r2
  
        // Execute a safety door stop with a feed hold, only during a cycle, and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged. The power-down is 
        // executed here, if IDLE, or when the CYCLE completes via the EXEC_CYCLE_STOP flag.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    3324:	55 fe       	sbrs	r5, 5
    3326:	10 c0       	rjmp	.+32     	; 0x3348 <protocol_execute_realtime+0x18a>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
    3328:	86 e0       	ldi	r24, 0x06	; 6
    332a:	0e 94 ed 34 	call	0x69da	; 0x69da <report_feedback_message>
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
    332e:	f8 01       	movw	r30, r16
    3330:	80 81       	ld	r24, Z
    3332:	81 ff       	sbrs	r24, 1
    3334:	03 c0       	rjmp	.+6      	; 0x333c <protocol_execute_realtime+0x17e>
    3336:	f5 2d       	mov	r31, r5
    3338:	f4 60       	ori	r31, 0x04	; 4
    333a:	5f 2e       	mov	r5, r31
          sys.suspend |= SUSPEND_ENERGIZE;
    333c:	84 60       	ori	r24, 0x04	; 4
    333e:	f8 01       	movw	r30, r16
    3340:	80 83       	st	Z, r24
          sys.state = STATE_SAFETY_DOOR;
    3342:	80 e2       	ldi	r24, 0x20	; 32
    3344:	f4 01       	movw	r30, r8
    3346:	80 83       	st	Z, r24
        }
         
      }
      bit_false_atomic(sys.rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    3348:	8f b7       	in	r24, 0x3f	; 63
    334a:	f8 94       	cli
    334c:	98 81       	ld	r25, Y
    334e:	97 79       	andi	r25, 0x97	; 151
    3350:	98 83       	st	Y, r25
    3352:	8f bf       	out	0x3f, r24	; 63
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    3354:	51 fe       	sbrs	r5, 1
    3356:	44 c0       	rjmp	.+136    	; 0x33e0 <protocol_execute_realtime+0x222>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) { 
    3358:	85 2d       	mov	r24, r5
    335a:	88 76       	andi	r24, 0x68	; 104
    335c:	d9 f5       	brne	.+118    	; 0x33d4 <protocol_execute_realtime+0x216>
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
    335e:	f4 01       	movw	r30, r8
    3360:	80 81       	ld	r24, Z
    3362:	88 23       	and	r24, r24
    3364:	31 f0       	breq	.+12     	; 0x3372 <protocol_execute_realtime+0x1b4>
    3366:	80 75       	andi	r24, 0x50	; 80
    3368:	a9 f1       	breq	.+106    	; 0x33d4 <protocol_execute_realtime+0x216>
    336a:	f8 01       	movw	r30, r16
    336c:	80 81       	ld	r24, Z
    336e:	81 ff       	sbrs	r24, 1
    3370:	31 c0       	rjmp	.+98     	; 0x33d4 <protocol_execute_realtime+0x216>
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
    3372:	f8 01       	movw	r30, r16
    3374:	80 81       	ld	r24, Z
    3376:	82 ff       	sbrs	r24, 2
    3378:	19 c0       	rjmp	.+50     	; 0x33ac <protocol_execute_realtime+0x1ee>
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    337a:	f5 01       	movw	r30, r10
    337c:	80 81       	ld	r24, Z
    337e:	88 23       	and	r24, r24
    3380:	59 f0       	breq	.+22     	; 0x3398 <protocol_execute_realtime+0x1da>
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    3382:	f3 01       	movw	r30, r6
    3384:	40 81       	ld	r20, Z
    3386:	51 81       	ldd	r21, Z+1	; 0x01
    3388:	62 81       	ldd	r22, Z+2	; 0x02
    338a:	73 81       	ldd	r23, Z+3	; 0x03
    338c:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <spindle_set_state>
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    3390:	80 ea       	ldi	r24, 0xA0	; 160
    3392:	9f e0       	ldi	r25, 0x0F	; 15
    3394:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <delay_ms>
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    3398:	f6 01       	movw	r30, r12
    339a:	80 81       	ld	r24, Z
    339c:	88 23       	and	r24, r24
    339e:	31 f0       	breq	.+12     	; 0x33ac <protocol_execute_realtime+0x1ee>
              coolant_set_state(gc_state.modal.coolant); 
    33a0:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <coolant_set_state>
              delay_ms(SAFETY_DOOR_COOLANT_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    33a4:	88 ee       	ldi	r24, 0xE8	; 232
    33a6:	93 e0       	ldi	r25, 0x03	; 3
    33a8:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <delay_ms>
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    33ac:	0e 94 67 2a 	call	0x54ce	; 0x54ce <plan_get_current_block>
    33b0:	89 2b       	or	r24, r25
    33b2:	61 f0       	breq	.+24     	; 0x33cc <protocol_execute_realtime+0x20e>
    33b4:	f8 01       	movw	r30, r16
    33b6:	80 81       	ld	r24, Z
    33b8:	83 fd       	sbrc	r24, 3
    33ba:	08 c0       	rjmp	.+16     	; 0x33cc <protocol_execute_realtime+0x20e>
            sys.state = STATE_CYCLE;
    33bc:	88 e0       	ldi	r24, 0x08	; 8
    33be:	f4 01       	movw	r30, r8
    33c0:	80 83       	st	Z, r24
            st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    33c2:	0e 94 6d 1e 	call	0x3cda	; 0x3cda <st_prep_buffer>
            st_wake_up();
    33c6:	0e 94 1a 1b 	call	0x3634	; 0x3634 <st_wake_up>
    33ca:	02 c0       	rjmp	.+4      	; 0x33d0 <protocol_execute_realtime+0x212>
          } else { // Otherwise, do nothing. Set and resume IDLE state.
            sys.state = STATE_IDLE;
    33cc:	f4 01       	movw	r30, r8
    33ce:	10 82       	st	Z, r1
          }
          sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    33d0:	f8 01       	movw	r30, r16
    33d2:	10 82       	st	Z, r1
        }
      }    
      bit_false_atomic(sys.rt_exec_state,EXEC_CYCLE_START);
    33d4:	8f b7       	in	r24, 0x3f	; 63
    33d6:	f8 94       	cli
    33d8:	98 81       	ld	r25, Y
    33da:	9d 7f       	andi	r25, 0xFD	; 253
    33dc:	98 83       	st	Y, r25
    33de:	8f bf       	out	0x3f, r24	; 63
    // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by 
    // realtime command execution in the main program, ensuring that the planner re-plans safely.
    // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
    // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.   
    // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
    if (rt_exec & EXEC_CYCLE_STOP) {
    33e0:	52 fe       	sbrs	r5, 2
    33e2:	1b c0       	rjmp	.+54     	; 0x341a <protocol_execute_realtime+0x25c>
      if (sys.state & (STATE_HOLD | STATE_SAFETY_DOOR)) {
    33e4:	f4 01       	movw	r30, r8
    33e6:	80 81       	ld	r24, Z
    33e8:	80 73       	andi	r24, 0x30	; 48
    33ea:	69 f0       	breq	.+26     	; 0x3406 <protocol_execute_realtime+0x248>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        if (sys.suspend & SUSPEND_ENERGIZE) { // De-energize system if safety door has been opened.
    33ec:	f8 01       	movw	r30, r16
    33ee:	80 81       	ld	r24, Z
    33f0:	82 ff       	sbrs	r24, 2
    33f2:	04 c0       	rjmp	.+8      	; 0x33fc <protocol_execute_realtime+0x23e>
          spindle_stop();
    33f4:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <spindle_stop>
          coolant_stop();
    33f8:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <coolant_stop>
          // TODO: Install parking motion here.
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY); //Problem in Bezug auf Jogging?
    33fc:	f8 01       	movw	r30, r16
    33fe:	80 81       	ld	r24, Z
    3400:	82 60       	ori	r24, 0x02	; 2
    3402:	80 83       	st	Z, r24
    3404:	04 c0       	rjmp	.+8      	; 0x340e <protocol_execute_realtime+0x250>
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    3406:	f8 01       	movw	r30, r16
    3408:	10 82       	st	Z, r1
        sys.state = STATE_IDLE;
    340a:	f4 01       	movw	r30, r8
    340c:	10 82       	st	Z, r1
      }
      bit_false_atomic(sys.rt_exec_state,EXEC_CYCLE_STOP);
    340e:	8f b7       	in	r24, 0x3f	; 63
    3410:	f8 94       	cli
    3412:	98 81       	ld	r25, Y
    3414:	9b 7f       	andi	r25, 0xFB	; 251
    3416:	98 83       	st	Y, r25
    3418:	8f bf       	out	0x3f, r24	; 63

  // Overrides flag byte (sys.override) and execution should be installed here, since they 
  // are realtime and require a direct and controlled interface to the main stepper program.

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_MOTION_CANCEL | STATE_SAFETY_DOOR | STATE_HOMING)) { st_prep_buffer(); }  
    341a:	f4 01       	movw	r30, r8
    341c:	80 81       	ld	r24, Z
    341e:	8c 77       	andi	r24, 0x7C	; 124
    3420:	11 f0       	breq	.+4      	; 0x3426 <protocol_execute_realtime+0x268>
    3422:	0e 94 6d 1e 	call	0x3cda	; 0x3cda <st_prep_buffer>
  
  // If safety door was opened, actively check when safety door is closed and ready to resume.
  // NOTE: This unlocks the SAFETY_DOOR state to a HOLD state, such that CYCLE_START can activate a resume.
  if (sys.state == STATE_SAFETY_DOOR) { 
    3426:	f4 01       	movw	r30, r8
    3428:	80 81       	ld	r24, Z
    342a:	80 32       	cpi	r24, 0x20	; 32
    342c:	51 f4       	brne	.+20     	; 0x3442 <protocol_execute_realtime+0x284>
    if (bit_istrue(sys.suspend,SUSPEND_ENABLE_READY)) { 
    342e:	f8 01       	movw	r30, r16
    3430:	80 81       	ld	r24, Z
    3432:	81 ff       	sbrs	r24, 1
    3434:	06 c0       	rjmp	.+12     	; 0x3442 <protocol_execute_realtime+0x284>
      if (!(system_check_safety_door_ajar())) {
    3436:	0e 94 df 39 	call	0x73be	; 0x73be <system_check_safety_door_ajar>
    343a:	81 11       	cpse	r24, r1
    343c:	02 c0       	rjmp	.+4      	; 0x3442 <protocol_execute_realtime+0x284>
        sys.state = STATE_HOLD; // Update to HOLD state to indicate door is closed and ready to resume.
    343e:	f4 01       	movw	r30, r8
    3440:	20 82       	st	Z, r2
      }
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
    3442:	f8 01       	movw	r30, r16
    3444:	80 81       	ld	r24, Z
    3446:	81 11       	cpse	r24, r1
    3448:	f6 ce       	rjmp	.-532    	; 0x3236 <protocol_execute_realtime+0x78>
    344a:	03 c0       	rjmp	.+6      	; 0x3452 <protocol_execute_realtime+0x294>
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    344c:	f4 01       	movw	r30, r8
    344e:	80 81       	ld	r24, Z
    3450:	58 cf       	rjmp	.-336    	; 0x3302 <protocol_execute_realtime+0x144>
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
  
}  
    3452:	df 91       	pop	r29
    3454:	cf 91       	pop	r28
    3456:	1f 91       	pop	r17
    3458:	0f 91       	pop	r16
    345a:	ff 90       	pop	r15
    345c:	ef 90       	pop	r14
    345e:	df 90       	pop	r13
    3460:	cf 90       	pop	r12
    3462:	bf 90       	pop	r11
    3464:	af 90       	pop	r10
    3466:	9f 90       	pop	r9
    3468:	8f 90       	pop	r8
    346a:	7f 90       	pop	r7
    346c:	6f 90       	pop	r6
    346e:	5f 90       	pop	r5
    3470:	4f 90       	pop	r4
    3472:	3f 90       	pop	r3
    3474:	2f 90       	pop	r2
    3476:	08 95       	ret

00003478 <protocol_process>:
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
  }
}

void protocol_process() { //Extracted from main_loop function to use it while in Jogging State
    3478:	df 92       	push	r13
    347a:	ef 92       	push	r14
    347c:	ff 92       	push	r15
    347e:	0f 93       	push	r16
    3480:	1f 93       	push	r17
    3482:	cf 93       	push	r28
    3484:	df 93       	push	r29
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    3486:	c7 e6       	ldi	r28, 0x67	; 103
    3488:	d7 e0       	ldi	r29, 0x07	; 7

  if (line[0] == 0) {
    348a:	06 e0       	ldi	r16, 0x06	; 6
    348c:	11 e0       	ldi	r17, 0x01	; 1
  else if (line[0] == '$') {
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    
  }
  else if (sys.state == STATE_ALARM) {
    348e:	0f 2e       	mov	r0, r31
    3490:	f8 e6       	ldi	r31, 0x68	; 104
    3492:	ef 2e       	mov	r14, r31
    3494:	f7 e0       	ldi	r31, 0x07	; 7
    3496:	ff 2e       	mov	r15, r31
    3498:	f0 2d       	mov	r31, r0
				else if (c == '(') {
					// Enable comments flag and ignore all characters until ')' or EOL.
					// NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
					// In the future, we could simply remove the items within the comments, but retain the
					// comment control characters, so that the g-code parser can error-check it.
					iscomment = true;
    349a:	dd 24       	eor	r13, r13
    349c:	d3 94       	inc	r13
	// line buffer, which is limited in size. The g-code standard actually states a line can't
	// exceed 256 characters, but the Arduino Uno does not have the memory space for this.
	// With a better processor, it would be very easy to pull this initial parsing out as a
	// seperate task to be shared by the g-code parser and Grbl's system commands.
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
    349e:	6a c0       	rjmp	.+212    	; 0x3574 <protocol_process+0xfc>
		if ((c == '\n') || (c == '\r')) { // End of line reached
    34a0:	8a 30       	cpi	r24, 0x0A	; 10
    34a2:	11 f0       	breq	.+4      	; 0x34a8 <protocol_process+0x30>
    34a4:	8d 30       	cpi	r24, 0x0D	; 13
    34a6:	91 f5       	brne	.+100    	; 0x350c <protocol_process+0x94>
			line[char_counter] = 0; // Set string termination character.
    34a8:	e0 91 05 01 	lds	r30, 0x0105
    34ac:	f0 e0       	ldi	r31, 0x00	; 0
    34ae:	ea 5f       	subi	r30, 0xFA	; 250
    34b0:	fe 4f       	sbci	r31, 0xFE	; 254
    34b2:	10 82       	st	Z, r1
// Directs and executes one line of formatted input from protocol_process. While mostly
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
    34b4:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    34b8:	88 81       	ld	r24, Y
    34ba:	81 11       	cpse	r24, r1
    34bc:	22 c0       	rjmp	.+68     	; 0x3502 <protocol_process+0x8a>

  if (line[0] == 0) {
    34be:	f8 01       	movw	r30, r16
    34c0:	80 81       	ld	r24, Z
    34c2:	81 11       	cpse	r24, r1
    34c4:	03 c0       	rjmp	.+6      	; 0x34cc <protocol_process+0x54>
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);
    34c6:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
    34ca:	1b c0       	rjmp	.+54     	; 0x3502 <protocol_process+0x8a>

  }
  else if (line[0] == '$') {
    34cc:	84 32       	cpi	r24, 0x24	; 36
    34ce:	31 f4       	brne	.+12     	; 0x34dc <protocol_process+0x64>
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    34d0:	c8 01       	movw	r24, r16
    34d2:	0e 94 02 3a 	call	0x7404	; 0x7404 <system_execute_line>
    34d6:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
    34da:	13 c0       	rjmp	.+38     	; 0x3502 <protocol_process+0x8a>
    
  }
  else if (sys.state == STATE_ALARM) {
    34dc:	f7 01       	movw	r30, r14
    34de:	80 81       	ld	r24, Z
    34e0:	81 30       	cpi	r24, 0x01	; 1
    34e2:	21 f4       	brne	.+8      	; 0x34ec <protocol_process+0x74>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);
    34e4:	89 e0       	ldi	r24, 0x09	; 9
    34e6:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
    34ea:	0b c0       	rjmp	.+22     	; 0x3502 <protocol_process+0x8a>

  } 
  else if (sys.state == STATE_JOG) {
    34ec:	80 38       	cpi	r24, 0x80	; 128
    34ee:	21 f4       	brne	.+8      	; 0x34f8 <protocol_process+0x80>
	// GCode shall be ignored as long as jogging is ongoing
	report_status_message(STATUS_JOG_ONGOING_LOCK);
    34f0:	8d e0       	ldi	r24, 0x0D	; 13
    34f2:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
    34f6:	05 c0       	rjmp	.+10     	; 0x3502 <protocol_process+0x8a>
  }
  else {
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
    34f8:	c8 01       	movw	r24, r16
    34fa:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <gc_execute_line>
    34fe:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
		if ((c == '\n') || (c == '\r')) { // End of line reached
			line[char_counter] = 0; // Set string termination character.
			protocol_execute_line(line); // Line is complete. Execute it!
			iscomment = false;
    3502:	10 92 04 01 	sts	0x0104, r1
			char_counter = 0;
    3506:	10 92 05 01 	sts	0x0105, r1
    350a:	34 c0       	rjmp	.+104    	; 0x3574 <protocol_process+0xfc>
		} 
		else {
			if (iscomment) {
    350c:	90 91 04 01 	lds	r25, 0x0104
    3510:	99 23       	and	r25, r25
    3512:	29 f0       	breq	.+10     	; 0x351e <protocol_process+0xa6>
				// Throw away all comment characters
				if (c == ')') {
    3514:	89 32       	cpi	r24, 0x29	; 41
    3516:	71 f5       	brne	.+92     	; 0x3574 <protocol_process+0xfc>
					// End of comment. Resume line.
					iscomment = false;
    3518:	10 92 04 01 	sts	0x0104, r1
    351c:	2b c0       	rjmp	.+86     	; 0x3574 <protocol_process+0xfc>
				}
			}
			else {
				if (c <= ' ') {
    351e:	81 32       	cpi	r24, 0x21	; 33
    3520:	48 f1       	brcs	.+82     	; 0x3574 <protocol_process+0xfc>
					// Throw away whitepace and control characters
				}
				else if (c == '/') {
    3522:	8f 32       	cpi	r24, 0x2F	; 47
    3524:	39 f1       	breq	.+78     	; 0x3574 <protocol_process+0xfc>
					// Block delete NOT SUPPORTED. Ignore character.
					// NOTE: If supported, would simply need to check the system if block delete is enabled.
				}
				else if (c == '(') {
    3526:	88 32       	cpi	r24, 0x28	; 40
    3528:	19 f4       	brne	.+6      	; 0x3530 <protocol_process+0xb8>
					// Enable comments flag and ignore all characters until ')' or EOL.
					// NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
					// In the future, we could simply remove the items within the comments, but retain the
					// comment control characters, so that the g-code parser can error-check it.
					iscomment = true;
    352a:	d0 92 04 01 	sts	0x0104, r13
    352e:	22 c0       	rjmp	.+68     	; 0x3574 <protocol_process+0xfc>
					// where, during a program, the system auto-cycle start will continue to execute
					// everything until the next '%' sign. This will help fix resuming issues with certain
					// functions that empty the planner buffer to execute its task on-time.

				}
				else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    3530:	e0 91 05 01 	lds	r30, 0x0105
    3534:	ef 34       	cpi	r30, 0x4F	; 79
    3536:	40 f0       	brcs	.+16     	; 0x3548 <protocol_process+0xd0>
					// Detect line buffer overflow. Report error and reset line buffer.
					report_status_message(STATUS_OVERFLOW);
    3538:	8b e0       	ldi	r24, 0x0B	; 11
    353a:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
					iscomment = false;
    353e:	10 92 04 01 	sts	0x0104, r1
					char_counter = 0;
    3542:	10 92 05 01 	sts	0x0105, r1
    3546:	16 c0       	rjmp	.+44     	; 0x3574 <protocol_process+0xfc>
				}
				else if (c >= 'a' && c <= 'z') { // Uppercase lowercase
    3548:	9f e9       	ldi	r25, 0x9F	; 159
    354a:	98 0f       	add	r25, r24
    354c:	9a 31       	cpi	r25, 0x1A	; 26
    354e:	50 f4       	brcc	.+20     	; 0x3564 <protocol_process+0xec>
					line[char_counter++] = c-'a'+'A';
    3550:	91 e0       	ldi	r25, 0x01	; 1
    3552:	9e 0f       	add	r25, r30
    3554:	90 93 05 01 	sts	0x0105, r25
    3558:	f0 e0       	ldi	r31, 0x00	; 0
    355a:	ea 5f       	subi	r30, 0xFA	; 250
    355c:	fe 4f       	sbci	r31, 0xFE	; 254
    355e:	80 52       	subi	r24, 0x20	; 32
    3560:	80 83       	st	Z, r24
    3562:	08 c0       	rjmp	.+16     	; 0x3574 <protocol_process+0xfc>
				}
				else {
					line[char_counter++] = c;
    3564:	91 e0       	ldi	r25, 0x01	; 1
    3566:	9e 0f       	add	r25, r30
    3568:	90 93 05 01 	sts	0x0105, r25
    356c:	f0 e0       	ldi	r31, 0x00	; 0
    356e:	ea 5f       	subi	r30, 0xFA	; 250
    3570:	fe 4f       	sbci	r31, 0xFE	; 254
    3572:	80 83       	st	Z, r24
	// line buffer, which is limited in size. The g-code standard actually states a line can't
	// exceed 256 characters, but the Arduino Uno does not have the memory space for this.
	// With a better processor, it would be very easy to pull this initial parsing out as a
	// seperate task to be shared by the g-code parser and Grbl's system commands.
	
	while((c = serial_read()) != SERIAL_NO_DATA) {
    3574:	0e 94 5d 18 	call	0x30ba	; 0x30ba <serial_read>
    3578:	8f 3f       	cpi	r24, 0xFF	; 255
    357a:	09 f0       	breq	.+2      	; 0x357e <protocol_process+0x106>
    357c:	91 cf       	rjmp	.-222    	; 0x34a0 <protocol_process+0x28>
					line[char_counter++] = c;
				}
			}
		}
	}	
}
    357e:	df 91       	pop	r29
    3580:	cf 91       	pop	r28
    3582:	1f 91       	pop	r17
    3584:	0f 91       	pop	r16
    3586:	ff 90       	pop	r15
    3588:	ef 90       	pop	r14
    358a:	df 90       	pop	r13
    358c:	08 95       	ret

0000358e <protocol_auto_cycle_start>:
// command in the planner queue.
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes 
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming 
// is finished, single commands), a command that needs to wait for the motions in the buffer to 
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start() { bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START); } 
    358e:	8f b7       	in	r24, 0x3f	; 63
    3590:	f8 94       	cli
    3592:	ea e6       	ldi	r30, 0x6A	; 106
    3594:	f7 e0       	ldi	r31, 0x07	; 7
    3596:	90 81       	ld	r25, Z
    3598:	92 60       	ori	r25, 0x02	; 2
    359a:	90 83       	st	Z, r25
    359c:	8f bf       	out	0x3f, r24	; 63
    359e:	08 95       	ret

000035a0 <protocol_main_loop>:

/* 
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    35a0:	cf 93       	push	r28
    35a2:	df 93       	push	r29
  // ------------------------------------------------------------
  // Complete initialization procedures upon a power-up or reset.
  // ------------------------------------------------------------
  
  // Print welcome message   
  report_init_message();
    35a4:	0e 94 24 35 	call	0x6a48	; 0x6a48 <report_init_message>

  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    35a8:	80 91 68 07 	lds	r24, 0x0768
    35ac:	81 30       	cpi	r24, 0x01	; 1
    35ae:	21 f4       	brne	.+8      	; 0x35b8 <protocol_main_loop+0x18>
    report_feedback_message(MESSAGE_ALARM_LOCK); 
    35b0:	82 e0       	ldi	r24, 0x02	; 2
    35b2:	0e 94 ed 34 	call	0x69da	; 0x69da <report_feedback_message>
    35b6:	12 c0       	rjmp	.+36     	; 0x35dc <protocol_main_loop+0x3c>
  } else {
    // All systems go! But first check for safety door.
    if (system_check_safety_door_ajar()) {
    35b8:	0e 94 df 39 	call	0x73be	; 0x73be <system_check_safety_door_ajar>
    35bc:	88 23       	and	r24, r24
    35be:	41 f0       	breq	.+16     	; 0x35d0 <protocol_main_loop+0x30>
      bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
    35c0:	ea e6       	ldi	r30, 0x6A	; 106
    35c2:	f7 e0       	ldi	r31, 0x07	; 7
    35c4:	80 81       	ld	r24, Z
    35c6:	80 62       	ori	r24, 0x20	; 32
    35c8:	80 83       	st	Z, r24
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    35ca:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
    35ce:	02 c0       	rjmp	.+4      	; 0x35d4 <protocol_main_loop+0x34>
    } else {
      sys.state = STATE_IDLE; // Set system to ready. Clear all state flags.
    35d0:	10 92 68 07 	sts	0x0768, r1
    } 
    system_execute_startup(line); // Execute startup script.
    35d4:	86 e0       	ldi	r24, 0x06	; 6
    35d6:	91 e0       	ldi	r25, 0x01	; 1
    35d8:	0e 94 e1 39 	call	0x73c2	; 0x73c2 <system_execute_startup>
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
	jogging();
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    35dc:	c7 e6       	ldi	r28, 0x67	; 103
    35de:	d7 e0       	ldi	r29, 0x07	; 7
  

  for (;;) {

    
    protocol_process();
    35e0:	0e 94 3c 1a 	call	0x3478	; 0x3478 <protocol_process>
    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    35e4:	0e 94 c7 1a 	call	0x358e	; 0x358e <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
    35e8:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
	jogging();
    35ec:	0e 94 2d 05 	call	0xa5a	; 0xa5a <jogging>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    35f0:	88 81       	ld	r24, Y
    35f2:	88 23       	and	r24, r24
    35f4:	a9 f3       	breq	.-22     	; 0x35e0 <protocol_main_loop+0x40>
              
  }
  
  return; /* Never reached */
}
    35f6:	df 91       	pop	r29
    35f8:	cf 91       	pop	r28
    35fa:	08 95       	ret

000035fc <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    35fc:	0f 93       	push	r16
    35fe:	1f 93       	push	r17
    3600:	cf 93       	push	r28
    3602:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    3604:	0e 94 c7 1a 	call	0x358e	; 0x358e <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    3608:	c7 e6       	ldi	r28, 0x67	; 103
    360a:	d7 e0       	ldi	r29, 0x07	; 7
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    360c:	08 e6       	ldi	r16, 0x68	; 104
    360e:	17 e0       	ldi	r17, 0x07	; 7
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    3610:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    3614:	88 81       	ld	r24, Y
    3616:	81 11       	cpse	r24, r1
    3618:	08 c0       	rjmp	.+16     	; 0x362a <protocol_buffer_synchronize+0x2e>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    361a:	0e 94 67 2a 	call	0x54ce	; 0x54ce <plan_get_current_block>
    361e:	89 2b       	or	r24, r25
    3620:	b9 f7       	brne	.-18     	; 0x3610 <protocol_buffer_synchronize+0x14>
    3622:	f8 01       	movw	r30, r16
    3624:	80 81       	ld	r24, Z
    3626:	88 30       	cpi	r24, 0x08	; 8
    3628:	99 f3       	breq	.-26     	; 0x3610 <protocol_buffer_synchronize+0x14>
}
    362a:	df 91       	pop	r29
    362c:	cf 91       	pop	r28
    362e:	1f 91       	pop	r17
    3630:	0f 91       	pop	r16
    3632:	08 95       	ret

00003634 <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up() 
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    3634:	80 91 3c 09 	lds	r24, 0x093C
    3638:	82 ff       	sbrs	r24, 2
    363a:	02 c0       	rjmp	.+4      	; 0x3640 <st_wake_up+0xc>
    363c:	28 9a       	sbi	0x05, 0	; 5
    363e:	01 c0       	rjmp	.+2      	; 0x3642 <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    3640:	28 98       	cbi	0x05, 0	; 5

  #ifdef LED_PRESENT
  LED_PORT &= ~(1<<LED_RUN_BIT); // active low
    3642:	44 98       	cbi	0x08, 4	; 8
  #endif

  if (sys.state & (STATE_CYCLE | STATE_HOMING)){
    3644:	80 91 68 07 	lds	r24, 0x0768
    3648:	8c 70       	andi	r24, 0x0C	; 12
    364a:	91 f1       	breq	.+100    	; 0x36b0 <st_wake_up+0x7c>
    // Initialize stepper output bits
    st.dir_outbits = dir_port_invert_mask; 
    364c:	80 91 86 01 	lds	r24, 0x0186
    3650:	80 93 9a 01 	sts	0x019A, r24
    st.step_outbits = step_port_invert_mask;
    3654:	80 91 87 01 	lds	r24, 0x0187
    3658:	80 93 99 01 	sts	0x0199, r24
      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
      // Set delay between direction pin write and step command.
      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    #else // Normal operation
      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    365c:	80 91 2f 09 	lds	r24, 0x092F
    3660:	90 e0       	ldi	r25, 0x00	; 0
    3662:	02 97       	sbiw	r24, 0x02	; 2
    3664:	aa 27       	eor	r26, r26
    3666:	97 fd       	sbrc	r25, 7
    3668:	a0 95       	com	r26
    366a:	ba 2f       	mov	r27, r26
    366c:	ac 01       	movw	r20, r24
    366e:	bd 01       	movw	r22, r26
    3670:	44 0f       	add	r20, r20
    3672:	55 1f       	adc	r21, r21
    3674:	66 1f       	adc	r22, r22
    3676:	77 1f       	adc	r23, r23
    3678:	44 0f       	add	r20, r20
    367a:	55 1f       	adc	r21, r21
    367c:	66 1f       	adc	r22, r22
    367e:	77 1f       	adc	r23, r23
    3680:	44 0f       	add	r20, r20
    3682:	55 1f       	adc	r21, r21
    3684:	66 1f       	adc	r22, r22
    3686:	77 1f       	adc	r23, r23
    3688:	84 0f       	add	r24, r20
    368a:	95 1f       	adc	r25, r21
    368c:	a6 1f       	adc	r26, r22
    368e:	b7 1f       	adc	r27, r23
    3690:	b5 95       	asr	r27
    3692:	a7 95       	ror	r26
    3694:	97 95       	ror	r25
    3696:	87 95       	ror	r24
    3698:	b5 95       	asr	r27
    369a:	a7 95       	ror	r26
    369c:	97 95       	ror	r25
    369e:	87 95       	ror	r24
    36a0:	81 95       	neg	r24
    36a2:	80 93 98 01 	sts	0x0198, r24
    #endif

    // Enable Stepper Driver Interrupt
    TIMSK1 |= (1<<OCIE1A);
    36a6:	ef e6       	ldi	r30, 0x6F	; 111
    36a8:	f0 e0       	ldi	r31, 0x00	; 0
    36aa:	80 81       	ld	r24, Z
    36ac:	82 60       	ori	r24, 0x02	; 2
    36ae:	80 83       	st	Z, r24
    36b0:	08 95       	ret

000036b2 <st_go_idle>:

// Stepper shutdown
void st_go_idle() 
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    36b2:	ef e6       	ldi	r30, 0x6F	; 111
    36b4:	f0 e0       	ldi	r31, 0x00	; 0
    36b6:	80 81       	ld	r24, Z
    36b8:	8d 7f       	andi	r24, 0xFD	; 253
    36ba:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    36bc:	e1 e8       	ldi	r30, 0x81	; 129
    36be:	f0 e0       	ldi	r31, 0x00	; 0
    36c0:	80 81       	ld	r24, Z
    36c2:	88 7f       	andi	r24, 0xF8	; 248
    36c4:	81 60       	ori	r24, 0x01	; 1
    36c6:	80 83       	st	Z, r24
  busy = false;
    36c8:	10 92 85 01 	sts	0x0185, r1
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys.rt_exec_alarm) && sys.state != STATE_HOMING) {
    36cc:	80 91 32 09 	lds	r24, 0x0932
    36d0:	8f 3f       	cpi	r24, 0xFF	; 255
    36d2:	21 f4       	brne	.+8      	; 0x36dc <st_go_idle+0x2a>
    36d4:	90 91 6b 07 	lds	r25, 0x076B
    36d8:	99 23       	and	r25, r25
    36da:	49 f0       	breq	.+18     	; 0x36ee <st_go_idle+0x3c>
    36dc:	90 91 68 07 	lds	r25, 0x0768
    36e0:	94 30       	cpi	r25, 0x04	; 4
    36e2:	39 f0       	breq	.+14     	; 0x36f2 <st_go_idle+0x40>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    36e4:	90 e0       	ldi	r25, 0x00	; 0
    36e6:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <delay_ms>
    pin_state = true; // Override. Disable steppers.
    36ea:	81 e0       	ldi	r24, 0x01	; 1
    36ec:	03 c0       	rjmp	.+6      	; 0x36f4 <st_go_idle+0x42>
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
  busy = false;
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
    36ee:	80 e0       	ldi	r24, 0x00	; 0
    36f0:	01 c0       	rjmp	.+2      	; 0x36f4 <st_go_idle+0x42>
    36f2:	80 e0       	ldi	r24, 0x00	; 0
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    36f4:	90 91 3c 09 	lds	r25, 0x093C
    36f8:	92 ff       	sbrs	r25, 2
    36fa:	02 c0       	rjmp	.+4      	; 0x3700 <st_go_idle+0x4e>
    36fc:	91 e0       	ldi	r25, 0x01	; 1
    36fe:	89 27       	eor	r24, r25
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    3700:	88 23       	and	r24, r24
    3702:	11 f0       	breq	.+4      	; 0x3708 <st_go_idle+0x56>
    3704:	28 9a       	sbi	0x05, 0	; 5
    3706:	01 c0       	rjmp	.+2      	; 0x370a <st_go_idle+0x58>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    3708:	28 98       	cbi	0x05, 0	; 5
	  
  #ifdef LED_PRESENT
  LED_PORT |= (1<<LED_RUN_BIT); // active low, so set high
    370a:	44 9a       	sbi	0x08, 4	; 8
    370c:	08 95       	ret

0000370e <__vector_13>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated 
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{        
    370e:	1f 92       	push	r1
    3710:	0f 92       	push	r0
    3712:	0f b6       	in	r0, 0x3f	; 63
    3714:	0f 92       	push	r0
    3716:	11 24       	eor	r1, r1
    3718:	2f 93       	push	r18
    371a:	3f 93       	push	r19
    371c:	4f 93       	push	r20
    371e:	5f 93       	push	r21
    3720:	6f 93       	push	r22
    3722:	7f 93       	push	r23
    3724:	8f 93       	push	r24
    3726:	9f 93       	push	r25
    3728:	af 93       	push	r26
    372a:	bf 93       	push	r27
    372c:	cf 93       	push	r28
    372e:	df 93       	push	r29
    3730:	ef 93       	push	r30
    3732:	ff 93       	push	r31
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    3734:	80 91 85 01 	lds	r24, 0x0185
    3738:	81 11       	cpse	r24, r1
    373a:	ec c1       	rjmp	.+984    	; 0x3b14 <__vector_13+0x406>
  
  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    373c:	8b b1       	in	r24, 0x0b	; 11
    373e:	90 91 9a 01 	lds	r25, 0x019A
    3742:	98 7a       	andi	r25, 0xA8	; 168
    3744:	87 75       	andi	r24, 0x57	; 87
    3746:	89 2b       	or	r24, r25
    3748:	8b b9       	out	0x0b, r24	; 11

  // Then pulse the stepping pins
  #ifdef STEP_PULSE_DELAY
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    374a:	8b b1       	in	r24, 0x0b	; 11
    374c:	8b 7a       	andi	r24, 0xAB	; 171
    374e:	90 91 99 01 	lds	r25, 0x0199
    3752:	89 2b       	or	r24, r25
    3754:	8b b9       	out	0x0b, r24	; 11
  #endif  

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    3756:	80 91 98 01 	lds	r24, 0x0198
    375a:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    375c:	82 e0       	ldi	r24, 0x02	; 2
    375e:	85 bd       	out	0x25, r24	; 37

  busy = true;
    3760:	81 e0       	ldi	r24, 0x01	; 1
    3762:	80 93 85 01 	sts	0x0185, r24
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. 
    3766:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.
    
  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    3768:	80 91 ac 01 	lds	r24, 0x01AC
    376c:	90 91 ad 01 	lds	r25, 0x01AD
    3770:	89 2b       	or	r24, r25
    3772:	09 f0       	breq	.+2      	; 0x3776 <__vector_13+0x68>
    3774:	a9 c0       	rjmp	.+338    	; 0x38c8 <__vector_13+0x1ba>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    3776:	80 91 8a 01 	lds	r24, 0x018A
    377a:	90 91 89 01 	lds	r25, 0x0189
    377e:	98 17       	cp	r25, r24
    3780:	09 f4       	brne	.+2      	; 0x3784 <__vector_13+0x76>
    3782:	97 c0       	rjmp	.+302    	; 0x38b2 <__vector_13+0x1a4>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    3784:	80 91 8a 01 	lds	r24, 0x018A
    3788:	90 e0       	ldi	r25, 0x00	; 0
    378a:	fc 01       	movw	r30, r24
    378c:	ee 0f       	add	r30, r30
    378e:	ff 1f       	adc	r31, r31
    3790:	8e 0f       	add	r24, r30
    3792:	9f 1f       	adc	r25, r31
    3794:	fc 01       	movw	r30, r24
    3796:	ee 0f       	add	r30, r30
    3798:	ff 1f       	adc	r31, r31
    379a:	e2 55       	subi	r30, 0x52	; 82
    379c:	fe 4f       	sbci	r31, 0xFE	; 254
    379e:	f0 93 ad 01 	sts	0x01AD, r31
    37a2:	e0 93 ac 01 	sts	0x01AC, r30
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    37a6:	83 81       	ldd	r24, Z+3	; 0x03
    37a8:	94 81       	ldd	r25, Z+4	; 0x04
    37aa:	90 93 89 00 	sts	0x0089, r25
    37ae:	80 93 88 00 	sts	0x0088, r24
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    37b2:	80 81       	ld	r24, Z
    37b4:	91 81       	ldd	r25, Z+1	; 0x01
    37b6:	90 93 a8 01 	sts	0x01A8, r25
    37ba:	80 93 a7 01 	sts	0x01A7, r24
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    37be:	a2 81       	ldd	r26, Z+2	; 0x02
    37c0:	80 91 a9 01 	lds	r24, 0x01A9
    37c4:	8a 17       	cp	r24, r26
    37c6:	71 f1       	breq	.+92     	; 0x3824 <__vector_13+0x116>
        st.exec_block_index = st.exec_segment->st_block_index;
    37c8:	a0 93 a9 01 	sts	0x01A9, r26
        st.exec_block = &st_block_buffer[st.exec_block_index];
    37cc:	81 e1       	ldi	r24, 0x11	; 17
    37ce:	a8 9f       	mul	r26, r24
    37d0:	d0 01       	movw	r26, r0
    37d2:	11 24       	eor	r1, r1
    37d4:	ae 52       	subi	r26, 0x2E	; 46
    37d6:	be 4f       	sbci	r27, 0xFE	; 254
    37d8:	b0 93 ab 01 	sts	0x01AB, r27
    37dc:	a0 93 aa 01 	sts	0x01AA, r26
        
        // Initialize Bresenham line and distance counters
        st.counter_x = (st.exec_block->step_event_count >> 1);
    37e0:	1d 96       	adiw	r26, 0x0d	; 13
    37e2:	8d 91       	ld	r24, X+
    37e4:	9d 91       	ld	r25, X+
    37e6:	0d 90       	ld	r0, X+
    37e8:	bc 91       	ld	r27, X
    37ea:	a0 2d       	mov	r26, r0
    37ec:	b6 95       	lsr	r27
    37ee:	a7 95       	ror	r26
    37f0:	97 95       	ror	r25
    37f2:	87 95       	ror	r24
    37f4:	80 93 8b 01 	sts	0x018B, r24
    37f8:	90 93 8c 01 	sts	0x018C, r25
    37fc:	a0 93 8d 01 	sts	0x018D, r26
    3800:	b0 93 8e 01 	sts	0x018E, r27
        st.counter_y = st.counter_x;
    3804:	80 93 8f 01 	sts	0x018F, r24
    3808:	90 93 90 01 	sts	0x0190, r25
    380c:	a0 93 91 01 	sts	0x0191, r26
    3810:	b0 93 92 01 	sts	0x0192, r27
        st.counter_z = st.counter_x;        
    3814:	80 93 93 01 	sts	0x0193, r24
    3818:	90 93 94 01 	sts	0x0194, r25
    381c:	a0 93 95 01 	sts	0x0195, r26
    3820:	b0 93 96 01 	sts	0x0196, r27
      }

      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask; 
    3824:	c0 91 aa 01 	lds	r28, 0x01AA
    3828:	d0 91 ab 01 	lds	r29, 0x01AB
    382c:	90 91 86 01 	lds	r25, 0x0186
    3830:	88 81       	ld	r24, Y
    3832:	89 27       	eor	r24, r25
    3834:	80 93 9a 01 	sts	0x019A, r24

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    3838:	89 81       	ldd	r24, Y+1	; 0x01
    383a:	9a 81       	ldd	r25, Y+2	; 0x02
    383c:	ab 81       	ldd	r26, Y+3	; 0x03
    383e:	bc 81       	ldd	r27, Y+4	; 0x04
    3840:	05 80       	ldd	r0, Z+5	; 0x05
    3842:	04 c0       	rjmp	.+8      	; 0x384c <__vector_13+0x13e>
    3844:	b6 95       	lsr	r27
    3846:	a7 95       	ror	r26
    3848:	97 95       	ror	r25
    384a:	87 95       	ror	r24
    384c:	0a 94       	dec	r0
    384e:	d2 f7       	brpl	.-12     	; 0x3844 <__vector_13+0x136>
    3850:	80 93 9b 01 	sts	0x019B, r24
    3854:	90 93 9c 01 	sts	0x019C, r25
    3858:	a0 93 9d 01 	sts	0x019D, r26
    385c:	b0 93 9e 01 	sts	0x019E, r27
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    3860:	8d 81       	ldd	r24, Y+5	; 0x05
    3862:	9e 81       	ldd	r25, Y+6	; 0x06
    3864:	af 81       	ldd	r26, Y+7	; 0x07
    3866:	b8 85       	ldd	r27, Y+8	; 0x08
    3868:	05 80       	ldd	r0, Z+5	; 0x05
    386a:	04 c0       	rjmp	.+8      	; 0x3874 <__vector_13+0x166>
    386c:	b6 95       	lsr	r27
    386e:	a7 95       	ror	r26
    3870:	97 95       	ror	r25
    3872:	87 95       	ror	r24
    3874:	0a 94       	dec	r0
    3876:	d2 f7       	brpl	.-12     	; 0x386c <__vector_13+0x15e>
    3878:	80 93 9f 01 	sts	0x019F, r24
    387c:	90 93 a0 01 	sts	0x01A0, r25
    3880:	a0 93 a1 01 	sts	0x01A1, r26
    3884:	b0 93 a2 01 	sts	0x01A2, r27
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    3888:	89 85       	ldd	r24, Y+9	; 0x09
    388a:	9a 85       	ldd	r25, Y+10	; 0x0a
    388c:	ab 85       	ldd	r26, Y+11	; 0x0b
    388e:	bc 85       	ldd	r27, Y+12	; 0x0c
    3890:	05 80       	ldd	r0, Z+5	; 0x05
    3892:	04 c0       	rjmp	.+8      	; 0x389c <__vector_13+0x18e>
    3894:	b6 95       	lsr	r27
    3896:	a7 95       	ror	r26
    3898:	97 95       	ror	r25
    389a:	87 95       	ror	r24
    389c:	0a 94       	dec	r0
    389e:	d2 f7       	brpl	.-12     	; 0x3894 <__vector_13+0x186>
    38a0:	80 93 a3 01 	sts	0x01A3, r24
    38a4:	90 93 a4 01 	sts	0x01A4, r25
    38a8:	a0 93 a5 01 	sts	0x01A5, r26
    38ac:	b0 93 a6 01 	sts	0x01A6, r27
    38b0:	0b c0       	rjmp	.+22     	; 0x38c8 <__vector_13+0x1ba>
      #endif
      
    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    38b2:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <st_go_idle>
      bit_true_atomic(sys.rt_exec_state,EXEC_CYCLE_STOP); // Flag main program for cycle end
    38b6:	8f b7       	in	r24, 0x3f	; 63
    38b8:	f8 94       	cli
    38ba:	ea e6       	ldi	r30, 0x6A	; 106
    38bc:	f7 e0       	ldi	r31, 0x07	; 7
    38be:	90 81       	ld	r25, Z
    38c0:	94 60       	ori	r25, 0x04	; 4
    38c2:	90 83       	st	Z, r25
    38c4:	8f bf       	out	0x3f, r24	; 63
      return; // Nothing to do but exit.
    38c6:	26 c1       	rjmp	.+588    	; 0x3b14 <__vector_13+0x406>
    }  
  }
  
  
  // Check probing state.
  probe_state_monitor();
    38c8:	0e 94 36 34 	call	0x686c	; 0x686c <probe_state_monitor>
   
  // Reset step out bits.
  st.step_outbits = 0; 
    38cc:	10 92 99 01 	sts	0x0199, r1

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    38d0:	eb e8       	ldi	r30, 0x8B	; 139
    38d2:	f1 e0       	ldi	r31, 0x01	; 1
    38d4:	40 91 9b 01 	lds	r20, 0x019B
    38d8:	50 91 9c 01 	lds	r21, 0x019C
    38dc:	60 91 9d 01 	lds	r22, 0x019D
    38e0:	70 91 9e 01 	lds	r23, 0x019E
    38e4:	80 81       	ld	r24, Z
    38e6:	91 81       	ldd	r25, Z+1	; 0x01
    38e8:	a2 81       	ldd	r26, Z+2	; 0x02
    38ea:	b3 81       	ldd	r27, Z+3	; 0x03
    38ec:	84 0f       	add	r24, r20
    38ee:	95 1f       	adc	r25, r21
    38f0:	a6 1f       	adc	r26, r22
    38f2:	b7 1f       	adc	r27, r23
    38f4:	80 83       	st	Z, r24
    38f6:	91 83       	std	Z+1, r25	; 0x01
    38f8:	a2 83       	std	Z+2, r26	; 0x02
    38fa:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif  
  if (st.counter_x > st.exec_block->step_event_count) {
    38fc:	e0 91 aa 01 	lds	r30, 0x01AA
    3900:	f0 91 ab 01 	lds	r31, 0x01AB
    3904:	45 85       	ldd	r20, Z+13	; 0x0d
    3906:	56 85       	ldd	r21, Z+14	; 0x0e
    3908:	67 85       	ldd	r22, Z+15	; 0x0f
    390a:	70 89       	ldd	r23, Z+16	; 0x10
    390c:	48 17       	cp	r20, r24
    390e:	59 07       	cpc	r21, r25
    3910:	6a 07       	cpc	r22, r26
    3912:	7b 07       	cpc	r23, r27
    3914:	88 f5       	brcc	.+98     	; 0x3978 <__vector_13+0x26a>
    st.step_outbits |= (1<<X_STEP_BIT);
    3916:	20 e4       	ldi	r18, 0x40	; 64
    3918:	20 93 99 01 	sts	0x0199, r18
    st.counter_x -= st.exec_block->step_event_count;
    391c:	45 85       	ldd	r20, Z+13	; 0x0d
    391e:	56 85       	ldd	r21, Z+14	; 0x0e
    3920:	67 85       	ldd	r22, Z+15	; 0x0f
    3922:	70 89       	ldd	r23, Z+16	; 0x10
    3924:	84 1b       	sub	r24, r20
    3926:	95 0b       	sbc	r25, r21
    3928:	a6 0b       	sbc	r26, r22
    392a:	b7 0b       	sbc	r27, r23
    392c:	80 93 8b 01 	sts	0x018B, r24
    3930:	90 93 8c 01 	sts	0x018C, r25
    3934:	a0 93 8d 01 	sts	0x018D, r26
    3938:	b0 93 8e 01 	sts	0x018E, r27
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys.position[X_AXIS]--; }
    393c:	80 81       	ld	r24, Z
    393e:	88 23       	and	r24, r24
    3940:	74 f4       	brge	.+28     	; 0x395e <__vector_13+0x250>
    3942:	cc e6       	ldi	r28, 0x6C	; 108
    3944:	d7 e0       	ldi	r29, 0x07	; 7
    3946:	88 81       	ld	r24, Y
    3948:	99 81       	ldd	r25, Y+1	; 0x01
    394a:	aa 81       	ldd	r26, Y+2	; 0x02
    394c:	bb 81       	ldd	r27, Y+3	; 0x03
    394e:	01 97       	sbiw	r24, 0x01	; 1
    3950:	a1 09       	sbc	r26, r1
    3952:	b1 09       	sbc	r27, r1
    3954:	88 83       	st	Y, r24
    3956:	99 83       	std	Y+1, r25	; 0x01
    3958:	aa 83       	std	Y+2, r26	; 0x02
    395a:	bb 83       	std	Y+3, r27	; 0x03
    395c:	0d c0       	rjmp	.+26     	; 0x3978 <__vector_13+0x26a>
    else { sys.position[X_AXIS]++; }
    395e:	cc e6       	ldi	r28, 0x6C	; 108
    3960:	d7 e0       	ldi	r29, 0x07	; 7
    3962:	88 81       	ld	r24, Y
    3964:	99 81       	ldd	r25, Y+1	; 0x01
    3966:	aa 81       	ldd	r26, Y+2	; 0x02
    3968:	bb 81       	ldd	r27, Y+3	; 0x03
    396a:	01 96       	adiw	r24, 0x01	; 1
    396c:	a1 1d       	adc	r26, r1
    396e:	b1 1d       	adc	r27, r1
    3970:	88 83       	st	Y, r24
    3972:	99 83       	std	Y+1, r25	; 0x01
    3974:	aa 83       	std	Y+2, r26	; 0x02
    3976:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    3978:	cf e8       	ldi	r28, 0x8F	; 143
    397a:	d1 e0       	ldi	r29, 0x01	; 1
    397c:	40 91 9f 01 	lds	r20, 0x019F
    3980:	50 91 a0 01 	lds	r21, 0x01A0
    3984:	60 91 a1 01 	lds	r22, 0x01A1
    3988:	70 91 a2 01 	lds	r23, 0x01A2
    398c:	88 81       	ld	r24, Y
    398e:	99 81       	ldd	r25, Y+1	; 0x01
    3990:	aa 81       	ldd	r26, Y+2	; 0x02
    3992:	bb 81       	ldd	r27, Y+3	; 0x03
    3994:	84 0f       	add	r24, r20
    3996:	95 1f       	adc	r25, r21
    3998:	a6 1f       	adc	r26, r22
    399a:	b7 1f       	adc	r27, r23
    399c:	88 83       	st	Y, r24
    399e:	99 83       	std	Y+1, r25	; 0x01
    39a0:	aa 83       	std	Y+2, r26	; 0x02
    39a2:	bb 83       	std	Y+3, r27	; 0x03
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif    
  if (st.counter_y > st.exec_block->step_event_count) {
    39a4:	45 85       	ldd	r20, Z+13	; 0x0d
    39a6:	56 85       	ldd	r21, Z+14	; 0x0e
    39a8:	67 85       	ldd	r22, Z+15	; 0x0f
    39aa:	70 89       	ldd	r23, Z+16	; 0x10
    39ac:	48 17       	cp	r20, r24
    39ae:	59 07       	cpc	r21, r25
    39b0:	6a 07       	cpc	r22, r26
    39b2:	7b 07       	cpc	r23, r27
    39b4:	98 f5       	brcc	.+102    	; 0x3a1c <__vector_13+0x30e>
    st.step_outbits |= (1<<Y_STEP_BIT);
    39b6:	c9 e9       	ldi	r28, 0x99	; 153
    39b8:	d1 e0       	ldi	r29, 0x01	; 1
    39ba:	28 81       	ld	r18, Y
    39bc:	20 61       	ori	r18, 0x10	; 16
    39be:	28 83       	st	Y, r18
    st.counter_y -= st.exec_block->step_event_count;
    39c0:	45 85       	ldd	r20, Z+13	; 0x0d
    39c2:	56 85       	ldd	r21, Z+14	; 0x0e
    39c4:	67 85       	ldd	r22, Z+15	; 0x0f
    39c6:	70 89       	ldd	r23, Z+16	; 0x10
    39c8:	84 1b       	sub	r24, r20
    39ca:	95 0b       	sbc	r25, r21
    39cc:	a6 0b       	sbc	r26, r22
    39ce:	b7 0b       	sbc	r27, r23
    39d0:	80 93 8f 01 	sts	0x018F, r24
    39d4:	90 93 90 01 	sts	0x0190, r25
    39d8:	a0 93 91 01 	sts	0x0191, r26
    39dc:	b0 93 92 01 	sts	0x0192, r27
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys.position[Y_AXIS]--; }
    39e0:	80 81       	ld	r24, Z
    39e2:	85 ff       	sbrs	r24, 5
    39e4:	0e c0       	rjmp	.+28     	; 0x3a02 <__vector_13+0x2f4>
    39e6:	c0 e7       	ldi	r28, 0x70	; 112
    39e8:	d7 e0       	ldi	r29, 0x07	; 7
    39ea:	88 81       	ld	r24, Y
    39ec:	99 81       	ldd	r25, Y+1	; 0x01
    39ee:	aa 81       	ldd	r26, Y+2	; 0x02
    39f0:	bb 81       	ldd	r27, Y+3	; 0x03
    39f2:	01 97       	sbiw	r24, 0x01	; 1
    39f4:	a1 09       	sbc	r26, r1
    39f6:	b1 09       	sbc	r27, r1
    39f8:	88 83       	st	Y, r24
    39fa:	99 83       	std	Y+1, r25	; 0x01
    39fc:	aa 83       	std	Y+2, r26	; 0x02
    39fe:	bb 83       	std	Y+3, r27	; 0x03
    3a00:	0d c0       	rjmp	.+26     	; 0x3a1c <__vector_13+0x30e>
    else { sys.position[Y_AXIS]++; }
    3a02:	c0 e7       	ldi	r28, 0x70	; 112
    3a04:	d7 e0       	ldi	r29, 0x07	; 7
    3a06:	88 81       	ld	r24, Y
    3a08:	99 81       	ldd	r25, Y+1	; 0x01
    3a0a:	aa 81       	ldd	r26, Y+2	; 0x02
    3a0c:	bb 81       	ldd	r27, Y+3	; 0x03
    3a0e:	01 96       	adiw	r24, 0x01	; 1
    3a10:	a1 1d       	adc	r26, r1
    3a12:	b1 1d       	adc	r27, r1
    3a14:	88 83       	st	Y, r24
    3a16:	99 83       	std	Y+1, r25	; 0x01
    3a18:	aa 83       	std	Y+2, r26	; 0x02
    3a1a:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    3a1c:	c3 e9       	ldi	r28, 0x93	; 147
    3a1e:	d1 e0       	ldi	r29, 0x01	; 1
    3a20:	40 91 a3 01 	lds	r20, 0x01A3
    3a24:	50 91 a4 01 	lds	r21, 0x01A4
    3a28:	60 91 a5 01 	lds	r22, 0x01A5
    3a2c:	70 91 a6 01 	lds	r23, 0x01A6
    3a30:	88 81       	ld	r24, Y
    3a32:	99 81       	ldd	r25, Y+1	; 0x01
    3a34:	aa 81       	ldd	r26, Y+2	; 0x02
    3a36:	bb 81       	ldd	r27, Y+3	; 0x03
    3a38:	84 0f       	add	r24, r20
    3a3a:	95 1f       	adc	r25, r21
    3a3c:	a6 1f       	adc	r26, r22
    3a3e:	b7 1f       	adc	r27, r23
    3a40:	88 83       	st	Y, r24
    3a42:	99 83       	std	Y+1, r25	; 0x01
    3a44:	aa 83       	std	Y+2, r26	; 0x02
    3a46:	bb 83       	std	Y+3, r27	; 0x03
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif  
  if (st.counter_z > st.exec_block->step_event_count) {
    3a48:	45 85       	ldd	r20, Z+13	; 0x0d
    3a4a:	56 85       	ldd	r21, Z+14	; 0x0e
    3a4c:	67 85       	ldd	r22, Z+15	; 0x0f
    3a4e:	70 89       	ldd	r23, Z+16	; 0x10
    3a50:	48 17       	cp	r20, r24
    3a52:	59 07       	cpc	r21, r25
    3a54:	6a 07       	cpc	r22, r26
    3a56:	7b 07       	cpc	r23, r27
    3a58:	98 f5       	brcc	.+102    	; 0x3ac0 <__vector_13+0x3b2>
    st.step_outbits |= (1<<Z_STEP_BIT);
    3a5a:	c9 e9       	ldi	r28, 0x99	; 153
    3a5c:	d1 e0       	ldi	r29, 0x01	; 1
    3a5e:	28 81       	ld	r18, Y
    3a60:	24 60       	ori	r18, 0x04	; 4
    3a62:	28 83       	st	Y, r18
    st.counter_z -= st.exec_block->step_event_count;
    3a64:	45 85       	ldd	r20, Z+13	; 0x0d
    3a66:	56 85       	ldd	r21, Z+14	; 0x0e
    3a68:	67 85       	ldd	r22, Z+15	; 0x0f
    3a6a:	70 89       	ldd	r23, Z+16	; 0x10
    3a6c:	84 1b       	sub	r24, r20
    3a6e:	95 0b       	sbc	r25, r21
    3a70:	a6 0b       	sbc	r26, r22
    3a72:	b7 0b       	sbc	r27, r23
    3a74:	80 93 93 01 	sts	0x0193, r24
    3a78:	90 93 94 01 	sts	0x0194, r25
    3a7c:	a0 93 95 01 	sts	0x0195, r26
    3a80:	b0 93 96 01 	sts	0x0196, r27
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys.position[Z_AXIS]--; }
    3a84:	80 81       	ld	r24, Z
    3a86:	83 ff       	sbrs	r24, 3
    3a88:	0e c0       	rjmp	.+28     	; 0x3aa6 <__vector_13+0x398>
    3a8a:	e4 e7       	ldi	r30, 0x74	; 116
    3a8c:	f7 e0       	ldi	r31, 0x07	; 7
    3a8e:	80 81       	ld	r24, Z
    3a90:	91 81       	ldd	r25, Z+1	; 0x01
    3a92:	a2 81       	ldd	r26, Z+2	; 0x02
    3a94:	b3 81       	ldd	r27, Z+3	; 0x03
    3a96:	01 97       	sbiw	r24, 0x01	; 1
    3a98:	a1 09       	sbc	r26, r1
    3a9a:	b1 09       	sbc	r27, r1
    3a9c:	80 83       	st	Z, r24
    3a9e:	91 83       	std	Z+1, r25	; 0x01
    3aa0:	a2 83       	std	Z+2, r26	; 0x02
    3aa2:	b3 83       	std	Z+3, r27	; 0x03
    3aa4:	0d c0       	rjmp	.+26     	; 0x3ac0 <__vector_13+0x3b2>
    else { sys.position[Z_AXIS]++; }
    3aa6:	e4 e7       	ldi	r30, 0x74	; 116
    3aa8:	f7 e0       	ldi	r31, 0x07	; 7
    3aaa:	80 81       	ld	r24, Z
    3aac:	91 81       	ldd	r25, Z+1	; 0x01
    3aae:	a2 81       	ldd	r26, Z+2	; 0x02
    3ab0:	b3 81       	ldd	r27, Z+3	; 0x03
    3ab2:	01 96       	adiw	r24, 0x01	; 1
    3ab4:	a1 1d       	adc	r26, r1
    3ab6:	b1 1d       	adc	r27, r1
    3ab8:	80 83       	st	Z, r24
    3aba:	91 83       	std	Z+1, r25	; 0x01
    3abc:	a2 83       	std	Z+2, r26	; 0x02
    3abe:	b3 83       	std	Z+3, r27	; 0x03
  }  

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }   
    3ac0:	80 91 68 07 	lds	r24, 0x0768
    3ac4:	84 30       	cpi	r24, 0x04	; 4
    3ac6:	39 f4       	brne	.+14     	; 0x3ad6 <__vector_13+0x3c8>
    3ac8:	e9 e9       	ldi	r30, 0x99	; 153
    3aca:	f1 e0       	ldi	r31, 0x01	; 1
    3acc:	90 91 78 07 	lds	r25, 0x0778
    3ad0:	80 81       	ld	r24, Z
    3ad2:	89 23       	and	r24, r25
    3ad4:	80 83       	st	Z, r24

  st.step_count--; // Decrement step events count 
    3ad6:	e7 ea       	ldi	r30, 0xA7	; 167
    3ad8:	f1 e0       	ldi	r31, 0x01	; 1
    3ada:	80 81       	ld	r24, Z
    3adc:	91 81       	ldd	r25, Z+1	; 0x01
    3ade:	01 97       	sbiw	r24, 0x01	; 1
    3ae0:	91 83       	std	Z+1, r25	; 0x01
    3ae2:	80 83       	st	Z, r24
  if (st.step_count == 0) {
    3ae4:	89 2b       	or	r24, r25
    3ae6:	69 f4       	brne	.+26     	; 0x3b02 <__vector_13+0x3f4>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    3ae8:	10 92 ad 01 	sts	0x01AD, r1
    3aec:	10 92 ac 01 	sts	0x01AC, r1
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    3af0:	80 91 8a 01 	lds	r24, 0x018A
    3af4:	8f 5f       	subi	r24, 0xFF	; 255
    3af6:	80 93 8a 01 	sts	0x018A, r24
    3afa:	86 30       	cpi	r24, 0x06	; 6
    3afc:	11 f4       	brne	.+4      	; 0x3b02 <__vector_13+0x3f4>
    3afe:	10 92 8a 01 	sts	0x018A, r1
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask    
    3b02:	e9 e9       	ldi	r30, 0x99	; 153
    3b04:	f1 e0       	ldi	r31, 0x01	; 1
    3b06:	90 91 87 01 	lds	r25, 0x0187
    3b0a:	80 81       	ld	r24, Z
    3b0c:	89 27       	eor	r24, r25
    3b0e:	80 83       	st	Z, r24
  busy = false;
    3b10:	10 92 85 01 	sts	0x0185, r1
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
}
    3b14:	ff 91       	pop	r31
    3b16:	ef 91       	pop	r30
    3b18:	df 91       	pop	r29
    3b1a:	cf 91       	pop	r28
    3b1c:	bf 91       	pop	r27
    3b1e:	af 91       	pop	r26
    3b20:	9f 91       	pop	r25
    3b22:	8f 91       	pop	r24
    3b24:	7f 91       	pop	r23
    3b26:	6f 91       	pop	r22
    3b28:	5f 91       	pop	r21
    3b2a:	4f 91       	pop	r20
    3b2c:	3f 91       	pop	r19
    3b2e:	2f 91       	pop	r18
    3b30:	0f 90       	pop	r0
    3b32:	0f be       	out	0x3f, r0	; 63
    3b34:	0f 90       	pop	r0
    3b36:	1f 90       	pop	r1
    3b38:	18 95       	reti

00003b3a <__vector_18>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) 
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    3b3a:	1f 92       	push	r1
    3b3c:	0f 92       	push	r0
    3b3e:	0f b6       	in	r0, 0x3f	; 63
    3b40:	0f 92       	push	r0
    3b42:	11 24       	eor	r1, r1
    3b44:	8f 93       	push	r24
    3b46:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK); 
    3b48:	8b b1       	in	r24, 0x0b	; 11
    3b4a:	90 91 87 01 	lds	r25, 0x0187
    3b4e:	94 75       	andi	r25, 0x54	; 84
    3b50:	8b 7a       	andi	r24, 0xAB	; 171
    3b52:	89 2b       	or	r24, r25
    3b54:	8b b9       	out	0x0b, r24	; 11
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed. 
    3b56:	15 bc       	out	0x25, r1	; 37
}
    3b58:	9f 91       	pop	r25
    3b5a:	8f 91       	pop	r24
    3b5c:	0f 90       	pop	r0
    3b5e:	0f be       	out	0x3f, r0	; 63
    3b60:	0f 90       	pop	r0
    3b62:	1f 90       	pop	r1
    3b64:	18 95       	reti

00003b66 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{  
    3b66:	cf 92       	push	r12
    3b68:	df 92       	push	r13
    3b6a:	ef 92       	push	r14
    3b6c:	ff 92       	push	r15
    3b6e:	0f 93       	push	r16
    3b70:	1f 93       	push	r17
    3b72:	cf 93       	push	r28
    3b74:	df 93       	push	r29
  uint8_t idx;
  step_port_invert_mask = 0;
    3b76:	10 92 87 01 	sts	0x0187, r1
  dir_port_invert_mask = 0;
    3b7a:	10 92 86 01 	sts	0x0186, r1
    3b7e:	c0 e0       	ldi	r28, 0x00	; 0
    3b80:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    3b82:	0f 2e       	mov	r0, r31
    3b84:	f0 e3       	ldi	r31, 0x30	; 48
    3b86:	ef 2e       	mov	r14, r31
    3b88:	f9 e0       	ldi	r31, 0x09	; 9
    3b8a:	ff 2e       	mov	r15, r31
    3b8c:	f0 2d       	mov	r31, r0
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3b8e:	01 e3       	ldi	r16, 0x31	; 49
    3b90:	19 e0       	ldi	r17, 0x09	; 9
    3b92:	cc 2e       	mov	r12, r28
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    3b94:	dc 2e       	mov	r13, r28
    3b96:	f7 01       	movw	r30, r14
    3b98:	40 81       	ld	r20, Z
    3b9a:	50 e0       	ldi	r21, 0x00	; 0
    3b9c:	0c 2e       	mov	r0, r28
    3b9e:	02 c0       	rjmp	.+4      	; 0x3ba4 <st_generate_step_dir_invert_masks+0x3e>
    3ba0:	55 95       	asr	r21
    3ba2:	47 95       	ror	r20
    3ba4:	0a 94       	dec	r0
    3ba6:	e2 f7       	brpl	.-8      	; 0x3ba0 <st_generate_step_dir_invert_masks+0x3a>
    3ba8:	40 ff       	sbrs	r20, 0
    3baa:	08 c0       	rjmp	.+16     	; 0x3bbc <st_generate_step_dir_invert_masks+0x56>
    3bac:	8c 2f       	mov	r24, r28
    3bae:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <get_step_pin_mask>
    3bb2:	90 91 87 01 	lds	r25, 0x0187
    3bb6:	89 2b       	or	r24, r25
    3bb8:	80 93 87 01 	sts	0x0187, r24
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3bbc:	f8 01       	movw	r30, r16
    3bbe:	20 81       	ld	r18, Z
    3bc0:	30 e0       	ldi	r19, 0x00	; 0
    3bc2:	02 c0       	rjmp	.+4      	; 0x3bc8 <st_generate_step_dir_invert_masks+0x62>
    3bc4:	35 95       	asr	r19
    3bc6:	27 95       	ror	r18
    3bc8:	da 94       	dec	r13
    3bca:	e2 f7       	brpl	.-8      	; 0x3bc4 <st_generate_step_dir_invert_masks+0x5e>
    3bcc:	20 ff       	sbrs	r18, 0
    3bce:	08 c0       	rjmp	.+16     	; 0x3be0 <st_generate_step_dir_invert_masks+0x7a>
    3bd0:	8c 2d       	mov	r24, r12
    3bd2:	0e 94 fe 28 	call	0x51fc	; 0x51fc <get_direction_pin_mask>
    3bd6:	90 91 86 01 	lds	r25, 0x0186
    3bda:	89 2b       	or	r24, r25
    3bdc:	80 93 86 01 	sts	0x0186, r24
    3be0:	21 96       	adiw	r28, 0x01	; 1
void st_generate_step_dir_invert_masks()
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    3be2:	c3 30       	cpi	r28, 0x03	; 3
    3be4:	d1 05       	cpc	r29, r1
    3be6:	a9 f6       	brne	.-86     	; 0x3b92 <st_generate_step_dir_invert_masks+0x2c>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
  }
}
    3be8:	df 91       	pop	r29
    3bea:	cf 91       	pop	r28
    3bec:	1f 91       	pop	r17
    3bee:	0f 91       	pop	r16
    3bf0:	ff 90       	pop	r15
    3bf2:	ef 90       	pop	r14
    3bf4:	df 90       	pop	r13
    3bf6:	cf 90       	pop	r12
    3bf8:	08 95       	ret

00003bfa <st_reset>:

// Reset and clear stepper subsystem variables
void st_reset()
{
  // Initialize stepper driver idle state.
  st_go_idle();
    3bfa:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <st_go_idle>
  
  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(prep));
    3bfe:	8b e2       	ldi	r24, 0x2B	; 43
    3c00:	e6 e5       	ldi	r30, 0x56	; 86
    3c02:	f1 e0       	ldi	r31, 0x01	; 1
    3c04:	df 01       	movw	r26, r30
    3c06:	1d 92       	st	X+, r1
    3c08:	8a 95       	dec	r24
    3c0a:	e9 f7       	brne	.-6      	; 0x3c06 <st_reset+0xc>
  memset(&st, 0, sizeof(st));
    3c0c:	83 e2       	ldi	r24, 0x23	; 35
    3c0e:	eb e8       	ldi	r30, 0x8B	; 139
    3c10:	f1 e0       	ldi	r31, 0x01	; 1
    3c12:	df 01       	movw	r26, r30
    3c14:	1d 92       	st	X+, r1
    3c16:	8a 95       	dec	r24
    3c18:	e9 f7       	brne	.-6      	; 0x3c14 <st_reset+0x1a>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    3c1a:	10 92 84 01 	sts	0x0184, r1
    3c1e:	10 92 83 01 	sts	0x0183, r1
  segment_buffer_tail = 0;
    3c22:	10 92 8a 01 	sts	0x018A, r1
  segment_buffer_head = 0; // empty = tail
    3c26:	10 92 89 01 	sts	0x0189, r1
  segment_next_head = 1;
    3c2a:	81 e0       	ldi	r24, 0x01	; 1
    3c2c:	80 93 88 01 	sts	0x0188, r24
  busy = false;
    3c30:	10 92 85 01 	sts	0x0185, r1
  
  st_generate_step_dir_invert_masks();
    3c34:	0e 94 b3 1d 	call	0x3b66	; 0x3b66 <st_generate_step_dir_invert_masks>
      
  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    3c38:	8b b1       	in	r24, 0x0b	; 11
    3c3a:	8b 7a       	andi	r24, 0xAB	; 171
    3c3c:	90 91 87 01 	lds	r25, 0x0187
    3c40:	89 2b       	or	r24, r25
    3c42:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    3c44:	8b b1       	in	r24, 0x0b	; 11
    3c46:	87 75       	andi	r24, 0x57	; 87
    3c48:	90 91 86 01 	lds	r25, 0x0186
    3c4c:	89 2b       	or	r24, r25
    3c4e:	8b b9       	out	0x0b, r24	; 11
    3c50:	08 95       	ret

00003c52 <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    3c52:	8a b1       	in	r24, 0x0a	; 10
    3c54:	84 65       	ori	r24, 0x54	; 84
    3c56:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    3c58:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    3c5a:	8a b1       	in	r24, 0x0a	; 10
    3c5c:	88 6a       	ori	r24, 0xA8	; 168
    3c5e:	8a b9       	out	0x0a, r24	; 10

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    3c60:	e1 e8       	ldi	r30, 0x81	; 129
    3c62:	f0 e0       	ldi	r31, 0x00	; 0
    3c64:	80 81       	ld	r24, Z
    3c66:	8f 7e       	andi	r24, 0xEF	; 239
    3c68:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    3c6a:	80 81       	ld	r24, Z
    3c6c:	88 60       	ori	r24, 0x08	; 8
    3c6e:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10)); 
    3c70:	e0 e8       	ldi	r30, 0x80	; 128
    3c72:	f0 e0       	ldi	r31, 0x00	; 0
    3c74:	80 81       	ld	r24, Z
    3c76:	8c 7f       	andi	r24, 0xFC	; 252
    3c78:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    3c7a:	80 81       	ld	r24, Z
    3c7c:	8f 70       	andi	r24, 0x0F	; 15
    3c7e:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().
  
  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    3c80:	ee e6       	ldi	r30, 0x6E	; 110
    3c82:	f0 e0       	ldi	r31, 0x00	; 0
    3c84:	80 81       	ld	r24, Z
    3c86:	88 7f       	andi	r24, 0xF8	; 248
    3c88:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    3c8a:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    3c8c:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    3c8e:	80 81       	ld	r24, Z
    3c90:	81 60       	ori	r24, 0x01	; 1
    3c92:	80 83       	st	Z, r24
    3c94:	08 95       	ret

00003c96 <st_update_plan_block_parameters>:
}
  

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{ 
    3c96:	cf 93       	push	r28
    3c98:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    3c9a:	c0 91 83 01 	lds	r28, 0x0183
    3c9e:	d0 91 84 01 	lds	r29, 0x0184
    3ca2:	20 97       	sbiw	r28, 0x00	; 0
    3ca4:	b9 f0       	breq	.+46     	; 0x3cd4 <st_update_plan_block_parameters+0x3e>
    prep.flag_partial_block = true;
    3ca6:	81 e0       	ldi	r24, 0x01	; 1
    3ca8:	80 93 57 01 	sts	0x0157, r24
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    3cac:	60 91 6d 01 	lds	r22, 0x016D
    3cb0:	70 91 6e 01 	lds	r23, 0x016E
    3cb4:	80 91 6f 01 	lds	r24, 0x016F
    3cb8:	90 91 70 01 	lds	r25, 0x0170
    3cbc:	9b 01       	movw	r18, r22
    3cbe:	ac 01       	movw	r20, r24
    3cc0:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    3cc4:	69 8b       	std	Y+17, r22	; 0x11
    3cc6:	7a 8b       	std	Y+18, r23	; 0x12
    3cc8:	8b 8b       	std	Y+19, r24	; 0x13
    3cca:	9c 8b       	std	Y+20, r25	; 0x14
    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.
    3ccc:	10 92 84 01 	sts	0x0184, r1
    3cd0:	10 92 83 01 	sts	0x0183, r1
  }
}
    3cd4:	df 91       	pop	r29
    3cd6:	cf 91       	pop	r28
    3cd8:	08 95       	ret

00003cda <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it. 
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    3cda:	2f 92       	push	r2
    3cdc:	3f 92       	push	r3
    3cde:	4f 92       	push	r4
    3ce0:	5f 92       	push	r5
    3ce2:	6f 92       	push	r6
    3ce4:	7f 92       	push	r7
    3ce6:	8f 92       	push	r8
    3ce8:	9f 92       	push	r9
    3cea:	af 92       	push	r10
    3cec:	bf 92       	push	r11
    3cee:	cf 92       	push	r12
    3cf0:	df 92       	push	r13
    3cf2:	ef 92       	push	r14
    3cf4:	ff 92       	push	r15
    3cf6:	0f 93       	push	r16
    3cf8:	1f 93       	push	r17
    3cfa:	cf 93       	push	r28
    3cfc:	df 93       	push	r29
    3cfe:	cd b7       	in	r28, 0x3d	; 61
    3d00:	de b7       	in	r29, 0x3e	; 62
    3d02:	e6 97       	sbiw	r28, 0x36	; 54
    3d04:	0f b6       	in	r0, 0x3f	; 63
    3d06:	f8 94       	cli
    3d08:	de bf       	out	0x3e, r29	; 62
    3d0a:	0f be       	out	0x3f, r0	; 63
    3d0c:	cd bf       	out	0x3d, r28	; 61

  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    3d0e:	80 91 68 07 	lds	r24, 0x0768
    3d12:	80 77       	andi	r24, 0x70	; 112
    3d14:	09 f4       	brne	.+2      	; 0x3d18 <st_prep_buffer+0x3e>
    3d16:	6e c6       	rjmp	.+3292   	; 0x49f4 <st_prep_buffer+0xd1a>
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
    3d18:	20 e0       	ldi	r18, 0x00	; 0
    3d1a:	30 e0       	ldi	r19, 0x00	; 0
    3d1c:	a9 01       	movw	r20, r18
    3d1e:	60 91 6d 01 	lds	r22, 0x016D
    3d22:	70 91 6e 01 	lds	r23, 0x016E
    3d26:	80 91 6f 01 	lds	r24, 0x016F
    3d2a:	90 91 70 01 	lds	r25, 0x0170
    3d2e:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    3d32:	81 11       	cpse	r24, r1
    3d34:	5f c6       	rjmp	.+3262   	; 0x49f4 <st_prep_buffer+0xd1a>
    3d36:	64 c6       	rjmp	.+3272   	; 0x4a00 <st_prep_buffer+0xd26>
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block has been replanned. 
    if (pl_block == NULL) {
    3d38:	80 91 83 01 	lds	r24, 0x0183
    3d3c:	90 91 84 01 	lds	r25, 0x0184
    3d40:	89 2b       	or	r24, r25
    3d42:	09 f0       	breq	.+2      	; 0x3d46 <st_prep_buffer+0x6c>
    3d44:	6c c2       	rjmp	.+1240   	; 0x421e <st_prep_buffer+0x544>
      pl_block = plan_get_current_block(); // Query planner for a queued block
    3d46:	0e 94 67 2a 	call	0x54ce	; 0x54ce <plan_get_current_block>
    3d4a:	8c 01       	movw	r16, r24
    3d4c:	90 93 84 01 	sts	0x0184, r25
    3d50:	80 93 83 01 	sts	0x0183, r24
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    3d54:	00 97       	sbiw	r24, 0x00	; 0
    3d56:	09 f4       	brne	.+2      	; 0x3d5a <st_prep_buffer+0x80>
    3d58:	53 c6       	rjmp	.+3238   	; 0x4a00 <st_prep_buffer+0xd26>
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    3d5a:	a7 e5       	ldi	r26, 0x57	; 87
    3d5c:	b1 e0       	ldi	r27, 0x01	; 1
    3d5e:	8c 91       	ld	r24, X
    3d60:	88 23       	and	r24, r24
    3d62:	11 f0       	breq	.+4      	; 0x3d68 <st_prep_buffer+0x8e>
        prep.flag_partial_block = false; // Reset flag
    3d64:	1c 92       	st	X, r1
    3d66:	dc c0       	rjmp	.+440    	; 0x3f20 <st_prep_buffer+0x246>
      } else {
        // Increment stepper common data index to store new planner block data. 
        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
    3d68:	e6 e5       	ldi	r30, 0x56	; 86
    3d6a:	f1 e0       	ldi	r31, 0x01	; 1
    3d6c:	80 81       	ld	r24, Z
    3d6e:	8f 5f       	subi	r24, 0xFF	; 255
    3d70:	85 30       	cpi	r24, 0x05	; 5
    3d72:	11 f0       	breq	.+4      	; 0x3d78 <st_prep_buffer+0x9e>
    3d74:	80 83       	st	Z, r24
    3d76:	03 c0       	rjmp	.+6      	; 0x3d7e <st_prep_buffer+0xa4>
    3d78:	a6 e5       	ldi	r26, 0x56	; 86
    3d7a:	b1 e0       	ldi	r27, 0x01	; 1
    3d7c:	1c 92       	st	X, r1
        
        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the 
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. 
        st_prep_block = &st_block_buffer[prep.st_block_index];
    3d7e:	a6 e5       	ldi	r26, 0x56	; 86
    3d80:	b1 e0       	ldi	r27, 0x01	; 1
    3d82:	ec 91       	ld	r30, X
    3d84:	b1 e1       	ldi	r27, 0x11	; 17
    3d86:	eb 9f       	mul	r30, r27
    3d88:	f0 01       	movw	r30, r0
    3d8a:	11 24       	eor	r1, r1
    3d8c:	ee 52       	subi	r30, 0x2E	; 46
    3d8e:	fe 4f       	sbci	r31, 0xFE	; 254
    3d90:	f0 93 82 01 	sts	0x0182, r31
    3d94:	e0 93 81 01 	sts	0x0181, r30
        st_prep_block->direction_bits = pl_block->direction_bits;
    3d98:	d8 01       	movw	r26, r16
    3d9a:	8c 91       	ld	r24, X
    3d9c:	80 83       	st	Z, r24
          st_prep_block->step_event_count = pl_block->step_event_count;
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS 
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS] << MAX_AMASS_LEVEL;
    3d9e:	11 96       	adiw	r26, 0x01	; 1
    3da0:	4d 91       	ld	r20, X+
    3da2:	5d 91       	ld	r21, X+
    3da4:	6d 91       	ld	r22, X+
    3da6:	7c 91       	ld	r23, X
    3da8:	14 97       	sbiw	r26, 0x04	; 4
    3daa:	db 01       	movw	r26, r22
    3dac:	ca 01       	movw	r24, r20
    3dae:	88 0f       	add	r24, r24
    3db0:	99 1f       	adc	r25, r25
    3db2:	aa 1f       	adc	r26, r26
    3db4:	bb 1f       	adc	r27, r27
    3db6:	88 0f       	add	r24, r24
    3db8:	99 1f       	adc	r25, r25
    3dba:	aa 1f       	adc	r26, r26
    3dbc:	bb 1f       	adc	r27, r27
    3dbe:	88 0f       	add	r24, r24
    3dc0:	99 1f       	adc	r25, r25
    3dc2:	aa 1f       	adc	r26, r26
    3dc4:	bb 1f       	adc	r27, r27
    3dc6:	81 83       	std	Z+1, r24	; 0x01
    3dc8:	92 83       	std	Z+2, r25	; 0x02
    3dca:	a3 83       	std	Z+3, r26	; 0x03
    3dcc:	b4 83       	std	Z+4, r27	; 0x04
          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS] << MAX_AMASS_LEVEL;
    3dce:	d8 01       	movw	r26, r16
    3dd0:	15 96       	adiw	r26, 0x05	; 5
    3dd2:	4d 91       	ld	r20, X+
    3dd4:	5d 91       	ld	r21, X+
    3dd6:	6d 91       	ld	r22, X+
    3dd8:	7c 91       	ld	r23, X
    3dda:	18 97       	sbiw	r26, 0x08	; 8
    3ddc:	db 01       	movw	r26, r22
    3dde:	ca 01       	movw	r24, r20
    3de0:	88 0f       	add	r24, r24
    3de2:	99 1f       	adc	r25, r25
    3de4:	aa 1f       	adc	r26, r26
    3de6:	bb 1f       	adc	r27, r27
    3de8:	88 0f       	add	r24, r24
    3dea:	99 1f       	adc	r25, r25
    3dec:	aa 1f       	adc	r26, r26
    3dee:	bb 1f       	adc	r27, r27
    3df0:	88 0f       	add	r24, r24
    3df2:	99 1f       	adc	r25, r25
    3df4:	aa 1f       	adc	r26, r26
    3df6:	bb 1f       	adc	r27, r27
    3df8:	85 83       	std	Z+5, r24	; 0x05
    3dfa:	96 83       	std	Z+6, r25	; 0x06
    3dfc:	a7 83       	std	Z+7, r26	; 0x07
    3dfe:	b0 87       	std	Z+8, r27	; 0x08
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;
    3e00:	d8 01       	movw	r26, r16
    3e02:	19 96       	adiw	r26, 0x09	; 9
    3e04:	4d 91       	ld	r20, X+
    3e06:	5d 91       	ld	r21, X+
    3e08:	6d 91       	ld	r22, X+
    3e0a:	7c 91       	ld	r23, X
    3e0c:	1c 97       	sbiw	r26, 0x0c	; 12
    3e0e:	db 01       	movw	r26, r22
    3e10:	ca 01       	movw	r24, r20
    3e12:	88 0f       	add	r24, r24
    3e14:	99 1f       	adc	r25, r25
    3e16:	aa 1f       	adc	r26, r26
    3e18:	bb 1f       	adc	r27, r27
    3e1a:	88 0f       	add	r24, r24
    3e1c:	99 1f       	adc	r25, r25
    3e1e:	aa 1f       	adc	r26, r26
    3e20:	bb 1f       	adc	r27, r27
    3e22:	88 0f       	add	r24, r24
    3e24:	99 1f       	adc	r25, r25
    3e26:	aa 1f       	adc	r26, r26
    3e28:	bb 1f       	adc	r27, r27
    3e2a:	81 87       	std	Z+9, r24	; 0x09
    3e2c:	92 87       	std	Z+10, r25	; 0x0a
    3e2e:	a3 87       	std	Z+11, r26	; 0x0b
    3e30:	b4 87       	std	Z+12, r27	; 0x0c
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    3e32:	d8 01       	movw	r26, r16
    3e34:	1d 96       	adiw	r26, 0x0d	; 13
    3e36:	4d 91       	ld	r20, X+
    3e38:	5d 91       	ld	r21, X+
    3e3a:	6d 91       	ld	r22, X+
    3e3c:	7c 91       	ld	r23, X
    3e3e:	50 97       	sbiw	r26, 0x10	; 16
    3e40:	44 0f       	add	r20, r20
    3e42:	55 1f       	adc	r21, r21
    3e44:	66 1f       	adc	r22, r22
    3e46:	77 1f       	adc	r23, r23
    3e48:	44 0f       	add	r20, r20
    3e4a:	55 1f       	adc	r21, r21
    3e4c:	66 1f       	adc	r22, r22
    3e4e:	77 1f       	adc	r23, r23
    3e50:	44 0f       	add	r20, r20
    3e52:	55 1f       	adc	r21, r21
    3e54:	66 1f       	adc	r22, r22
    3e56:	77 1f       	adc	r23, r23
    3e58:	45 87       	std	Z+13, r20	; 0x0d
    3e5a:	56 87       	std	Z+14, r21	; 0x0e
    3e5c:	67 87       	std	Z+15, r22	; 0x0f
    3e5e:	70 8b       	std	Z+16, r23	; 0x10
        #endif
        
        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = pl_block->step_event_count;
    3e60:	1d 96       	adiw	r26, 0x0d	; 13
    3e62:	6d 91       	ld	r22, X+
    3e64:	7d 91       	ld	r23, X+
    3e66:	8d 91       	ld	r24, X+
    3e68:	9c 91       	ld	r25, X
    3e6a:	50 97       	sbiw	r26, 0x10	; 16
    3e6c:	0e 94 3a 3d 	call	0x7a74	; 0x7a74 <__floatunsisf>
    3e70:	e8 e5       	ldi	r30, 0x58	; 88
    3e72:	f1 e0       	ldi	r31, 0x01	; 1
    3e74:	60 83       	st	Z, r22
    3e76:	71 83       	std	Z+1, r23	; 0x01
    3e78:	82 83       	std	Z+2, r24	; 0x02
    3e7a:	93 83       	std	Z+3, r25	; 0x03
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    3e7c:	d8 01       	movw	r26, r16
    3e7e:	95 96       	adiw	r26, 0x25	; 37
    3e80:	2d 91       	ld	r18, X+
    3e82:	3d 91       	ld	r19, X+
    3e84:	4d 91       	ld	r20, X+
    3e86:	5c 91       	ld	r21, X
    3e88:	98 97       	sbiw	r26, 0x28	; 40
    3e8a:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    3e8e:	9b 01       	movw	r18, r22
    3e90:	ac 01       	movw	r20, r24
    3e92:	ec e5       	ldi	r30, 0x5C	; 92
    3e94:	f1 e0       	ldi	r31, 0x01	; 1
    3e96:	60 83       	st	Z, r22
    3e98:	71 83       	std	Z+1, r23	; 0x01
    3e9a:	82 83       	std	Z+2, r24	; 0x02
    3e9c:	93 83       	std	Z+3, r25	; 0x03
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    3e9e:	60 e0       	ldi	r22, 0x00	; 0
    3ea0:	70 e0       	ldi	r23, 0x00	; 0
    3ea2:	80 ea       	ldi	r24, 0xA0	; 160
    3ea4:	9f e3       	ldi	r25, 0x3F	; 63
    3ea6:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    3eaa:	60 93 60 01 	sts	0x0160, r22
    3eae:	70 93 61 01 	sts	0x0161, r23
    3eb2:	80 93 62 01 	sts	0x0162, r24
    3eb6:	90 93 63 01 	sts	0x0163, r25
        
        prep.dt_remainder = 0.0; // Reset for new planner block
    3eba:	10 92 64 01 	sts	0x0164, r1
    3ebe:	10 92 65 01 	sts	0x0165, r1
    3ec2:	10 92 66 01 	sts	0x0166, r1
    3ec6:	10 92 67 01 	sts	0x0167, r1

        if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    3eca:	a8 e6       	ldi	r26, 0x68	; 104
    3ecc:	b7 e0       	ldi	r27, 0x07	; 7
    3ece:	8c 91       	ld	r24, X
    3ed0:	80 77       	andi	r24, 0x70	; 112
    3ed2:	b9 f0       	breq	.+46     	; 0x3f02 <st_prep_buffer+0x228>
          // Override planner block entry speed and enforce deceleration during feed hold.
          prep.current_speed = prep.exit_speed; 
    3ed4:	e5 e7       	ldi	r30, 0x75	; 117
    3ed6:	f1 e0       	ldi	r31, 0x01	; 1
    3ed8:	60 81       	ld	r22, Z
    3eda:	71 81       	ldd	r23, Z+1	; 0x01
    3edc:	82 81       	ldd	r24, Z+2	; 0x02
    3ede:	93 81       	ldd	r25, Z+3	; 0x03
    3ee0:	ad e6       	ldi	r26, 0x6D	; 109
    3ee2:	b1 e0       	ldi	r27, 0x01	; 1
    3ee4:	6d 93       	st	X+, r22
    3ee6:	7d 93       	st	X+, r23
    3ee8:	8d 93       	st	X+, r24
    3eea:	9c 93       	st	X, r25
    3eec:	13 97       	sbiw	r26, 0x03	; 3
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; 
    3eee:	9b 01       	movw	r18, r22
    3ef0:	ac 01       	movw	r20, r24
    3ef2:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    3ef6:	f8 01       	movw	r30, r16
    3ef8:	61 8b       	std	Z+17, r22	; 0x11
    3efa:	72 8b       	std	Z+18, r23	; 0x12
    3efc:	83 8b       	std	Z+19, r24	; 0x13
    3efe:	94 8b       	std	Z+20, r25	; 0x14
    3f00:	0f c0       	rjmp	.+30     	; 0x3f20 <st_prep_buffer+0x246>
        }
        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }
    3f02:	d8 01       	movw	r26, r16
    3f04:	51 96       	adiw	r26, 0x11	; 17
    3f06:	6d 91       	ld	r22, X+
    3f08:	7d 91       	ld	r23, X+
    3f0a:	8d 91       	ld	r24, X+
    3f0c:	9c 91       	ld	r25, X
    3f0e:	54 97       	sbiw	r26, 0x14	; 20
    3f10:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    3f14:	ed e6       	ldi	r30, 0x6D	; 109
    3f16:	f1 e0       	ldi	r31, 0x01	; 1
    3f18:	60 83       	st	Z, r22
    3f1a:	71 83       	std	Z+1, r23	; 0x01
    3f1c:	82 83       	std	Z+2, r24	; 0x02
    3f1e:	93 83       	std	Z+3, r25	; 0x03
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
      */
      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    3f20:	a9 e6       	ldi	r26, 0x69	; 105
    3f22:	b1 e0       	ldi	r27, 0x01	; 1
    3f24:	1d 92       	st	X+, r1
    3f26:	1d 92       	st	X+, r1
    3f28:	1d 92       	st	X+, r1
    3f2a:	1c 92       	st	X, r1
    3f2c:	13 97       	sbiw	r26, 0x03	; 3
      float inv_2_accel = 0.5/pl_block->acceleration;
    3f2e:	00 91 83 01 	lds	r16, 0x0183
    3f32:	10 91 84 01 	lds	r17, 0x0184
    3f36:	f8 01       	movw	r30, r16
    3f38:	81 a0       	ldd	r8, Z+33	; 0x21
    3f3a:	92 a0       	ldd	r9, Z+34	; 0x22
    3f3c:	a3 a0       	ldd	r10, Z+35	; 0x23
    3f3e:	b4 a0       	ldd	r11, Z+36	; 0x24
    3f40:	a5 01       	movw	r20, r10
    3f42:	94 01       	movw	r18, r8
    3f44:	60 e0       	ldi	r22, 0x00	; 0
    3f46:	70 e0       	ldi	r23, 0x00	; 0
    3f48:	80 e0       	ldi	r24, 0x00	; 0
    3f4a:	9f e3       	ldi	r25, 0x3F	; 63
    3f4c:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    3f50:	6b 01       	movw	r12, r22
    3f52:	7c 01       	movw	r14, r24
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { // [Forced Deceleration to Zero Velocity]
    3f54:	a8 e6       	ldi	r26, 0x68	; 104
    3f56:	b7 e0       	ldi	r27, 0x07	; 7
    3f58:	8c 91       	ld	r24, X
    3f5a:	80 77       	andi	r24, 0x70	; 112
    3f5c:	09 f4       	brne	.+2      	; 0x3f60 <st_prep_buffer+0x286>
    3f5e:	57 c0       	rjmp	.+174    	; 0x400e <st_prep_buffer+0x334>
        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
        // the planner block profile, enforcing a deceleration to zero speed.
        prep.ramp_type = RAMP_DECEL;
    3f60:	82 e0       	ldi	r24, 0x02	; 2
    3f62:	e8 e6       	ldi	r30, 0x68	; 104
    3f64:	f1 e0       	ldi	r31, 0x01	; 1
    3f66:	80 83       	st	Z, r24
        // Compute decelerate distance relative to end of block.
        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    3f68:	d8 01       	movw	r26, r16
    3f6a:	95 96       	adiw	r26, 0x25	; 37
    3f6c:	4d 90       	ld	r4, X+
    3f6e:	5d 90       	ld	r5, X+
    3f70:	6d 90       	ld	r6, X+
    3f72:	7c 90       	ld	r7, X
    3f74:	98 97       	sbiw	r26, 0x28	; 40
    3f76:	51 96       	adiw	r26, 0x11	; 17
    3f78:	2d 91       	ld	r18, X+
    3f7a:	3d 91       	ld	r19, X+
    3f7c:	4d 91       	ld	r20, X+
    3f7e:	5c 91       	ld	r21, X
    3f80:	54 97       	sbiw	r26, 0x14	; 20
    3f82:	29 83       	std	Y+1, r18	; 0x01
    3f84:	3a 83       	std	Y+2, r19	; 0x02
    3f86:	4b 83       	std	Y+3, r20	; 0x03
    3f88:	5c 83       	std	Y+4, r21	; 0x04
    3f8a:	a7 01       	movw	r20, r14
    3f8c:	96 01       	movw	r18, r12
    3f8e:	69 81       	ldd	r22, Y+1	; 0x01
    3f90:	7a 81       	ldd	r23, Y+2	; 0x02
    3f92:	8b 81       	ldd	r24, Y+3	; 0x03
    3f94:	9c 81       	ldd	r25, Y+4	; 0x04
    3f96:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    3f9a:	9b 01       	movw	r18, r22
    3f9c:	ac 01       	movw	r20, r24
    3f9e:	c3 01       	movw	r24, r6
    3fa0:	b2 01       	movw	r22, r4
    3fa2:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    3fa6:	6b 01       	movw	r12, r22
    3fa8:	7c 01       	movw	r14, r24
        if (decel_dist < 0.0) {
    3faa:	20 e0       	ldi	r18, 0x00	; 0
    3fac:	30 e0       	ldi	r19, 0x00	; 0
    3fae:	a9 01       	movw	r20, r18
    3fb0:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    3fb4:	88 23       	and	r24, r24
    3fb6:	ec f4       	brge	.+58     	; 0x3ff2 <st_prep_buffer+0x318>
          // Deceleration through entire planner block. End of feed hold is not in this block.
          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3fb8:	a5 01       	movw	r20, r10
    3fba:	94 01       	movw	r18, r8
    3fbc:	c5 01       	movw	r24, r10
    3fbe:	b4 01       	movw	r22, r8
    3fc0:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    3fc4:	9b 01       	movw	r18, r22
    3fc6:	ac 01       	movw	r20, r24
    3fc8:	c3 01       	movw	r24, r6
    3fca:	b2 01       	movw	r22, r4
    3fcc:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    3fd0:	9b 01       	movw	r18, r22
    3fd2:	ac 01       	movw	r20, r24
    3fd4:	69 81       	ldd	r22, Y+1	; 0x01
    3fd6:	7a 81       	ldd	r23, Y+2	; 0x02
    3fd8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fda:	9c 81       	ldd	r25, Y+4	; 0x04
    3fdc:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    3fe0:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    3fe4:	e5 e7       	ldi	r30, 0x75	; 117
    3fe6:	f1 e0       	ldi	r31, 0x01	; 1
    3fe8:	60 83       	st	Z, r22
    3fea:	71 83       	std	Z+1, r23	; 0x01
    3fec:	82 83       	std	Z+2, r24	; 0x02
    3fee:	93 83       	std	Z+3, r25	; 0x03
    3ff0:	16 c1       	rjmp	.+556    	; 0x421e <st_prep_buffer+0x544>
        } else {
          prep.mm_complete = decel_dist; // End of feed hold.
    3ff2:	a9 e6       	ldi	r26, 0x69	; 105
    3ff4:	b1 e0       	ldi	r27, 0x01	; 1
    3ff6:	cd 92       	st	X+, r12
    3ff8:	dd 92       	st	X+, r13
    3ffa:	ed 92       	st	X+, r14
    3ffc:	fc 92       	st	X, r15
    3ffe:	13 97       	sbiw	r26, 0x03	; 3
          prep.exit_speed = 0.0;
    4000:	e5 e7       	ldi	r30, 0x75	; 117
    4002:	f1 e0       	ldi	r31, 0x01	; 1
    4004:	10 82       	st	Z, r1
    4006:	11 82       	std	Z+1, r1	; 0x01
    4008:	12 82       	std	Z+2, r1	; 0x02
    400a:	13 82       	std	Z+3, r1	; 0x03
    400c:	08 c1       	rjmp	.+528    	; 0x421e <st_prep_buffer+0x544>
        }
      } else { // [Normal Operation]
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    400e:	a8 e6       	ldi	r26, 0x68	; 104
    4010:	b1 e0       	ldi	r27, 0x01	; 1
    4012:	1c 92       	st	X, r1
        prep.accelerate_until = pl_block->millimeters; 
    4014:	f8 01       	movw	r30, r16
    4016:	85 a1       	ldd	r24, Z+37	; 0x25
    4018:	96 a1       	ldd	r25, Z+38	; 0x26
    401a:	a7 a1       	ldd	r26, Z+39	; 0x27
    401c:	b0 a5       	ldd	r27, Z+40	; 0x28
    401e:	e9 e7       	ldi	r30, 0x79	; 121
    4020:	f1 e0       	ldi	r31, 0x01	; 1
    4022:	80 83       	st	Z, r24
    4024:	91 83       	std	Z+1, r25	; 0x01
    4026:	a2 83       	std	Z+2, r26	; 0x02
    4028:	b3 83       	std	Z+3, r27	; 0x03
        prep.exit_speed = plan_get_exec_block_exit_speed();   
    402a:	0e 94 77 2a 	call	0x54ee	; 0x54ee <plan_get_exec_block_exit_speed>
    402e:	2b 01       	movw	r4, r22
    4030:	3c 01       	movw	r6, r24
    4032:	a5 e7       	ldi	r26, 0x75	; 117
    4034:	b1 e0       	ldi	r27, 0x01	; 1
    4036:	6d 93       	st	X+, r22
    4038:	7d 93       	st	X+, r23
    403a:	8d 93       	st	X+, r24
    403c:	9c 93       	st	X, r25
    403e:	13 97       	sbiw	r26, 0x03	; 3
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
    4040:	9b 01       	movw	r18, r22
    4042:	ac 01       	movw	r20, r24
    4044:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    4048:	69 83       	std	Y+1, r22	; 0x01
    404a:	7a 83       	std	Y+2, r23	; 0x02
    404c:	8b 83       	std	Y+3, r24	; 0x03
    404e:	9c 83       	std	Y+4, r25	; 0x04
        float intersect_distance =
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    4050:	00 91 83 01 	lds	r16, 0x0183
    4054:	10 91 84 01 	lds	r17, 0x0184
    4058:	d8 01       	movw	r26, r16
    405a:	95 96       	adiw	r26, 0x25	; 37
    405c:	2d 91       	ld	r18, X+
    405e:	3d 91       	ld	r19, X+
    4060:	4d 91       	ld	r20, X+
    4062:	5c 91       	ld	r21, X
    4064:	98 97       	sbiw	r26, 0x28	; 40
    4066:	2d 83       	std	Y+5, r18	; 0x05
    4068:	3e 83       	std	Y+6, r19	; 0x06
    406a:	4f 83       	std	Y+7, r20	; 0x07
    406c:	58 87       	std	Y+8, r21	; 0x08
    406e:	9b 01       	movw	r18, r22
    4070:	ac 01       	movw	r20, r24
    4072:	51 96       	adiw	r26, 0x11	; 17
    4074:	6d 91       	ld	r22, X+
    4076:	7d 91       	ld	r23, X+
    4078:	8d 91       	ld	r24, X+
    407a:	9c 91       	ld	r25, X
    407c:	54 97       	sbiw	r26, 0x14	; 20
    407e:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    4082:	a7 01       	movw	r20, r14
    4084:	96 01       	movw	r18, r12
    4086:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    408a:	9b 01       	movw	r18, r22
    408c:	ac 01       	movw	r20, r24
    408e:	6d 81       	ldd	r22, Y+5	; 0x05
    4090:	7e 81       	ldd	r23, Y+6	; 0x06
    4092:	8f 81       	ldd	r24, Y+7	; 0x07
    4094:	98 85       	ldd	r25, Y+8	; 0x08
    4096:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
        prep.accelerate_until = pl_block->millimeters; 
        prep.exit_speed = plan_get_exec_block_exit_speed();   
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
        float intersect_distance =
    409a:	20 e0       	ldi	r18, 0x00	; 0
    409c:	30 e0       	ldi	r19, 0x00	; 0
    409e:	40 e0       	ldi	r20, 0x00	; 0
    40a0:	5f e3       	ldi	r21, 0x3F	; 63
    40a2:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    40a6:	4b 01       	movw	r8, r22
    40a8:	5c 01       	movw	r10, r24
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
        if (intersect_distance > 0.0) {
    40aa:	20 e0       	ldi	r18, 0x00	; 0
    40ac:	30 e0       	ldi	r19, 0x00	; 0
    40ae:	a9 01       	movw	r20, r18
    40b0:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    40b4:	18 16       	cp	r1, r24
    40b6:	0c f0       	brlt	.+2      	; 0x40ba <st_prep_buffer+0x3e0>
    40b8:	a5 c0       	rjmp	.+330    	; 0x4204 <st_prep_buffer+0x52a>
          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    40ba:	a5 01       	movw	r20, r10
    40bc:	94 01       	movw	r18, r8
    40be:	6d 81       	ldd	r22, Y+5	; 0x05
    40c0:	7e 81       	ldd	r23, Y+6	; 0x06
    40c2:	8f 81       	ldd	r24, Y+7	; 0x07
    40c4:	98 85       	ldd	r25, Y+8	; 0x08
    40c6:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    40ca:	18 16       	cp	r1, r24
    40cc:	0c f0       	brlt	.+2      	; 0x40d0 <st_prep_buffer+0x3f6>
    40ce:	89 c0       	rjmp	.+274    	; 0x41e2 <st_prep_buffer+0x508>
            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);
    40d0:	29 81       	ldd	r18, Y+1	; 0x01
    40d2:	3a 81       	ldd	r19, Y+2	; 0x02
    40d4:	4b 81       	ldd	r20, Y+3	; 0x03
    40d6:	5c 81       	ldd	r21, Y+4	; 0x04
    40d8:	f8 01       	movw	r30, r16
    40da:	65 8d       	ldd	r22, Z+29	; 0x1d
    40dc:	76 8d       	ldd	r23, Z+30	; 0x1e
    40de:	87 8d       	ldd	r24, Z+31	; 0x1f
    40e0:	90 a1       	ldd	r25, Z+32	; 0x20
    40e2:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    40e6:	a7 01       	movw	r20, r14
    40e8:	96 01       	movw	r18, r12
    40ea:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    40ee:	9b 01       	movw	r18, r22
    40f0:	ac 01       	movw	r20, r24
    40f2:	ad e7       	ldi	r26, 0x7D	; 125
    40f4:	b1 e0       	ldi	r27, 0x01	; 1
    40f6:	6d 93       	st	X+, r22
    40f8:	7d 93       	st	X+, r23
    40fa:	8d 93       	st	X+, r24
    40fc:	9c 93       	st	X, r25
    40fe:	13 97       	sbiw	r26, 0x03	; 3
            if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    4100:	c5 01       	movw	r24, r10
    4102:	b4 01       	movw	r22, r8
    4104:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    4108:	18 16       	cp	r1, r24
    410a:	0c f0       	brlt	.+2      	; 0x410e <st_prep_buffer+0x434>
    410c:	40 c0       	rjmp	.+128    	; 0x418e <st_prep_buffer+0x4b4>
              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);
    410e:	f8 01       	movw	r30, r16
    4110:	65 8d       	ldd	r22, Z+29	; 0x1d
    4112:	76 8d       	ldd	r23, Z+30	; 0x1e
    4114:	87 8d       	ldd	r24, Z+31	; 0x1f
    4116:	90 a1       	ldd	r25, Z+32	; 0x20
    4118:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    411c:	a1 e7       	ldi	r26, 0x71	; 113
    411e:	b1 e0       	ldi	r27, 0x01	; 1
    4120:	6d 93       	st	X+, r22
    4122:	7d 93       	st	X+, r23
    4124:	8d 93       	st	X+, r24
    4126:	9c 93       	st	X, r25
    4128:	13 97       	sbiw	r26, 0x03	; 3
              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { 
    412a:	f8 01       	movw	r30, r16
    412c:	41 88       	ldd	r4, Z+17	; 0x11
    412e:	52 88       	ldd	r5, Z+18	; 0x12
    4130:	63 88       	ldd	r6, Z+19	; 0x13
    4132:	74 88       	ldd	r7, Z+20	; 0x14
    4134:	85 8c       	ldd	r8, Z+29	; 0x1d
    4136:	96 8c       	ldd	r9, Z+30	; 0x1e
    4138:	a7 8c       	ldd	r10, Z+31	; 0x1f
    413a:	b0 a0       	ldd	r11, Z+32	; 0x20
    413c:	a5 01       	movw	r20, r10
    413e:	94 01       	movw	r18, r8
    4140:	c3 01       	movw	r24, r6
    4142:	b2 01       	movw	r22, r4
    4144:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    4148:	81 11       	cpse	r24, r1
    414a:	05 c0       	rjmp	.+10     	; 0x4156 <st_prep_buffer+0x47c>
                // Cruise-deceleration or cruise-only type.
                prep.ramp_type = RAMP_CRUISE;
    414c:	81 e0       	ldi	r24, 0x01	; 1
    414e:	a8 e6       	ldi	r26, 0x68	; 104
    4150:	b1 e0       	ldi	r27, 0x01	; 1
    4152:	8c 93       	st	X, r24
    4154:	64 c0       	rjmp	.+200    	; 0x421e <st_prep_buffer+0x544>
              } else {
                // Full-trapezoid or acceleration-cruise types
                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); 
    4156:	a3 01       	movw	r20, r6
    4158:	92 01       	movw	r18, r4
    415a:	c5 01       	movw	r24, r10
    415c:	b4 01       	movw	r22, r8
    415e:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    4162:	a7 01       	movw	r20, r14
    4164:	96 01       	movw	r18, r12
    4166:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    416a:	9b 01       	movw	r18, r22
    416c:	ac 01       	movw	r20, r24
    416e:	e9 e7       	ldi	r30, 0x79	; 121
    4170:	f1 e0       	ldi	r31, 0x01	; 1
    4172:	60 81       	ld	r22, Z
    4174:	71 81       	ldd	r23, Z+1	; 0x01
    4176:	82 81       	ldd	r24, Z+2	; 0x02
    4178:	93 81       	ldd	r25, Z+3	; 0x03
    417a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    417e:	a9 e7       	ldi	r26, 0x79	; 121
    4180:	b1 e0       	ldi	r27, 0x01	; 1
    4182:	6d 93       	st	X+, r22
    4184:	7d 93       	st	X+, r23
    4186:	8d 93       	st	X+, r24
    4188:	9c 93       	st	X, r25
    418a:	13 97       	sbiw	r26, 0x03	; 3
    418c:	48 c0       	rjmp	.+144    	; 0x421e <st_prep_buffer+0x544>
              }
            } else { // Triangle type
              prep.accelerate_until = intersect_distance;
    418e:	e9 e7       	ldi	r30, 0x79	; 121
    4190:	f1 e0       	ldi	r31, 0x01	; 1
    4192:	80 82       	st	Z, r8
    4194:	91 82       	std	Z+1, r9	; 0x01
    4196:	a2 82       	std	Z+2, r10	; 0x02
    4198:	b3 82       	std	Z+3, r11	; 0x03
              prep.decelerate_after = intersect_distance;
    419a:	ad e7       	ldi	r26, 0x7D	; 125
    419c:	b1 e0       	ldi	r27, 0x01	; 1
    419e:	8d 92       	st	X+, r8
    41a0:	9d 92       	st	X+, r9
    41a2:	ad 92       	st	X+, r10
    41a4:	bc 92       	st	X, r11
    41a6:	13 97       	sbiw	r26, 0x03	; 3
              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    41a8:	f8 01       	movw	r30, r16
    41aa:	61 a1       	ldd	r22, Z+33	; 0x21
    41ac:	72 a1       	ldd	r23, Z+34	; 0x22
    41ae:	83 a1       	ldd	r24, Z+35	; 0x23
    41b0:	94 a1       	ldd	r25, Z+36	; 0x24
    41b2:	9b 01       	movw	r18, r22
    41b4:	ac 01       	movw	r20, r24
    41b6:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    41ba:	a5 01       	movw	r20, r10
    41bc:	94 01       	movw	r18, r8
    41be:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    41c2:	29 81       	ldd	r18, Y+1	; 0x01
    41c4:	3a 81       	ldd	r19, Y+2	; 0x02
    41c6:	4b 81       	ldd	r20, Y+3	; 0x03
    41c8:	5c 81       	ldd	r21, Y+4	; 0x04
    41ca:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    41ce:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    41d2:	a1 e7       	ldi	r26, 0x71	; 113
    41d4:	b1 e0       	ldi	r27, 0x01	; 1
    41d6:	6d 93       	st	X+, r22
    41d8:	7d 93       	st	X+, r23
    41da:	8d 93       	st	X+, r24
    41dc:	9c 93       	st	X, r25
    41de:	13 97       	sbiw	r26, 0x03	; 3
    41e0:	1e c0       	rjmp	.+60     	; 0x421e <st_prep_buffer+0x544>
            }          
          } else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    41e2:	82 e0       	ldi	r24, 0x02	; 2
    41e4:	e8 e6       	ldi	r30, 0x68	; 104
    41e6:	f1 e0       	ldi	r31, 0x01	; 1
    41e8:	80 83       	st	Z, r24
            // prep.decelerate_after = pl_block->millimeters;
            prep.maximum_speed = prep.current_speed;
    41ea:	ed e6       	ldi	r30, 0x6D	; 109
    41ec:	f1 e0       	ldi	r31, 0x01	; 1
    41ee:	80 81       	ld	r24, Z
    41f0:	91 81       	ldd	r25, Z+1	; 0x01
    41f2:	a2 81       	ldd	r26, Z+2	; 0x02
    41f4:	b3 81       	ldd	r27, Z+3	; 0x03
    41f6:	e1 e7       	ldi	r30, 0x71	; 113
    41f8:	f1 e0       	ldi	r31, 0x01	; 1
    41fa:	80 83       	st	Z, r24
    41fc:	91 83       	std	Z+1, r25	; 0x01
    41fe:	a2 83       	std	Z+2, r26	; 0x02
    4200:	b3 83       	std	Z+3, r27	; 0x03
    4202:	0d c0       	rjmp	.+26     	; 0x421e <st_prep_buffer+0x544>
          }
        } else { // Acceleration-only type
          prep.accelerate_until = 0.0;
    4204:	a9 e7       	ldi	r26, 0x79	; 121
    4206:	b1 e0       	ldi	r27, 0x01	; 1
    4208:	1d 92       	st	X+, r1
    420a:	1d 92       	st	X+, r1
    420c:	1d 92       	st	X+, r1
    420e:	1c 92       	st	X, r1
    4210:	13 97       	sbiw	r26, 0x03	; 3
          // prep.decelerate_after = 0.0;
          prep.maximum_speed = prep.exit_speed;
    4212:	e1 e7       	ldi	r30, 0x71	; 113
    4214:	f1 e0       	ldi	r31, 0x01	; 1
    4216:	40 82       	st	Z, r4
    4218:	51 82       	std	Z+1, r5	; 0x01
    421a:	62 82       	std	Z+2, r6	; 0x02
    421c:	73 82       	std	Z+3, r7	; 0x03
        }
      }  
    }

    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    421e:	80 91 89 01 	lds	r24, 0x0189
    4222:	90 e0       	ldi	r25, 0x00	; 0
    4224:	9c 01       	movw	r18, r24
    4226:	22 0f       	add	r18, r18
    4228:	33 1f       	adc	r19, r19
    422a:	82 0f       	add	r24, r18
    422c:	93 1f       	adc	r25, r19
    422e:	88 0f       	add	r24, r24
    4230:	99 1f       	adc	r25, r25
    4232:	9c 01       	movw	r18, r24
    4234:	22 55       	subi	r18, 0x52	; 82
    4236:	3e 4f       	sbci	r19, 0xFE	; 254
    4238:	3c a7       	std	Y+44, r19	; 0x2c
    423a:	2b a7       	std	Y+43, r18	; 0x2b

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    423c:	a6 e5       	ldi	r26, 0x56	; 86
    423e:	b1 e0       	ldi	r27, 0x01	; 1
    4240:	8c 91       	ld	r24, X
    4242:	f9 01       	movw	r30, r18
    4244:	82 83       	std	Z+2, r24	; 0x02
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable   
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    4246:	20 91 83 01 	lds	r18, 0x0183
    424a:	30 91 84 01 	lds	r19, 0x0184
    424e:	3e 8b       	std	Y+22, r19	; 0x16
    4250:	2d 8b       	std	Y+21, r18	; 0x15
    4252:	d9 01       	movw	r26, r18
    4254:	95 96       	adiw	r26, 0x25	; 37
    4256:	bc 91       	ld	r27, X
    4258:	bd a7       	std	Y+45, r27	; 0x2d
    425a:	f9 01       	movw	r30, r18
    425c:	f6 a1       	ldd	r31, Z+38	; 0x26
    425e:	fe a7       	std	Y+46, r31	; 0x2e
    4260:	d9 01       	movw	r26, r18
    4262:	97 96       	adiw	r26, 0x27	; 39
    4264:	bc 91       	ld	r27, X
    4266:	bf a7       	std	Y+47, r27	; 0x2f
    4268:	f9 01       	movw	r30, r18
    426a:	f0 a5       	ldd	r31, Z+40	; 0x28
    426c:	f8 ab       	std	Y+48, r31	; 0x30
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    426e:	20 91 60 01 	lds	r18, 0x0160
    4272:	30 91 61 01 	lds	r19, 0x0161
    4276:	40 91 62 01 	lds	r20, 0x0162
    427a:	50 91 63 01 	lds	r21, 0x0163
    427e:	6d a5       	ldd	r22, Y+45	; 0x2d
    4280:	7e a5       	ldd	r23, Y+46	; 0x2e
    4282:	8b 2f       	mov	r24, r27
    4284:	9f 2f       	mov	r25, r31
    4286:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    428a:	6b a3       	std	Y+35, r22	; 0x23
    428c:	7c a3       	std	Y+36, r23	; 0x24
    428e:	8d a3       	std	Y+37, r24	; 0x25
    4290:	9e a3       	std	Y+38, r25	; 0x26
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    4292:	20 e0       	ldi	r18, 0x00	; 0
    4294:	30 e0       	ldi	r19, 0x00	; 0
    4296:	a9 01       	movw	r20, r18
    4298:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    429c:	88 23       	and	r24, r24
    429e:	24 f4       	brge	.+8      	; 0x42a8 <st_prep_buffer+0x5ce>
    42a0:	1b a2       	std	Y+35, r1	; 0x23
    42a2:	1c a2       	std	Y+36, r1	; 0x24
    42a4:	1d a2       	std	Y+37, r1	; 0x25
    42a6:	1e a2       	std	Y+38, r1	; 0x26
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    42a8:	a9 e7       	ldi	r26, 0x79	; 121
    42aa:	b1 e0       	ldi	r27, 0x01	; 1
    42ac:	bc 91       	ld	r27, X
    42ae:	bf 8b       	std	Y+23, r27	; 0x17
    42b0:	e0 91 7a 01 	lds	r30, 0x017A
    42b4:	e8 8f       	std	Y+24, r30	; 0x18
    42b6:	f0 91 7b 01 	lds	r31, 0x017B
    42ba:	f9 8f       	std	Y+25, r31	; 0x19
    42bc:	20 91 7c 01 	lds	r18, 0x017C
    42c0:	2a 8f       	std	Y+26, r18	; 0x1a
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    42c2:	a1 e7       	ldi	r26, 0x71	; 113
    42c4:	b1 e0       	ldi	r27, 0x01	; 1
    42c6:	bc 91       	ld	r27, X
    42c8:	bb 8f       	std	Y+27, r27	; 0x1b
    42ca:	e0 91 72 01 	lds	r30, 0x0172
    42ce:	ec 8f       	std	Y+28, r30	; 0x1c
    42d0:	f0 91 73 01 	lds	r31, 0x0173
    42d4:	fd 8f       	std	Y+29, r31	; 0x1d
    42d6:	20 91 74 01 	lds	r18, 0x0174
    42da:	2e 8f       	std	Y+30, r18	; 0x1e
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    42dc:	ad e7       	ldi	r26, 0x7D	; 125
    42de:	b1 e0       	ldi	r27, 0x01	; 1
    42e0:	bc 91       	ld	r27, X
    42e2:	bf 8f       	std	Y+31, r27	; 0x1f
    42e4:	e0 91 7e 01 	lds	r30, 0x017E
    42e8:	e8 a3       	std	Y+32, r30	; 0x20
    42ea:	f0 91 7f 01 	lds	r31, 0x017F
    42ee:	f9 a3       	std	Y+33, r31	; 0x21
    42f0:	20 91 80 01 	lds	r18, 0x0180
    42f4:	2a a3       	std	Y+34, r18	; 0x22
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
    42f6:	a9 e6       	ldi	r26, 0x69	; 105
    42f8:	b1 e0       	ldi	r27, 0x01	; 1
    42fa:	bc 91       	ld	r27, X
    42fc:	b9 8b       	std	Y+17, r27	; 0x11
    42fe:	e0 91 6a 01 	lds	r30, 0x016A
    4302:	ea 8b       	std	Y+18, r30	; 0x12
    4304:	f0 91 6b 01 	lds	r31, 0x016B
    4308:	fb 8b       	std	Y+19, r31	; 0x13
    430a:	20 91 6c 01 	lds	r18, 0x016C
    430e:	2c 8b       	std	Y+20, r18	; 0x14
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    4310:	a5 e7       	ldi	r26, 0x75	; 117
    4312:	b1 e0       	ldi	r27, 0x01	; 1
    4314:	8d 91       	ld	r24, X+
    4316:	9d 91       	ld	r25, X+
    4318:	0d 90       	ld	r0, X+
    431a:	bc 91       	ld	r27, X
    431c:	a0 2d       	mov	r26, r0
    431e:	89 ab       	std	Y+49, r24	; 0x31
    4320:	9a ab       	std	Y+50, r25	; 0x32
    4322:	ab ab       	std	Y+51, r26	; 0x33
    4324:	bc ab       	std	Y+52, r27	; 0x34
    4326:	ed e6       	ldi	r30, 0x6D	; 109
    4328:	f1 e0       	ldi	r31, 0x01	; 1
    432a:	f0 81       	ld	r31, Z
    432c:	fd 87       	std	Y+13, r31	; 0x0d
    432e:	20 91 6e 01 	lds	r18, 0x016E
    4332:	2e 87       	std	Y+14, r18	; 0x0e
    4334:	30 91 6f 01 	lds	r19, 0x016F
    4338:	3f 87       	std	Y+15, r19	; 0x0f
    433a:	40 91 70 01 	lds	r20, 0x0170
    433e:	48 8b       	std	Y+16, r20	; 0x10
    4340:	a8 e6       	ldi	r26, 0x68	; 104
    4342:	b1 e0       	ldi	r27, 0x01	; 1
    4344:	bc 91       	ld	r27, X
    4346:	b9 87       	std	Y+9, r27	; 0x09
    4348:	ed a5       	ldd	r30, Y+45	; 0x2d
    434a:	fe a5       	ldd	r31, Y+46	; 0x2e
    434c:	ff a3       	std	Y+39, r31	; 0x27
    434e:	0f a5       	ldd	r16, Y+47	; 0x2f
    4350:	18 a9       	ldd	r17, Y+48	; 0x30
    4352:	0f 2e       	mov	r0, r31
    4354:	fe e3       	ldi	r31, 0x3E	; 62
    4356:	2f 2e       	mov	r2, r31
    4358:	f0 2d       	mov	r31, r0
    435a:	0f 2e       	mov	r0, r31
    435c:	f3 ec       	ldi	r31, 0xC3	; 195
    435e:	6f 2e       	mov	r6, r31
    4360:	f0 2d       	mov	r31, r0
    4362:	0f 2e       	mov	r0, r31
    4364:	fe ea       	ldi	r31, 0xAE	; 174
    4366:	7f 2e       	mov	r7, r31
    4368:	f0 2d       	mov	r31, r0
    436a:	0f 2e       	mov	r0, r31
    436c:	f9 e3       	ldi	r31, 0x39	; 57
    436e:	3f 2e       	mov	r3, r31
    4370:	f0 2d       	mov	r31, r0
    4372:	c1 2c       	mov	r12, r1
    4374:	d1 2c       	mov	r13, r1
    4376:	76 01       	movw	r14, r12
    4378:	0f 2e       	mov	r0, r31
    437a:	fe e3       	ldi	r31, 0x3E	; 62
    437c:	4f 2e       	mov	r4, r31
    437e:	f0 2d       	mov	r31, r0
    4380:	0f 2e       	mov	r0, r31
    4382:	f3 ec       	ldi	r31, 0xC3	; 195
    4384:	5f 2e       	mov	r5, r31
    4386:	f0 2d       	mov	r31, r0
    4388:	2e ea       	ldi	r18, 0xAE	; 174
    438a:	29 83       	std	Y+1, r18	; 0x01
    438c:	39 e3       	ldi	r19, 0x39	; 57
    438e:	3d 83       	std	Y+5, r19	; 0x05
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
    4390:	ed ab       	std	Y+53, r30	; 0x35
    4392:	fe ab       	std	Y+54, r31	; 0x36
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    4394:	49 85       	ldd	r20, Y+9	; 0x09
    4396:	44 23       	and	r20, r20
    4398:	21 f0       	breq	.+8      	; 0x43a2 <st_prep_buffer+0x6c8>
    439a:	41 30       	cpi	r20, 0x01	; 1
    439c:	09 f4       	brne	.+2      	; 0x43a0 <st_prep_buffer+0x6c6>
    439e:	8a c0       	rjmp	.+276    	; 0x44b4 <st_prep_buffer+0x7da>
    43a0:	c9 c0       	rjmp	.+402    	; 0x4534 <st_prep_buffer+0x85a>
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    43a2:	ad 89       	ldd	r26, Y+21	; 0x15
    43a4:	be 89       	ldd	r27, Y+22	; 0x16
    43a6:	91 96       	adiw	r26, 0x21	; 33
    43a8:	2d 91       	ld	r18, X+
    43aa:	3d 91       	ld	r19, X+
    43ac:	4d 91       	ld	r20, X+
    43ae:	5c 91       	ld	r21, X
    43b0:	94 97       	sbiw	r26, 0x24	; 36
    43b2:	62 2d       	mov	r22, r2
    43b4:	76 2d       	mov	r23, r6
    43b6:	87 2d       	mov	r24, r7
    43b8:	93 2d       	mov	r25, r3
    43ba:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    43be:	4b 01       	movw	r8, r22
    43c0:	5c 01       	movw	r10, r24
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    43c2:	20 e0       	ldi	r18, 0x00	; 0
    43c4:	30 e0       	ldi	r19, 0x00	; 0
    43c6:	40 e0       	ldi	r20, 0x00	; 0
    43c8:	5f e3       	ldi	r21, 0x3F	; 63
    43ca:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    43ce:	2d 85       	ldd	r18, Y+13	; 0x0d
    43d0:	3e 85       	ldd	r19, Y+14	; 0x0e
    43d2:	4f 85       	ldd	r20, Y+15	; 0x0f
    43d4:	58 89       	ldd	r21, Y+16	; 0x10
    43d6:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    43da:	22 2d       	mov	r18, r2
    43dc:	36 2d       	mov	r19, r6
    43de:	47 2d       	mov	r20, r7
    43e0:	53 2d       	mov	r21, r3
    43e2:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    43e6:	9b 01       	movw	r18, r22
    43e8:	ac 01       	movw	r20, r24
    43ea:	6d a9       	ldd	r22, Y+53	; 0x35
    43ec:	7e a9       	ldd	r23, Y+54	; 0x36
    43ee:	80 2f       	mov	r24, r16
    43f0:	91 2f       	mov	r25, r17
    43f2:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    43f6:	6d ab       	std	Y+53, r22	; 0x35
    43f8:	7e ab       	std	Y+54, r23	; 0x36
    43fa:	08 2f       	mov	r16, r24
    43fc:	19 2f       	mov	r17, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    43fe:	2f 89       	ldd	r18, Y+23	; 0x17
    4400:	38 8d       	ldd	r19, Y+24	; 0x18
    4402:	49 8d       	ldd	r20, Y+25	; 0x19
    4404:	5a 8d       	ldd	r21, Y+26	; 0x1a
    4406:	91 2f       	mov	r25, r17
    4408:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    440c:	88 23       	and	r24, r24
    440e:	0c f0       	brlt	.+2      	; 0x4412 <st_prep_buffer+0x738>
    4410:	44 c0       	rjmp	.+136    	; 0x449a <st_prep_buffer+0x7c0>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    4412:	2f 89       	ldd	r18, Y+23	; 0x17
    4414:	38 8d       	ldd	r19, Y+24	; 0x18
    4416:	49 8d       	ldd	r20, Y+25	; 0x19
    4418:	5a 8d       	ldd	r21, Y+26	; 0x1a
    441a:	6d a5       	ldd	r22, Y+45	; 0x2d
    441c:	7e a5       	ldd	r23, Y+46	; 0x2e
    441e:	8f a5       	ldd	r24, Y+47	; 0x2f
    4420:	98 a9       	ldd	r25, Y+48	; 0x30
    4422:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    4426:	9b 01       	movw	r18, r22
    4428:	ac 01       	movw	r20, r24
    442a:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    442e:	4b 01       	movw	r8, r22
    4430:	5c 01       	movw	r10, r24
    4432:	2d 85       	ldd	r18, Y+13	; 0x0d
    4434:	3e 85       	ldd	r19, Y+14	; 0x0e
    4436:	4f 85       	ldd	r20, Y+15	; 0x0f
    4438:	58 89       	ldd	r21, Y+16	; 0x10
    443a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    443c:	7c 8d       	ldd	r23, Y+28	; 0x1c
    443e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4440:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4442:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    4446:	9b 01       	movw	r18, r22
    4448:	ac 01       	movw	r20, r24
    444a:	c5 01       	movw	r24, r10
    444c:	b4 01       	movw	r22, r8
    444e:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    4452:	26 2e       	mov	r2, r22
    4454:	67 2e       	mov	r6, r23
    4456:	78 2e       	mov	r7, r24
    4458:	39 2e       	mov	r3, r25
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    445a:	2f 8d       	ldd	r18, Y+31	; 0x1f
    445c:	38 a1       	ldd	r19, Y+32	; 0x20
    445e:	49 a1       	ldd	r20, Y+33	; 0x21
    4460:	5a a1       	ldd	r21, Y+34	; 0x22
    4462:	6f 89       	ldd	r22, Y+23	; 0x17
    4464:	78 8d       	ldd	r23, Y+24	; 0x18
    4466:	89 8d       	ldd	r24, Y+25	; 0x19
    4468:	9a 8d       	ldd	r25, Y+26	; 0x1a
    446a:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    446e:	88 23       	and	r24, r24
    4470:	19 f0       	breq	.+6      	; 0x4478 <st_prep_buffer+0x79e>
            else { prep.ramp_type = RAMP_CRUISE; }
    4472:	b1 e0       	ldi	r27, 0x01	; 1
    4474:	b9 87       	std	Y+9, r27	; 0x09
    4476:	02 c0       	rjmp	.+4      	; 0x447c <st_prep_buffer+0x7a2>
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    4478:	e2 e0       	ldi	r30, 0x02	; 2
    447a:	e9 87       	std	Y+9, r30	; 0x09
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    447c:	fb 8d       	ldd	r31, Y+27	; 0x1b
    447e:	fd 87       	std	Y+13, r31	; 0x0d
    4480:	2c 8d       	ldd	r18, Y+28	; 0x1c
    4482:	2e 87       	std	Y+14, r18	; 0x0e
    4484:	3d 8d       	ldd	r19, Y+29	; 0x1d
    4486:	3f 87       	std	Y+15, r19	; 0x0f
    4488:	4e 8d       	ldd	r20, Y+30	; 0x1e
    448a:	48 8b       	std	Y+16, r20	; 0x10
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    448c:	5f 89       	ldd	r21, Y+23	; 0x17
    448e:	5d ab       	std	Y+53, r21	; 0x35
    4490:	88 8d       	ldd	r24, Y+24	; 0x18
    4492:	8e ab       	std	Y+54, r24	; 0x36
    4494:	09 8d       	ldd	r16, Y+25	; 0x19
    4496:	1a 8d       	ldd	r17, Y+26	; 0x1a
    4498:	d1 c0       	rjmp	.+418    	; 0x463c <st_prep_buffer+0x962>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only. 
            prep.current_speed += speed_var;
    449a:	2d 85       	ldd	r18, Y+13	; 0x0d
    449c:	3e 85       	ldd	r19, Y+14	; 0x0e
    449e:	4f 85       	ldd	r20, Y+15	; 0x0f
    44a0:	58 89       	ldd	r21, Y+16	; 0x10
    44a2:	c5 01       	movw	r24, r10
    44a4:	b4 01       	movw	r22, r8
    44a6:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    44aa:	6d 87       	std	Y+13, r22	; 0x0d
    44ac:	7e 87       	std	Y+14, r23	; 0x0e
    44ae:	8f 87       	std	Y+15, r24	; 0x0f
    44b0:	98 8b       	std	Y+16, r25	; 0x10
    44b2:	c4 c0       	rjmp	.+392    	; 0x463c <st_prep_buffer+0x962>
          break;
        case RAMP_CRUISE: 
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To 
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    44b4:	2b 8d       	ldd	r18, Y+27	; 0x1b
    44b6:	3c 8d       	ldd	r19, Y+28	; 0x1c
    44b8:	4d 8d       	ldd	r20, Y+29	; 0x1d
    44ba:	5e 8d       	ldd	r21, Y+30	; 0x1e
    44bc:	62 2d       	mov	r22, r2
    44be:	76 2d       	mov	r23, r6
    44c0:	87 2d       	mov	r24, r7
    44c2:	93 2d       	mov	r25, r3
    44c4:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    44c8:	9b 01       	movw	r18, r22
    44ca:	ac 01       	movw	r20, r24
    44cc:	6d a9       	ldd	r22, Y+53	; 0x35
    44ce:	7e a9       	ldd	r23, Y+54	; 0x36
    44d0:	80 2f       	mov	r24, r16
    44d2:	91 2f       	mov	r25, r17
    44d4:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    44d8:	a6 2e       	mov	r10, r22
    44da:	b7 2e       	mov	r11, r23
    44dc:	88 2e       	mov	r8, r24
    44de:	99 2e       	mov	r9, r25
          if (mm_var < prep.decelerate_after) { // End of cruise. 
    44e0:	26 2f       	mov	r18, r22
    44e2:	37 2f       	mov	r19, r23
    44e4:	48 2f       	mov	r20, r24
    44e6:	59 2f       	mov	r21, r25
    44e8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    44ea:	78 a1       	ldd	r23, Y+32	; 0x20
    44ec:	89 a1       	ldd	r24, Y+33	; 0x21
    44ee:	9a a1       	ldd	r25, Y+34	; 0x22
    44f0:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    44f4:	18 16       	cp	r1, r24
    44f6:	0c f0       	brlt	.+2      	; 0x44fa <st_prep_buffer+0x820>
    44f8:	9d c0       	rjmp	.+314    	; 0x4634 <st_prep_buffer+0x95a>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    44fa:	2f 8d       	ldd	r18, Y+31	; 0x1f
    44fc:	38 a1       	ldd	r19, Y+32	; 0x20
    44fe:	49 a1       	ldd	r20, Y+33	; 0x21
    4500:	5a a1       	ldd	r21, Y+34	; 0x22
    4502:	6d a9       	ldd	r22, Y+53	; 0x35
    4504:	7e a9       	ldd	r23, Y+54	; 0x36
    4506:	80 2f       	mov	r24, r16
    4508:	91 2f       	mov	r25, r17
    450a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    450e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    4510:	3c 8d       	ldd	r19, Y+28	; 0x1c
    4512:	4d 8d       	ldd	r20, Y+29	; 0x1d
    4514:	5e 8d       	ldd	r21, Y+30	; 0x1e
    4516:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    451a:	26 2e       	mov	r2, r22
    451c:	67 2e       	mov	r6, r23
    451e:	78 2e       	mov	r7, r24
    4520:	39 2e       	mov	r3, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    4522:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4524:	9d ab       	std	Y+53, r25	; 0x35
    4526:	a8 a1       	ldd	r26, Y+32	; 0x20
    4528:	ae ab       	std	Y+54, r26	; 0x36
    452a:	09 a1       	ldd	r16, Y+33	; 0x21
    452c:	1a a1       	ldd	r17, Y+34	; 0x22
            prep.ramp_type = RAMP_DECEL;
    452e:	b2 e0       	ldi	r27, 0x02	; 2
    4530:	b9 87       	std	Y+9, r27	; 0x09
    4532:	84 c0       	rjmp	.+264    	; 0x463c <st_prep_buffer+0x962>
            mm_remaining = mm_var; 
          } 
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    4534:	ed 89       	ldd	r30, Y+21	; 0x15
    4536:	fe 89       	ldd	r31, Y+22	; 0x16
    4538:	21 a1       	ldd	r18, Z+33	; 0x21
    453a:	32 a1       	ldd	r19, Z+34	; 0x22
    453c:	43 a1       	ldd	r20, Z+35	; 0x23
    453e:	54 a1       	ldd	r21, Z+36	; 0x24
    4540:	62 2d       	mov	r22, r2
    4542:	76 2d       	mov	r23, r6
    4544:	87 2d       	mov	r24, r7
    4546:	93 2d       	mov	r25, r3
    4548:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    454c:	4b 01       	movw	r8, r22
    454e:	5c 01       	movw	r10, r24
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    4550:	9b 01       	movw	r18, r22
    4552:	ac 01       	movw	r20, r24
    4554:	6d 85       	ldd	r22, Y+13	; 0x0d
    4556:	7e 85       	ldd	r23, Y+14	; 0x0e
    4558:	8f 85       	ldd	r24, Y+15	; 0x0f
    455a:	98 89       	ldd	r25, Y+16	; 0x10
    455c:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    4560:	18 16       	cp	r1, r24
    4562:	ec f5       	brge	.+122    	; 0x45de <st_prep_buffer+0x904>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    4564:	20 e0       	ldi	r18, 0x00	; 0
    4566:	30 e0       	ldi	r19, 0x00	; 0
    4568:	40 e0       	ldi	r20, 0x00	; 0
    456a:	5f e3       	ldi	r21, 0x3F	; 63
    456c:	c5 01       	movw	r24, r10
    456e:	b4 01       	movw	r22, r8
    4570:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    4574:	9b 01       	movw	r18, r22
    4576:	ac 01       	movw	r20, r24
    4578:	6d 85       	ldd	r22, Y+13	; 0x0d
    457a:	7e 85       	ldd	r23, Y+14	; 0x0e
    457c:	8f 85       	ldd	r24, Y+15	; 0x0f
    457e:	98 89       	ldd	r25, Y+16	; 0x10
    4580:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    4584:	22 2d       	mov	r18, r2
    4586:	36 2d       	mov	r19, r6
    4588:	47 2d       	mov	r20, r7
    458a:	53 2d       	mov	r21, r3
    458c:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    4590:	9b 01       	movw	r18, r22
    4592:	ac 01       	movw	r20, r24
    4594:	6d a9       	ldd	r22, Y+53	; 0x35
    4596:	7e a9       	ldd	r23, Y+54	; 0x36
    4598:	80 2f       	mov	r24, r16
    459a:	91 2f       	mov	r25, r17
    459c:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    45a0:	6f a3       	std	Y+39, r22	; 0x27
    45a2:	78 a7       	std	Y+40, r23	; 0x28
    45a4:	89 a7       	std	Y+41, r24	; 0x29
    45a6:	9a a7       	std	Y+42, r25	; 0x2a
            if (mm_var > prep.mm_complete) { // Deceleration only.
    45a8:	29 89       	ldd	r18, Y+17	; 0x11
    45aa:	3a 89       	ldd	r19, Y+18	; 0x12
    45ac:	4b 89       	ldd	r20, Y+19	; 0x13
    45ae:	5c 89       	ldd	r21, Y+20	; 0x14
    45b0:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    45b4:	18 16       	cp	r1, r24
    45b6:	9c f4       	brge	.+38     	; 0x45de <st_prep_buffer+0x904>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    45b8:	a5 01       	movw	r20, r10
    45ba:	94 01       	movw	r18, r8
    45bc:	6d 85       	ldd	r22, Y+13	; 0x0d
    45be:	7e 85       	ldd	r23, Y+14	; 0x0e
    45c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    45c2:	98 89       	ldd	r25, Y+16	; 0x10
    45c4:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    45c8:	6d 87       	std	Y+13, r22	; 0x0d
    45ca:	7e 87       	std	Y+14, r23	; 0x0e
    45cc:	8f 87       	std	Y+15, r24	; 0x0f
    45ce:	98 8b       	std	Y+16, r25	; 0x10
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
              mm_remaining = mm_var;
    45d0:	ff a1       	ldd	r31, Y+39	; 0x27
    45d2:	fd ab       	std	Y+53, r31	; 0x35
    45d4:	28 a5       	ldd	r18, Y+40	; 0x28
    45d6:	2e ab       	std	Y+54, r18	; 0x36
    45d8:	09 a5       	ldd	r16, Y+41	; 0x29
    45da:	1a a5       	ldd	r17, Y+42	; 0x2a
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    45dc:	2f c0       	rjmp	.+94     	; 0x463c <st_prep_buffer+0x962>
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    45de:	29 89       	ldd	r18, Y+17	; 0x11
    45e0:	3a 89       	ldd	r19, Y+18	; 0x12
    45e2:	4b 89       	ldd	r20, Y+19	; 0x13
    45e4:	5c 89       	ldd	r21, Y+20	; 0x14
    45e6:	6d a9       	ldd	r22, Y+53	; 0x35
    45e8:	7e a9       	ldd	r23, Y+54	; 0x36
    45ea:	80 2f       	mov	r24, r16
    45ec:	91 2f       	mov	r25, r17
    45ee:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    45f2:	9b 01       	movw	r18, r22
    45f4:	ac 01       	movw	r20, r24
    45f6:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    45fa:	4b 01       	movw	r8, r22
    45fc:	5c 01       	movw	r10, r24
    45fe:	29 a9       	ldd	r18, Y+49	; 0x31
    4600:	3a a9       	ldd	r19, Y+50	; 0x32
    4602:	4b a9       	ldd	r20, Y+51	; 0x33
    4604:	5c a9       	ldd	r21, Y+52	; 0x34
    4606:	6d 85       	ldd	r22, Y+13	; 0x0d
    4608:	7e 85       	ldd	r23, Y+14	; 0x0e
    460a:	8f 85       	ldd	r24, Y+15	; 0x0f
    460c:	98 89       	ldd	r25, Y+16	; 0x10
    460e:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    4612:	9b 01       	movw	r18, r22
    4614:	ac 01       	movw	r20, r24
    4616:	c5 01       	movw	r24, r10
    4618:	b4 01       	movw	r22, r8
    461a:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    461e:	26 2e       	mov	r2, r22
    4620:	67 2e       	mov	r6, r23
    4622:	78 2e       	mov	r7, r24
    4624:	39 2e       	mov	r3, r25
          mm_remaining = prep.mm_complete; 
    4626:	39 89       	ldd	r19, Y+17	; 0x11
    4628:	3d ab       	std	Y+53, r19	; 0x35
    462a:	4a 89       	ldd	r20, Y+18	; 0x12
    462c:	4e ab       	std	Y+54, r20	; 0x36
    462e:	0b 89       	ldd	r16, Y+19	; 0x13
    4630:	1c 89       	ldd	r17, Y+20	; 0x14
    4632:	04 c0       	rjmp	.+8      	; 0x463c <st_prep_buffer+0x962>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.         
            mm_remaining = mm_var; 
    4634:	ad aa       	std	Y+53, r10	; 0x35
    4636:	be aa       	std	Y+54, r11	; 0x36
    4638:	08 2d       	mov	r16, r8
    463a:	19 2d       	mov	r17, r9
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete; 
      }
      dt += time_var; // Add computed ramp time to total segment time.
    463c:	22 2d       	mov	r18, r2
    463e:	36 2d       	mov	r19, r6
    4640:	47 2d       	mov	r20, r7
    4642:	53 2d       	mov	r21, r3
    4644:	c7 01       	movw	r24, r14
    4646:	b6 01       	movw	r22, r12
    4648:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    464c:	6b 01       	movw	r12, r22
    464e:	7c 01       	movw	r14, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    4650:	9b 01       	movw	r18, r22
    4652:	ac 01       	movw	r20, r24
    4654:	64 2d       	mov	r22, r4
    4656:	75 2d       	mov	r23, r5
    4658:	89 81       	ldd	r24, Y+1	; 0x01
    465a:	9d 81       	ldd	r25, Y+5	; 0x05
    465c:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    4660:	18 16       	cp	r1, r24
    4662:	6c f4       	brge	.+26     	; 0x467e <st_prep_buffer+0x9a4>
    4664:	a7 01       	movw	r20, r14
    4666:	96 01       	movw	r18, r12
    4668:	64 2d       	mov	r22, r4
    466a:	75 2d       	mov	r23, r5
    466c:	89 81       	ldd	r24, Y+1	; 0x01
    466e:	9d 81       	ldd	r25, Y+5	; 0x05
    4670:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    4674:	26 2e       	mov	r2, r22
    4676:	67 2e       	mov	r6, r23
    4678:	78 2e       	mov	r7, r24
    467a:	39 2e       	mov	r3, r25
    467c:	33 c0       	rjmp	.+102    	; 0x46e4 <st_prep_buffer+0xa0a>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    467e:	2b a1       	ldd	r18, Y+35	; 0x23
    4680:	3c a1       	ldd	r19, Y+36	; 0x24
    4682:	4d a1       	ldd	r20, Y+37	; 0x25
    4684:	5e a1       	ldd	r21, Y+38	; 0x26
    4686:	6d a9       	ldd	r22, Y+53	; 0x35
    4688:	7e a9       	ldd	r23, Y+54	; 0x36
    468a:	80 2f       	mov	r24, r16
    468c:	91 2f       	mov	r25, r17
    468e:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    4692:	18 16       	cp	r1, r24
    4694:	8c f0       	brlt	.+34     	; 0x46b8 <st_prep_buffer+0x9de>
    4696:	8e a9       	ldd	r24, Y+54	; 0x36
    4698:	8f a3       	std	Y+39, r24	; 0x27
    469a:	8d 85       	ldd	r24, Y+13	; 0x0d
    469c:	9e 85       	ldd	r25, Y+14	; 0x0e
    469e:	af 85       	ldd	r26, Y+15	; 0x0f
    46a0:	b8 89       	ldd	r27, Y+16	; 0x10
    46a2:	ed e6       	ldi	r30, 0x6D	; 109
    46a4:	f1 e0       	ldi	r31, 0x01	; 1
    46a6:	80 83       	st	Z, r24
    46a8:	91 83       	std	Z+1, r25	; 0x01
    46aa:	a2 83       	std	Z+2, r26	; 0x02
    46ac:	b3 83       	std	Z+3, r27	; 0x03
    46ae:	e9 85       	ldd	r30, Y+9	; 0x09
    46b0:	a8 e6       	ldi	r26, 0x68	; 104
    46b2:	b1 e0       	ldi	r27, 0x01	; 1
    46b4:	ec 93       	st	X, r30
    46b6:	33 c0       	rjmp	.+102    	; 0x471e <st_prep_buffer+0xa44>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    46b8:	2e e3       	ldi	r18, 0x3E	; 62
    46ba:	33 ec       	ldi	r19, 0xC3	; 195
    46bc:	4e ea       	ldi	r20, 0xAE	; 174
    46be:	59 e3       	ldi	r21, 0x39	; 57
    46c0:	64 2d       	mov	r22, r4
    46c2:	75 2d       	mov	r23, r5
    46c4:	89 81       	ldd	r24, Y+1	; 0x01
    46c6:	9d 81       	ldd	r25, Y+5	; 0x05
    46c8:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    46cc:	46 2e       	mov	r4, r22
    46ce:	57 2e       	mov	r5, r23
    46d0:	89 83       	std	Y+1, r24	; 0x01
    46d2:	9d 83       	std	Y+5, r25	; 0x05
          time_var = dt_max - dt;
    46d4:	a7 01       	movw	r20, r14
    46d6:	96 01       	movw	r18, r12
    46d8:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    46dc:	26 2e       	mov	r2, r22
    46de:	67 2e       	mov	r6, r23
    46e0:	78 2e       	mov	r7, r24
    46e2:	39 2e       	mov	r3, r25
        } else { 
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    46e4:	29 89       	ldd	r18, Y+17	; 0x11
    46e6:	3a 89       	ldd	r19, Y+18	; 0x12
    46e8:	4b 89       	ldd	r20, Y+19	; 0x13
    46ea:	5c 89       	ldd	r21, Y+20	; 0x14
    46ec:	6d a9       	ldd	r22, Y+53	; 0x35
    46ee:	7e a9       	ldd	r23, Y+54	; 0x36
    46f0:	80 2f       	mov	r24, r16
    46f2:	91 2f       	mov	r25, r17
    46f4:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    46f8:	18 16       	cp	r1, r24
    46fa:	0c f4       	brge	.+2      	; 0x46fe <st_prep_buffer+0xa24>
    46fc:	4b ce       	rjmp	.-874    	; 0x4394 <st_prep_buffer+0x6ba>
    46fe:	8e a9       	ldd	r24, Y+54	; 0x36
    4700:	8f a3       	std	Y+39, r24	; 0x27
    4702:	8d 85       	ldd	r24, Y+13	; 0x0d
    4704:	9e 85       	ldd	r25, Y+14	; 0x0e
    4706:	af 85       	ldd	r26, Y+15	; 0x0f
    4708:	b8 89       	ldd	r27, Y+16	; 0x10
    470a:	ed e6       	ldi	r30, 0x6D	; 109
    470c:	f1 e0       	ldi	r31, 0x01	; 1
    470e:	80 83       	st	Z, r24
    4710:	91 83       	std	Z+1, r25	; 0x01
    4712:	a2 83       	std	Z+2, r26	; 0x02
    4714:	b3 83       	std	Z+3, r27	; 0x03
    4716:	e9 85       	ldd	r30, Y+9	; 0x09
    4718:	a8 e6       	ldi	r26, 0x68	; 104
    471a:	b1 e0       	ldi	r27, 0x01	; 1
    471c:	ec 93       	st	X, r30
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    471e:	ac e5       	ldi	r26, 0x5C	; 92
    4720:	b1 e0       	ldi	r27, 0x01	; 1
    4722:	2d 91       	ld	r18, X+
    4724:	3d 91       	ld	r19, X+
    4726:	4d 91       	ld	r20, X+
    4728:	5c 91       	ld	r21, X
    472a:	29 87       	std	Y+9, r18	; 0x09
    472c:	3a 87       	std	Y+10, r19	; 0x0a
    472e:	4b 87       	std	Y+11, r20	; 0x0b
    4730:	5c 87       	std	Y+12, r21	; 0x0c
    4732:	2d a9       	ldd	r18, Y+53	; 0x35
    4734:	3f a1       	ldd	r19, Y+39	; 0x27
    4736:	40 2f       	mov	r20, r16
    4738:	51 2f       	mov	r21, r17
    473a:	69 85       	ldd	r22, Y+9	; 0x09
    473c:	7a 85       	ldd	r23, Y+10	; 0x0a
    473e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4740:	9c 85       	ldd	r25, Y+12	; 0x0c
    4742:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    4746:	2b 01       	movw	r4, r22
    4748:	3c 01       	movw	r6, r24
    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining
    474a:	0e 94 87 3c 	call	0x790e	; 0x790e <ceil>
    474e:	6d 83       	std	Y+5, r22	; 0x05
    4750:	7e 83       	std	Y+6, r23	; 0x06
    4752:	8f 83       	std	Y+7, r24	; 0x07
    4754:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    4756:	e8 e5       	ldi	r30, 0x58	; 88
    4758:	f1 e0       	ldi	r31, 0x01	; 1
    475a:	60 81       	ld	r22, Z
    475c:	71 81       	ldd	r23, Z+1	; 0x01
    475e:	82 81       	ldd	r24, Z+2	; 0x02
    4760:	93 81       	ldd	r25, Z+3	; 0x03
    4762:	0e 94 87 3c 	call	0x790e	; 0x790e <ceil>
    4766:	4b 01       	movw	r8, r22
    4768:	5c 01       	movw	r10, r24
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    476a:	2d 81       	ldd	r18, Y+5	; 0x05
    476c:	3e 81       	ldd	r19, Y+6	; 0x06
    476e:	4f 81       	ldd	r20, Y+7	; 0x07
    4770:	58 85       	ldd	r21, Y+8	; 0x08
    4772:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    4776:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
    477a:	69 83       	std	Y+1, r22	; 0x01
    477c:	7a 83       	std	Y+2, r23	; 0x02
    477e:	8b 83       	std	Y+3, r24	; 0x03
    4780:	9c 83       	std	Y+4, r25	; 0x04
    4782:	e9 81       	ldd	r30, Y+1	; 0x01
    4784:	fa 81       	ldd	r31, Y+2	; 0x02
    4786:	ab a5       	ldd	r26, Y+43	; 0x2b
    4788:	bc a5       	ldd	r27, Y+44	; 0x2c
    478a:	ed 93       	st	X+, r30
    478c:	fc 93       	st	X, r31
    
    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    478e:	30 97       	sbiw	r30, 0x00	; 0
    4790:	91 f5       	brne	.+100    	; 0x47f6 <st_prep_buffer+0xb1c>
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    4792:	a8 e6       	ldi	r26, 0x68	; 104
    4794:	b7 e0       	ldi	r27, 0x07	; 7
    4796:	8c 91       	ld	r24, X
    4798:	80 77       	andi	r24, 0x70	; 112
    479a:	69 f1       	breq	.+90     	; 0x47f6 <st_prep_buffer+0xb1c>
    479c:	4d 80       	ldd	r4, Y+5	; 0x05
    479e:	5e 80       	ldd	r5, Y+6	; 0x06
    47a0:	6f 80       	ldd	r6, Y+7	; 0x07
    47a2:	78 84       	ldd	r7, Y+8	; 0x08
        // Less than one step to decelerate to zero speed, but already very close. AMASS 
        // requires full steps to execute. So, just bail.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    47a4:	10 92 6d 01 	sts	0x016D, r1
    47a8:	10 92 6e 01 	sts	0x016E, r1
    47ac:	10 92 6f 01 	sts	0x016F, r1
    47b0:	10 92 70 01 	sts	0x0170, r1
        prep.dt_remainder = 0.0;
    47b4:	10 92 64 01 	sts	0x0164, r1
    47b8:	10 92 65 01 	sts	0x0165, r1
    47bc:	10 92 66 01 	sts	0x0166, r1
    47c0:	10 92 67 01 	sts	0x0167, r1
        prep.steps_remaining = n_steps_remaining;
    47c4:	40 92 58 01 	sts	0x0158, r4
    47c8:	50 92 59 01 	sts	0x0159, r5
    47cc:	60 92 5a 01 	sts	0x015A, r6
    47d0:	70 92 5b 01 	sts	0x015B, r7
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    47d4:	29 85       	ldd	r18, Y+9	; 0x09
    47d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    47d8:	4b 85       	ldd	r20, Y+11	; 0x0b
    47da:	5c 85       	ldd	r21, Y+12	; 0x0c
    47dc:	c3 01       	movw	r24, r6
    47de:	b2 01       	movw	r22, r4
    47e0:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    47e4:	ed 89       	ldd	r30, Y+21	; 0x15
    47e6:	fe 89       	ldd	r31, Y+22	; 0x16
    47e8:	65 a3       	std	Z+37, r22	; 0x25
    47ea:	76 a3       	std	Z+38, r23	; 0x26
    47ec:	87 a3       	std	Z+39, r24	; 0x27
    47ee:	90 a7       	std	Z+40, r25	; 0x28
        plan_cycle_reinitialize();         
    47f0:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <plan_cycle_reinitialize>
        return; // Segment not generated, but current step data still retained.
    47f4:	05 c1       	rjmp	.+522    	; 0x4a00 <st_prep_buffer+0xd26>
    // compensate, we track the time to execute the previous segment's partial step and simply
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are 
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    47f6:	0f 2e       	mov	r0, r31
    47f8:	f4 e6       	ldi	r31, 0x64	; 100
    47fa:	2f 2e       	mov	r2, r31
    47fc:	f1 e0       	ldi	r31, 0x01	; 1
    47fe:	3f 2e       	mov	r3, r31
    4800:	f0 2d       	mov	r31, r0
    4802:	d1 01       	movw	r26, r2
    4804:	2d 91       	ld	r18, X+
    4806:	3d 91       	ld	r19, X+
    4808:	4d 91       	ld	r20, X+
    480a:	5c 91       	ld	r21, X
    480c:	c7 01       	movw	r24, r14
    480e:	b6 01       	movw	r22, r12
    4810:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    4814:	6b 01       	movw	r12, r22
    4816:	7c 01       	movw	r14, r24
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
    4818:	a3 01       	movw	r20, r6
    481a:	92 01       	movw	r18, r4
    481c:	c5 01       	movw	r24, r10
    481e:	b4 01       	movw	r22, r8
    4820:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    4824:	9b 01       	movw	r18, r22
    4826:	ac 01       	movw	r20, r24
    4828:	c7 01       	movw	r24, r14
    482a:	b6 01       	movw	r22, r12
    482c:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    4830:	6b 01       	movw	r12, r22
    4832:	7c 01       	movw	r14, r24
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time
    4834:	a3 01       	movw	r20, r6
    4836:	92 01       	movw	r18, r4
    4838:	6d 81       	ldd	r22, Y+5	; 0x05
    483a:	7e 81       	ldd	r23, Y+6	; 0x06
    483c:	8f 81       	ldd	r24, Y+7	; 0x07
    483e:	98 85       	ldd	r25, Y+8	; 0x08
    4840:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    4844:	a7 01       	movw	r20, r14
    4846:	96 01       	movw	r18, r12
    4848:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    484c:	f1 01       	movw	r30, r2
    484e:	60 83       	st	Z, r22
    4850:	71 83       	std	Z+1, r23	; 0x01
    4852:	82 83       	std	Z+2, r24	; 0x02
    4854:	93 83       	std	Z+3, r25	; 0x03

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)    
    4856:	2c ef       	ldi	r18, 0xFC	; 252
    4858:	3e eb       	ldi	r19, 0xBE	; 190
    485a:	40 e8       	ldi	r20, 0x80	; 128
    485c:	5e e4       	ldi	r21, 0x4E	; 78
    485e:	c7 01       	movw	r24, r14
    4860:	b6 01       	movw	r22, r12
    4862:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    4866:	0e 94 87 3c 	call	0x790e	; 0x790e <ceil>
    486a:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    486e:	61 15       	cp	r22, r1
    4870:	f9 e0       	ldi	r31, 0x09	; 9
    4872:	7f 07       	cpc	r23, r31
    4874:	81 05       	cpc	r24, r1
    4876:	91 05       	cpc	r25, r1
    4878:	28 f4       	brcc	.+10     	; 0x4884 <st_prep_buffer+0xbaa>
    487a:	ab a5       	ldd	r26, Y+43	; 0x2b
    487c:	bc a5       	ldd	r27, Y+44	; 0x2c
    487e:	15 96       	adiw	r26, 0x05	; 5
    4880:	1c 92       	st	X, r1
    4882:	31 c0       	rjmp	.+98     	; 0x48e6 <st_prep_buffer+0xc0c>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    4884:	61 15       	cp	r22, r1
    4886:	b2 e1       	ldi	r27, 0x12	; 18
    4888:	7b 07       	cpc	r23, r27
    488a:	81 05       	cpc	r24, r1
    488c:	91 05       	cpc	r25, r1
    488e:	28 f4       	brcc	.+10     	; 0x489a <st_prep_buffer+0xbc0>
    4890:	21 e0       	ldi	r18, 0x01	; 1
    4892:	eb a5       	ldd	r30, Y+43	; 0x2b
    4894:	fc a5       	ldd	r31, Y+44	; 0x2c
    4896:	25 83       	std	Z+5, r18	; 0x05
    4898:	10 c0       	rjmp	.+32     	; 0x48ba <st_prep_buffer+0xbe0>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    489a:	61 15       	cp	r22, r1
    489c:	f4 e2       	ldi	r31, 0x24	; 36
    489e:	7f 07       	cpc	r23, r31
    48a0:	81 05       	cpc	r24, r1
    48a2:	91 05       	cpc	r25, r1
    48a4:	30 f4       	brcc	.+12     	; 0x48b2 <st_prep_buffer+0xbd8>
    48a6:	22 e0       	ldi	r18, 0x02	; 2
    48a8:	ab a5       	ldd	r26, Y+43	; 0x2b
    48aa:	bc a5       	ldd	r27, Y+44	; 0x2c
    48ac:	15 96       	adiw	r26, 0x05	; 5
    48ae:	2c 93       	st	X, r18
    48b0:	04 c0       	rjmp	.+8      	; 0x48ba <st_prep_buffer+0xbe0>
        else { prep_segment->amass_level = 3; }    
    48b2:	23 e0       	ldi	r18, 0x03	; 3
    48b4:	eb a5       	ldd	r30, Y+43	; 0x2b
    48b6:	fc a5       	ldd	r31, Y+44	; 0x2c
    48b8:	25 83       	std	Z+5, r18	; 0x05
        cycles >>= prep_segment->amass_level; 
    48ba:	ab a5       	ldd	r26, Y+43	; 0x2b
    48bc:	bc a5       	ldd	r27, Y+44	; 0x2c
    48be:	15 96       	adiw	r26, 0x05	; 5
    48c0:	2c 91       	ld	r18, X
    48c2:	15 97       	sbiw	r26, 0x05	; 5
    48c4:	02 2e       	mov	r0, r18
    48c6:	04 c0       	rjmp	.+8      	; 0x48d0 <st_prep_buffer+0xbf6>
    48c8:	96 95       	lsr	r25
    48ca:	87 95       	ror	r24
    48cc:	77 95       	ror	r23
    48ce:	67 95       	ror	r22
    48d0:	0a 94       	dec	r0
    48d2:	d2 f7       	brpl	.-12     	; 0x48c8 <st_prep_buffer+0xbee>
        prep_segment->n_step <<= prep_segment->amass_level;
    48d4:	e9 81       	ldd	r30, Y+1	; 0x01
    48d6:	fa 81       	ldd	r31, Y+2	; 0x02
    48d8:	02 c0       	rjmp	.+4      	; 0x48de <st_prep_buffer+0xc04>
    48da:	ee 0f       	add	r30, r30
    48dc:	ff 1f       	adc	r31, r31
    48de:	2a 95       	dec	r18
    48e0:	e2 f7       	brpl	.-8      	; 0x48da <st_prep_buffer+0xc00>
    48e2:	ed 93       	st	X+, r30
    48e4:	fc 93       	st	X, r31
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    48e6:	61 15       	cp	r22, r1
    48e8:	71 05       	cpc	r23, r1
    48ea:	f1 e0       	ldi	r31, 0x01	; 1
    48ec:	8f 07       	cpc	r24, r31
    48ee:	91 05       	cpc	r25, r1
    48f0:	38 f4       	brcc	.+14     	; 0x4900 <st_prep_buffer+0xc26>
    48f2:	ab a5       	ldd	r26, Y+43	; 0x2b
    48f4:	bc a5       	ldd	r27, Y+44	; 0x2c
    48f6:	14 96       	adiw	r26, 0x04	; 4
    48f8:	7c 93       	st	X, r23
    48fa:	6e 93       	st	-X, r22
    48fc:	13 97       	sbiw	r26, 0x03	; 3
    48fe:	06 c0       	rjmp	.+12     	; 0x490c <st_prep_buffer+0xc32>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    4900:	8f ef       	ldi	r24, 0xFF	; 255
    4902:	9f ef       	ldi	r25, 0xFF	; 255
    4904:	eb a5       	ldd	r30, Y+43	; 0x2b
    4906:	fc a5       	ldd	r31, Y+44	; 0x2c
    4908:	94 83       	std	Z+4, r25	; 0x04
    490a:	83 83       	std	Z+3, r24	; 0x03
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices.
    segment_buffer_head = segment_next_head;
    490c:	80 91 88 01 	lds	r24, 0x0188
    4910:	80 93 89 01 	sts	0x0189, r24
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    4914:	8f 5f       	subi	r24, 0xFF	; 255
    4916:	86 30       	cpi	r24, 0x06	; 6
    4918:	19 f0       	breq	.+6      	; 0x4920 <st_prep_buffer+0xc46>
    491a:	80 93 88 01 	sts	0x0188, r24
    491e:	02 c0       	rjmp	.+4      	; 0x4924 <st_prep_buffer+0xc4a>
    4920:	10 92 88 01 	sts	0x0188, r1

    // Setup initial conditions for next segment.
    if (mm_remaining > prep.mm_complete) { 
    4924:	2d a9       	ldd	r18, Y+53	; 0x35
    4926:	3f a1       	ldd	r19, Y+39	; 0x27
    4928:	40 2f       	mov	r20, r16
    492a:	51 2f       	mov	r21, r17
    492c:	a9 e6       	ldi	r26, 0x69	; 105
    492e:	b1 e0       	ldi	r27, 0x01	; 1
    4930:	6d 91       	ld	r22, X+
    4932:	7d 91       	ld	r23, X+
    4934:	8d 91       	ld	r24, X+
    4936:	9c 91       	ld	r25, X
    4938:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    493c:	88 23       	and	r24, r24
    493e:	9c f4       	brge	.+38     	; 0x4966 <st_prep_buffer+0xc8c>
      // Normal operation. Block incomplete. Distance remaining in block to be executed.
      pl_block->millimeters = mm_remaining;      
    4940:	e0 91 83 01 	lds	r30, 0x0183
    4944:	f0 91 84 01 	lds	r31, 0x0184
    4948:	8d a9       	ldd	r24, Y+53	; 0x35
    494a:	9f a1       	ldd	r25, Y+39	; 0x27
    494c:	a0 2f       	mov	r26, r16
    494e:	b1 2f       	mov	r27, r17
    4950:	85 a3       	std	Z+37, r24	; 0x25
    4952:	96 a3       	std	Z+38, r25	; 0x26
    4954:	a7 a3       	std	Z+39, r26	; 0x27
    4956:	b0 a7       	std	Z+40, r27	; 0x28
      prep.steps_remaining = steps_remaining;  
    4958:	e8 e5       	ldi	r30, 0x58	; 88
    495a:	f1 e0       	ldi	r31, 0x01	; 1
    495c:	40 82       	st	Z, r4
    495e:	51 82       	std	Z+1, r5	; 0x01
    4960:	62 82       	std	Z+2, r6	; 0x02
    4962:	73 82       	std	Z+3, r7	; 0x03
    4964:	47 c0       	rjmp	.+142    	; 0x49f4 <st_prep_buffer+0xd1a>
    } else { 
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    4966:	20 e0       	ldi	r18, 0x00	; 0
    4968:	30 e0       	ldi	r19, 0x00	; 0
    496a:	a9 01       	movw	r20, r18
    496c:	6d a9       	ldd	r22, Y+53	; 0x35
    496e:	7f a1       	ldd	r23, Y+39	; 0x27
    4970:	80 2f       	mov	r24, r16
    4972:	91 2f       	mov	r25, r17
    4974:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    4978:	18 16       	cp	r1, r24
    497a:	b4 f5       	brge	.+108    	; 0x49e8 <st_prep_buffer+0xd0e>
    497c:	4d 80       	ldd	r4, Y+5	; 0x05
    497e:	5e 80       	ldd	r5, Y+6	; 0x06
    4980:	6f 80       	ldd	r6, Y+7	; 0x07
    4982:	78 84       	ldd	r7, Y+8	; 0x08
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the 
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    4984:	10 92 6d 01 	sts	0x016D, r1
    4988:	10 92 6e 01 	sts	0x016E, r1
    498c:	10 92 6f 01 	sts	0x016F, r1
    4990:	10 92 70 01 	sts	0x0170, r1
        prep.dt_remainder = 0.0;
    4994:	10 92 64 01 	sts	0x0164, r1
    4998:	10 92 65 01 	sts	0x0165, r1
    499c:	10 92 66 01 	sts	0x0166, r1
    49a0:	10 92 67 01 	sts	0x0167, r1
        prep.steps_remaining = ceil(steps_remaining);
    49a4:	40 92 58 01 	sts	0x0158, r4
    49a8:	50 92 59 01 	sts	0x0159, r5
    49ac:	60 92 5a 01 	sts	0x015A, r6
    49b0:	70 92 5b 01 	sts	0x015B, r7
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    49b4:	00 91 83 01 	lds	r16, 0x0183
    49b8:	10 91 84 01 	lds	r17, 0x0184
    49bc:	20 91 5c 01 	lds	r18, 0x015C
    49c0:	30 91 5d 01 	lds	r19, 0x015D
    49c4:	40 91 5e 01 	lds	r20, 0x015E
    49c8:	50 91 5f 01 	lds	r21, 0x015F
    49cc:	c3 01       	movw	r24, r6
    49ce:	b2 01       	movw	r22, r4
    49d0:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    49d4:	d8 01       	movw	r26, r16
    49d6:	95 96       	adiw	r26, 0x25	; 37
    49d8:	6d 93       	st	X+, r22
    49da:	7d 93       	st	X+, r23
    49dc:	8d 93       	st	X+, r24
    49de:	9c 93       	st	X, r25
    49e0:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize(); 
    49e2:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <plan_cycle_reinitialize>
        return; // Bail!
    49e6:	0c c0       	rjmp	.+24     	; 0x4a00 <st_prep_buffer+0xd26>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    49e8:	10 92 84 01 	sts	0x0184, r1
    49ec:	10 92 83 01 	sts	0x0183, r1
        plan_discard_current_block();
    49f0:	0e 94 53 2a 	call	0x54a6	; 0x54a6 <plan_discard_current_block>
  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    49f4:	90 91 8a 01 	lds	r25, 0x018A
    49f8:	80 91 88 01 	lds	r24, 0x0188
    49fc:	98 13       	cpse	r25, r24
    49fe:	9c c9       	rjmp	.-3272   	; 0x3d38 <st_prep_buffer+0x5e>
        plan_discard_current_block();
      }
    }

  } 
}      
    4a00:	e6 96       	adiw	r28, 0x36	; 54
    4a02:	0f b6       	in	r0, 0x3f	; 63
    4a04:	f8 94       	cli
    4a06:	de bf       	out	0x3e, r29	; 62
    4a08:	0f be       	out	0x3f, r0	; 63
    4a0a:	cd bf       	out	0x3d, r28	; 61
    4a0c:	df 91       	pop	r29
    4a0e:	cf 91       	pop	r28
    4a10:	1f 91       	pop	r17
    4a12:	0f 91       	pop	r16
    4a14:	ff 90       	pop	r15
    4a16:	ef 90       	pop	r14
    4a18:	df 90       	pop	r13
    4a1a:	cf 90       	pop	r12
    4a1c:	bf 90       	pop	r11
    4a1e:	af 90       	pop	r10
    4a20:	9f 90       	pop	r9
    4a22:	8f 90       	pop	r8
    4a24:	7f 90       	pop	r7
    4a26:	6f 90       	pop	r6
    4a28:	5f 90       	pop	r5
    4a2a:	4f 90       	pop	r4
    4a2c:	3f 90       	pop	r3
    4a2e:	2f 90       	pop	r2
    4a30:	08 95       	ret

00004a32 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4a32:	f9 99       	sbic	0x1f, 1	; 31
    4a34:	fe cf       	rjmp	.-4      	; 0x4a32 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    4a36:	92 bd       	out	0x22, r25	; 34
    4a38:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4a3a:	81 e0       	ldi	r24, 0x01	; 1
    4a3c:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    4a3e:	80 b5       	in	r24, 0x20	; 32
}
    4a40:	08 95       	ret

00004a42 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    4a42:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4a44:	f9 99       	sbic	0x1f, 1	; 31
    4a46:	fe cf       	rjmp	.-4      	; 0x4a44 <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    4a48:	92 bd       	out	0x22, r25	; 34
    4a4a:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4a4c:	81 e0       	ldi	r24, 0x01	; 1
    4a4e:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    4a50:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    4a52:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    4a54:	98 2f       	mov	r25, r24
    4a56:	96 23       	and	r25, r22
    4a58:	59 f0       	breq	.+22     	; 0x4a70 <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    4a5a:	6f 3f       	cpi	r22, 0xFF	; 255
    4a5c:	29 f0       	breq	.+10     	; 0x4a68 <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    4a5e:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a60:	84 e0       	ldi	r24, 0x04	; 4
    4a62:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    4a64:	f9 9a       	sbi	0x1f, 1	; 31
    4a66:	0a c0       	rjmp	.+20     	; 0x4a7c <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a68:	84 e1       	ldi	r24, 0x14	; 20
    4a6a:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    4a6c:	f9 9a       	sbi	0x1f, 1	; 31
    4a6e:	06 c0       	rjmp	.+12     	; 0x4a7c <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    4a70:	88 23       	and	r24, r24
    4a72:	21 f0       	breq	.+8      	; 0x4a7c <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    4a74:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4a76:	84 e2       	ldi	r24, 0x24	; 36
    4a78:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4a7a:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    4a7c:	78 94       	sei
    4a7e:	08 95       	ret

00004a80 <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    4a80:	8f 92       	push	r8
    4a82:	9f 92       	push	r9
    4a84:	af 92       	push	r10
    4a86:	bf 92       	push	r11
    4a88:	cf 92       	push	r12
    4a8a:	df 92       	push	r13
    4a8c:	ef 92       	push	r14
    4a8e:	ff 92       	push	r15
    4a90:	0f 93       	push	r16
    4a92:	1f 93       	push	r17
    4a94:	cf 93       	push	r28
    4a96:	df 93       	push	r29
    4a98:	6c 01       	movw	r12, r24
    4a9a:	8b 01       	movw	r16, r22
    4a9c:	5a 01       	movw	r10, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4a9e:	41 15       	cp	r20, r1
    4aa0:	51 05       	cpc	r21, r1
    4aa2:	11 f1       	breq	.+68     	; 0x4ae8 <memcpy_to_eeprom_with_checksum+0x68>
    4aa4:	ea 01       	movw	r28, r20

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4aa6:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    4aa8:	88 24       	eor	r8, r8
    4aaa:	83 94       	inc	r8
    4aac:	91 10       	cpse	r9, r1
    4aae:	09 c0       	rjmp	.+18     	; 0x4ac2 <memcpy_to_eeprom_with_checksum+0x42>
    4ab0:	69 2d       	mov	r22, r9
    4ab2:	77 27       	eor	r23, r23
    4ab4:	67 fd       	sbrc	r22, 7
    4ab6:	70 95       	com	r23
    4ab8:	97 2e       	mov	r9, r23
    4aba:	99 1c       	adc	r9, r9
    4abc:	99 24       	eor	r9, r9
    4abe:	99 1c       	adc	r9, r9
    4ac0:	01 c0       	rjmp	.+2      	; 0x4ac4 <memcpy_to_eeprom_with_checksum+0x44>
    4ac2:	98 2c       	mov	r9, r8
    checksum += *source;
    4ac4:	f8 01       	movw	r30, r16
    4ac6:	61 91       	ld	r22, Z+
    4ac8:	8f 01       	movw	r16, r30
    4aca:	96 0e       	add	r9, r22
    eeprom_put_char(destination++, *(source++)); 
    4acc:	7c 01       	movw	r14, r24
    4ace:	ff ef       	ldi	r31, 0xFF	; 255
    4ad0:	ef 1a       	sub	r14, r31
    4ad2:	ff 0a       	sbc	r15, r31
    4ad4:	0e 94 21 25 	call	0x4a42	; 0x4a42 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4ad8:	21 97       	sbiw	r28, 0x01	; 1
    4ada:	20 97       	sbiw	r28, 0x00	; 0
    4adc:	11 f0       	breq	.+4      	; 0x4ae2 <memcpy_to_eeprom_with_checksum+0x62>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    4ade:	c7 01       	movw	r24, r14
    4ae0:	e5 cf       	rjmp	.-54     	; 0x4aac <memcpy_to_eeprom_with_checksum+0x2c>
    4ae2:	ca 0c       	add	r12, r10
    4ae4:	db 1c       	adc	r13, r11
    4ae6:	01 c0       	rjmp	.+2      	; 0x4aea <memcpy_to_eeprom_with_checksum+0x6a>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4ae8:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    4aea:	69 2d       	mov	r22, r9
    4aec:	c6 01       	movw	r24, r12
    4aee:	0e 94 21 25 	call	0x4a42	; 0x4a42 <eeprom_put_char>
}
    4af2:	df 91       	pop	r29
    4af4:	cf 91       	pop	r28
    4af6:	1f 91       	pop	r17
    4af8:	0f 91       	pop	r16
    4afa:	ff 90       	pop	r15
    4afc:	ef 90       	pop	r14
    4afe:	df 90       	pop	r13
    4b00:	cf 90       	pop	r12
    4b02:	bf 90       	pop	r11
    4b04:	af 90       	pop	r10
    4b06:	9f 90       	pop	r9
    4b08:	8f 90       	pop	r8
    4b0a:	08 95       	ret

00004b0c <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    4b0c:	8f 92       	push	r8
    4b0e:	9f 92       	push	r9
    4b10:	af 92       	push	r10
    4b12:	bf 92       	push	r11
    4b14:	cf 92       	push	r12
    4b16:	df 92       	push	r13
    4b18:	ef 92       	push	r14
    4b1a:	ff 92       	push	r15
    4b1c:	0f 93       	push	r16
    4b1e:	1f 93       	push	r17
    4b20:	cf 93       	push	r28
    4b22:	df 93       	push	r29
    4b24:	6b 01       	movw	r12, r22
    4b26:	5a 01       	movw	r10, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4b28:	41 15       	cp	r20, r1
    4b2a:	51 05       	cpc	r21, r1
    4b2c:	29 f1       	breq	.+74     	; 0x4b78 <memcpy_from_eeprom_with_checksum+0x6c>
    4b2e:	08 2f       	mov	r16, r24
    4b30:	19 2f       	mov	r17, r25
    4b32:	ea 01       	movw	r28, r20
    4b34:	cb 01       	movw	r24, r22
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4b36:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    4b38:	88 24       	eor	r8, r8
    4b3a:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    4b3c:	7c 01       	movw	r14, r24
    4b3e:	2f ef       	ldi	r18, 0xFF	; 255
    4b40:	e2 1a       	sub	r14, r18
    4b42:	f2 0a       	sbc	r15, r18
    4b44:	0e 94 19 25 	call	0x4a32	; 0x4a32 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    4b48:	91 10       	cpse	r9, r1
    4b4a:	09 c0       	rjmp	.+18     	; 0x4b5e <memcpy_from_eeprom_with_checksum+0x52>
    4b4c:	29 2d       	mov	r18, r9
    4b4e:	33 27       	eor	r19, r19
    4b50:	27 fd       	sbrc	r18, 7
    4b52:	30 95       	com	r19
    4b54:	93 2e       	mov	r9, r19
    4b56:	99 1c       	adc	r9, r9
    4b58:	99 24       	eor	r9, r9
    4b5a:	99 1c       	adc	r9, r9
    4b5c:	01 c0       	rjmp	.+2      	; 0x4b60 <memcpy_from_eeprom_with_checksum+0x54>
    4b5e:	98 2c       	mov	r9, r8
    checksum += data;    
    4b60:	98 0e       	add	r9, r24
    *(destination++) = data; 
    4b62:	f8 01       	movw	r30, r16
    4b64:	81 93       	st	Z+, r24
    4b66:	8f 01       	movw	r16, r30
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4b68:	21 97       	sbiw	r28, 0x01	; 1
    4b6a:	20 97       	sbiw	r28, 0x00	; 0
    4b6c:	11 f0       	breq	.+4      	; 0x4b72 <memcpy_from_eeprom_with_checksum+0x66>
    data = eeprom_get_char(source++);
    4b6e:	c7 01       	movw	r24, r14
    4b70:	e5 cf       	rjmp	.-54     	; 0x4b3c <memcpy_from_eeprom_with_checksum+0x30>
    4b72:	ca 0c       	add	r12, r10
    4b74:	db 1c       	adc	r13, r11
    4b76:	01 c0       	rjmp	.+2      	; 0x4b7a <memcpy_from_eeprom_with_checksum+0x6e>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4b78:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4b7a:	c6 01       	movw	r24, r12
    4b7c:	0e 94 19 25 	call	0x4a32	; 0x4a32 <eeprom_get_char>
    4b80:	41 e0       	ldi	r20, 0x01	; 1
    4b82:	50 e0       	ldi	r21, 0x00	; 0
    4b84:	89 15       	cp	r24, r9
    4b86:	11 f0       	breq	.+4      	; 0x4b8c <memcpy_from_eeprom_with_checksum+0x80>
    4b88:	40 e0       	ldi	r20, 0x00	; 0
    4b8a:	50 e0       	ldi	r21, 0x00	; 0
}
    4b8c:	ca 01       	movw	r24, r20
    4b8e:	df 91       	pop	r29
    4b90:	cf 91       	pop	r28
    4b92:	1f 91       	pop	r17
    4b94:	0f 91       	pop	r16
    4b96:	ff 90       	pop	r15
    4b98:	ef 90       	pop	r14
    4b9a:	df 90       	pop	r13
    4b9c:	cf 90       	pop	r12
    4b9e:	bf 90       	pop	r11
    4ba0:	af 90       	pop	r10
    4ba2:	9f 90       	pop	r9
    4ba4:	8f 90       	pop	r8
    4ba6:	08 95       	ret

00004ba8 <settings_store_startup_line>:


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    4ba8:	21 e5       	ldi	r18, 0x51	; 81
    4baa:	82 9f       	mul	r24, r18
    4bac:	c0 01       	movw	r24, r0
    4bae:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    4bb0:	40 e5       	ldi	r20, 0x50	; 80
    4bb2:	50 e0       	ldi	r21, 0x00	; 0
    4bb4:	9d 5f       	subi	r25, 0xFD	; 253
    4bb6:	0e 94 40 25 	call	0x4a80	; 0x4a80 <memcpy_to_eeprom_with_checksum>
    4bba:	08 95       	ret

00004bbc <settings_store_build_info>:


// Method to store build info into EEPROM
void settings_store_build_info(char *line)
{
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    4bbc:	40 e5       	ldi	r20, 0x50	; 80
    4bbe:	50 e0       	ldi	r21, 0x00	; 0
    4bc0:	bc 01       	movw	r22, r24
    4bc2:	8e ea       	ldi	r24, 0xAE	; 174
    4bc4:	93 e0       	ldi	r25, 0x03	; 3
    4bc6:	0e 94 40 25 	call	0x4a80	; 0x4a80 <memcpy_to_eeprom_with_checksum>
    4bca:	08 95       	ret

00004bcc <settings_write_coord_data>:


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{  
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    4bcc:	2d e0       	ldi	r18, 0x0D	; 13
    4bce:	82 9f       	mul	r24, r18
    4bd0:	c0 01       	movw	r24, r0
    4bd2:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    4bd4:	4c e0       	ldi	r20, 0x0C	; 12
    4bd6:	50 e0       	ldi	r21, 0x00	; 0
    4bd8:	9e 5f       	subi	r25, 0xFE	; 254
    4bda:	0e 94 40 25 	call	0x4a80	; 0x4a80 <memcpy_to_eeprom_with_checksum>
    4bde:	08 95       	ret

00004be0 <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
void write_global_settings() 
{
  eeprom_put_char(0, SETTINGS_VERSION);
    4be0:	69 e0       	ldi	r22, 0x09	; 9
    4be2:	80 e0       	ldi	r24, 0x00	; 0
    4be4:	90 e0       	ldi	r25, 0x00	; 0
    4be6:	0e 94 21 25 	call	0x4a42	; 0x4a42 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    4bea:	45 e5       	ldi	r20, 0x55	; 85
    4bec:	50 e0       	ldi	r21, 0x00	; 0
    4bee:	6f ef       	ldi	r22, 0xFF	; 255
    4bf0:	78 e0       	ldi	r23, 0x08	; 8
    4bf2:	81 e0       	ldi	r24, 0x01	; 1
    4bf4:	90 e0       	ldi	r25, 0x00	; 0
    4bf6:	0e 94 40 25 	call	0x4a80	; 0x4a80 <memcpy_to_eeprom_with_checksum>
    4bfa:	08 95       	ret

00004bfc <settings_restore_global_settings>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults. 
void settings_restore_global_settings() {  
  settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
    4bfc:	8a e0       	ldi	r24, 0x0A	; 10
    4bfe:	80 93 2f 09 	sts	0x092F, r24
  settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
    4c02:	89 e1       	ldi	r24, 0x19	; 25
    4c04:	80 93 32 09 	sts	0x0932, r24
  settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
    4c08:	10 92 30 09 	sts	0x0930, r1
  settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
    4c0c:	10 92 31 09 	sts	0x0931, r1
  settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
    4c10:	83 e0       	ldi	r24, 0x03	; 3
    4c12:	80 93 33 09 	sts	0x0933, r24
  settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
    4c16:	8d ec       	ldi	r24, 0xCD	; 205
    4c18:	9c ec       	ldi	r25, 0xCC	; 204
    4c1a:	ac ec       	ldi	r26, 0xCC	; 204
    4c1c:	bd e3       	ldi	r27, 0x3D	; 61
    4c1e:	80 93 34 09 	sts	0x0934, r24
    4c22:	90 93 35 09 	sts	0x0935, r25
    4c26:	a0 93 36 09 	sts	0x0936, r26
    4c2a:	b0 93 37 09 	sts	0x0937, r27
  settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
    4c2e:	8a e0       	ldi	r24, 0x0A	; 10
    4c30:	97 ed       	ldi	r25, 0xD7	; 215
    4c32:	a3 ea       	ldi	r26, 0xA3	; 163
    4c34:	bc e3       	ldi	r27, 0x3C	; 60
    4c36:	80 93 38 09 	sts	0x0938, r24
    4c3a:	90 93 39 09 	sts	0x0939, r25
    4c3e:	a0 93 3a 09 	sts	0x093A, r26
    4c42:	b0 93 3b 09 	sts	0x093B, r27
  settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
    4c46:	10 92 3d 09 	sts	0x093D, r1
  settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
    4c4a:	80 e0       	ldi	r24, 0x00	; 0
    4c4c:	90 e0       	ldi	r25, 0x00	; 0
    4c4e:	a8 e4       	ldi	r26, 0x48	; 72
    4c50:	b3 e4       	ldi	r27, 0x43	; 67
    4c52:	80 93 3e 09 	sts	0x093E, r24
    4c56:	90 93 3f 09 	sts	0x093F, r25
    4c5a:	a0 93 40 09 	sts	0x0940, r26
    4c5e:	b0 93 41 09 	sts	0x0941, r27
  settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
    4c62:	80 e0       	ldi	r24, 0x00	; 0
    4c64:	90 e8       	ldi	r25, 0x80	; 128
    4c66:	ab eb       	ldi	r26, 0xBB	; 187
    4c68:	b4 e4       	ldi	r27, 0x44	; 68
    4c6a:	80 93 42 09 	sts	0x0942, r24
    4c6e:	90 93 43 09 	sts	0x0943, r25
    4c72:	a0 93 44 09 	sts	0x0944, r26
    4c76:	b0 93 45 09 	sts	0x0945, r27
  settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
    4c7a:	84 e6       	ldi	r24, 0x64	; 100
    4c7c:	90 e0       	ldi	r25, 0x00	; 0
    4c7e:	90 93 47 09 	sts	0x0947, r25
    4c82:	80 93 46 09 	sts	0x0946, r24
  settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
    4c86:	80 e0       	ldi	r24, 0x00	; 0
    4c88:	90 e0       	ldi	r25, 0x00	; 0
    4c8a:	a0 ea       	ldi	r26, 0xA0	; 160
    4c8c:	b0 e4       	ldi	r27, 0x40	; 64
    4c8e:	80 93 48 09 	sts	0x0948, r24
    4c92:	90 93 49 09 	sts	0x0949, r25
    4c96:	a0 93 4a 09 	sts	0x094A, r26
    4c9a:	b0 93 4b 09 	sts	0x094B, r27
  settings.z_zero_gauge = DEFAULT_Z_GAUGE;
    4c9e:	80 e0       	ldi	r24, 0x00	; 0
    4ca0:	90 e0       	ldi	r25, 0x00	; 0
    4ca2:	a0 e2       	ldi	r26, 0x20	; 32
    4ca4:	b1 e4       	ldi	r27, 0x41	; 65
    4ca6:	80 93 50 09 	sts	0x0950, r24
    4caa:	90 93 51 09 	sts	0x0951, r25
    4cae:	a0 93 52 09 	sts	0x0952, r26
    4cb2:	b0 93 53 09 	sts	0x0953, r27
  settings.z_zero_pulloff = DEFAULT_Z_PULLOFF;
    4cb6:	10 92 4c 09 	sts	0x094C, r1
    4cba:	10 92 4d 09 	sts	0x094D, r1
    4cbe:	10 92 4e 09 	sts	0x094E, r1
    4cc2:	10 92 4f 09 	sts	0x094F, r1
  if (DEFAULT_REPORT_INCHES) { settings.flags |= BITFLAG_REPORT_INCHES; }
  if (DEFAULT_INVERT_ST_ENABLE) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
  if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
  if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
  if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
  if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    4cc6:	88 e1       	ldi	r24, 0x18	; 24
    4cc8:	80 93 3c 09 	sts	0x093C, r24
  
  settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
    4ccc:	80 e0       	ldi	r24, 0x00	; 0
    4cce:	90 e0       	ldi	r25, 0x00	; 0
    4cd0:	a0 ea       	ldi	r26, 0xA0	; 160
    4cd2:	b2 e4       	ldi	r27, 0x42	; 66
    4cd4:	80 93 ff 08 	sts	0x08FF, r24
    4cd8:	90 93 00 09 	sts	0x0900, r25
    4cdc:	a0 93 01 09 	sts	0x0901, r26
    4ce0:	b0 93 02 09 	sts	0x0902, r27
  settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
    4ce4:	80 93 03 09 	sts	0x0903, r24
    4ce8:	90 93 04 09 	sts	0x0904, r25
    4cec:	a0 93 05 09 	sts	0x0905, r26
    4cf0:	b0 93 06 09 	sts	0x0906, r27
  settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
    4cf4:	80 e0       	ldi	r24, 0x00	; 0
    4cf6:	90 e0       	ldi	r25, 0x00	; 0
    4cf8:	a8 ec       	ldi	r26, 0xC8	; 200
    4cfa:	b2 e4       	ldi	r27, 0x42	; 66
    4cfc:	80 93 07 09 	sts	0x0907, r24
    4d00:	90 93 08 09 	sts	0x0908, r25
    4d04:	a0 93 09 09 	sts	0x0909, r26
    4d08:	b0 93 0a 09 	sts	0x090A, r27
  settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
    4d0c:	40 e0       	ldi	r20, 0x00	; 0
    4d0e:	50 e0       	ldi	r21, 0x00	; 0
    4d10:	68 ec       	ldi	r22, 0xC8	; 200
    4d12:	73 e4       	ldi	r23, 0x43	; 67
    4d14:	40 93 0b 09 	sts	0x090B, r20
    4d18:	50 93 0c 09 	sts	0x090C, r21
    4d1c:	60 93 0d 09 	sts	0x090D, r22
    4d20:	70 93 0e 09 	sts	0x090E, r23
  settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
    4d24:	40 93 0f 09 	sts	0x090F, r20
    4d28:	50 93 10 09 	sts	0x0910, r21
    4d2c:	60 93 11 09 	sts	0x0911, r22
    4d30:	70 93 12 09 	sts	0x0912, r23
  settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
    4d34:	80 93 13 09 	sts	0x0913, r24
    4d38:	90 93 14 09 	sts	0x0914, r25
    4d3c:	a0 93 15 09 	sts	0x0915, r26
    4d40:	b0 93 16 09 	sts	0x0916, r27
  settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
    4d44:	80 e0       	ldi	r24, 0x00	; 0
    4d46:	98 ec       	ldi	r25, 0xC8	; 200
    4d48:	af e2       	ldi	r26, 0x2F	; 47
    4d4a:	b9 e4       	ldi	r27, 0x49	; 73
    4d4c:	80 93 17 09 	sts	0x0917, r24
    4d50:	90 93 18 09 	sts	0x0918, r25
    4d54:	a0 93 19 09 	sts	0x0919, r26
    4d58:	b0 93 1a 09 	sts	0x091A, r27
  settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
    4d5c:	80 93 1b 09 	sts	0x091B, r24
    4d60:	90 93 1c 09 	sts	0x091C, r25
    4d64:	a0 93 1d 09 	sts	0x091D, r26
    4d68:	b0 93 1e 09 	sts	0x091E, r27
  settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
    4d6c:	80 93 1f 09 	sts	0x091F, r24
    4d70:	90 93 20 09 	sts	0x0920, r25
    4d74:	a0 93 21 09 	sts	0x0921, r26
    4d78:	b0 93 22 09 	sts	0x0922, r27
  settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
    4d7c:	80 e0       	ldi	r24, 0x00	; 0
    4d7e:	90 e0       	ldi	r25, 0x00	; 0
    4d80:	a8 e4       	ldi	r26, 0x48	; 72
    4d82:	b4 ec       	ldi	r27, 0xC4	; 196
    4d84:	80 93 23 09 	sts	0x0923, r24
    4d88:	90 93 24 09 	sts	0x0924, r25
    4d8c:	a0 93 25 09 	sts	0x0925, r26
    4d90:	b0 93 26 09 	sts	0x0926, r27
  settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
    4d94:	80 e0       	ldi	r24, 0x00	; 0
    4d96:	90 e0       	ldi	r25, 0x00	; 0
    4d98:	aa ef       	ldi	r26, 0xFA	; 250
    4d9a:	b3 ec       	ldi	r27, 0xC3	; 195
    4d9c:	80 93 27 09 	sts	0x0927, r24
    4da0:	90 93 28 09 	sts	0x0928, r25
    4da4:	a0 93 29 09 	sts	0x0929, r26
    4da8:	b0 93 2a 09 	sts	0x092A, r27
  settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    
    4dac:	80 e0       	ldi	r24, 0x00	; 0
    4dae:	90 e0       	ldi	r25, 0x00	; 0
    4db0:	a0 ef       	ldi	r26, 0xF0	; 240
    4db2:	b2 ec       	ldi	r27, 0xC2	; 194
    4db4:	80 93 2b 09 	sts	0x092B, r24
    4db8:	90 93 2c 09 	sts	0x092C, r25
    4dbc:	a0 93 2d 09 	sts	0x092D, r26
    4dc0:	b0 93 2e 09 	sts	0x092E, r27

  write_global_settings();
    4dc4:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <write_global_settings>
    4dc8:	08 95       	ret

00004dca <settings_clear_startup_lines>:


// Helper function to clear the EEPROM space containing the startup lines.
void settings_clear_startup_lines() {
  #if N_STARTUP_LINE > 0
  eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    4dca:	60 e0       	ldi	r22, 0x00	; 0
    4dcc:	80 e0       	ldi	r24, 0x00	; 0
    4dce:	93 e0       	ldi	r25, 0x03	; 3
    4dd0:	0e 94 21 25 	call	0x4a42	; 0x4a42 <eeprom_put_char>
  #endif
  #if N_STARTUP_LINE > 1
  eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    4dd4:	60 e0       	ldi	r22, 0x00	; 0
    4dd6:	81 e5       	ldi	r24, 0x51	; 81
    4dd8:	93 e0       	ldi	r25, 0x03	; 3
    4dda:	0e 94 21 25 	call	0x4a42	; 0x4a42 <eeprom_put_char>
    4dde:	08 95       	ret

00004de0 <settings_clear_build_info>:
  #endif
}


// Helper function to clear the EEPROM space containing the user build info string.
void settings_clear_build_info() { eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0); }
    4de0:	60 e0       	ldi	r22, 0x00	; 0
    4de2:	8e ea       	ldi	r24, 0xAE	; 174
    4de4:	93 e0       	ldi	r25, 0x03	; 3
    4de6:	0e 94 21 25 	call	0x4a42	; 0x4a42 <eeprom_put_char>
    4dea:	08 95       	ret

00004dec <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    4dec:	1f 93       	push	r17
    4dee:	cf 93       	push	r28
    4df0:	df 93       	push	r29
    4df2:	18 2f       	mov	r17, r24
    4df4:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    4df6:	81 e5       	ldi	r24, 0x51	; 81
    4df8:	18 9f       	mul	r17, r24
    4dfa:	b0 01       	movw	r22, r0
    4dfc:	11 24       	eor	r1, r1
    4dfe:	7d 5f       	subi	r23, 0xFD	; 253
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    4e00:	40 e5       	ldi	r20, 0x50	; 80
    4e02:	50 e0       	ldi	r21, 0x00	; 0
    4e04:	ce 01       	movw	r24, r28
    4e06:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <memcpy_from_eeprom_with_checksum>
    4e0a:	89 2b       	or	r24, r25
    4e0c:	39 f4       	brne	.+14     	; 0x4e1c <settings_read_startup_line+0x30>
    // Reset line with default value
    line[0] = 0; // Empty line
    4e0e:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    4e10:	be 01       	movw	r22, r28
    4e12:	81 2f       	mov	r24, r17
    4e14:	0e 94 d4 25 	call	0x4ba8	; 0x4ba8 <settings_store_startup_line>
    return(false);
    4e18:	80 e0       	ldi	r24, 0x00	; 0
    4e1a:	01 c0       	rjmp	.+2      	; 0x4e1e <settings_read_startup_line+0x32>
  }
  return(true);
    4e1c:	81 e0       	ldi	r24, 0x01	; 1
}
    4e1e:	df 91       	pop	r29
    4e20:	cf 91       	pop	r28
    4e22:	1f 91       	pop	r17
    4e24:	08 95       	ret

00004e26 <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    4e26:	cf 93       	push	r28
    4e28:	df 93       	push	r29
    4e2a:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    4e2c:	40 e5       	ldi	r20, 0x50	; 80
    4e2e:	50 e0       	ldi	r21, 0x00	; 0
    4e30:	6e ea       	ldi	r22, 0xAE	; 174
    4e32:	73 e0       	ldi	r23, 0x03	; 3
    4e34:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <memcpy_from_eeprom_with_checksum>
    4e38:	89 2b       	or	r24, r25
    4e3a:	31 f4       	brne	.+12     	; 0x4e48 <settings_read_build_info+0x22>
    // Reset line with default value
    line[0] = 0; // Empty line
    4e3c:	18 82       	st	Y, r1
    settings_store_build_info(line);
    4e3e:	ce 01       	movw	r24, r28
    4e40:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <settings_store_build_info>
    return(false);
    4e44:	80 e0       	ldi	r24, 0x00	; 0
    4e46:	01 c0       	rjmp	.+2      	; 0x4e4a <settings_read_build_info+0x24>
  }
  return(true);
    4e48:	81 e0       	ldi	r24, 0x01	; 1
}
    4e4a:	df 91       	pop	r29
    4e4c:	cf 91       	pop	r28
    4e4e:	08 95       	ret

00004e50 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    4e50:	1f 93       	push	r17
    4e52:	cf 93       	push	r28
    4e54:	df 93       	push	r29
    4e56:	18 2f       	mov	r17, r24
    4e58:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    4e5a:	8d e0       	ldi	r24, 0x0D	; 13
    4e5c:	18 9f       	mul	r17, r24
    4e5e:	b0 01       	movw	r22, r0
    4e60:	11 24       	eor	r1, r1
    4e62:	7e 5f       	subi	r23, 0xFE	; 254
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    4e64:	4c e0       	ldi	r20, 0x0C	; 12
    4e66:	50 e0       	ldi	r21, 0x00	; 0
    4e68:	ce 01       	movw	r24, r28
    4e6a:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <memcpy_from_eeprom_with_checksum>
    4e6e:	89 2b       	or	r24, r25
    4e70:	59 f4       	brne	.+22     	; 0x4e88 <settings_read_coord_data+0x38>
    // Reset with default zero vector
    clear_vector_float(coord_data); 
    4e72:	8c e0       	ldi	r24, 0x0C	; 12
    4e74:	fe 01       	movw	r30, r28
    4e76:	11 92       	st	Z+, r1
    4e78:	8a 95       	dec	r24
    4e7a:	e9 f7       	brne	.-6      	; 0x4e76 <settings_read_coord_data+0x26>
    settings_write_coord_data(coord_select,coord_data);
    4e7c:	be 01       	movw	r22, r28
    4e7e:	81 2f       	mov	r24, r17
    4e80:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <settings_write_coord_data>
    return(false);
    4e84:	80 e0       	ldi	r24, 0x00	; 0
    4e86:	01 c0       	rjmp	.+2      	; 0x4e8a <settings_read_coord_data+0x3a>
  }
  return(true);
    4e88:	81 e0       	ldi	r24, 0x01	; 1
}  
    4e8a:	df 91       	pop	r29
    4e8c:	cf 91       	pop	r28
    4e8e:	1f 91       	pop	r17
    4e90:	08 95       	ret

00004e92 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    4e92:	80 e0       	ldi	r24, 0x00	; 0
    4e94:	90 e0       	ldi	r25, 0x00	; 0
    4e96:	0e 94 19 25 	call	0x4a32	; 0x4a32 <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4e9a:	89 30       	cpi	r24, 0x09	; 9
    4e9c:	69 f4       	brne	.+26     	; 0x4eb8 <read_global_settings+0x26>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4e9e:	45 e5       	ldi	r20, 0x55	; 85
    4ea0:	50 e0       	ldi	r21, 0x00	; 0
    4ea2:	61 e0       	ldi	r22, 0x01	; 1
    4ea4:	70 e0       	ldi	r23, 0x00	; 0
    4ea6:	8f ef       	ldi	r24, 0xFF	; 255
    4ea8:	98 e0       	ldi	r25, 0x08	; 8
    4eaa:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <memcpy_from_eeprom_with_checksum>
    4eae:	21 e0       	ldi	r18, 0x01	; 1
    4eb0:	89 2b       	or	r24, r25
    4eb2:	19 f4       	brne	.+6      	; 0x4eba <read_global_settings+0x28>
    4eb4:	20 e0       	ldi	r18, 0x00	; 0
    4eb6:	01 c0       	rjmp	.+2      	; 0x4eba <read_global_settings+0x28>
      return(false);
    }
  } else {
    return(false); 
    4eb8:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    4eba:	82 2f       	mov	r24, r18
    4ebc:	08 95       	ret

00004ebe <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4ebe:	cf 92       	push	r12
    4ec0:	df 92       	push	r13
    4ec2:	ef 92       	push	r14
    4ec4:	ff 92       	push	r15
    4ec6:	cf 93       	push	r28
    4ec8:	df 93       	push	r29
    4eca:	d8 2f       	mov	r29, r24
    4ecc:	6a 01       	movw	r12, r20
    4ece:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    4ed0:	20 e0       	ldi	r18, 0x00	; 0
    4ed2:	30 e0       	ldi	r19, 0x00	; 0
    4ed4:	a9 01       	movw	r20, r18
    4ed6:	c7 01       	movw	r24, r14
    4ed8:	b6 01       	movw	r22, r12
    4eda:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    4ede:	88 23       	and	r24, r24
    4ee0:	0c f4       	brge	.+2      	; 0x4ee4 <settings_store_global_setting+0x26>
    4ee2:	ef c0       	rjmp	.+478    	; 0x50c2 <settings_store_global_setting+0x204>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    4ee4:	d4 36       	cpi	r29, 0x64	; 100
    4ee6:	a0 f0       	brcs	.+40     	; 0x4f10 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    4ee8:	ec e9       	ldi	r30, 0x9C	; 156
    4eea:	ed 0f       	add	r30, r29
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4eec:	e3 30       	cpi	r30, 0x03	; 3
    4eee:	20 f0       	brcs	.+8      	; 0x4ef8 <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ef0:	ea 30       	cpi	r30, 0x0A	; 10
    4ef2:	08 f0       	brcs	.+2      	; 0x4ef6 <settings_store_global_setting+0x38>
    4ef4:	f4 c0       	rjmp	.+488    	; 0x50de <settings_store_global_setting+0x220>
    4ef6:	e7 c0       	rjmp	.+462    	; 0x50c6 <settings_store_global_setting+0x208>
      if (parameter < N_AXIS) {
        // Valid axis setting found.
        switch (set_idx) {
          case 0:
            // if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.steps_per_mm[parameter] = value;
    4ef8:	f0 e0       	ldi	r31, 0x00	; 0
    4efa:	ee 0f       	add	r30, r30
    4efc:	ff 1f       	adc	r31, r31
    4efe:	ee 0f       	add	r30, r30
    4f00:	ff 1f       	adc	r31, r31
    4f02:	e1 50       	subi	r30, 0x01	; 1
    4f04:	f7 4f       	sbci	r31, 0xF7	; 247
    4f06:	c0 82       	st	Z, r12
    4f08:	d1 82       	std	Z+1, r13	; 0x01
    4f0a:	e2 82       	std	Z+2, r14	; 0x02
    4f0c:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4f0e:	d5 c0       	rjmp	.+426    	; 0x50ba <settings_store_global_setting+0x1fc>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    4f10:	c7 01       	movw	r24, r14
    4f12:	b6 01       	movw	r22, r12
    4f14:	0e 94 a6 3f 	call	0x7f4c	; 0x7f4c <trunc>
    4f18:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
    switch(parameter) {
    4f1c:	8d 2f       	mov	r24, r29
    4f1e:	90 e0       	ldi	r25, 0x00	; 0
    4f20:	80 32       	cpi	r24, 0x20	; 32
    4f22:	91 05       	cpc	r25, r1
    4f24:	08 f0       	brcs	.+2      	; 0x4f28 <settings_store_global_setting+0x6a>
    4f26:	d1 c0       	rjmp	.+418    	; 0x50ca <settings_store_global_setting+0x20c>
    4f28:	fc 01       	movw	r30, r24
    4f2a:	e5 52       	subi	r30, 0x25	; 37
    4f2c:	ff 4f       	sbci	r31, 0xFF	; 255
    4f2e:	0c 94 e7 3f 	jmp	0x7fce	; 0x7fce <__tablejump2__>
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4f32:	63 30       	cpi	r22, 0x03	; 3
    4f34:	08 f4       	brcc	.+2      	; 0x4f38 <settings_store_global_setting+0x7a>
    4f36:	cb c0       	rjmp	.+406    	; 0x50ce <settings_store_global_setting+0x210>
        settings.pulse_microseconds = int_value; break;
    4f38:	60 93 2f 09 	sts	0x092F, r22
    4f3c:	be c0       	rjmp	.+380    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4f3e:	60 93 32 09 	sts	0x0932, r22
    4f42:	bb c0       	rjmp	.+374    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 2: 
        settings.step_invert_mask = int_value; 
    4f44:	60 93 30 09 	sts	0x0930, r22
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4f48:	0e 94 b3 1d 	call	0x3b66	; 0x3b66 <st_generate_step_dir_invert_masks>
        break;
    4f4c:	b6 c0       	rjmp	.+364    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 3: 
        settings.dir_invert_mask = int_value; 
    4f4e:	60 93 31 09 	sts	0x0931, r22
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4f52:	0e 94 b3 1d 	call	0x3b66	; 0x3b66 <st_generate_step_dir_invert_masks>
        break;
    4f56:	b1 c0       	rjmp	.+354    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4f58:	66 23       	and	r22, r22
    4f5a:	31 f0       	breq	.+12     	; 0x4f68 <settings_store_global_setting+0xaa>
    4f5c:	ec e3       	ldi	r30, 0x3C	; 60
    4f5e:	f9 e0       	ldi	r31, 0x09	; 9
    4f60:	80 81       	ld	r24, Z
    4f62:	84 60       	ori	r24, 0x04	; 4
    4f64:	80 83       	st	Z, r24
    4f66:	a9 c0       	rjmp	.+338    	; 0x50ba <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4f68:	ec e3       	ldi	r30, 0x3C	; 60
    4f6a:	f9 e0       	ldi	r31, 0x09	; 9
    4f6c:	80 81       	ld	r24, Z
    4f6e:	8b 7f       	andi	r24, 0xFB	; 251
    4f70:	80 83       	st	Z, r24
    4f72:	a3 c0       	rjmp	.+326    	; 0x50ba <settings_store_global_setting+0x1fc>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4f74:	66 23       	and	r22, r22
    4f76:	31 f0       	breq	.+12     	; 0x4f84 <settings_store_global_setting+0xc6>
    4f78:	ec e3       	ldi	r30, 0x3C	; 60
    4f7a:	f9 e0       	ldi	r31, 0x09	; 9
    4f7c:	80 81       	ld	r24, Z
    4f7e:	80 64       	ori	r24, 0x40	; 64
    4f80:	80 83       	st	Z, r24
    4f82:	9b c0       	rjmp	.+310    	; 0x50ba <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4f84:	ec e3       	ldi	r30, 0x3C	; 60
    4f86:	f9 e0       	ldi	r31, 0x09	; 9
    4f88:	80 81       	ld	r24, Z
    4f8a:	8f 7b       	andi	r24, 0xBF	; 191
    4f8c:	80 83       	st	Z, r24
    4f8e:	95 c0       	rjmp	.+298    	; 0x50ba <settings_store_global_setting+0x1fc>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4f90:	66 23       	and	r22, r22
    4f92:	31 f0       	breq	.+12     	; 0x4fa0 <settings_store_global_setting+0xe2>
    4f94:	ec e3       	ldi	r30, 0x3C	; 60
    4f96:	f9 e0       	ldi	r31, 0x09	; 9
    4f98:	80 81       	ld	r24, Z
    4f9a:	80 68       	ori	r24, 0x80	; 128
    4f9c:	80 83       	st	Z, r24
    4f9e:	8d c0       	rjmp	.+282    	; 0x50ba <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4fa0:	ec e3       	ldi	r30, 0x3C	; 60
    4fa2:	f9 e0       	ldi	r31, 0x09	; 9
    4fa4:	80 81       	ld	r24, Z
    4fa6:	8f 77       	andi	r24, 0x7F	; 127
    4fa8:	80 83       	st	Z, r24
    4faa:	87 c0       	rjmp	.+270    	; 0x50ba <settings_store_global_setting+0x1fc>
        break;
      case 10: settings.status_report_mask = int_value; break;
    4fac:	60 93 33 09 	sts	0x0933, r22
    4fb0:	84 c0       	rjmp	.+264    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 11: settings.junction_deviation = value; break;
    4fb2:	c0 92 34 09 	sts	0x0934, r12
    4fb6:	d0 92 35 09 	sts	0x0935, r13
    4fba:	e0 92 36 09 	sts	0x0936, r14
    4fbe:	f0 92 37 09 	sts	0x0937, r15
    4fc2:	7b c0       	rjmp	.+246    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 12: settings.arc_tolerance = value; break;
    4fc4:	c0 92 38 09 	sts	0x0938, r12
    4fc8:	d0 92 39 09 	sts	0x0939, r13
    4fcc:	e0 92 3a 09 	sts	0x093A, r14
    4fd0:	f0 92 3b 09 	sts	0x093B, r15
    4fd4:	72 c0       	rjmp	.+228    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4fd6:	66 23       	and	r22, r22
    4fd8:	31 f0       	breq	.+12     	; 0x4fe6 <settings_store_global_setting+0x128>
    4fda:	ec e3       	ldi	r30, 0x3C	; 60
    4fdc:	f9 e0       	ldi	r31, 0x09	; 9
    4fde:	80 81       	ld	r24, Z
    4fe0:	81 60       	ori	r24, 0x01	; 1
    4fe2:	80 83       	st	Z, r24
    4fe4:	6a c0       	rjmp	.+212    	; 0x50ba <settings_store_global_setting+0x1fc>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    4fe6:	ec e3       	ldi	r30, 0x3C	; 60
    4fe8:	f9 e0       	ldi	r31, 0x09	; 9
    4fea:	80 81       	ld	r24, Z
    4fec:	8e 7f       	andi	r24, 0xFE	; 254
    4fee:	80 83       	st	Z, r24
    4ff0:	64 c0       	rjmp	.+200    	; 0x50ba <settings_store_global_setting+0x1fc>
        break;
      case 20:
        if (int_value) { 
    4ff2:	66 23       	and	r22, r22
    4ff4:	41 f0       	breq	.+16     	; 0x5006 <settings_store_global_setting+0x148>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4ff6:	80 91 3c 09 	lds	r24, 0x093C
    4ffa:	84 ff       	sbrs	r24, 4
    4ffc:	6a c0       	rjmp	.+212    	; 0x50d2 <settings_store_global_setting+0x214>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; 
    4ffe:	80 62       	ori	r24, 0x20	; 32
    5000:	80 93 3c 09 	sts	0x093C, r24
    5004:	5a c0       	rjmp	.+180    	; 0x50ba <settings_store_global_setting+0x1fc>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    5006:	ec e3       	ldi	r30, 0x3C	; 60
    5008:	f9 e0       	ldi	r31, 0x09	; 9
    500a:	80 81       	ld	r24, Z
    500c:	8f 7d       	andi	r24, 0xDF	; 223
    500e:	80 83       	st	Z, r24
    5010:	54 c0       	rjmp	.+168    	; 0x50ba <settings_store_global_setting+0x1fc>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    5012:	66 23       	and	r22, r22
    5014:	31 f0       	breq	.+12     	; 0x5022 <settings_store_global_setting+0x164>
    5016:	ec e3       	ldi	r30, 0x3C	; 60
    5018:	f9 e0       	ldi	r31, 0x09	; 9
    501a:	80 81       	ld	r24, Z
    501c:	88 60       	ori	r24, 0x08	; 8
    501e:	80 83       	st	Z, r24
    5020:	05 c0       	rjmp	.+10     	; 0x502c <settings_store_global_setting+0x16e>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    5022:	ec e3       	ldi	r30, 0x3C	; 60
    5024:	f9 e0       	ldi	r31, 0x09	; 9
    5026:	80 81       	ld	r24, Z
    5028:	87 7f       	andi	r24, 0xF7	; 247
    502a:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    502c:	0e 94 45 2f 	call	0x5e8a	; 0x5e8a <limits_init>
        break;
    5030:	44 c0       	rjmp	.+136    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    5032:	66 23       	and	r22, r22
    5034:	31 f0       	breq	.+12     	; 0x5042 <settings_store_global_setting+0x184>
    5036:	ec e3       	ldi	r30, 0x3C	; 60
    5038:	f9 e0       	ldi	r31, 0x09	; 9
    503a:	80 81       	ld	r24, Z
    503c:	80 61       	ori	r24, 0x10	; 16
    503e:	80 83       	st	Z, r24
    5040:	3c c0       	rjmp	.+120    	; 0x50ba <settings_store_global_setting+0x1fc>
        else { 
          settings.flags &= ~BITFLAG_HOMING_ENABLE; 
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    5042:	ec e3       	ldi	r30, 0x3C	; 60
    5044:	f9 e0       	ldi	r31, 0x09	; 9
    5046:	80 81       	ld	r24, Z
    5048:	8f 7c       	andi	r24, 0xCF	; 207
    504a:	80 83       	st	Z, r24
    504c:	36 c0       	rjmp	.+108    	; 0x50ba <settings_store_global_setting+0x1fc>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    504e:	60 93 3d 09 	sts	0x093D, r22
    5052:	33 c0       	rjmp	.+102    	; 0x50ba <settings_store_global_setting+0x1fc>
      case 24: settings.homing_feed_rate = value; break;
    5054:	c0 92 3e 09 	sts	0x093E, r12
    5058:	d0 92 3f 09 	sts	0x093F, r13
    505c:	e0 92 40 09 	sts	0x0940, r14
    5060:	f0 92 41 09 	sts	0x0941, r15
    5064:	2a c0       	rjmp	.+84     	; 0x50ba <settings_store_global_setting+0x1fc>
      case 25: settings.homing_seek_rate = value; break;
    5066:	c0 92 42 09 	sts	0x0942, r12
    506a:	d0 92 43 09 	sts	0x0943, r13
    506e:	e0 92 44 09 	sts	0x0944, r14
    5072:	f0 92 45 09 	sts	0x0945, r15
    5076:	21 c0       	rjmp	.+66     	; 0x50ba <settings_store_global_setting+0x1fc>
      case 26: settings.homing_debounce_delay = int_value; break;
    5078:	86 2f       	mov	r24, r22
    507a:	90 e0       	ldi	r25, 0x00	; 0
    507c:	90 93 47 09 	sts	0x0947, r25
    5080:	80 93 46 09 	sts	0x0946, r24
    5084:	1a c0       	rjmp	.+52     	; 0x50ba <settings_store_global_setting+0x1fc>
      case 27: settings.homing_pulloff = value; break;
    5086:	c0 92 48 09 	sts	0x0948, r12
    508a:	d0 92 49 09 	sts	0x0949, r13
    508e:	e0 92 4a 09 	sts	0x094A, r14
    5092:	f0 92 4b 09 	sts	0x094B, r15
    5096:	11 c0       	rjmp	.+34     	; 0x50ba <settings_store_global_setting+0x1fc>
	  case 30: settings.z_zero_gauge = value; break;
    5098:	c0 92 50 09 	sts	0x0950, r12
    509c:	d0 92 51 09 	sts	0x0951, r13
    50a0:	e0 92 52 09 	sts	0x0952, r14
    50a4:	f0 92 53 09 	sts	0x0953, r15
    50a8:	08 c0       	rjmp	.+16     	; 0x50ba <settings_store_global_setting+0x1fc>
	  case 31: settings.z_zero_pulloff = value; break;
    50aa:	c0 92 4c 09 	sts	0x094C, r12
    50ae:	d0 92 4d 09 	sts	0x094D, r13
    50b2:	e0 92 4e 09 	sts	0x094E, r14
    50b6:	f0 92 4f 09 	sts	0x094F, r15
      default: 
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    50ba:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <write_global_settings>
  return(STATUS_OK);
    50be:	80 e0       	ldi	r24, 0x00	; 0
    50c0:	56 c0       	rjmp	.+172    	; 0x516e <settings_store_global_setting+0x2b0>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    50c2:	84 e0       	ldi	r24, 0x04	; 4
    50c4:	54 c0       	rjmp	.+168    	; 0x516e <settings_store_global_setting+0x2b0>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50c6:	83 e0       	ldi	r24, 0x03	; 3
    50c8:	52 c0       	rjmp	.+164    	; 0x516e <settings_store_global_setting+0x2b0>
      case 26: settings.homing_debounce_delay = int_value; break;
      case 27: settings.homing_pulloff = value; break;
	  case 30: settings.z_zero_gauge = value; break;
	  case 31: settings.z_zero_pulloff = value; break;
      default: 
        return(STATUS_INVALID_STATEMENT);
    50ca:	83 e0       	ldi	r24, 0x03	; 3
    50cc:	50 c0       	rjmp	.+160    	; 0x516e <settings_store_global_setting+0x2b0>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    50ce:	86 e0       	ldi	r24, 0x06	; 6
    50d0:	4e c0       	rjmp	.+156    	; 0x516e <settings_store_global_setting+0x2b0>
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        break;
      case 20:
        if (int_value) { 
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    50d2:	8a e0       	ldi	r24, 0x0A	; 10
    50d4:	4c c0       	rjmp	.+152    	; 0x516e <settings_store_global_setting+0x2b0>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50d6:	83 e0       	ldi	r24, 0x03	; 3
    50d8:	4a c0       	rjmp	.+148    	; 0x516e <settings_store_global_setting+0x2b0>
    50da:	83 e0       	ldi	r24, 0x03	; 3
    50dc:	48 c0       	rjmp	.+144    	; 0x516e <settings_store_global_setting+0x2b0>
        parameter -= AXIS_SETTINGS_INCREMENT;
    50de:	e2 e9       	ldi	r30, 0x92	; 146
    50e0:	ed 0f       	add	r30, r29
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    50e2:	e3 30       	cpi	r30, 0x03	; 3
    50e4:	68 f0       	brcs	.+26     	; 0x5100 <settings_store_global_setting+0x242>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50e6:	ea 30       	cpi	r30, 0x0A	; 10
    50e8:	b0 f3       	brcs	.-20     	; 0x50d6 <settings_store_global_setting+0x218>
        parameter -= AXIS_SETTINGS_INCREMENT;
    50ea:	c8 e8       	ldi	r28, 0x88	; 136
    50ec:	cd 0f       	add	r28, r29
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    50ee:	c3 30       	cpi	r28, 0x03	; 3
    50f0:	98 f0       	brcs	.+38     	; 0x5118 <settings_store_global_setting+0x25a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50f2:	ca 30       	cpi	r28, 0x0A	; 10
    50f4:	90 f3       	brcs	.-28     	; 0x50da <settings_store_global_setting+0x21c>
        parameter -= AXIS_SETTINGS_INCREMENT;
    50f6:	d2 58       	subi	r29, 0x82	; 130
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    50f8:	d3 30       	cpi	r29, 0x03	; 3
    50fa:	40 f1       	brcs	.+80     	; 0x514c <settings_store_global_setting+0x28e>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    50fc:	83 e0       	ldi	r24, 0x03	; 3
    50fe:	37 c0       	rjmp	.+110    	; 0x516e <settings_store_global_setting+0x2b0>
            // if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.steps_per_mm[parameter] = value;
            break;
          case 1:
            // if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            settings.max_rate[parameter] = value;
    5100:	f0 e0       	ldi	r31, 0x00	; 0
    5102:	ee 0f       	add	r30, r30
    5104:	ff 1f       	adc	r31, r31
    5106:	ee 0f       	add	r30, r30
    5108:	ff 1f       	adc	r31, r31
    510a:	e5 5f       	subi	r30, 0xF5	; 245
    510c:	f6 4f       	sbci	r31, 0xF6	; 246
    510e:	c0 82       	st	Z, r12
    5110:	d1 82       	std	Z+1, r13	; 0x01
    5112:	e2 82       	std	Z+2, r14	; 0x02
    5114:	f3 82       	std	Z+3, r15	; 0x03
            break;
    5116:	d1 cf       	rjmp	.-94     	; 0x50ba <settings_store_global_setting+0x1fc>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    5118:	d0 e0       	ldi	r29, 0x00	; 0
    511a:	cc 0f       	add	r28, r28
    511c:	dd 1f       	adc	r29, r29
    511e:	cc 0f       	add	r28, r28
    5120:	dd 1f       	adc	r29, r29
    5122:	c9 5e       	subi	r28, 0xE9	; 233
    5124:	d6 4f       	sbci	r29, 0xF6	; 246
    5126:	20 e0       	ldi	r18, 0x00	; 0
    5128:	30 e0       	ldi	r19, 0x00	; 0
    512a:	40 e7       	ldi	r20, 0x70	; 112
    512c:	52 e4       	ldi	r21, 0x42	; 66
    512e:	c7 01       	movw	r24, r14
    5130:	b6 01       	movw	r22, r12
    5132:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5136:	20 e0       	ldi	r18, 0x00	; 0
    5138:	30 e0       	ldi	r19, 0x00	; 0
    513a:	40 e7       	ldi	r20, 0x70	; 112
    513c:	52 e4       	ldi	r21, 0x42	; 66
    513e:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5142:	68 83       	st	Y, r22
    5144:	79 83       	std	Y+1, r23	; 0x01
    5146:	8a 83       	std	Y+2, r24	; 0x02
    5148:	9b 83       	std	Y+3, r25	; 0x03
    514a:	b7 cf       	rjmp	.-146    	; 0x50ba <settings_store_global_setting+0x1fc>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    514c:	ed 2f       	mov	r30, r29
    514e:	f0 e0       	ldi	r31, 0x00	; 0
    5150:	ee 0f       	add	r30, r30
    5152:	ff 1f       	adc	r31, r31
    5154:	ee 0f       	add	r30, r30
    5156:	ff 1f       	adc	r31, r31
    5158:	ed 5d       	subi	r30, 0xDD	; 221
    515a:	f6 4f       	sbci	r31, 0xF6	; 246
    515c:	f7 fa       	bst	r15, 7
    515e:	f0 94       	com	r15
    5160:	f7 f8       	bld	r15, 7
    5162:	f0 94       	com	r15
    5164:	c0 82       	st	Z, r12
    5166:	d1 82       	std	Z+1, r13	; 0x01
    5168:	e2 82       	std	Z+2, r14	; 0x02
    516a:	f3 82       	std	Z+3, r15	; 0x03
    516c:	a6 cf       	rjmp	.-180    	; 0x50ba <settings_store_global_setting+0x1fc>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    516e:	df 91       	pop	r29
    5170:	cf 91       	pop	r28
    5172:	ff 90       	pop	r15
    5174:	ef 90       	pop	r14
    5176:	df 90       	pop	r13
    5178:	cf 90       	pop	r12
    517a:	08 95       	ret

0000517c <settings_init>:


// Initialize the config subsystem
void settings_init() {
    517c:	1f 93       	push	r17
    517e:	cf 93       	push	r28
    5180:	df 93       	push	r29
    5182:	cd b7       	in	r28, 0x3d	; 61
    5184:	de b7       	in	r29, 0x3e	; 62
    5186:	2c 97       	sbiw	r28, 0x0c	; 12
    5188:	0f b6       	in	r0, 0x3f	; 63
    518a:	f8 94       	cli
    518c:	de bf       	out	0x3e, r29	; 62
    518e:	0f be       	out	0x3f, r0	; 63
    5190:	cd bf       	out	0x3d, r28	; 61
  if(!read_global_settings()) {
    5192:	0e 94 49 27 	call	0x4e92	; 0x4e92 <read_global_settings>
    5196:	81 11       	cpse	r24, r1
    5198:	1b c0       	rjmp	.+54     	; 0x51d0 <settings_init+0x54>
    report_status_message(STATUS_SETTING_READ_FAIL);
    519a:	87 e0       	ldi	r24, 0x07	; 7
    519c:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>

    settings_restore_global_settings();
    51a0:	0e 94 fe 25 	call	0x4bfc	; 0x4bfc <settings_restore_global_settings>
    
    // Force clear startup lines and build info user data. Parameters should be ok.
    // TODO: For next version, remove these clears. Only here because line buffer increased.
    settings_clear_startup_lines();
    51a4:	0e 94 e5 26 	call	0x4dca	; 0x4dca <settings_clear_startup_lines>
    settings_clear_build_info();
    51a8:	0e 94 f0 26 	call	0x4de0	; 0x4de0 <settings_clear_build_info>
    
    report_grbl_settings();
    51ac:	0e 94 2e 35 	call	0x6a5c	; 0x6a5c <report_grbl_settings>
    51b0:	0f c0       	rjmp	.+30     	; 0x51d0 <settings_init+0x54>

  // Check all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.
  float coord_data[N_AXIS];
  uint8_t i;
  for (i=0; i<=SETTING_INDEX_NCOORD; i++) {
    if (!settings_read_coord_data(i, coord_data)) {
    51b2:	be 01       	movw	r22, r28
    51b4:	6f 5f       	subi	r22, 0xFF	; 255
    51b6:	7f 4f       	sbci	r23, 0xFF	; 255
    51b8:	81 2f       	mov	r24, r17
    51ba:	0e 94 28 27 	call	0x4e50	; 0x4e50 <settings_read_coord_data>
    51be:	81 11       	cpse	r24, r1
    51c0:	03 c0       	rjmp	.+6      	; 0x51c8 <settings_init+0x4c>
      report_status_message(STATUS_SETTING_READ_FAIL);
    51c2:	87 e0       	ldi	r24, 0x07	; 7
    51c4:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
  }

  // Check all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.
  float coord_data[N_AXIS];
  uint8_t i;
  for (i=0; i<=SETTING_INDEX_NCOORD; i++) {
    51c8:	1f 5f       	subi	r17, 0xFF	; 255
    51ca:	18 30       	cpi	r17, 0x08	; 8
    51cc:	91 f7       	brne	.-28     	; 0x51b2 <settings_init+0x36>
    51ce:	02 c0       	rjmp	.+4      	; 0x51d4 <settings_init+0x58>
  return(STATUS_OK);
}


// Initialize the config subsystem
void settings_init() {
    51d0:	10 e0       	ldi	r17, 0x00	; 0
    51d2:	ef cf       	rjmp	.-34     	; 0x51b2 <settings_init+0x36>
      report_status_message(STATUS_SETTING_READ_FAIL);
    }
  }
  // NOTE: Startup lines are checked and executed by protocol_main_loop at the end of initialization.
  // TODO: Build info should be checked here, but will wait until v1.0 to address this. Ok for now.
}
    51d4:	2c 96       	adiw	r28, 0x0c	; 12
    51d6:	0f b6       	in	r0, 0x3f	; 63
    51d8:	f8 94       	cli
    51da:	de bf       	out	0x3e, r29	; 62
    51dc:	0f be       	out	0x3f, r0	; 63
    51de:	cd bf       	out	0x3d, r28	; 61
    51e0:	df 91       	pop	r29
    51e2:	cf 91       	pop	r28
    51e4:	1f 91       	pop	r17
    51e6:	08 95       	ret

000051e8 <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    51e8:	88 23       	and	r24, r24
    51ea:	21 f0       	breq	.+8      	; 0x51f4 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    51ec:	81 30       	cpi	r24, 0x01	; 1
    51ee:	21 f4       	brne	.+8      	; 0x51f8 <get_step_pin_mask+0x10>
    51f0:	80 e1       	ldi	r24, 0x10	; 16
    51f2:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    51f4:	80 e4       	ldi	r24, 0x40	; 64
    51f6:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
  return((1<<Z_STEP_BIT));
    51f8:	84 e0       	ldi	r24, 0x04	; 4
}
    51fa:	08 95       	ret

000051fc <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    51fc:	88 23       	and	r24, r24
    51fe:	21 f0       	breq	.+8      	; 0x5208 <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    5200:	81 30       	cpi	r24, 0x01	; 1
    5202:	21 f4       	brne	.+8      	; 0x520c <get_direction_pin_mask+0x10>
    5204:	80 e2       	ldi	r24, 0x20	; 32
    5206:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    5208:	80 e8       	ldi	r24, 0x80	; 128
    520a:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
  return((1<<Z_DIRECTION_BIT));
    520c:	88 e0       	ldi	r24, 0x08	; 8
}
    520e:	08 95       	ret

00005210 <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    5210:	88 23       	and	r24, r24
    5212:	21 f0       	breq	.+8      	; 0x521c <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    5214:	81 30       	cpi	r24, 0x01	; 1
    5216:	21 f4       	brne	.+8      	; 0x5220 <get_limit_pin_mask+0x10>
    5218:	84 e0       	ldi	r24, 0x04	; 4
    521a:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    521c:	82 e0       	ldi	r24, 0x02	; 2
    521e:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
  return((1<<Z_LIMIT_BIT));
    5220:	88 e0       	ldi	r24, 0x08	; 8
}
    5222:	08 95       	ret

00005224 <planner_recalculate>:
  to compute an optimal plan, so select carefully. The Arduino 328p memory is already maxed out, but future
  ARM versions should have enough memory and speed for look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate() 
{   
    5224:	3f 92       	push	r3
    5226:	4f 92       	push	r4
    5228:	5f 92       	push	r5
    522a:	6f 92       	push	r6
    522c:	7f 92       	push	r7
    522e:	8f 92       	push	r8
    5230:	9f 92       	push	r9
    5232:	af 92       	push	r10
    5234:	bf 92       	push	r11
    5236:	cf 92       	push	r12
    5238:	df 92       	push	r13
    523a:	ef 92       	push	r14
    523c:	ff 92       	push	r15
    523e:	0f 93       	push	r16
    5240:	1f 93       	push	r17
    5242:	cf 93       	push	r28
    5244:	df 93       	push	r29
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
    5246:	80 91 45 02 	lds	r24, 0x0245


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    524a:	81 11       	cpse	r24, r1
    524c:	01 c0       	rjmp	.+2      	; 0x5250 <planner_recalculate+0x2c>
    524e:	80 e2       	ldi	r24, 0x20	; 32
  block_index--;
    5250:	77 24       	eor	r7, r7
    5252:	7a 94       	dec	r7
    5254:	78 0e       	add	r7, r24
{   
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
        
  // Bail. Can't do anything with one only one plan-able block.
  if (block_index == block_buffer_planned) { return; }
    5256:	c0 91 43 02 	lds	r28, 0x0243
    525a:	c7 15       	cp	r28, r7
    525c:	09 f4       	brne	.+2      	; 0x5260 <planner_recalculate+0x3c>
    525e:	00 c1       	rjmp	.+512    	; 0x5460 <planner_recalculate+0x23c>
  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
  float entry_speed_sqr;
  plan_block_t *next;
  plan_block_t *current = &block_buffer[block_index];
    5260:	89 e2       	ldi	r24, 0x29	; 41
    5262:	78 9e       	mul	r7, r24
    5264:	80 01       	movw	r16, r0
    5266:	11 24       	eor	r1, r1
    5268:	09 5b       	subi	r16, 0xB9	; 185
    526a:	1d 4f       	sbci	r17, 0xFD	; 253

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
    526c:	f8 01       	movw	r30, r16
    526e:	95 88       	ldd	r9, Z+21	; 0x15
    5270:	a6 88       	ldd	r10, Z+22	; 0x16
    5272:	b7 88       	ldd	r11, Z+23	; 0x17
    5274:	c0 8c       	ldd	r12, Z+24	; 0x18
    5276:	61 a1       	ldd	r22, Z+33	; 0x21
    5278:	72 a1       	ldd	r23, Z+34	; 0x22
    527a:	83 a1       	ldd	r24, Z+35	; 0x23
    527c:	94 a1       	ldd	r25, Z+36	; 0x24
    527e:	9b 01       	movw	r18, r22
    5280:	ac 01       	movw	r20, r24
    5282:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    5286:	f8 01       	movw	r30, r16
    5288:	25 a1       	ldd	r18, Z+37	; 0x25
    528a:	36 a1       	ldd	r19, Z+38	; 0x26
    528c:	47 a1       	ldd	r20, Z+39	; 0x27
    528e:	50 a5       	ldd	r21, Z+40	; 0x28
    5290:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5294:	d6 2e       	mov	r13, r22
    5296:	e7 2e       	mov	r14, r23
    5298:	f8 2e       	mov	r15, r24
    529a:	d9 2f       	mov	r29, r25
    529c:	26 2f       	mov	r18, r22
    529e:	37 2f       	mov	r19, r23
    52a0:	48 2f       	mov	r20, r24
    52a2:	59 2f       	mov	r21, r25
    52a4:	69 2d       	mov	r22, r9
    52a6:	7a 2d       	mov	r23, r10
    52a8:	8b 2d       	mov	r24, r11
    52aa:	9c 2d       	mov	r25, r12
    52ac:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    52b0:	88 23       	and	r24, r24
    52b2:	24 f4       	brge	.+8      	; 0x52bc <planner_recalculate+0x98>
    52b4:	d9 2c       	mov	r13, r9
    52b6:	ea 2c       	mov	r14, r10
    52b8:	fb 2c       	mov	r15, r11
    52ba:	dc 2d       	mov	r29, r12
    52bc:	4d 2d       	mov	r20, r13
    52be:	5e 2d       	mov	r21, r14
    52c0:	6f 2d       	mov	r22, r15
    52c2:	7d 2f       	mov	r23, r29
    52c4:	f8 01       	movw	r30, r16
    52c6:	41 8b       	std	Z+17, r20	; 0x11
    52c8:	52 8b       	std	Z+18, r21	; 0x12
    52ca:	63 8b       	std	Z+19, r22	; 0x13
    52cc:	74 8b       	std	Z+20, r23	; 0x14


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    52ce:	71 10       	cpse	r7, r1
    52d0:	03 c0       	rjmp	.+6      	; 0x52d8 <planner_recalculate+0xb4>
    52d2:	68 94       	set
    52d4:	77 24       	eor	r7, r7
    52d6:	75 f8       	bld	r7, 5
  block_index--;
    52d8:	7a 94       	dec	r7

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    52da:	c7 15       	cp	r28, r7
    52dc:	29 f0       	breq	.+10     	; 0x52e8 <planner_recalculate+0xc4>
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
    52de:	0f 2e       	mov	r0, r31
    52e0:	f9 e2       	ldi	r31, 0x29	; 41
    52e2:	6f 2e       	mov	r6, r31
    52e4:	f0 2d       	mov	r31, r0
    52e6:	4f c0       	rjmp	.+158    	; 0x5386 <planner_recalculate+0x162>
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
    52e8:	80 91 46 02 	lds	r24, 0x0246
    52ec:	c8 13       	cpse	r28, r24
    52ee:	4f c0       	rjmp	.+158    	; 0x538e <planner_recalculate+0x16a>
    52f0:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <st_update_plan_block_parameters>
    52f4:	4c c0       	rjmp	.+152    	; 0x538e <planner_recalculate+0x16a>
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
    52f6:	67 9c       	mul	r6, r7
    52f8:	e0 01       	movw	r28, r0
    52fa:	11 24       	eor	r1, r1
    52fc:	c9 5b       	subi	r28, 0xB9	; 185
    52fe:	dd 4f       	sbci	r29, 0xFD	; 253


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    5300:	71 10       	cpse	r7, r1
    5302:	03 c0       	rjmp	.+6      	; 0x530a <planner_recalculate+0xe6>
    5304:	68 94       	set
    5306:	77 24       	eor	r7, r7
    5308:	75 f8       	bld	r7, 5
  block_index--;
    530a:	7a 94       	dec	r7
      next = current;
      current = &block_buffer[block_index];
      block_index = plan_prev_block_index(block_index);

      // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
      if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); } 
    530c:	80 91 46 02 	lds	r24, 0x0246
    5310:	87 11       	cpse	r24, r7
    5312:	02 c0       	rjmp	.+4      	; 0x5318 <planner_recalculate+0xf4>
    5314:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <st_update_plan_block_parameters>

      // Compute maximum entry speed decelerating over the current block from its exit speed.
      if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
    5318:	cd 88       	ldd	r12, Y+21	; 0x15
    531a:	de 88       	ldd	r13, Y+22	; 0x16
    531c:	ef 88       	ldd	r14, Y+23	; 0x17
    531e:	f8 8c       	ldd	r15, Y+24	; 0x18
    5320:	a7 01       	movw	r20, r14
    5322:	96 01       	movw	r18, r12
    5324:	69 89       	ldd	r22, Y+17	; 0x11
    5326:	7a 89       	ldd	r23, Y+18	; 0x12
    5328:	8b 89       	ldd	r24, Y+19	; 0x13
    532a:	9c 89       	ldd	r25, Y+20	; 0x14
    532c:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    5330:	88 23       	and	r24, r24
    5332:	41 f1       	breq	.+80     	; 0x5384 <planner_recalculate+0x160>
        entry_speed_sqr = next->entry_speed_sqr + 2*current->acceleration*current->millimeters;
    5334:	69 a1       	ldd	r22, Y+33	; 0x21
    5336:	7a a1       	ldd	r23, Y+34	; 0x22
    5338:	8b a1       	ldd	r24, Y+35	; 0x23
    533a:	9c a1       	ldd	r25, Y+36	; 0x24
    533c:	9b 01       	movw	r18, r22
    533e:	ac 01       	movw	r20, r24
    5340:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    5344:	2d a1       	ldd	r18, Y+37	; 0x25
    5346:	3e a1       	ldd	r19, Y+38	; 0x26
    5348:	4f a1       	ldd	r20, Y+39	; 0x27
    534a:	58 a5       	ldd	r21, Y+40	; 0x28
    534c:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5350:	f8 01       	movw	r30, r16
    5352:	21 89       	ldd	r18, Z+17	; 0x11
    5354:	32 89       	ldd	r19, Z+18	; 0x12
    5356:	43 89       	ldd	r20, Z+19	; 0x13
    5358:	54 89       	ldd	r21, Z+20	; 0x14
    535a:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    535e:	4b 01       	movw	r8, r22
    5360:	5c 01       	movw	r10, r24
        if (entry_speed_sqr < current->max_entry_speed_sqr) {
    5362:	9b 01       	movw	r18, r22
    5364:	ac 01       	movw	r20, r24
    5366:	c7 01       	movw	r24, r14
    5368:	b6 01       	movw	r22, r12
    536a:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    536e:	18 16       	cp	r1, r24
    5370:	2c f4       	brge	.+10     	; 0x537c <planner_recalculate+0x158>
          current->entry_speed_sqr = entry_speed_sqr;
    5372:	89 8a       	std	Y+17, r8	; 0x11
    5374:	9a 8a       	std	Y+18, r9	; 0x12
    5376:	ab 8a       	std	Y+19, r10	; 0x13
    5378:	bc 8a       	std	Y+20, r11	; 0x14
    537a:	04 c0       	rjmp	.+8      	; 0x5384 <planner_recalculate+0x160>
        } else {
          current->entry_speed_sqr = current->max_entry_speed_sqr;
    537c:	c9 8a       	std	Y+17, r12	; 0x11
    537e:	da 8a       	std	Y+18, r13	; 0x12
    5380:	eb 8a       	std	Y+19, r14	; 0x13
    5382:	fc 8a       	std	Y+20, r15	; 0x14


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    5384:	8e 01       	movw	r16, r28
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
    5386:	80 91 43 02 	lds	r24, 0x0243
    538a:	78 12       	cpse	r7, r24
    538c:	b4 cf       	rjmp	.-152    	; 0x52f6 <planner_recalculate+0xd2>
    }
  }    

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
    538e:	40 90 43 02 	lds	r4, 0x0243
    5392:	f9 e2       	ldi	r31, 0x29	; 41
    5394:	4f 9e       	mul	r4, r31
    5396:	80 01       	movw	r16, r0
    5398:	11 24       	eor	r1, r1
    539a:	09 5b       	subi	r16, 0xB9	; 185
    539c:	1d 4f       	sbci	r17, 0xFD	; 253


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    539e:	77 24       	eor	r7, r7
    53a0:	73 94       	inc	r7
    53a2:	74 0c       	add	r7, r4
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    53a4:	80 e2       	ldi	r24, 0x20	; 32
    53a6:	78 12       	cpse	r7, r24
    53a8:	01 c0       	rjmp	.+2      	; 0x53ac <planner_recalculate+0x188>
    53aa:	71 2c       	mov	r7, r1

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    53ac:	60 90 45 02 	lds	r6, 0x0245
    current = next;
    next = &block_buffer[block_index];
    53b0:	0f 2e       	mov	r0, r31
    53b2:	f9 e2       	ldi	r31, 0x29	; 41
    53b4:	5f 2e       	mov	r5, r31
    53b6:	f0 2d       	mov	r31, r0

// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    53b8:	31 2c       	mov	r3, r1

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    53ba:	4e c0       	rjmp	.+156    	; 0x5458 <planner_recalculate+0x234>
    current = next;
    next = &block_buffer[block_index];
    53bc:	57 9c       	mul	r5, r7
    53be:	e0 01       	movw	r28, r0
    53c0:	11 24       	eor	r1, r1
    53c2:	c9 5b       	subi	r28, 0xB9	; 185
    53c4:	dd 4f       	sbci	r29, 0xFD	; 253
    
    // Any acceleration detected in the forward pass automatically moves the optimal planned
    // pointer forward, since everything before this is all optimal. In other words, nothing
    // can improve the plan from the buffer tail to the planned pointer by logic.
    if (current->entry_speed_sqr < next->entry_speed_sqr) {
    53c6:	f8 01       	movw	r30, r16
    53c8:	81 88       	ldd	r8, Z+17	; 0x11
    53ca:	92 88       	ldd	r9, Z+18	; 0x12
    53cc:	a3 88       	ldd	r10, Z+19	; 0x13
    53ce:	b4 88       	ldd	r11, Z+20	; 0x14
    53d0:	c9 88       	ldd	r12, Y+17	; 0x11
    53d2:	da 88       	ldd	r13, Y+18	; 0x12
    53d4:	eb 88       	ldd	r14, Y+19	; 0x13
    53d6:	fc 88       	ldd	r15, Y+20	; 0x14
    53d8:	a7 01       	movw	r20, r14
    53da:	96 01       	movw	r18, r12
    53dc:	c5 01       	movw	r24, r10
    53de:	b4 01       	movw	r22, r8
    53e0:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    53e4:	88 23       	and	r24, r24
    53e6:	2c f5       	brge	.+74     	; 0x5432 <planner_recalculate+0x20e>
      entry_speed_sqr = current->entry_speed_sqr + 2*current->acceleration*current->millimeters;
    53e8:	f8 01       	movw	r30, r16
    53ea:	61 a1       	ldd	r22, Z+33	; 0x21
    53ec:	72 a1       	ldd	r23, Z+34	; 0x22
    53ee:	83 a1       	ldd	r24, Z+35	; 0x23
    53f0:	94 a1       	ldd	r25, Z+36	; 0x24
    53f2:	9b 01       	movw	r18, r22
    53f4:	ac 01       	movw	r20, r24
    53f6:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    53fa:	f8 01       	movw	r30, r16
    53fc:	25 a1       	ldd	r18, Z+37	; 0x25
    53fe:	36 a1       	ldd	r19, Z+38	; 0x26
    5400:	47 a1       	ldd	r20, Z+39	; 0x27
    5402:	50 a5       	ldd	r21, Z+40	; 0x28
    5404:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5408:	9b 01       	movw	r18, r22
    540a:	ac 01       	movw	r20, r24
    540c:	c5 01       	movw	r24, r10
    540e:	b4 01       	movw	r22, r8
    5410:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    5414:	4b 01       	movw	r8, r22
    5416:	5c 01       	movw	r10, r24
      // If true, current block is full-acceleration and we can move the planned pointer forward.
      if (entry_speed_sqr < next->entry_speed_sqr) {
    5418:	9b 01       	movw	r18, r22
    541a:	ac 01       	movw	r20, r24
    541c:	c7 01       	movw	r24, r14
    541e:	b6 01       	movw	r22, r12
    5420:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    5424:	18 16       	cp	r1, r24
    5426:	2c f4       	brge	.+10     	; 0x5432 <planner_recalculate+0x20e>
        next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
    5428:	89 8a       	std	Y+17, r8	; 0x11
    542a:	9a 8a       	std	Y+18, r9	; 0x12
    542c:	ab 8a       	std	Y+19, r10	; 0x13
    542e:	bc 8a       	std	Y+20, r11	; 0x14
        block_buffer_planned = block_index; // Set optimal plan pointer.
    5430:	47 2c       	mov	r4, r7
    
    // Any block set at its maximum entry speed also creates an optimal plan up to this
    // point in the buffer. When the plan is bracketed by either the beginning of the
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    5432:	2d 89       	ldd	r18, Y+21	; 0x15
    5434:	3e 89       	ldd	r19, Y+22	; 0x16
    5436:	4f 89       	ldd	r20, Y+23	; 0x17
    5438:	58 8d       	ldd	r21, Y+24	; 0x18
    543a:	69 89       	ldd	r22, Y+17	; 0x11
    543c:	7a 89       	ldd	r23, Y+18	; 0x12
    543e:	8b 89       	ldd	r24, Y+19	; 0x13
    5440:	9c 89       	ldd	r25, Y+20	; 0x14
    5442:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    5446:	81 11       	cpse	r24, r1
    5448:	01 c0       	rjmp	.+2      	; 0x544c <planner_recalculate+0x228>
    544a:	47 2c       	mov	r4, r7


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    544c:	73 94       	inc	r7
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    544e:	f0 e2       	ldi	r31, 0x20	; 32
    5450:	7f 12       	cpse	r7, r31
    5452:	01 c0       	rjmp	.+2      	; 0x5456 <planner_recalculate+0x232>
    5454:	73 2c       	mov	r7, r3
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    current = next;
    next = &block_buffer[block_index];
    5456:	8e 01       	movw	r16, r28

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    5458:	76 10       	cpse	r7, r6
    545a:	b0 cf       	rjmp	.-160    	; 0x53bc <planner_recalculate+0x198>
    545c:	40 92 43 02 	sts	0x0243, r4
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    block_index = plan_next_block_index( block_index );
  } 
}
    5460:	df 91       	pop	r29
    5462:	cf 91       	pop	r28
    5464:	1f 91       	pop	r17
    5466:	0f 91       	pop	r16
    5468:	ff 90       	pop	r15
    546a:	ef 90       	pop	r14
    546c:	df 90       	pop	r13
    546e:	cf 90       	pop	r12
    5470:	bf 90       	pop	r11
    5472:	af 90       	pop	r10
    5474:	9f 90       	pop	r9
    5476:	8f 90       	pop	r8
    5478:	7f 90       	pop	r7
    547a:	6f 90       	pop	r6
    547c:	5f 90       	pop	r5
    547e:	4f 90       	pop	r4
    5480:	3f 90       	pop	r3
    5482:	08 95       	ret

00005484 <plan_reset>:


void plan_reset() 
{
  memset(&pl, 0, sizeof(pl)); // Clear planner struct
    5484:	8c e1       	ldi	r24, 0x1C	; 28
    5486:	e7 e2       	ldi	r30, 0x27	; 39
    5488:	f2 e0       	ldi	r31, 0x02	; 2
    548a:	df 01       	movw	r26, r30
    548c:	1d 92       	st	X+, r1
    548e:	8a 95       	dec	r24
    5490:	e9 f7       	brne	.-6      	; 0x548c <plan_reset+0x8>
  block_buffer_tail = 0;
    5492:	10 92 46 02 	sts	0x0246, r1
  block_buffer_head = 0; // Empty = tail
    5496:	10 92 45 02 	sts	0x0245, r1
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
    549a:	81 e0       	ldi	r24, 0x01	; 1
    549c:	80 93 44 02 	sts	0x0244, r24
  block_buffer_planned = 0; // = block_buffer_tail;
    54a0:	10 92 43 02 	sts	0x0243, r1
    54a4:	08 95       	ret

000054a6 <plan_discard_current_block>:
}


void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    54a6:	80 91 46 02 	lds	r24, 0x0246
    54aa:	90 91 45 02 	lds	r25, 0x0245
    54ae:	98 17       	cp	r25, r24
    54b0:	69 f0       	breq	.+26     	; 0x54cc <plan_discard_current_block+0x26>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    54b2:	91 e0       	ldi	r25, 0x01	; 1
    54b4:	98 0f       	add	r25, r24
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    54b6:	90 32       	cpi	r25, 0x20	; 32
    54b8:	09 f4       	brne	.+2      	; 0x54bc <plan_discard_current_block+0x16>
    54ba:	90 e0       	ldi	r25, 0x00	; 0
void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
    54bc:	20 91 43 02 	lds	r18, 0x0243
    54c0:	82 13       	cpse	r24, r18
    54c2:	02 c0       	rjmp	.+4      	; 0x54c8 <plan_discard_current_block+0x22>
    54c4:	90 93 43 02 	sts	0x0243, r25
    block_buffer_tail = block_index;
    54c8:	90 93 46 02 	sts	0x0246, r25
    54cc:	08 95       	ret

000054ce <plan_get_current_block>:
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    54ce:	80 91 46 02 	lds	r24, 0x0246
    54d2:	90 91 45 02 	lds	r25, 0x0245
    54d6:	98 17       	cp	r25, r24
    54d8:	39 f0       	breq	.+14     	; 0x54e8 <plan_get_current_block+0x1a>
  return(&block_buffer[block_buffer_tail]);
    54da:	29 e2       	ldi	r18, 0x29	; 41
    54dc:	82 9f       	mul	r24, r18
    54de:	c0 01       	movw	r24, r0
    54e0:	11 24       	eor	r1, r1
    54e2:	89 5b       	subi	r24, 0xB9	; 185
    54e4:	9d 4f       	sbci	r25, 0xFD	; 253
    54e6:	08 95       	ret
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    54e8:	80 e0       	ldi	r24, 0x00	; 0
    54ea:	90 e0       	ldi	r25, 0x00	; 0
  return(&block_buffer[block_buffer_tail]);
}
    54ec:	08 95       	ret

000054ee <plan_get_exec_block_exit_speed>:


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    54ee:	e0 91 46 02 	lds	r30, 0x0246
    54f2:	ef 5f       	subi	r30, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    54f4:	e0 32       	cpi	r30, 0x20	; 32
    54f6:	09 f4       	brne	.+2      	; 0x54fa <plan_get_exec_block_exit_speed+0xc>
    54f8:	e0 e0       	ldi	r30, 0x00	; 0


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    54fa:	80 91 45 02 	lds	r24, 0x0245
    54fe:	8e 17       	cp	r24, r30
    5500:	69 f0       	breq	.+26     	; 0x551c <plan_get_exec_block_exit_speed+0x2e>
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
    5502:	89 e2       	ldi	r24, 0x29	; 41
    5504:	e8 9f       	mul	r30, r24
    5506:	f0 01       	movw	r30, r0
    5508:	11 24       	eor	r1, r1
    550a:	e9 5b       	subi	r30, 0xB9	; 185
    550c:	fd 4f       	sbci	r31, 0xFD	; 253
    550e:	61 89       	ldd	r22, Z+17	; 0x11
    5510:	72 89       	ldd	r23, Z+18	; 0x12
    5512:	83 89       	ldd	r24, Z+19	; 0x13
    5514:	94 89       	ldd	r25, Z+20	; 0x14
    5516:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    551a:	08 95       	ret


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    551c:	60 e0       	ldi	r22, 0x00	; 0
    551e:	70 e0       	ldi	r23, 0x00	; 0
    5520:	cb 01       	movw	r24, r22
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
}
    5522:	08 95       	ret

00005524 <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
  if (block_buffer_tail == next_buffer_head) { return(true); }
    5524:	81 e0       	ldi	r24, 0x01	; 1
    5526:	20 91 46 02 	lds	r18, 0x0246
    552a:	90 91 44 02 	lds	r25, 0x0244
    552e:	29 13       	cpse	r18, r25
    5530:	80 e0       	ldi	r24, 0x00	; 0
  return(false);
}
    5532:	08 95       	ret

00005534 <plan_buffer_line>:
#ifdef USE_LINE_NUMBERS   
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number) 
#else
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate) 
#endif
{
    5534:	2f 92       	push	r2
    5536:	3f 92       	push	r3
    5538:	4f 92       	push	r4
    553a:	5f 92       	push	r5
    553c:	6f 92       	push	r6
    553e:	7f 92       	push	r7
    5540:	8f 92       	push	r8
    5542:	9f 92       	push	r9
    5544:	af 92       	push	r10
    5546:	bf 92       	push	r11
    5548:	cf 92       	push	r12
    554a:	df 92       	push	r13
    554c:	ef 92       	push	r14
    554e:	ff 92       	push	r15
    5550:	0f 93       	push	r16
    5552:	1f 93       	push	r17
    5554:	cf 93       	push	r28
    5556:	df 93       	push	r29
    5558:	cd b7       	in	r28, 0x3d	; 61
    555a:	de b7       	in	r29, 0x3e	; 62
    555c:	ad 97       	sbiw	r28, 0x2d	; 45
    555e:	0f b6       	in	r0, 0x3f	; 63
    5560:	f8 94       	cli
    5562:	de bf       	out	0x3e, r29	; 62
    5564:	0f be       	out	0x3f, r0	; 63
    5566:	cd bf       	out	0x3d, r28	; 61
    5568:	49 a3       	std	Y+33, r20	; 0x21
    556a:	5a a3       	std	Y+34, r21	; 0x22
    556c:	6b a3       	std	Y+35, r22	; 0x23
    556e:	7c a3       	std	Y+36, r23	; 0x24
    5570:	2d a3       	std	Y+37, r18	; 0x25
  // Prepare and initialize new block
  plan_block_t *block = &block_buffer[block_buffer_head];
    5572:	20 91 45 02 	lds	r18, 0x0245
    5576:	49 e2       	ldi	r20, 0x29	; 41
    5578:	24 9f       	mul	r18, r20
    557a:	90 01       	movw	r18, r0
    557c:	11 24       	eor	r1, r1
    557e:	f9 01       	movw	r30, r18
    5580:	e9 5b       	subi	r30, 0xB9	; 185
    5582:	fd 4f       	sbci	r31, 0xFD	; 253
    5584:	1f 01       	movw	r2, r30
  block->step_event_count = 0;
    5586:	15 86       	std	Z+13, r1	; 0x0d
    5588:	16 86       	std	Z+14, r1	; 0x0e
    558a:	17 86       	std	Z+15, r1	; 0x0f
    558c:	10 8a       	std	Z+16, r1	; 0x10
  block->millimeters = 0;
    558e:	15 a2       	std	Z+37, r1	; 0x25
    5590:	16 a2       	std	Z+38, r1	; 0x26
    5592:	17 a2       	std	Z+39, r1	; 0x27
    5594:	10 a6       	std	Z+40, r1	; 0x28
  block->direction_bits = 0;
    5596:	10 82       	st	Z, r1
  block->acceleration = SOME_LARGE_VALUE; // Scaled down to maximum acceleration later
    5598:	49 e9       	ldi	r20, 0x99	; 153
    559a:	56 e7       	ldi	r21, 0x76	; 118
    559c:	66 e9       	ldi	r22, 0x96	; 150
    559e:	7e e7       	ldi	r23, 0x7E	; 126
    55a0:	41 a3       	std	Z+33, r20	; 0x21
    55a2:	52 a3       	std	Z+34, r21	; 0x22
    55a4:	63 a3       	std	Z+35, r22	; 0x23
    55a6:	74 a3       	std	Z+36, r23	; 0x24
    55a8:	5c 01       	movw	r10, r24
    55aa:	0f ef       	ldi	r16, 0xFF	; 255
    55ac:	18 e0       	ldi	r17, 0x08	; 8
    55ae:	ae 01       	movw	r20, r28
    55b0:	4f 5f       	subi	r20, 0xFF	; 255
    55b2:	5f 4f       	sbci	r21, 0xFF	; 255
    55b4:	5c 8f       	std	Y+28, r21	; 0x1c
    55b6:	4b 8f       	std	Y+27, r20	; 0x1b
    55b8:	0f 2e       	mov	r0, r31
    55ba:	f7 e2       	ldi	r31, 0x27	; 39
    55bc:	4f 2e       	mov	r4, r31
    55be:	f2 e0       	ldi	r31, 0x02	; 2
    55c0:	5f 2e       	mov	r5, r31
    55c2:	f0 2d       	mov	r31, r0
    55c4:	7f 01       	movw	r14, r30
    55c6:	ce 01       	movw	r24, r28
    55c8:	0d 96       	adiw	r24, 0x0d	; 13
    55ca:	6c 01       	movw	r12, r24
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    55cc:	71 2c       	mov	r7, r1
    55ce:	be 8e       	std	Y+30, r11	; 0x1e
    55d0:	ad 8e       	std	Y+29, r10	; 0x1d
        delta_mm = ((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]))/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
    55d2:	ed 8d       	ldd	r30, Y+29	; 0x1d
    55d4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    55d6:	61 91       	ld	r22, Z+
    55d8:	71 91       	ld	r23, Z+
    55da:	81 91       	ld	r24, Z+
    55dc:	91 91       	ld	r25, Z+
    55de:	fe 8f       	std	Y+30, r31	; 0x1e
    55e0:	ed 8f       	std	Y+29, r30	; 0x1d
    55e2:	18 a3       	std	Y+32, r17	; 0x20
    55e4:	0f 8f       	std	Y+31, r16	; 0x1f
    55e6:	f8 01       	movw	r30, r16
    55e8:	20 81       	ld	r18, Z
    55ea:	31 81       	ldd	r19, Z+1	; 0x01
    55ec:	42 81       	ldd	r20, Z+2	; 0x02
    55ee:	53 81       	ldd	r21, Z+3	; 0x03
    55f0:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    55f4:	0e 94 a8 3e 	call	0x7d50	; 0x7d50 <lround>
    55f8:	eb 8d       	ldd	r30, Y+27	; 0x1b
    55fa:	fc 8d       	ldd	r31, Y+28	; 0x1c
    55fc:	61 93       	st	Z+, r22
    55fe:	71 93       	st	Z+, r23
    5600:	81 93       	st	Z+, r24
    5602:	91 93       	st	Z+, r25
    5604:	fc 8f       	std	Y+28, r31	; 0x1c
    5606:	eb 8f       	std	Y+27, r30	; 0x1b
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
    5608:	f2 01       	movw	r30, r4
    560a:	81 90       	ld	r8, Z+
    560c:	91 90       	ld	r9, Z+
    560e:	a1 90       	ld	r10, Z+
    5610:	b1 90       	ld	r11, Z+
    5612:	2f 01       	movw	r4, r30
    5614:	68 19       	sub	r22, r8
    5616:	79 09       	sbc	r23, r9
    5618:	8a 09       	sbc	r24, r10
    561a:	9b 09       	sbc	r25, r11
    561c:	9b 01       	movw	r18, r22
    561e:	ac 01       	movw	r20, r24
    5620:	3a f4       	brpl	.+14     	; 0x5630 <plan_buffer_line+0xfc>
    5622:	22 27       	eor	r18, r18
    5624:	33 27       	eor	r19, r19
    5626:	a9 01       	movw	r20, r18
    5628:	26 1b       	sub	r18, r22
    562a:	37 0b       	sbc	r19, r23
    562c:	48 0b       	sbc	r20, r24
    562e:	59 0b       	sbc	r21, r25
    5630:	f7 01       	movw	r30, r14
    5632:	21 83       	std	Z+1, r18	; 0x01
    5634:	32 83       	std	Z+2, r19	; 0x02
    5636:	43 83       	std	Z+3, r20	; 0x03
    5638:	54 83       	std	Z+4, r21	; 0x04
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    563a:	f1 01       	movw	r30, r2
    563c:	85 84       	ldd	r8, Z+13	; 0x0d
    563e:	96 84       	ldd	r9, Z+14	; 0x0e
    5640:	a7 84       	ldd	r10, Z+15	; 0x0f
    5642:	b0 88       	ldd	r11, Z+16	; 0x10
    5644:	28 15       	cp	r18, r8
    5646:	39 05       	cpc	r19, r9
    5648:	4a 05       	cpc	r20, r10
    564a:	5b 05       	cpc	r21, r11
    564c:	10 f4       	brcc	.+4      	; 0x5652 <plan_buffer_line+0x11e>
    564e:	a5 01       	movw	r20, r10
    5650:	94 01       	movw	r18, r8
    5652:	f1 01       	movw	r30, r2
    5654:	25 87       	std	Z+13, r18	; 0x0d
    5656:	36 87       	std	Z+14, r19	; 0x0e
    5658:	47 87       	std	Z+15, r20	; 0x0f
    565a:	50 8b       	std	Z+16, r21	; 0x10
      delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
    565c:	0e 94 3c 3d 	call	0x7a78	; 0x7a78 <__floatsisf>
    5660:	ef 8d       	ldd	r30, Y+31	; 0x1f
    5662:	f8 a1       	ldd	r31, Y+32	; 0x20
    5664:	20 81       	ld	r18, Z
    5666:	31 81       	ldd	r19, Z+1	; 0x01
    5668:	42 81       	ldd	r20, Z+2	; 0x02
    566a:	53 81       	ldd	r21, Z+3	; 0x03
    566c:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    5670:	4b 01       	movw	r8, r22
    5672:	5c 01       	movw	r10, r24
    #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
    5674:	f6 01       	movw	r30, r12
    5676:	61 93       	st	Z+, r22
    5678:	71 93       	st	Z+, r23
    567a:	81 93       	st	Z+, r24
    567c:	91 93       	st	Z+, r25
    567e:	6f 01       	movw	r12, r30
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    5680:	20 e0       	ldi	r18, 0x00	; 0
    5682:	30 e0       	ldi	r19, 0x00	; 0
    5684:	a9 01       	movw	r20, r18
    5686:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    568a:	88 23       	and	r24, r24
    568c:	44 f4       	brge	.+16     	; 0x569e <plan_buffer_line+0x16a>
    568e:	f1 01       	movw	r30, r2
    5690:	60 80       	ld	r6, Z
    5692:	87 2d       	mov	r24, r7
    5694:	0e 94 fe 28 	call	0x51fc	; 0x51fc <get_direction_pin_mask>
    5698:	86 29       	or	r24, r6
    569a:	f1 01       	movw	r30, r2
    569c:	80 83       	st	Z, r24
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    569e:	a5 01       	movw	r20, r10
    56a0:	94 01       	movw	r18, r8
    56a2:	c5 01       	movw	r24, r10
    56a4:	b4 01       	movw	r22, r8
    56a6:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    56aa:	f1 01       	movw	r30, r2
    56ac:	25 a1       	ldd	r18, Z+37	; 0x25
    56ae:	36 a1       	ldd	r19, Z+38	; 0x26
    56b0:	47 a1       	ldd	r20, Z+39	; 0x27
    56b2:	50 a5       	ldd	r21, Z+40	; 0x28
    56b4:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    56b8:	f1 01       	movw	r30, r2
    56ba:	65 a3       	std	Z+37, r22	; 0x25
    56bc:	76 a3       	std	Z+38, r23	; 0x26
    56be:	87 a3       	std	Z+39, r24	; 0x27
    56c0:	90 a7       	std	Z+40, r25	; 0x28
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    56c2:	73 94       	inc	r7
    56c4:	0c 5f       	subi	r16, 0xFC	; 252
    56c6:	1f 4f       	sbci	r17, 0xFF	; 255
    56c8:	f4 e0       	ldi	r31, 0x04	; 4
    56ca:	ef 0e       	add	r14, r31
    56cc:	f1 1c       	adc	r15, r1
    56ce:	23 e0       	ldi	r18, 0x03	; 3
    56d0:	72 12       	cpse	r7, r18
    56d2:	7f cf       	rjmp	.-258    	; 0x55d2 <plan_buffer_line+0x9e>
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
  }
  block->millimeters = sqrt(block->millimeters); // Complete millimeters calculation with sqrt()
    56d4:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    56d8:	6b 01       	movw	r12, r22
    56da:	7c 01       	movw	r14, r24
    56dc:	f1 01       	movw	r30, r2
    56de:	65 a3       	std	Z+37, r22	; 0x25
    56e0:	76 a3       	std	Z+38, r23	; 0x26
    56e2:	87 a3       	std	Z+39, r24	; 0x27
    56e4:	90 a7       	std	Z+40, r25	; 0x28
  
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
    56e6:	85 85       	ldd	r24, Z+13	; 0x0d
    56e8:	96 85       	ldd	r25, Z+14	; 0x0e
    56ea:	a7 85       	ldd	r26, Z+15	; 0x0f
    56ec:	b0 89       	ldd	r27, Z+16	; 0x10
    56ee:	89 2b       	or	r24, r25
    56f0:	8a 2b       	or	r24, r26
    56f2:	8b 2b       	or	r24, r27
    56f4:	09 f4       	brne	.+2      	; 0x56f8 <plan_buffer_line+0x1c4>
    56f6:	1f c2       	rjmp	.+1086   	; 0x5b36 <plan_buffer_line+0x602>
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    56f8:	20 e0       	ldi	r18, 0x00	; 0
    56fa:	30 e0       	ldi	r19, 0x00	; 0
    56fc:	a9 01       	movw	r20, r18
    56fe:	69 a1       	ldd	r22, Y+33	; 0x21
    5700:	7a a1       	ldd	r23, Y+34	; 0x22
    5702:	8b a1       	ldd	r24, Y+35	; 0x23
    5704:	9c a1       	ldd	r25, Y+36	; 0x24
    5706:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    570a:	88 23       	and	r24, r24
    570c:	e4 f0       	brlt	.+56     	; 0x5746 <plan_buffer_line+0x212>
  else if (invert_feed_rate) { feed_rate = block->millimeters/feed_rate; }
    570e:	fd a1       	ldd	r31, Y+37	; 0x25
    5710:	ff 23       	and	r31, r31
    5712:	61 f0       	breq	.+24     	; 0x572c <plan_buffer_line+0x1f8>
    5714:	29 a1       	ldd	r18, Y+33	; 0x21
    5716:	3a a1       	ldd	r19, Y+34	; 0x22
    5718:	4b a1       	ldd	r20, Y+35	; 0x23
    571a:	5c a1       	ldd	r21, Y+36	; 0x24
    571c:	c7 01       	movw	r24, r14
    571e:	b6 01       	movw	r22, r12
    5720:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    5724:	69 a3       	std	Y+33, r22	; 0x21
    5726:	7a a3       	std	Y+34, r23	; 0x22
    5728:	8b a3       	std	Y+35, r24	; 0x23
    572a:	9c a3       	std	Y+36, r25	; 0x24
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    572c:	20 e0       	ldi	r18, 0x00	; 0
    572e:	30 e0       	ldi	r19, 0x00	; 0
    5730:	40 e8       	ldi	r20, 0x80	; 128
    5732:	5f e3       	ldi	r21, 0x3F	; 63
    5734:	69 a1       	ldd	r22, Y+33	; 0x21
    5736:	7a a1       	ldd	r23, Y+34	; 0x22
    5738:	8b a1       	ldd	r24, Y+35	; 0x23
    573a:	9c a1       	ldd	r25, Y+36	; 0x24
    573c:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    5740:	88 23       	and	r24, r24
    5742:	84 f4       	brge	.+32     	; 0x5764 <plan_buffer_line+0x230>
    5744:	09 c0       	rjmp	.+18     	; 0x5758 <plan_buffer_line+0x224>
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    5746:	29 e9       	ldi	r18, 0x99	; 153
    5748:	29 a3       	std	Y+33, r18	; 0x21
    574a:	46 e7       	ldi	r20, 0x76	; 118
    574c:	4a a3       	std	Y+34, r20	; 0x22
    574e:	56 e9       	ldi	r21, 0x96	; 150
    5750:	5b a3       	std	Y+35, r21	; 0x23
    5752:	8e e7       	ldi	r24, 0x7E	; 126
    5754:	8c a3       	std	Y+36, r24	; 0x24
    5756:	06 c0       	rjmp	.+12     	; 0x5764 <plan_buffer_line+0x230>
  else if (invert_feed_rate) { feed_rate = block->millimeters/feed_rate; }
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    5758:	19 a2       	std	Y+33, r1	; 0x21
    575a:	1a a2       	std	Y+34, r1	; 0x22
    575c:	90 e8       	ldi	r25, 0x80	; 128
    575e:	9b a3       	std	Y+35, r25	; 0x23
    5760:	ef e3       	ldi	r30, 0x3F	; 63
    5762:	ec a3       	std	Y+36, r30	; 0x24
  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled 
  // down such that no individual axes maximum values are exceeded with respect to the line direction. 
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
    5764:	a7 01       	movw	r20, r14
    5766:	96 01       	movw	r18, r12
    5768:	60 e0       	ldi	r22, 0x00	; 0
    576a:	70 e0       	ldi	r23, 0x00	; 0
    576c:	80 e8       	ldi	r24, 0x80	; 128
    576e:	9f e3       	ldi	r25, 0x3F	; 63
    5770:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    5774:	6a a7       	std	Y+42, r22	; 0x2a
    5776:	7b a7       	std	Y+43, r23	; 0x2b
    5778:	8c a7       	std	Y+44, r24	; 0x2c
    577a:	9d a7       	std	Y+45, r25	; 0x2d
    577c:	03 e3       	ldi	r16, 0x33	; 51
    577e:	12 e0       	ldi	r17, 0x02	; 2
    5780:	0f 2e       	mov	r0, r31
    5782:	fb e0       	ldi	r31, 0x0B	; 11
    5784:	4f 2e       	mov	r4, r31
    5786:	f9 e0       	ldi	r31, 0x09	; 9
    5788:	5f 2e       	mov	r5, r31
    578a:	f0 2d       	mov	r31, r0
    578c:	ae 01       	movw	r20, r28
    578e:	47 5e       	subi	r20, 0xE7	; 231
    5790:	5f 4f       	sbci	r21, 0xFF	; 255
    5792:	5a 8f       	std	Y+26, r21	; 0x1a
    5794:	49 8f       	std	Y+25, r20	; 0x19
    5796:	ce 01       	movw	r24, r28
    5798:	0d 96       	adiw	r24, 0x0d	; 13
  float junction_cos_theta = 0;
    579a:	1f 8e       	std	Y+31, r1	; 0x1f
    579c:	1d a2       	std	Y+37, r1	; 0x25
    579e:	1e a2       	std	Y+38, r1	; 0x26
    57a0:	1f a2       	std	Y+39, r1	; 0x27
    57a2:	3c 8e       	std	Y+28, r3	; 0x1c
    57a4:	2b 8e       	std	Y+27, r2	; 0x1b
    57a6:	1e 8f       	std	Y+30, r17	; 0x1e
    57a8:	0d 8f       	std	Y+29, r16	; 0x1d
    57aa:	8c 01       	movw	r16, r24
    57ac:	32 01       	movw	r6, r4
    57ae:	29 a0       	ldd	r2, Y+33	; 0x21
    57b0:	3a a0       	ldd	r3, Y+34	; 0x22
    57b2:	4b a0       	ldd	r4, Y+35	; 0x23
    57b4:	5c a0       	ldd	r5, Y+36	; 0x24
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    57b6:	f8 01       	movw	r30, r16
    57b8:	c0 80       	ld	r12, Z
    57ba:	d1 80       	ldd	r13, Z+1	; 0x01
    57bc:	e2 80       	ldd	r14, Z+2	; 0x02
    57be:	f3 80       	ldd	r15, Z+3	; 0x03
    57c0:	20 e0       	ldi	r18, 0x00	; 0
    57c2:	30 e0       	ldi	r19, 0x00	; 0
    57c4:	a9 01       	movw	r20, r18
    57c6:	c7 01       	movw	r24, r14
    57c8:	b6 01       	movw	r22, r12
    57ca:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    57ce:	88 23       	and	r24, r24
    57d0:	09 f4       	brne	.+2      	; 0x57d4 <plan_buffer_line+0x2a0>
    57d2:	7e c0       	rjmp	.+252    	; 0x58d0 <plan_buffer_line+0x39c>
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
    57d4:	a7 01       	movw	r20, r14
    57d6:	96 01       	movw	r18, r12
    57d8:	6a a5       	ldd	r22, Y+42	; 0x2a
    57da:	7b a5       	ldd	r23, Y+43	; 0x2b
    57dc:	8c a5       	ldd	r24, Y+44	; 0x2c
    57de:	9d a5       	ldd	r25, Y+45	; 0x2d
    57e0:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    57e4:	6b 01       	movw	r12, r22
    57e6:	7c 01       	movw	r14, r24
    57e8:	f8 01       	movw	r30, r16
    57ea:	60 83       	st	Z, r22
    57ec:	71 83       	std	Z+1, r23	; 0x01
    57ee:	82 83       	std	Z+2, r24	; 0x02
    57f0:	93 83       	std	Z+3, r25	; 0x03
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.
    57f2:	9b 01       	movw	r18, r22
    57f4:	ac 01       	movw	r20, r24
    57f6:	60 e0       	ldi	r22, 0x00	; 0
    57f8:	70 e0       	ldi	r23, 0x00	; 0
    57fa:	80 e8       	ldi	r24, 0x80	; 128
    57fc:	9f e3       	ldi	r25, 0x3F	; 63
    57fe:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    5802:	4b 01       	movw	r8, r22
    5804:	5c 01       	movw	r10, r24
    5806:	e8 94       	clt
    5808:	b7 f8       	bld	r11, 7
    580a:	79 a6       	std	Y+41, r7	; 0x29
    580c:	68 a6       	std	Y+40, r6	; 0x28

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    580e:	f3 01       	movw	r30, r6
    5810:	20 81       	ld	r18, Z
    5812:	31 81       	ldd	r19, Z+1	; 0x01
    5814:	42 81       	ldd	r20, Z+2	; 0x02
    5816:	53 81       	ldd	r21, Z+3	; 0x03
    5818:	c5 01       	movw	r24, r10
    581a:	b4 01       	movw	r22, r8
    581c:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5820:	69 a3       	std	Y+33, r22	; 0x21
    5822:	7a a3       	std	Y+34, r23	; 0x22
    5824:	8b a3       	std	Y+35, r24	; 0x23
    5826:	9c a3       	std	Y+36, r25	; 0x24
    5828:	22 2d       	mov	r18, r2
    582a:	33 2d       	mov	r19, r3
    582c:	44 2d       	mov	r20, r4
    582e:	55 2d       	mov	r21, r5
    5830:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    5834:	18 16       	cp	r1, r24
    5836:	24 f4       	brge	.+8      	; 0x5840 <plan_buffer_line+0x30c>
    5838:	29 a2       	std	Y+33, r2	; 0x21
    583a:	3a a2       	std	Y+34, r3	; 0x22
    583c:	4b a2       	std	Y+35, r4	; 0x23
    583e:	5c a2       	std	Y+36, r5	; 0x24
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    5840:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5842:	fc 8d       	ldd	r31, Y+28	; 0x1c
    5844:	21 a0       	ldd	r2, Z+33	; 0x21
    5846:	32 a0       	ldd	r3, Z+34	; 0x22
    5848:	43 a0       	ldd	r4, Z+35	; 0x23
    584a:	54 a0       	ldd	r5, Z+36	; 0x24
    584c:	e8 a5       	ldd	r30, Y+40	; 0x28
    584e:	f9 a5       	ldd	r31, Y+41	; 0x29
    5850:	24 85       	ldd	r18, Z+12	; 0x0c
    5852:	35 85       	ldd	r19, Z+13	; 0x0d
    5854:	46 85       	ldd	r20, Z+14	; 0x0e
    5856:	57 85       	ldd	r21, Z+15	; 0x0f
    5858:	c5 01       	movw	r24, r10
    585a:	b4 01       	movw	r22, r8
    585c:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5860:	86 2e       	mov	r8, r22
    5862:	97 2e       	mov	r9, r23
    5864:	a8 2e       	mov	r10, r24
    5866:	b9 2e       	mov	r11, r25
    5868:	26 2f       	mov	r18, r22
    586a:	37 2f       	mov	r19, r23
    586c:	48 2f       	mov	r20, r24
    586e:	59 2f       	mov	r21, r25
    5870:	62 2d       	mov	r22, r2
    5872:	73 2d       	mov	r23, r3
    5874:	84 2d       	mov	r24, r4
    5876:	95 2d       	mov	r25, r5
    5878:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    587c:	88 23       	and	r24, r24
    587e:	24 f0       	brlt	.+8      	; 0x5888 <plan_buffer_line+0x354>
    5880:	28 2c       	mov	r2, r8
    5882:	39 2c       	mov	r3, r9
    5884:	4a 2c       	mov	r4, r10
    5886:	5b 2c       	mov	r5, r11
    5888:	82 2d       	mov	r24, r2
    588a:	93 2d       	mov	r25, r3
    588c:	a4 2d       	mov	r26, r4
    588e:	b5 2d       	mov	r27, r5
    5890:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5892:	fc 8d       	ldd	r31, Y+28	; 0x1c
    5894:	81 a3       	std	Z+33, r24	; 0x21
    5896:	92 a3       	std	Z+34, r25	; 0x22
    5898:	a3 a3       	std	Z+35, r26	; 0x23
    589a:	b4 a3       	std	Z+36, r27	; 0x24

      // Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction
      // between the current move and the previous move is simply the dot product of the two unit vectors, 
      // where prev_unit_vec is negative. Used later to compute maximum junction speed.
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    589c:	ed 8d       	ldd	r30, Y+29	; 0x1d
    589e:	fe 8d       	ldd	r31, Y+30	; 0x1e
    58a0:	20 81       	ld	r18, Z
    58a2:	31 81       	ldd	r19, Z+1	; 0x01
    58a4:	42 81       	ldd	r20, Z+2	; 0x02
    58a6:	53 81       	ldd	r21, Z+3	; 0x03
    58a8:	c7 01       	movw	r24, r14
    58aa:	b6 01       	movw	r22, r12
    58ac:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    58b0:	9b 01       	movw	r18, r22
    58b2:	ac 01       	movw	r20, r24
    58b4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    58b6:	7d a1       	ldd	r23, Y+37	; 0x25
    58b8:	8e a1       	ldd	r24, Y+38	; 0x26
    58ba:	9f a1       	ldd	r25, Y+39	; 0x27
    58bc:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    58c0:	6f 8f       	std	Y+31, r22	; 0x1f
    58c2:	7d a3       	std	Y+37, r23	; 0x25
    58c4:	8e a3       	std	Y+38, r24	; 0x26
    58c6:	9f a3       	std	Y+39, r25	; 0x27
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    58c8:	29 a0       	ldd	r2, Y+33	; 0x21
    58ca:	3a a0       	ldd	r3, Y+34	; 0x22
    58cc:	4b a0       	ldd	r4, Y+35	; 0x23
    58ce:	5c a0       	ldd	r5, Y+36	; 0x24
    58d0:	0c 5f       	subi	r16, 0xFC	; 252
    58d2:	1f 4f       	sbci	r17, 0xFF	; 255
    58d4:	4d 8d       	ldd	r20, Y+29	; 0x1d
    58d6:	5e 8d       	ldd	r21, Y+30	; 0x1e
    58d8:	4c 5f       	subi	r20, 0xFC	; 252
    58da:	5f 4f       	sbci	r21, 0xFF	; 255
    58dc:	5e 8f       	std	Y+30, r21	; 0x1e
    58de:	4d 8f       	std	Y+29, r20	; 0x1d
    58e0:	54 e0       	ldi	r21, 0x04	; 4
    58e2:	65 0e       	add	r6, r21
    58e4:	71 1c       	adc	r7, r1
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    58e6:	89 8d       	ldd	r24, Y+25	; 0x19
    58e8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    58ea:	08 17       	cp	r16, r24
    58ec:	19 07       	cpc	r17, r25
    58ee:	09 f0       	breq	.+2      	; 0x58f2 <plan_buffer_line+0x3be>
    58f0:	62 cf       	rjmp	.-316    	; 0x57b6 <plan_buffer_line+0x282>
    58f2:	29 a2       	std	Y+33, r2	; 0x21
    58f4:	3a a2       	std	Y+34, r3	; 0x22
    58f6:	2b 8c       	ldd	r2, Y+27	; 0x1b
    58f8:	3c 8c       	ldd	r3, Y+28	; 0x1c
    58fa:	4b a2       	std	Y+35, r4	; 0x23
    58fc:	5c a2       	std	Y+36, r5	; 0x24
    58fe:	ef 8c       	ldd	r14, Y+31	; 0x1f
    5900:	fd a0       	ldd	r15, Y+37	; 0x25
    5902:	0e a1       	ldd	r16, Y+38	; 0x26
    5904:	1f a1       	ldd	r17, Y+39	; 0x27
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    }
  }
  
  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if (block_buffer_head == block_buffer_tail) {
    5906:	90 91 45 02 	lds	r25, 0x0245
    590a:	80 91 46 02 	lds	r24, 0x0246
    590e:	98 13       	cpse	r25, r24
    5910:	0a c0       	rjmp	.+20     	; 0x5926 <plan_buffer_line+0x3f2>
  
    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    block->entry_speed_sqr = 0.0;
    5912:	f1 01       	movw	r30, r2
    5914:	11 8a       	std	Z+17, r1	; 0x11
    5916:	12 8a       	std	Z+18, r1	; 0x12
    5918:	13 8a       	std	Z+19, r1	; 0x13
    591a:	14 8a       	std	Z+20, r1	; 0x14
    block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
    591c:	11 8e       	std	Z+25, r1	; 0x19
    591e:	12 8e       	std	Z+26, r1	; 0x1a
    5920:	13 8e       	std	Z+27, r1	; 0x1b
    5922:	14 8e       	std	Z+28, r1	; 0x1c
    5924:	75 c0       	rjmp	.+234    	; 0x5a10 <plan_buffer_line+0x4dc>
       changed dynamically during operation nor can the line move geometry. This must be kept in
       memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
       change the overall maximum entry speed conditions of all blocks.
    */
    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.99) {
    5926:	24 ea       	ldi	r18, 0xA4	; 164
    5928:	30 e7       	ldi	r19, 0x70	; 112
    592a:	4d e7       	ldi	r20, 0x7D	; 125
    592c:	5f e3       	ldi	r21, 0x3F	; 63
    592e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    5930:	7d a1       	ldd	r23, Y+37	; 0x25
    5932:	8e a1       	ldd	r24, Y+38	; 0x26
    5934:	9f a1       	ldd	r25, Y+39	; 0x27
    5936:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    593a:	18 16       	cp	r1, r24
    593c:	34 f4       	brge	.+12     	; 0x594a <plan_buffer_line+0x416>
      //  For a 0 degree acute junction, just set minimum junction speed. 
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
    593e:	f1 01       	movw	r30, r2
    5940:	11 8e       	std	Z+25, r1	; 0x19
    5942:	12 8e       	std	Z+26, r1	; 0x1a
    5944:	13 8e       	std	Z+27, r1	; 0x1b
    5946:	14 8e       	std	Z+28, r1	; 0x1c
    5948:	63 c0       	rjmp	.+198    	; 0x5a10 <plan_buffer_line+0x4dc>
    } else {
      junction_cos_theta = max(junction_cos_theta,-0.99); // Check for numerical round-off to avoid divide by zero.
    594a:	24 ea       	ldi	r18, 0xA4	; 164
    594c:	30 e7       	ldi	r19, 0x70	; 112
    594e:	4d e7       	ldi	r20, 0x7D	; 125
    5950:	5f eb       	ldi	r21, 0xBF	; 191
    5952:	6e 2d       	mov	r22, r14
    5954:	7f 2d       	mov	r23, r15
    5956:	80 2f       	mov	r24, r16
    5958:	91 2f       	mov	r25, r17
    595a:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    595e:	18 16       	cp	r1, r24
    5960:	44 f0       	brlt	.+16     	; 0x5972 <plan_buffer_line+0x43e>
    5962:	f4 ea       	ldi	r31, 0xA4	; 164
    5964:	ff 8f       	std	Y+31, r31	; 0x1f
    5966:	20 e7       	ldi	r18, 0x70	; 112
    5968:	2d a3       	std	Y+37, r18	; 0x25
    596a:	4d e7       	ldi	r20, 0x7D	; 125
    596c:	4e a3       	std	Y+38, r20	; 0x26
    596e:	5f eb       	ldi	r21, 0xBF	; 191
    5970:	5f a3       	std	Y+39, r21	; 0x27
      float sin_theta_d2 = sqrt(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Always positive.
    5972:	2f 8d       	ldd	r18, Y+31	; 0x1f
    5974:	3d a1       	ldd	r19, Y+37	; 0x25
    5976:	4e a1       	ldd	r20, Y+38	; 0x26
    5978:	5f a1       	ldd	r21, Y+39	; 0x27
    597a:	60 e0       	ldi	r22, 0x00	; 0
    597c:	70 e0       	ldi	r23, 0x00	; 0
    597e:	80 e8       	ldi	r24, 0x80	; 128
    5980:	9f e3       	ldi	r25, 0x3F	; 63
    5982:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    5986:	20 e0       	ldi	r18, 0x00	; 0
    5988:	30 e0       	ldi	r19, 0x00	; 0
    598a:	40 e0       	ldi	r20, 0x00	; 0
    598c:	5f e3       	ldi	r21, 0x3F	; 63
    598e:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5992:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    5996:	6b 01       	movw	r12, r22
    5998:	7c 01       	movw	r14, r24

      // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
      // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
      block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
    599a:	20 91 34 09 	lds	r18, 0x0934
    599e:	30 91 35 09 	lds	r19, 0x0935
    59a2:	40 91 36 09 	lds	r20, 0x0936
    59a6:	50 91 37 09 	lds	r21, 0x0937
    59aa:	f1 01       	movw	r30, r2
    59ac:	61 a1       	ldd	r22, Z+33	; 0x21
    59ae:	72 a1       	ldd	r23, Z+34	; 0x22
    59b0:	83 a1       	ldd	r24, Z+35	; 0x23
    59b2:	94 a1       	ldd	r25, Z+36	; 0x24
    59b4:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    59b8:	a7 01       	movw	r20, r14
    59ba:	96 01       	movw	r18, r12
    59bc:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    59c0:	4b 01       	movw	r8, r22
    59c2:	5c 01       	movw	r10, r24
    59c4:	a7 01       	movw	r20, r14
    59c6:	96 01       	movw	r18, r12
    59c8:	60 e0       	ldi	r22, 0x00	; 0
    59ca:	70 e0       	ldi	r23, 0x00	; 0
    59cc:	80 e8       	ldi	r24, 0x80	; 128
    59ce:	9f e3       	ldi	r25, 0x3F	; 63
    59d0:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    59d4:	9b 01       	movw	r18, r22
    59d6:	ac 01       	movw	r20, r24
    59d8:	c5 01       	movw	r24, r10
    59da:	b4 01       	movw	r22, r8
    59dc:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    59e0:	e6 2e       	mov	r14, r22
    59e2:	f7 2e       	mov	r15, r23
    59e4:	08 2f       	mov	r16, r24
    59e6:	19 2f       	mov	r17, r25
    59e8:	20 e0       	ldi	r18, 0x00	; 0
    59ea:	30 e0       	ldi	r19, 0x00	; 0
    59ec:	a9 01       	movw	r20, r18
    59ee:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    59f2:	88 23       	and	r24, r24
    59f4:	24 f4       	brge	.+8      	; 0x59fe <plan_buffer_line+0x4ca>
    59f6:	e1 2c       	mov	r14, r1
    59f8:	f1 2c       	mov	r15, r1
    59fa:	00 e0       	ldi	r16, 0x00	; 0
    59fc:	10 e0       	ldi	r17, 0x00	; 0
    59fe:	4e 2d       	mov	r20, r14
    5a00:	5f 2d       	mov	r21, r15
    5a02:	60 2f       	mov	r22, r16
    5a04:	71 2f       	mov	r23, r17
    5a06:	f1 01       	movw	r30, r2
    5a08:	41 8f       	std	Z+25, r20	; 0x19
    5a0a:	52 8f       	std	Z+26, r21	; 0x1a
    5a0c:	63 8f       	std	Z+27, r22	; 0x1b
    5a0e:	74 8f       	std	Z+28, r23	; 0x1c

    }
  }

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
    5a10:	29 a1       	ldd	r18, Y+33	; 0x21
    5a12:	3a a1       	ldd	r19, Y+34	; 0x22
    5a14:	4b a1       	ldd	r20, Y+35	; 0x23
    5a16:	5c a1       	ldd	r21, Y+36	; 0x24
    5a18:	69 a1       	ldd	r22, Y+33	; 0x21
    5a1a:	7a a1       	ldd	r23, Y+34	; 0x22
    5a1c:	8b a1       	ldd	r24, Y+35	; 0x23
    5a1e:	9c a1       	ldd	r25, Y+36	; 0x24
    5a20:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5a24:	16 2f       	mov	r17, r22
    5a26:	07 2f       	mov	r16, r23
    5a28:	f8 2e       	mov	r15, r24
    5a2a:	e9 2e       	mov	r14, r25
    5a2c:	86 2f       	mov	r24, r22
    5a2e:	90 2f       	mov	r25, r16
    5a30:	af 2d       	mov	r26, r15
    5a32:	be 2d       	mov	r27, r14
    5a34:	f1 01       	movw	r30, r2
    5a36:	85 8f       	std	Z+29, r24	; 0x1d
    5a38:	96 8f       	std	Z+30, r25	; 0x1e
    5a3a:	a7 8f       	std	Z+31, r26	; 0x1f
    5a3c:	b0 a3       	std	Z+32, r27	; 0x20
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    5a3e:	91 8c       	ldd	r9, Z+25	; 0x19
    5a40:	82 8c       	ldd	r8, Z+26	; 0x1a
    5a42:	73 8c       	ldd	r7, Z+27	; 0x1b
    5a44:	64 8c       	ldd	r6, Z+28	; 0x1c
    5a46:	a0 90 3f 02 	lds	r10, 0x023F
    5a4a:	b0 90 40 02 	lds	r11, 0x0240
    5a4e:	c0 90 41 02 	lds	r12, 0x0241
    5a52:	d0 90 42 02 	lds	r13, 0x0242
    5a56:	2a 2d       	mov	r18, r10
    5a58:	3b 2d       	mov	r19, r11
    5a5a:	4c 2d       	mov	r20, r12
    5a5c:	5d 2d       	mov	r21, r13
    5a5e:	61 2f       	mov	r22, r17
    5a60:	70 2f       	mov	r23, r16
    5a62:	8f 2d       	mov	r24, r15
    5a64:	9e 2d       	mov	r25, r14
    5a66:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    5a6a:	88 23       	and	r24, r24
    5a6c:	0c f4       	brge	.+2      	; 0x5a70 <plan_buffer_line+0x53c>
    5a6e:	55 c0       	rjmp	.+170    	; 0x5b1a <plan_buffer_line+0x5e6>
    5a70:	2a 2d       	mov	r18, r10
    5a72:	3b 2d       	mov	r19, r11
    5a74:	4c 2d       	mov	r20, r12
    5a76:	5d 2d       	mov	r21, r13
    5a78:	69 2d       	mov	r22, r9
    5a7a:	78 2d       	mov	r23, r8
    5a7c:	87 2d       	mov	r24, r7
    5a7e:	96 2d       	mov	r25, r6
    5a80:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    5a84:	88 23       	and	r24, r24
    5a86:	ac f0       	brlt	.+42     	; 0x5ab2 <plan_buffer_line+0x57e>
    5a88:	2a 2d       	mov	r18, r10
    5a8a:	3b 2d       	mov	r19, r11
    5a8c:	4c 2d       	mov	r20, r12
    5a8e:	5d 2d       	mov	r21, r13
    5a90:	61 2f       	mov	r22, r17
    5a92:	70 2f       	mov	r23, r16
    5a94:	8f 2d       	mov	r24, r15
    5a96:	9e 2d       	mov	r25, r14
    5a98:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    5a9c:	88 23       	and	r24, r24
    5a9e:	2c f4       	brge	.+10     	; 0x5aaa <plan_buffer_line+0x576>
    5aa0:	91 2e       	mov	r9, r17
    5aa2:	80 2e       	mov	r8, r16
    5aa4:	7f 2c       	mov	r7, r15
    5aa6:	6e 2c       	mov	r6, r14
    5aa8:	04 c0       	rjmp	.+8      	; 0x5ab2 <plan_buffer_line+0x57e>
    5aaa:	9a 2c       	mov	r9, r10
    5aac:	8b 2c       	mov	r8, r11
    5aae:	7c 2c       	mov	r7, r12
    5ab0:	6d 2c       	mov	r6, r13
    5ab2:	89 2d       	mov	r24, r9
    5ab4:	98 2d       	mov	r25, r8
    5ab6:	a7 2d       	mov	r26, r7
    5ab8:	b6 2d       	mov	r27, r6
    5aba:	f1 01       	movw	r30, r2
    5abc:	85 8b       	std	Z+21, r24	; 0x15
    5abe:	96 8b       	std	Z+22, r25	; 0x16
    5ac0:	a7 8b       	std	Z+23, r26	; 0x17
    5ac2:	b0 8f       	std	Z+24, r27	; 0x18
                                   min(block->nominal_speed_sqr,pl.previous_nominal_speed_sqr));
  
  // Update previous path unit_vector and nominal speed (squared)
  memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
    5ac4:	8c e0       	ldi	r24, 0x0C	; 12
    5ac6:	fe 01       	movw	r30, r28
    5ac8:	3d 96       	adiw	r30, 0x0d	; 13
    5aca:	a3 e3       	ldi	r26, 0x33	; 51
    5acc:	b2 e0       	ldi	r27, 0x02	; 2
    5ace:	01 90       	ld	r0, Z+
    5ad0:	0d 92       	st	X+, r0
    5ad2:	8a 95       	dec	r24
    5ad4:	e1 f7       	brne	.-8      	; 0x5ace <plan_buffer_line+0x59a>
  pl.previous_nominal_speed_sqr = block->nominal_speed_sqr;
    5ad6:	81 2f       	mov	r24, r17
    5ad8:	90 2f       	mov	r25, r16
    5ada:	af 2d       	mov	r26, r15
    5adc:	be 2d       	mov	r27, r14
    5ade:	80 93 3f 02 	sts	0x023F, r24
    5ae2:	90 93 40 02 	sts	0x0240, r25
    5ae6:	a0 93 41 02 	sts	0x0241, r26
    5aea:	b0 93 42 02 	sts	0x0242, r27
    
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
    5aee:	8c e0       	ldi	r24, 0x0C	; 12
    5af0:	fe 01       	movw	r30, r28
    5af2:	31 96       	adiw	r30, 0x01	; 1
    5af4:	a7 e2       	ldi	r26, 0x27	; 39
    5af6:	b2 e0       	ldi	r27, 0x02	; 2
    5af8:	01 90       	ld	r0, Z+
    5afa:	0d 92       	st	X+, r0
    5afc:	8a 95       	dec	r24
    5afe:	e1 f7       	brne	.-8      	; 0x5af8 <plan_buffer_line+0x5c4>

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
    5b00:	80 91 44 02 	lds	r24, 0x0244
    5b04:	80 93 45 02 	sts	0x0245, r24


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    5b08:	8f 5f       	subi	r24, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    5b0a:	80 32       	cpi	r24, 0x20	; 32
    5b0c:	09 f4       	brne	.+2      	; 0x5b10 <plan_buffer_line+0x5dc>
    5b0e:	80 e0       	ldi	r24, 0x00	; 0
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
    5b10:	80 93 44 02 	sts	0x0244, r24
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
    5b14:	0e 94 12 29 	call	0x5224	; 0x5224 <planner_recalculate>
    5b18:	0e c0       	rjmp	.+28     	; 0x5b36 <plan_buffer_line+0x602>

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    5b1a:	29 2d       	mov	r18, r9
    5b1c:	38 2d       	mov	r19, r8
    5b1e:	47 2d       	mov	r20, r7
    5b20:	56 2d       	mov	r21, r6
    5b22:	61 2f       	mov	r22, r17
    5b24:	70 2f       	mov	r23, r16
    5b26:	8f 2d       	mov	r24, r15
    5b28:	9e 2d       	mov	r25, r14
    5b2a:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    5b2e:	18 16       	cp	r1, r24
    5b30:	0c f0       	brlt	.+2      	; 0x5b34 <plan_buffer_line+0x600>
    5b32:	b6 cf       	rjmp	.-148    	; 0x5aa0 <plan_buffer_line+0x56c>
    5b34:	be cf       	rjmp	.-132    	; 0x5ab2 <plan_buffer_line+0x57e>
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
}
    5b36:	ad 96       	adiw	r28, 0x2d	; 45
    5b38:	0f b6       	in	r0, 0x3f	; 63
    5b3a:	f8 94       	cli
    5b3c:	de bf       	out	0x3e, r29	; 62
    5b3e:	0f be       	out	0x3f, r0	; 63
    5b40:	cd bf       	out	0x3d, r28	; 61
    5b42:	df 91       	pop	r29
    5b44:	cf 91       	pop	r28
    5b46:	1f 91       	pop	r17
    5b48:	0f 91       	pop	r16
    5b4a:	ff 90       	pop	r15
    5b4c:	ef 90       	pop	r14
    5b4e:	df 90       	pop	r13
    5b50:	cf 90       	pop	r12
    5b52:	bf 90       	pop	r11
    5b54:	af 90       	pop	r10
    5b56:	9f 90       	pop	r9
    5b58:	8f 90       	pop	r8
    5b5a:	7f 90       	pop	r7
    5b5c:	6f 90       	pop	r6
    5b5e:	5f 90       	pop	r5
    5b60:	4f 90       	pop	r4
    5b62:	3f 90       	pop	r3
    5b64:	2f 90       	pop	r2
    5b66:	08 95       	ret

00005b68 <plan_sync_position>:
        pl.position[idx] = (sys.position[A_MOTOR] - sys.position[B_MOTOR])/2;
      } else {
        pl.position[idx] = sys.position[idx];
      }
    #else
      pl.position[idx] = sys.position[idx];
    5b68:	80 91 6c 07 	lds	r24, 0x076C
    5b6c:	90 91 6d 07 	lds	r25, 0x076D
    5b70:	a0 91 6e 07 	lds	r26, 0x076E
    5b74:	b0 91 6f 07 	lds	r27, 0x076F
    5b78:	80 93 27 02 	sts	0x0227, r24
    5b7c:	90 93 28 02 	sts	0x0228, r25
    5b80:	a0 93 29 02 	sts	0x0229, r26
    5b84:	b0 93 2a 02 	sts	0x022A, r27
    5b88:	80 91 70 07 	lds	r24, 0x0770
    5b8c:	90 91 71 07 	lds	r25, 0x0771
    5b90:	a0 91 72 07 	lds	r26, 0x0772
    5b94:	b0 91 73 07 	lds	r27, 0x0773
    5b98:	80 93 2b 02 	sts	0x022B, r24
    5b9c:	90 93 2c 02 	sts	0x022C, r25
    5ba0:	a0 93 2d 02 	sts	0x022D, r26
    5ba4:	b0 93 2e 02 	sts	0x022E, r27
    5ba8:	80 91 74 07 	lds	r24, 0x0774
    5bac:	90 91 75 07 	lds	r25, 0x0775
    5bb0:	a0 91 76 07 	lds	r26, 0x0776
    5bb4:	b0 91 77 07 	lds	r27, 0x0777
    5bb8:	80 93 2f 02 	sts	0x022F, r24
    5bbc:	90 93 30 02 	sts	0x0230, r25
    5bc0:	a0 93 31 02 	sts	0x0231, r26
    5bc4:	b0 93 32 02 	sts	0x0232, r27
    5bc8:	08 95       	ret

00005bca <plan_get_block_buffer_count>:


// Returns the number of active blocks are in the planner buffer.
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
    5bca:	80 91 45 02 	lds	r24, 0x0245
    5bce:	90 91 46 02 	lds	r25, 0x0246
    5bd2:	89 17       	cp	r24, r25
    5bd4:	10 f0       	brcs	.+4      	; 0x5bda <plan_get_block_buffer_count+0x10>
    5bd6:	89 1b       	sub	r24, r25
    5bd8:	08 95       	ret
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
    5bda:	80 5e       	subi	r24, 0xE0	; 224
    5bdc:	89 1b       	sub	r24, r25
}
    5bde:	08 95       	ret

00005be0 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    5be0:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    5be4:	80 91 46 02 	lds	r24, 0x0246
    5be8:	80 93 43 02 	sts	0x0243, r24
  planner_recalculate();  
    5bec:	0e 94 12 29 	call	0x5224	; 0x5224 <planner_recalculate>
    5bf0:	08 95       	ret

00005bf2 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized. 
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
uint8_t read_float(char *line, uint8_t *char_counter, float *float_ptr)                  
{
    5bf2:	4f 92       	push	r4
    5bf4:	5f 92       	push	r5
    5bf6:	6f 92       	push	r6
    5bf8:	7f 92       	push	r7
    5bfa:	9f 92       	push	r9
    5bfc:	af 92       	push	r10
    5bfe:	bf 92       	push	r11
    5c00:	cf 92       	push	r12
    5c02:	df 92       	push	r13
    5c04:	ef 92       	push	r14
    5c06:	ff 92       	push	r15
    5c08:	0f 93       	push	r16
    5c0a:	1f 93       	push	r17
    5c0c:	cf 93       	push	r28
    5c0e:	df 93       	push	r29
    5c10:	7c 01       	movw	r14, r24
    5c12:	8b 01       	movw	r16, r22
    5c14:	6a 01       	movw	r12, r20
  char *ptr = line + *char_counter;
    5c16:	fb 01       	movw	r30, r22
    5c18:	80 81       	ld	r24, Z
    5c1a:	f7 01       	movw	r30, r14
    5c1c:	e8 0f       	add	r30, r24
    5c1e:	f1 1d       	adc	r31, r1
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
    5c20:	40 81       	ld	r20, Z
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    5c22:	4d 32       	cpi	r20, 0x2D	; 45
    5c24:	39 f4       	brne	.+14     	; 0x5c34 <read_float+0x42>
    isnegative = true;
    c = *ptr++;
    5c26:	9f 01       	movw	r18, r30
    5c28:	2e 5f       	subi	r18, 0xFE	; 254
    5c2a:	3f 4f       	sbci	r19, 0xFF	; 255
    5c2c:	41 81       	ldd	r20, Z+1	; 0x01
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    isnegative = true;
    5c2e:	aa 24       	eor	r10, r10
    5c30:	a3 94       	inc	r10
    5c32:	0c c0       	rjmp	.+24     	; 0x5c4c <read_float+0x5a>
    c = *ptr++;
  } else if (c == '+') {
    5c34:	4b 32       	cpi	r20, 0x2B	; 43
    5c36:	29 f0       	breq	.+10     	; 0x5c42 <read_float+0x50>
{
  char *ptr = line + *char_counter;
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
    5c38:	9f 01       	movw	r18, r30
    5c3a:	2f 5f       	subi	r18, 0xFF	; 255
    5c3c:	3f 4f       	sbci	r19, 0xFF	; 255
  
  // Capture initial positive/minus character
  bool isnegative = false;
    5c3e:	a1 2c       	mov	r10, r1
    5c40:	05 c0       	rjmp	.+10     	; 0x5c4c <read_float+0x5a>
  if (c == '-') {
    isnegative = true;
    c = *ptr++;
  } else if (c == '+') {
    c = *ptr++;
    5c42:	9f 01       	movw	r18, r30
    5c44:	2e 5f       	subi	r18, 0xFE	; 254
    5c46:	3f 4f       	sbci	r19, 0xFF	; 255
    5c48:	41 81       	ldd	r20, Z+1	; 0x01
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
    5c4a:	a1 2c       	mov	r10, r1
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
    5c4c:	e0 e0       	ldi	r30, 0x00	; 0
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
    5c4e:	50 e0       	ldi	r21, 0x00	; 0
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
    5c50:	b1 2c       	mov	r11, r1
  } else if (c == '+') {
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
    5c52:	60 e0       	ldi	r22, 0x00	; 0
    5c54:	70 e0       	ldi	r23, 0x00	; 0
    5c56:	cb 01       	movw	r24, r22
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
      isdecimal = true;
    5c58:	f1 e0       	ldi	r31, 0x01	; 1
    5c5a:	e9 01       	movw	r28, r18
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
  while(1) {
    c -= '0';
    5c5c:	40 53       	subi	r20, 0x30	; 48
    if (c <= 9) {
    5c5e:	4a 30       	cpi	r20, 0x0A	; 10
    5c60:	20 f5       	brcc	.+72     	; 0x5caa <read_float+0xb8>
      ndigit++;
    5c62:	5f 5f       	subi	r21, 0xFF	; 255
      if (ndigit <= MAX_INT_DIGITS) {
    5c64:	59 30       	cpi	r21, 0x09	; 9
    5c66:	e8 f4       	brcc	.+58     	; 0x5ca2 <read_float+0xb0>
        if (isdecimal) { exp--; }
    5c68:	e1 11       	cpse	r30, r1
    5c6a:	ba 94       	dec	r11
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
    5c6c:	2b 01       	movw	r4, r22
    5c6e:	3c 01       	movw	r6, r24
    5c70:	44 0c       	add	r4, r4
    5c72:	55 1c       	adc	r5, r5
    5c74:	66 1c       	adc	r6, r6
    5c76:	77 1c       	adc	r7, r7
    5c78:	44 0c       	add	r4, r4
    5c7a:	55 1c       	adc	r5, r5
    5c7c:	66 1c       	adc	r6, r6
    5c7e:	77 1c       	adc	r7, r7
    5c80:	dc 01       	movw	r26, r24
    5c82:	cb 01       	movw	r24, r22
    5c84:	84 0d       	add	r24, r4
    5c86:	95 1d       	adc	r25, r5
    5c88:	a6 1d       	adc	r26, r6
    5c8a:	b7 1d       	adc	r27, r7
    5c8c:	88 0f       	add	r24, r24
    5c8e:	99 1f       	adc	r25, r25
    5c90:	aa 1f       	adc	r26, r26
    5c92:	bb 1f       	adc	r27, r27
    5c94:	bc 01       	movw	r22, r24
    5c96:	cd 01       	movw	r24, r26
    5c98:	64 0f       	add	r22, r20
    5c9a:	71 1d       	adc	r23, r1
    5c9c:	81 1d       	adc	r24, r1
    5c9e:	91 1d       	adc	r25, r1
    5ca0:	09 c0       	rjmp	.+18     	; 0x5cb4 <read_float+0xc2>
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
    5ca2:	e1 11       	cpse	r30, r1
    5ca4:	07 c0       	rjmp	.+14     	; 0x5cb4 <read_float+0xc2>
    5ca6:	b3 94       	inc	r11
    5ca8:	05 c0       	rjmp	.+10     	; 0x5cb4 <read_float+0xc2>
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
    5caa:	4e 3f       	cpi	r20, 0xFE	; 254
    5cac:	39 f4       	brne	.+14     	; 0x5cbc <read_float+0xca>
    5cae:	e1 11       	cpse	r30, r1
    5cb0:	07 c0       	rjmp	.+14     	; 0x5cc0 <read_float+0xce>
      isdecimal = true;
    5cb2:	ef 2f       	mov	r30, r31
    } else {
      break;
    }
    c = *ptr++;
    5cb4:	48 81       	ld	r20, Y
    5cb6:	2f 5f       	subi	r18, 0xFF	; 255
    5cb8:	3f 4f       	sbci	r19, 0xFF	; 255
  }
    5cba:	cf cf       	rjmp	.-98     	; 0x5c5a <read_float+0x68>
    5cbc:	9b 2c       	mov	r9, r11
    5cbe:	01 c0       	rjmp	.+2      	; 0x5cc2 <read_float+0xd0>
    5cc0:	9b 2c       	mov	r9, r11
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
    5cc2:	55 23       	and	r21, r21
    5cc4:	09 f4       	brne	.+2      	; 0x5cc8 <read_float+0xd6>
    5cc6:	50 c0       	rjmp	.+160    	; 0x5d68 <read_float+0x176>
  
  // Convert integer into floating point.
  float fval;
  fval = (float)intval;
    5cc8:	0e 94 3a 3d 	call	0x7a74	; 0x7a74 <__floatunsisf>
    5ccc:	2b 01       	movw	r4, r22
    5cce:	3c 01       	movw	r6, r24
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    5cd0:	20 e0       	ldi	r18, 0x00	; 0
    5cd2:	30 e0       	ldi	r19, 0x00	; 0
    5cd4:	a9 01       	movw	r20, r18
    5cd6:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    5cda:	88 23       	and	r24, r24
    5cdc:	69 f1       	breq	.+90     	; 0x5d38 <read_float+0x146>
    while (exp <= -2) {
    5cde:	ff ef       	ldi	r31, 0xFF	; 255
    5ce0:	9f 16       	cp	r9, r31
    5ce2:	7c f4       	brge	.+30     	; 0x5d02 <read_float+0x110>
      fval *= 0.01; 
    5ce4:	2a e0       	ldi	r18, 0x0A	; 10
    5ce6:	37 ed       	ldi	r19, 0xD7	; 215
    5ce8:	43 e2       	ldi	r20, 0x23	; 35
    5cea:	5c e3       	ldi	r21, 0x3C	; 60
    5cec:	c3 01       	movw	r24, r6
    5cee:	b2 01       	movw	r22, r4
    5cf0:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5cf4:	2b 01       	movw	r4, r22
    5cf6:	3c 01       	movw	r6, r24
    5cf8:	b3 94       	inc	r11
    5cfa:	b3 94       	inc	r11
  fval = (float)intval;
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    while (exp <= -2) {
    5cfc:	8f ef       	ldi	r24, 0xFF	; 255
    5cfe:	b8 16       	cp	r11, r24
    5d00:	8c f3       	brlt	.-30     	; 0x5ce4 <read_float+0xf2>
      fval *= 0.01; 
      exp += 2;
    }
    if (exp < 0) { 
    5d02:	bb 20       	and	r11, r11
    5d04:	5c f4       	brge	.+22     	; 0x5d1c <read_float+0x12a>
      fval *= 0.1; 
    5d06:	2d ec       	ldi	r18, 0xCD	; 205
    5d08:	3c ec       	ldi	r19, 0xCC	; 204
    5d0a:	4c ec       	ldi	r20, 0xCC	; 204
    5d0c:	5d e3       	ldi	r21, 0x3D	; 61
    5d0e:	c3 01       	movw	r24, r6
    5d10:	b2 01       	movw	r22, r4
    5d12:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5d16:	2b 01       	movw	r4, r22
    5d18:	3c 01       	movw	r6, r24
    5d1a:	0e c0       	rjmp	.+28     	; 0x5d38 <read_float+0x146>
    } else if (exp > 0) {
    5d1c:	1b 14       	cp	r1, r11
    5d1e:	64 f4       	brge	.+24     	; 0x5d38 <read_float+0x146>
      do {
        fval *= 10.0;
    5d20:	20 e0       	ldi	r18, 0x00	; 0
    5d22:	30 e0       	ldi	r19, 0x00	; 0
    5d24:	40 e2       	ldi	r20, 0x20	; 32
    5d26:	51 e4       	ldi	r21, 0x41	; 65
    5d28:	c3 01       	movw	r24, r6
    5d2a:	b2 01       	movw	r22, r4
    5d2c:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5d30:	2b 01       	movw	r4, r22
    5d32:	3c 01       	movw	r6, r24
      } while (--exp > 0);
    5d34:	ba 94       	dec	r11
    5d36:	a1 f7       	brne	.-24     	; 0x5d20 <read_float+0x12e>
    } 
  }

  // Assign floating point value with correct sign.    
  if (isnegative) {
    5d38:	aa 20       	and	r10, r10
    5d3a:	51 f0       	breq	.+20     	; 0x5d50 <read_float+0x15e>
    *float_ptr = -fval;
    5d3c:	77 fa       	bst	r7, 7
    5d3e:	70 94       	com	r7
    5d40:	77 f8       	bld	r7, 7
    5d42:	70 94       	com	r7
    5d44:	f6 01       	movw	r30, r12
    5d46:	40 82       	st	Z, r4
    5d48:	51 82       	std	Z+1, r5	; 0x01
    5d4a:	62 82       	std	Z+2, r6	; 0x02
    5d4c:	73 82       	std	Z+3, r7	; 0x03
    5d4e:	05 c0       	rjmp	.+10     	; 0x5d5a <read_float+0x168>
  } else {
    *float_ptr = fval;
    5d50:	f6 01       	movw	r30, r12
    5d52:	40 82       	st	Z, r4
    5d54:	51 82       	std	Z+1, r5	; 0x01
    5d56:	62 82       	std	Z+2, r6	; 0x02
    5d58:	73 82       	std	Z+3, r7	; 0x03
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
    5d5a:	ce 19       	sub	r28, r14
    5d5c:	df 09       	sbc	r29, r15
    5d5e:	c1 50       	subi	r28, 0x01	; 1
    5d60:	f8 01       	movw	r30, r16
    5d62:	c0 83       	st	Z, r28
  
  return(true);
    5d64:	81 e0       	ldi	r24, 0x01	; 1
    5d66:	01 c0       	rjmp	.+2      	; 0x5d6a <read_float+0x178>
    }
    c = *ptr++;
  }
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
    5d68:	80 e0       	ldi	r24, 0x00	; 0
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
  
  return(true);
}
    5d6a:	df 91       	pop	r29
    5d6c:	cf 91       	pop	r28
    5d6e:	1f 91       	pop	r17
    5d70:	0f 91       	pop	r16
    5d72:	ff 90       	pop	r15
    5d74:	ef 90       	pop	r14
    5d76:	df 90       	pop	r13
    5d78:	cf 90       	pop	r12
    5d7a:	bf 90       	pop	r11
    5d7c:	af 90       	pop	r10
    5d7e:	9f 90       	pop	r9
    5d80:	7f 90       	pop	r7
    5d82:	6f 90       	pop	r6
    5d84:	5f 90       	pop	r5
    5d86:	4f 90       	pop	r4
    5d88:	08 95       	ret

00005d8a <delay_ms>:

// Delays variable defined milliseconds. Compiler compatibility fix for _delay_ms(),
// which only accepts constants in future compiler releases.
void delay_ms(uint16_t ms) 
{
  while ( ms-- ) { _delay_ms(1); }
    5d8a:	00 97       	sbiw	r24, 0x00	; 0
    5d8c:	49 f0       	breq	.+18     	; 0x5da0 <delay_ms+0x16>
    5d8e:	ef ef       	ldi	r30, 0xFF	; 255
    5d90:	f1 e1       	ldi	r31, 0x11	; 17
    5d92:	31 97       	sbiw	r30, 0x01	; 1
    5d94:	f1 f7       	brne	.-4      	; 0x5d92 <delay_ms+0x8>
    5d96:	00 c0       	rjmp	.+0      	; 0x5d98 <delay_ms+0xe>
    5d98:	00 00       	nop
    5d9a:	01 97       	sbiw	r24, 0x01	; 1
    5d9c:	00 97       	sbiw	r24, 0x00	; 0
    5d9e:	b9 f7       	brne	.-18     	; 0x5d8e <delay_ms+0x4>
    5da0:	08 95       	ret

00005da2 <delay_us>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    5da2:	61 15       	cp	r22, r1
    5da4:	71 05       	cpc	r23, r1
    5da6:	81 05       	cpc	r24, r1
    5da8:	91 05       	cpc	r25, r1
    5daa:	e1 f1       	breq	.+120    	; 0x5e24 <delay_us+0x82>
    if (us < 10) { 
    5dac:	6a 30       	cpi	r22, 0x0A	; 10
    5dae:	71 05       	cpc	r23, r1
    5db0:	81 05       	cpc	r24, r1
    5db2:	91 05       	cpc	r25, r1
    5db4:	48 f4       	brcc	.+18     	; 0x5dc8 <delay_us+0x26>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5db6:	26 e0       	ldi	r18, 0x06	; 6
    5db8:	2a 95       	dec	r18
    5dba:	f1 f7       	brne	.-4      	; 0x5db8 <delay_us+0x16>
    5dbc:	00 00       	nop
      _delay_us(1);
      us--;
    5dbe:	61 50       	subi	r22, 0x01	; 1
    5dc0:	71 09       	sbc	r23, r1
    5dc2:	81 09       	sbc	r24, r1
    5dc4:	91 09       	sbc	r25, r1
    5dc6:	29 c0       	rjmp	.+82     	; 0x5e1a <delay_us+0x78>
    } else if (us < 100) {
    5dc8:	64 36       	cpi	r22, 0x64	; 100
    5dca:	71 05       	cpc	r23, r1
    5dcc:	81 05       	cpc	r24, r1
    5dce:	91 05       	cpc	r25, r1
    5dd0:	48 f4       	brcc	.+18     	; 0x5de4 <delay_us+0x42>
    5dd2:	ed e3       	ldi	r30, 0x3D	; 61
    5dd4:	ea 95       	dec	r30
    5dd6:	f1 f7       	brne	.-4      	; 0x5dd4 <delay_us+0x32>
    5dd8:	00 c0       	rjmp	.+0      	; 0x5dda <delay_us+0x38>
      _delay_us(10);
      us -= 10;
    5dda:	6a 50       	subi	r22, 0x0A	; 10
    5ddc:	71 09       	sbc	r23, r1
    5dde:	81 09       	sbc	r24, r1
    5de0:	91 09       	sbc	r25, r1
    5de2:	1b c0       	rjmp	.+54     	; 0x5e1a <delay_us+0x78>
    } else if (us < 1000) {
    5de4:	68 3e       	cpi	r22, 0xE8	; 232
    5de6:	f3 e0       	ldi	r31, 0x03	; 3
    5de8:	7f 07       	cpc	r23, r31
    5dea:	81 05       	cpc	r24, r1
    5dec:	91 05       	cpc	r25, r1
    5dee:	58 f4       	brcc	.+22     	; 0x5e06 <delay_us+0x64>
    5df0:	ec ec       	ldi	r30, 0xCC	; 204
    5df2:	f1 e0       	ldi	r31, 0x01	; 1
    5df4:	31 97       	sbiw	r30, 0x01	; 1
    5df6:	f1 f7       	brne	.-4      	; 0x5df4 <delay_us+0x52>
    5df8:	00 c0       	rjmp	.+0      	; 0x5dfa <delay_us+0x58>
    5dfa:	00 00       	nop
      _delay_us(100);
      us -= 100;
    5dfc:	64 56       	subi	r22, 0x64	; 100
    5dfe:	71 09       	sbc	r23, r1
    5e00:	81 09       	sbc	r24, r1
    5e02:	91 09       	sbc	r25, r1
    5e04:	0a c0       	rjmp	.+20     	; 0x5e1a <delay_us+0x78>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5e06:	ef ef       	ldi	r30, 0xFF	; 255
    5e08:	f1 e1       	ldi	r31, 0x11	; 17
    5e0a:	31 97       	sbiw	r30, 0x01	; 1
    5e0c:	f1 f7       	brne	.-4      	; 0x5e0a <delay_us+0x68>
    5e0e:	00 c0       	rjmp	.+0      	; 0x5e10 <delay_us+0x6e>
    5e10:	00 00       	nop
    } else {
      _delay_ms(1);
      us -= 1000;
    5e12:	68 5e       	subi	r22, 0xE8	; 232
    5e14:	73 40       	sbci	r23, 0x03	; 3
    5e16:	81 09       	sbc	r24, r1
    5e18:	91 09       	sbc	r25, r1
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    5e1a:	61 15       	cp	r22, r1
    5e1c:	71 05       	cpc	r23, r1
    5e1e:	81 05       	cpc	r24, r1
    5e20:	91 05       	cpc	r25, r1
    5e22:	21 f6       	brne	.-120    	; 0x5dac <delay_us+0xa>
    5e24:	08 95       	ret

00005e26 <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    5e26:	8f 92       	push	r8
    5e28:	9f 92       	push	r9
    5e2a:	af 92       	push	r10
    5e2c:	bf 92       	push	r11
    5e2e:	cf 92       	push	r12
    5e30:	df 92       	push	r13
    5e32:	ef 92       	push	r14
    5e34:	ff 92       	push	r15
    5e36:	69 01       	movw	r12, r18
    5e38:	7a 01       	movw	r14, r20
    5e3a:	9b 01       	movw	r18, r22
    5e3c:	ac 01       	movw	r20, r24
    5e3e:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5e42:	4b 01       	movw	r8, r22
    5e44:	5c 01       	movw	r10, r24
    5e46:	a7 01       	movw	r20, r14
    5e48:	96 01       	movw	r18, r12
    5e4a:	c7 01       	movw	r24, r14
    5e4c:	b6 01       	movw	r22, r12
    5e4e:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    5e52:	9b 01       	movw	r18, r22
    5e54:	ac 01       	movw	r20, r24
    5e56:	c5 01       	movw	r24, r10
    5e58:	b4 01       	movw	r22, r8
    5e5a:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    5e5e:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    5e62:	ff 90       	pop	r15
    5e64:	ef 90       	pop	r14
    5e66:	df 90       	pop	r13
    5e68:	cf 90       	pop	r12
    5e6a:	bf 90       	pop	r11
    5e6c:	af 90       	pop	r10
    5e6e:	9f 90       	pop	r9
    5e70:	8f 90       	pop	r8
    5e72:	08 95       	ret

00005e74 <limits_disable>:
}


void limits_disable()
{
  LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    5e74:	ec e6       	ldi	r30, 0x6C	; 108
    5e76:	f0 e0       	ldi	r31, 0x00	; 0
    5e78:	80 81       	ld	r24, Z
    5e7a:	81 7f       	andi	r24, 0xF1	; 241
    5e7c:	80 83       	st	Z, r24
  PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    5e7e:	e8 e6       	ldi	r30, 0x68	; 104
    5e80:	f0 e0       	ldi	r31, 0x00	; 0
    5e82:	80 81       	ld	r24, Z
    5e84:	8d 7f       	andi	r24, 0xFD	; 253
    5e86:	80 83       	st	Z, r24
    5e88:	08 95       	ret

00005e8a <limits_init>:
#define HOMING_AXIS_SEARCH_SCALAR  1.5 // Must be > 1 to ensure limit switch will be engaged.


void limits_init() 
{
  LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    5e8a:	84 b1       	in	r24, 0x04	; 4
    5e8c:	81 7f       	andi	r24, 0xF1	; 241
    5e8e:	84 b9       	out	0x04, r24	; 4

  #ifdef DISABLE_LIMIT_PIN_PULL_UP
    LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
  #else
    LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    5e90:	85 b1       	in	r24, 0x05	; 5
    5e92:	8e 60       	ori	r24, 0x0E	; 14
    5e94:	85 b9       	out	0x05, r24	; 5
  #endif

  if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    5e96:	80 91 3c 09 	lds	r24, 0x093C
    5e9a:	83 ff       	sbrs	r24, 3
    5e9c:	0b c0       	rjmp	.+22     	; 0x5eb4 <limits_init+0x2a>
    LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    5e9e:	ec e6       	ldi	r30, 0x6C	; 108
    5ea0:	f0 e0       	ldi	r31, 0x00	; 0
    5ea2:	80 81       	ld	r24, Z
    5ea4:	8e 60       	ori	r24, 0x0E	; 14
    5ea6:	80 83       	st	Z, r24
    PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    5ea8:	e8 e6       	ldi	r30, 0x68	; 104
    5eaa:	f0 e0       	ldi	r31, 0x00	; 0
    5eac:	80 81       	ld	r24, Z
    5eae:	82 60       	ori	r24, 0x02	; 2
    5eb0:	80 83       	st	Z, r24
    5eb2:	08 95       	ret
  } else {
    limits_disable(); 
    5eb4:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <limits_disable>
    5eb8:	08 95       	ret

00005eba <__vector_5>:
// homing cycles and will not respond correctly. Upon user request or need, there may be a
// special pinout for an e-stop, but it is generally recommended to just directly connect
// your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
#ifndef ENABLE_SOFTWARE_DEBOUNCE
  ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process. 
  {
    5eba:	1f 92       	push	r1
    5ebc:	0f 92       	push	r0
    5ebe:	0f b6       	in	r0, 0x3f	; 63
    5ec0:	0f 92       	push	r0
    5ec2:	11 24       	eor	r1, r1
    5ec4:	2f 93       	push	r18
    5ec6:	3f 93       	push	r19
    5ec8:	4f 93       	push	r20
    5eca:	5f 93       	push	r21
    5ecc:	6f 93       	push	r22
    5ece:	7f 93       	push	r23
    5ed0:	8f 93       	push	r24
    5ed2:	9f 93       	push	r25
    5ed4:	af 93       	push	r26
    5ed6:	bf 93       	push	r27
    5ed8:	ef 93       	push	r30
    5eda:	ff 93       	push	r31
    // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
    // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
    // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
    // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
    // limit setting if their limits are constantly triggering after a reset and move their axes.
    if (sys.state != STATE_ALARM) { 
    5edc:	80 91 68 07 	lds	r24, 0x0768
    5ee0:	81 30       	cpi	r24, 0x01	; 1
    5ee2:	71 f0       	breq	.+28     	; 0x5f00 <__vector_5+0x46>
      if (!(sys.rt_exec_alarm)) {
    5ee4:	80 91 6b 07 	lds	r24, 0x076B
    5ee8:	81 11       	cpse	r24, r1
    5eea:	0a c0       	rjmp	.+20     	; 0x5f00 <__vector_5+0x46>
        mc_reset(); // Initiate system kill.
    5eec:	0e 94 ad 0c 	call	0x195a	; 0x195a <mc_reset>
        bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
    5ef0:	8f b7       	in	r24, 0x3f	; 63
    5ef2:	f8 94       	cli
    5ef4:	eb e6       	ldi	r30, 0x6B	; 107
    5ef6:	f7 e0       	ldi	r31, 0x07	; 7
    5ef8:	90 81       	ld	r25, Z
    5efa:	93 60       	ori	r25, 0x03	; 3
    5efc:	90 83       	st	Z, r25
    5efe:	8f bf       	out	0x3f, r24	; 63
      }
    }
  }  
    5f00:	ff 91       	pop	r31
    5f02:	ef 91       	pop	r30
    5f04:	bf 91       	pop	r27
    5f06:	af 91       	pop	r26
    5f08:	9f 91       	pop	r25
    5f0a:	8f 91       	pop	r24
    5f0c:	7f 91       	pop	r23
    5f0e:	6f 91       	pop	r22
    5f10:	5f 91       	pop	r21
    5f12:	4f 91       	pop	r20
    5f14:	3f 91       	pop	r19
    5f16:	2f 91       	pop	r18
    5f18:	0f 90       	pop	r0
    5f1a:	0f be       	out	0x3f, r0	; 63
    5f1c:	0f 90       	pop	r0
    5f1e:	1f 90       	pop	r1
    5f20:	18 95       	reti

00005f22 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically 
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask) 
{
    5f22:	2f 92       	push	r2
    5f24:	3f 92       	push	r3
    5f26:	4f 92       	push	r4
    5f28:	5f 92       	push	r5
    5f2a:	6f 92       	push	r6
    5f2c:	7f 92       	push	r7
    5f2e:	8f 92       	push	r8
    5f30:	9f 92       	push	r9
    5f32:	af 92       	push	r10
    5f34:	bf 92       	push	r11
    5f36:	cf 92       	push	r12
    5f38:	df 92       	push	r13
    5f3a:	ef 92       	push	r14
    5f3c:	ff 92       	push	r15
    5f3e:	0f 93       	push	r16
    5f40:	1f 93       	push	r17
    5f42:	cf 93       	push	r28
    5f44:	df 93       	push	r29
    5f46:	cd b7       	in	r28, 0x3d	; 61
    5f48:	de b7       	in	r29, 0x3e	; 62
    5f4a:	e3 97       	sbiw	r28, 0x33	; 51
    5f4c:	0f b6       	in	r0, 0x3f	; 63
    5f4e:	f8 94       	cli
    5f50:	de bf       	out	0x3e, r29	; 62
    5f52:	0f be       	out	0x3f, r0	; 63
    5f54:	cd bf       	out	0x3d, r28	; 61
    5f56:	a8 2e       	mov	r10, r24
  if (sys.abort) { return; } // Block if system reset has been issued.
    5f58:	80 91 67 07 	lds	r24, 0x0767
    5f5c:	81 11       	cpse	r24, r1
    5f5e:	7b c2       	rjmp	.+1270   	; 0x6456 <limits_go_home+0x534>

  // Initialize homing in search mode to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    5f60:	80 91 42 09 	lds	r24, 0x0942
    5f64:	90 91 43 09 	lds	r25, 0x0943
    5f68:	a0 91 44 09 	lds	r26, 0x0944
    5f6c:	b0 91 45 09 	lds	r27, 0x0945
    5f70:	88 a3       	std	Y+32, r24	; 0x20
    5f72:	99 a3       	std	Y+33, r25	; 0x21
    5f74:	aa a3       	std	Y+34, r26	; 0x22
    5f76:	bb a3       	std	Y+35, r27	; 0x23
    5f78:	de 01       	movw	r26, r28
    5f7a:	1d 96       	adiw	r26, 0x0d	; 13
    5f7c:	be 8b       	std	Y+22, r27	; 0x16
    5f7e:	ad 8b       	std	Y+21, r26	; 0x15
    5f80:	fe 01       	movw	r30, r28
    5f82:	70 96       	adiw	r30, 0x10	; 16
    5f84:	fc 8b       	std	Y+20, r31	; 0x14
    5f86:	eb 8b       	std	Y+19, r30	; 0x13
    5f88:	1f 01       	movw	r2, r30
    5f8a:	0f 2e       	mov	r0, r31
    5f8c:	f3 e2       	ldi	r31, 0x23	; 35
    5f8e:	4f 2e       	mov	r4, r31
    5f90:	f9 e0       	ldi	r31, 0x09	; 9
    5f92:	5f 2e       	mov	r5, r31
    5f94:	f0 2d       	mov	r31, r0
    5f96:	3f 01       	movw	r6, r30
    5f98:	8d 01       	movw	r16, r26
  uint8_t invert_pin, idx;
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  float target[N_AXIS];
  
  uint8_t limit_pin[N_AXIS], step_pin[N_AXIS];
  float max_travel = 0.0;
    5f9a:	81 2c       	mov	r8, r1
    5f9c:	91 2c       	mov	r9, r1
    5f9e:	b1 2c       	mov	r11, r1
    5fa0:	a9 8e       	std	Y+25, r10	; 0x19
    5fa2:	ab 2c       	mov	r10, r11
    5fa4:	f0 2e       	mov	r15, r16
    5fa6:	3d 89       	ldd	r19, Y+21	; 0x15
    5fa8:	f3 1a       	sub	r15, r19
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize limit and step pin masks
    limit_pin[idx] = get_limit_pin_mask(idx);
    5faa:	8f 2d       	mov	r24, r15
    5fac:	0e 94 08 29 	call	0x5210	; 0x5210 <get_limit_pin_mask>
    5fb0:	d8 01       	movw	r26, r16
    5fb2:	8d 93       	st	X+, r24
    5fb4:	8d 01       	movw	r16, r26
    step_pin[idx] = get_step_pin_mask(idx);
    5fb6:	8f 2d       	mov	r24, r15
    5fb8:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <get_step_pin_mask>
    5fbc:	f3 01       	movw	r30, r6
    5fbe:	81 93       	st	Z+, r24
    5fc0:	3f 01       	movw	r6, r30
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif
    
    // Determine travel distance to the furthest homing switch based on user max travel settings.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (max_travel > settings.max_travel[idx]) { max_travel = settings.max_travel[idx]; }
    5fc2:	d2 01       	movw	r26, r4
    5fc4:	cd 90       	ld	r12, X+
    5fc6:	dd 90       	ld	r13, X+
    5fc8:	ed 90       	ld	r14, X+
    5fca:	fd 90       	ld	r15, X+
    5fcc:	2d 01       	movw	r4, r26
    5fce:	2b 2d       	mov	r18, r11
    5fd0:	38 2d       	mov	r19, r8
    5fd2:	49 2d       	mov	r20, r9
    5fd4:	5a 2d       	mov	r21, r10
    5fd6:	c7 01       	movw	r24, r14
    5fd8:	b6 01       	movw	r22, r12
    5fda:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    5fde:	88 23       	and	r24, r24
    5fe0:	24 f4       	brge	.+8      	; 0x5fea <limits_go_home+0xc8>
    5fe2:	bc 2c       	mov	r11, r12
    5fe4:	8d 2c       	mov	r8, r13
    5fe6:	9e 2c       	mov	r9, r14
    5fe8:	af 2c       	mov	r10, r15
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  float target[N_AXIS];
  
  uint8_t limit_pin[N_AXIS], step_pin[N_AXIS];
  float max_travel = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {  
    5fea:	02 15       	cp	r16, r2
    5fec:	13 05       	cpc	r17, r3
    5fee:	d1 f6       	brne	.-76     	; 0x5fa4 <limits_go_home+0x82>
    5ff0:	fb 2c       	mov	r15, r11
    5ff2:	ba 2c       	mov	r11, r10
    5ff4:	a9 8c       	ldd	r10, Y+25	; 0x19
    
    // Determine travel distance to the furthest homing switch based on user max travel settings.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (max_travel > settings.max_travel[idx]) { max_travel = settings.max_travel[idx]; }
  }
  max_travel *= -HOMING_AXIS_SEARCH_SCALAR; // Ensure homing switches engaged by over-estimating max travel.
    5ff6:	20 e0       	ldi	r18, 0x00	; 0
    5ff8:	30 e0       	ldi	r19, 0x00	; 0
    5ffa:	40 ec       	ldi	r20, 0xC0	; 192
    5ffc:	5f eb       	ldi	r21, 0xBF	; 191
    5ffe:	6f 2d       	mov	r22, r15
    6000:	78 2d       	mov	r23, r8
    6002:	89 2d       	mov	r24, r9
    6004:	9b 2d       	mov	r25, r11
    6006:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    600a:	6c a3       	std	Y+36, r22	; 0x24
    600c:	7d a3       	std	Y+37, r23	; 0x25
    600e:	8e a3       	std	Y+38, r24	; 0x26
    6010:	9f a3       	std	Y+39, r25	; 0x27
  
  plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
    6012:	0e 94 42 2a 	call	0x5484	; 0x5484 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    6016:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <plan_sync_position>
    601a:	b6 e0       	ldi	r27, 0x06	; 6
    601c:	be a7       	std	Y+46, r27	; 0x2e
void limits_go_home(uint8_t cycle_mask) 
{
  if (sys.abort) { return; } // Block if system reset has been issued.

  // Initialize homing in search mode to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    601e:	e1 e0       	ldi	r30, 0x01	; 1
    6020:	ec 8f       	std	Y+28, r30	; 0x1c

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    6022:	9e 01       	movw	r18, r28
    6024:	2f 5f       	subi	r18, 0xFF	; 255
    6026:	3f 4f       	sbci	r19, 0xFF	; 255
    6028:	38 8f       	std	Y+24, r19	; 0x18
    602a:	2f 8b       	std	Y+23, r18	; 0x17
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    602c:	8a 2d       	mov	r24, r10
    602e:	90 e0       	ldi	r25, 0x00	; 0
    6030:	9b 8f       	std	Y+27, r25	; 0x1b
    6032:	8a 8f       	std	Y+26, r24	; 0x1a
    6034:	9a 8d       	ldd	r25, Y+26	; 0x1a
    6036:	9d 8f       	std	Y+29, r25	; 0x1d
    6038:	ab 8d       	ldd	r26, Y+27	; 0x1b
    603a:	af a7       	std	Y+47, r26	; 0x2f

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    sys.homing_axis_lock = axislock;
    603c:	0f 2e       	mov	r0, r31
    603e:	f8 e7       	ldi	r31, 0x78	; 120
    6040:	4f 2e       	mov	r4, r31
    6042:	f7 e0       	ldi	r31, 0x07	; 7
    6044:	5f 2e       	mov	r5, r31
    6046:	f0 2d       	mov	r31, r0
    6048:	3e 01       	movw	r6, r28
    604a:	b3 e1       	ldi	r27, 0x13	; 19
    604c:	6b 0e       	add	r6, r27
    604e:	71 1c       	adc	r7, r1
      }
      sys.homing_axis_lock = axislock;
      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
      // Check only for user reset. No time to run protocol_execute_realtime() in this loop.

      if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) { // Abort homing and alarm upon safety door.
    6050:	0f 2e       	mov	r0, r31
    6052:	fa e6       	ldi	r31, 0x6A	; 106
    6054:	cf 2e       	mov	r12, r31
    6056:	f7 e0       	ldi	r31, 0x07	; 7
    6058:	df 2e       	mov	r13, r31
    605a:	f0 2d       	mov	r31, r0
    605c:	2d 88       	ldd	r2, Y+21	; 0x15
    605e:	ee 88       	ldd	r14, Y+22	; 0x16
    6060:	fb 88       	ldd	r15, Y+19	; 0x13
    6062:	3c 88       	ldd	r3, Y+20	; 0x14
    6064:	9f 2c       	mov	r9, r15
    6066:	83 2c       	mov	r8, r3
    6068:	3e 2c       	mov	r3, r14
  plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
  plan_sync_position(); // Sync planner position to current machine position.
  
  do {
    // Initialize invert_pin boolean based on approach and invert pin user setting.
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    606a:	80 91 3c 09 	lds	r24, 0x093C
    606e:	86 fd       	sbrc	r24, 6
    6070:	02 c0       	rjmp	.+4      	; 0x6076 <limits_go_home+0x154>
    6072:	ec 8c       	ldd	r14, Y+28	; 0x1c
    6074:	03 c0       	rjmp	.+6      	; 0x607c <limits_go_home+0x15a>
    else { invert_pin = !approach; }
    6076:	81 e0       	ldi	r24, 0x01	; 1
    6078:	ec 8c       	ldd	r14, Y+28	; 0x1c
    607a:	e8 26       	eor	r14, r24

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    607c:	6c e6       	ldi	r22, 0x6C	; 108
    607e:	77 e0       	ldi	r23, 0x07	; 7
    6080:	ce 01       	movw	r24, r28
    6082:	01 96       	adiw	r24, 0x01	; 1
    6084:	0e 94 a6 3b 	call	0x774c	; 0x774c <system_convert_array_steps_to_mpos>
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
        n_active_axis++;
        if (approach) {
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] -= max_travel; }
    6088:	80 91 3d 09 	lds	r24, 0x093D
    608c:	e8 2f       	mov	r30, r24
    608e:	f0 e0       	ldi	r31, 0x00	; 0
    6090:	ff 8f       	std	Y+31, r31	; 0x1f
    6092:	ee 8f       	std	Y+30, r30	; 0x1e
    6094:	ff 89       	ldd	r31, Y+23	; 0x17
    6096:	fa ab       	std	Y+50, r31	; 0x32
    6098:	28 8d       	ldd	r18, Y+24	; 0x18
    609a:	2b ab       	std	Y+51, r18	; 0x33
    609c:	ce 01       	movw	r24, r28
    609e:	01 96       	adiw	r24, 0x01	; 1
    60a0:	00 e0       	ldi	r16, 0x00	; 0
    60a2:	10 e0       	ldi	r17, 0x00	; 0
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    else { invert_pin = !approach; }

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;
    60a4:	f1 2c       	mov	r15, r1
    // Initialize invert_pin boolean based on approach and invert pin user setting.
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    else { invert_pin = !approach; }

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    60a6:	19 8e       	std	Y+25, r1	; 0x19
    60a8:	59 a6       	std	Y+41, r5	; 0x29
    60aa:	48 a6       	std	Y+40, r4	; 0x28
    60ac:	7b a6       	std	Y+43, r7	; 0x2b
    60ae:	6a a6       	std	Y+42, r6	; 0x2a
    60b0:	dd a6       	std	Y+45, r13	; 0x2d
    60b2:	cc a6       	std	Y+44, r12	; 0x2c
    60b4:	5f a4       	ldd	r5, Y+47	; 0x2f
    60b6:	d9 2c       	mov	r13, r9
    60b8:	9f 2c       	mov	r9, r15
    60ba:	78 2c       	mov	r7, r8
    60bc:	8e 2c       	mov	r8, r14
    60be:	7c 01       	movw	r14, r24
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    60c0:	ad 8c       	ldd	r10, Y+29	; 0x1d
    60c2:	b5 2c       	mov	r11, r5
    60c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    60c6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    60c8:	00 2e       	mov	r0, r16
    60ca:	02 c0       	rjmp	.+4      	; 0x60d0 <limits_go_home+0x1ae>
    60cc:	95 95       	asr	r25
    60ce:	87 95       	ror	r24
    60d0:	0a 94       	dec	r0
    60d2:	e2 f7       	brpl	.-8      	; 0x60cc <limits_go_home+0x1aa>
    60d4:	80 ff       	sbrs	r24, 0
    60d6:	62 c0       	rjmp	.+196    	; 0x619c <limits_go_home+0x27a>
        n_active_axis++;
    60d8:	99 8d       	ldd	r25, Y+25	; 0x19
    60da:	9f 5f       	subi	r25, 0xFF	; 255
    60dc:	99 8f       	std	Y+25, r25	; 0x19
        if (approach) {
    60de:	ac 8d       	ldd	r26, Y+28	; 0x1c
    60e0:	aa 23       	and	r26, r26
    60e2:	71 f1       	breq	.+92     	; 0x6140 <limits_go_home+0x21e>
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] -= max_travel; }
    60e4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    60e6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    60e8:	00 2e       	mov	r0, r16
    60ea:	02 c0       	rjmp	.+4      	; 0x60f0 <limits_go_home+0x1ce>
    60ec:	95 95       	asr	r25
    60ee:	87 95       	ror	r24
    60f0:	0a 94       	dec	r0
    60f2:	e2 f7       	brpl	.-8      	; 0x60ec <limits_go_home+0x1ca>
    60f4:	80 ff       	sbrs	r24, 0
    60f6:	12 c0       	rjmp	.+36     	; 0x611c <limits_go_home+0x1fa>
    60f8:	2c a1       	ldd	r18, Y+36	; 0x24
    60fa:	3d a1       	ldd	r19, Y+37	; 0x25
    60fc:	4e a1       	ldd	r20, Y+38	; 0x26
    60fe:	5f a1       	ldd	r21, Y+39	; 0x27
    6100:	f7 01       	movw	r30, r14
    6102:	60 81       	ld	r22, Z
    6104:	71 81       	ldd	r23, Z+1	; 0x01
    6106:	82 81       	ldd	r24, Z+2	; 0x02
    6108:	93 81       	ldd	r25, Z+3	; 0x03
    610a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    610e:	d7 01       	movw	r26, r14
    6110:	6d 93       	st	X+, r22
    6112:	7d 93       	st	X+, r23
    6114:	8d 93       	st	X+, r24
    6116:	9c 93       	st	X, r25
    6118:	13 97       	sbiw	r26, 0x03	; 3
    611a:	94 c1       	rjmp	.+808    	; 0x6444 <limits_go_home+0x522>
          else { target[idx] += max_travel; }
    611c:	2c a1       	ldd	r18, Y+36	; 0x24
    611e:	3d a1       	ldd	r19, Y+37	; 0x25
    6120:	4e a1       	ldd	r20, Y+38	; 0x26
    6122:	5f a1       	ldd	r21, Y+39	; 0x27
    6124:	f7 01       	movw	r30, r14
    6126:	60 81       	ld	r22, Z
    6128:	71 81       	ldd	r23, Z+1	; 0x01
    612a:	82 81       	ldd	r24, Z+2	; 0x02
    612c:	93 81       	ldd	r25, Z+3	; 0x03
    612e:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    6132:	d7 01       	movw	r26, r14
    6134:	6d 93       	st	X+, r22
    6136:	7d 93       	st	X+, r23
    6138:	8d 93       	st	X+, r24
    613a:	9c 93       	st	X, r25
    613c:	13 97       	sbiw	r26, 0x03	; 3
    613e:	82 c1       	rjmp	.+772    	; 0x6444 <limits_go_home+0x522>
        } else { 
          // Set target direction based on cycle mask
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] += max_travel; }
    6140:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6142:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6144:	00 2e       	mov	r0, r16
    6146:	02 c0       	rjmp	.+4      	; 0x614c <limits_go_home+0x22a>
    6148:	95 95       	asr	r25
    614a:	87 95       	ror	r24
    614c:	0a 94       	dec	r0
    614e:	e2 f7       	brpl	.-8      	; 0x6148 <limits_go_home+0x226>
    6150:	80 ff       	sbrs	r24, 0
    6152:	12 c0       	rjmp	.+36     	; 0x6178 <limits_go_home+0x256>
    6154:	2c a1       	ldd	r18, Y+36	; 0x24
    6156:	3d a1       	ldd	r19, Y+37	; 0x25
    6158:	4e a1       	ldd	r20, Y+38	; 0x26
    615a:	5f a1       	ldd	r21, Y+39	; 0x27
    615c:	f7 01       	movw	r30, r14
    615e:	60 81       	ld	r22, Z
    6160:	71 81       	ldd	r23, Z+1	; 0x01
    6162:	82 81       	ldd	r24, Z+2	; 0x02
    6164:	93 81       	ldd	r25, Z+3	; 0x03
    6166:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    616a:	d7 01       	movw	r26, r14
    616c:	6d 93       	st	X+, r22
    616e:	7d 93       	st	X+, r23
    6170:	8d 93       	st	X+, r24
    6172:	9c 93       	st	X, r25
    6174:	13 97       	sbiw	r26, 0x03	; 3
    6176:	66 c1       	rjmp	.+716    	; 0x6444 <limits_go_home+0x522>
          else { target[idx] -= max_travel; }
    6178:	2c a1       	ldd	r18, Y+36	; 0x24
    617a:	3d a1       	ldd	r19, Y+37	; 0x25
    617c:	4e a1       	ldd	r20, Y+38	; 0x26
    617e:	5f a1       	ldd	r21, Y+39	; 0x27
    6180:	f7 01       	movw	r30, r14
    6182:	60 81       	ld	r22, Z
    6184:	71 81       	ldd	r23, Z+1	; 0x01
    6186:	82 81       	ldd	r24, Z+2	; 0x02
    6188:	93 81       	ldd	r25, Z+3	; 0x03
    618a:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    618e:	d7 01       	movw	r26, r14
    6190:	6d 93       	st	X+, r22
    6192:	7d 93       	st	X+, r23
    6194:	8d 93       	st	X+, r24
    6196:	9c 93       	st	X, r25
    6198:	13 97       	sbiw	r26, 0x03	; 3
    619a:	54 c1       	rjmp	.+680    	; 0x6444 <limits_go_home+0x522>
    619c:	0f 5f       	subi	r16, 0xFF	; 255
    619e:	1f 4f       	sbci	r17, 0xFF	; 255
    61a0:	b4 e0       	ldi	r27, 0x04	; 4
    61a2:	eb 0e       	add	r14, r27
    61a4:	f1 1c       	adc	r15, r1
    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;

    system_convert_array_steps_to_mpos(target,sys.position);      
    for (idx=0; idx<N_AXIS; idx++) {
    61a6:	03 30       	cpi	r16, 0x03	; 3
    61a8:	11 05       	cpc	r17, r1
    61aa:	09 f0       	breq	.+2      	; 0x61ae <limits_go_home+0x28c>
    61ac:	89 cf       	rjmp	.-238    	; 0x60c0 <limits_go_home+0x19e>
    61ae:	e8 2c       	mov	r14, r8
    61b0:	f9 2c       	mov	r15, r9
    61b2:	b9 aa       	std	Y+49, r11	; 0x31
    61b4:	a8 aa       	std	Y+48, r10	; 0x30
    61b6:	48 a4       	ldd	r4, Y+40	; 0x28
    61b8:	59 a4       	ldd	r5, Y+41	; 0x29
    61ba:	9d 2c       	mov	r9, r13
    61bc:	cc a4       	ldd	r12, Y+44	; 0x2c
    61be:	dd a4       	ldd	r13, Y+45	; 0x2d
    61c0:	87 2c       	mov	r8, r7
    61c2:	6a a4       	ldd	r6, Y+42	; 0x2a
    61c4:	7b a4       	ldd	r7, Y+43	; 0x2b
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    61c6:	e9 8d       	ldd	r30, Y+25	; 0x19
    61c8:	6e 2f       	mov	r22, r30
    61ca:	70 e0       	ldi	r23, 0x00	; 0
    61cc:	80 e0       	ldi	r24, 0x00	; 0
    61ce:	90 e0       	ldi	r25, 0x00	; 0
    61d0:	0e 94 3a 3d 	call	0x7a74	; 0x7a74 <__floatunsisf>
    61d4:	0e 94 65 3f 	call	0x7eca	; 0x7eca <sqrt>
    sys.homing_axis_lock = axislock;
    61d8:	d2 01       	movw	r26, r4
    61da:	fc 92       	st	X, r15
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    61dc:	28 a1       	ldd	r18, Y+32	; 0x20
    61de:	39 a1       	ldd	r19, Y+33	; 0x21
    61e0:	4a a1       	ldd	r20, Y+34	; 0x22
    61e2:	5b a1       	ldd	r21, Y+35	; 0x23
    61e4:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    61e8:	ab 01       	movw	r20, r22
    61ea:	bc 01       	movw	r22, r24
    uint8_t limit_state;
    
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, homing_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan homing motion.
    #else
      plan_buffer_line(target, homing_rate, false); // Bypass mc_line(). Directly plan homing motion.
    61ec:	20 e0       	ldi	r18, 0x00	; 0
    61ee:	ce 01       	movw	r24, r28
    61f0:	01 96       	adiw	r24, 0x01	; 1
    61f2:	0e 94 9a 2a 	call	0x5534	; 0x5534 <plan_buffer_line>
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    61f6:	0e 94 6d 1e 	call	0x3cda	; 0x3cda <st_prep_buffer>
    st_wake_up(); // Initiate motion
    61fa:	0e 94 1a 1b 	call	0x3634	; 0x3634 <st_wake_up>
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
    61fe:	1e e0       	ldi	r17, 0x0E	; 14
    6200:	0f 2d       	mov	r16, r15
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    st_wake_up(); // Initiate motion
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
    6202:	23 b1       	in	r18, 0x03	; 3
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
    6204:	e1 10       	cpse	r14, r1
    6206:	21 27       	eor	r18, r17
    6208:	a2 2d       	mov	r26, r2
    620a:	b3 2d       	mov	r27, r3
    620c:	e9 2d       	mov	r30, r9
    620e:	f8 2d       	mov	r31, r8
      for (idx=0; idx<N_AXIS; idx++) {
        if (axislock & step_pin[idx]) {
    6210:	81 91       	ld	r24, Z+
    6212:	98 2f       	mov	r25, r24
    6214:	90 23       	and	r25, r16
    6216:	29 f0       	breq	.+10     	; 0x6222 <limits_go_home+0x300>
          if (limit_state & limit_pin[idx]) { axislock &= ~(step_pin[idx]); }
    6218:	9c 91       	ld	r25, X
    621a:	92 23       	and	r25, r18
    621c:	11 f0       	breq	.+4      	; 0x6222 <limits_go_home+0x300>
    621e:	80 95       	com	r24
    6220:	08 23       	and	r16, r24
    6222:	11 96       	adiw	r26, 0x01	; 1
    st_wake_up(); // Initiate motion
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
      for (idx=0; idx<N_AXIS; idx++) {
    6224:	e6 15       	cp	r30, r6
    6226:	f7 05       	cpc	r31, r7
    6228:	99 f7       	brne	.-26     	; 0x6210 <limits_go_home+0x2ee>
        if (axislock & step_pin[idx]) {
          if (limit_state & limit_pin[idx]) { axislock &= ~(step_pin[idx]); }
        }
      }
      sys.homing_axis_lock = axislock;
    622a:	f2 01       	movw	r30, r4
    622c:	00 83       	st	Z, r16
      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    622e:	0e 94 6d 1e 	call	0x3cda	; 0x3cda <st_prep_buffer>
      // Check only for user reset. No time to run protocol_execute_realtime() in this loop.

      if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) { // Abort homing and alarm upon safety door.
    6232:	d6 01       	movw	r26, r12
    6234:	8c 91       	ld	r24, X
    6236:	80 73       	andi	r24, 0x30	; 48
    6238:	41 f0       	breq	.+16     	; 0x624a <limits_go_home+0x328>
        if (sys.rt_exec_state & EXEC_SAFETY_DOOR) { mc_reset(); }  
    623a:	80 91 6a 07 	lds	r24, 0x076A
    623e:	85 fd       	sbrc	r24, 5
    6240:	0e 94 ad 0c 	call	0x195a	; 0x195a <mc_reset>
        protocol_execute_realtime();
    6244:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
        return;
    6248:	06 c1       	rjmp	.+524    	; 0x6456 <limits_go_home+0x534>
      }
    } while (STEP_MASK & axislock);
    624a:	80 2f       	mov	r24, r16
    624c:	84 75       	andi	r24, 0x54	; 84
    624e:	c9 f6       	brne	.-78     	; 0x6202 <limits_go_home+0x2e0>
    
    st_reset(); // Immediately force kill steppers and reset step segment buffer.
    6250:	0e 94 fd 1d 	call	0x3bfa	; 0x3bfa <st_reset>
    plan_reset(); // Reset planner buffer. Zero planner positions. Ensure homing motion is cleared.
    6254:	0e 94 42 2a 	call	0x5484	; 0x5484 <plan_reset>
    plan_sync_position(); // Sync planner position to current machine position
    6258:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <plan_sync_position>

    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    625c:	80 91 46 09 	lds	r24, 0x0946
    6260:	90 91 47 09 	lds	r25, 0x0947
    6264:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    homing_rate = settings.homing_feed_rate;
    6268:	80 91 3e 09 	lds	r24, 0x093E
    626c:	90 91 3f 09 	lds	r25, 0x093F
    6270:	a0 91 40 09 	lds	r26, 0x0940
    6274:	b0 91 41 09 	lds	r27, 0x0941
    6278:	88 a3       	std	Y+32, r24	; 0x20
    627a:	99 a3       	std	Y+33, r25	; 0x21
    627c:	aa a3       	std	Y+34, r26	; 0x22
    627e:	bb a3       	std	Y+35, r27	; 0x23
    approach = !approach;
    6280:	81 e0       	ldi	r24, 0x01	; 1
    6282:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6284:	98 27       	eor	r25, r24
    6286:	9c 8f       	std	Y+28, r25	; 0x1c
    6288:	ae a5       	ldd	r26, Y+46	; 0x2e
    628a:	a1 50       	subi	r26, 0x01	; 1
    628c:	ae a7       	std	Y+46, r26	; 0x2e
    
  } while (n_cycle-- > 0);
    628e:	a1 11       	cpse	r26, r1
    6290:	ec ce       	rjmp	.-552    	; 0x606a <limits_go_home+0x148>
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
      #ifndef HOMING_FORCE_SET_ORIGIN
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6292:	c0 90 3d 09 	lds	r12, 0x093D
    6296:	d1 2c       	mov	r13, r1
    6298:	e1 2c       	mov	r14, r1
    629a:	f1 2c       	mov	r15, r1
    629c:	00 e0       	ldi	r16, 0x00	; 0
    629e:	10 e0       	ldi	r17, 0x00	; 0
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
    62a0:	81 2c       	mov	r8, r1
    62a2:	91 2c       	mov	r9, r1
    62a4:	a1 2c       	mov	r10, r1
    62a6:	b1 2c       	mov	r11, r1
    62a8:	68 a8       	ldd	r6, Y+48	; 0x30
    62aa:	79 a8       	ldd	r7, Y+49	; 0x31
  #endif
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    62ac:	c3 01       	movw	r24, r6
    62ae:	00 2e       	mov	r0, r16
    62b0:	02 c0       	rjmp	.+4      	; 0x62b6 <limits_go_home+0x394>
    62b2:	95 95       	asr	r25
    62b4:	87 95       	ror	r24
    62b6:	0a 94       	dec	r0
    62b8:	e2 f7       	brpl	.-8      	; 0x62b2 <limits_go_home+0x390>
    62ba:	80 ff       	sbrs	r24, 0
    62bc:	28 c0       	rjmp	.+80     	; 0x630e <limits_go_home+0x3ec>
      set_axis_position = 0;     
      #ifndef HOMING_FORCE_SET_ORIGIN
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    62be:	c6 01       	movw	r24, r12
    62c0:	00 2e       	mov	r0, r16
    62c2:	02 c0       	rjmp	.+4      	; 0x62c8 <limits_go_home+0x3a6>
    62c4:	95 95       	asr	r25
    62c6:	87 95       	ror	r24
    62c8:	0a 94       	dec	r0
    62ca:	e2 f7       	brpl	.-8      	; 0x62c4 <limits_go_home+0x3a2>
    62cc:	80 ff       	sbrs	r24, 0
    62ce:	14 c0       	rjmp	.+40     	; 0x62f8 <limits_go_home+0x3d6>
    62d0:	f7 01       	movw	r30, r14
    62d2:	e1 50       	subi	r30, 0x01	; 1
    62d4:	f7 4f       	sbci	r31, 0xF7	; 247
          set_axis_position = lround(settings.max_travel[idx]*settings.steps_per_mm[idx]);
    62d6:	20 81       	ld	r18, Z
    62d8:	31 81       	ldd	r19, Z+1	; 0x01
    62da:	42 81       	ldd	r20, Z+2	; 0x02
    62dc:	53 81       	ldd	r21, Z+3	; 0x03
    62de:	64 a1       	ldd	r22, Z+36	; 0x24
    62e0:	75 a1       	ldd	r23, Z+37	; 0x25
    62e2:	86 a1       	ldd	r24, Z+38	; 0x26
    62e4:	97 a1       	ldd	r25, Z+39	; 0x27
    62e6:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    62ea:	0e 94 a8 3e 	call	0x7d50	; 0x7d50 <lround>
    62ee:	46 2f       	mov	r20, r22
    62f0:	37 2f       	mov	r19, r23
    62f2:	28 2f       	mov	r18, r24
    62f4:	89 2f       	mov	r24, r25
    62f6:	04 c0       	rjmp	.+8      	; 0x6300 <limits_go_home+0x3de>
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      set_axis_position = 0;     
    62f8:	48 2d       	mov	r20, r8
    62fa:	39 2d       	mov	r19, r9
    62fc:	2a 2d       	mov	r18, r10
    62fe:	8b 2d       	mov	r24, r11
    6300:	f7 01       	movw	r30, r14
    6302:	e9 59       	subi	r30, 0x99	; 153
    6304:	f8 4f       	sbci	r31, 0xF8	; 248
          sys.position[B_MOTOR] = off_axis_position + set_axis_position;
        } else {
          sys.position[idx] = set_axis_position;
        }        
      #else 
        sys.position[idx] = set_axis_position;
    6306:	45 83       	std	Z+5, r20	; 0x05
    6308:	36 83       	std	Z+6, r19	; 0x06
    630a:	27 83       	std	Z+7, r18	; 0x07
    630c:	80 87       	std	Z+8, r24	; 0x08
    630e:	0f 5f       	subi	r16, 0xFF	; 255
    6310:	1f 4f       	sbci	r17, 0xFF	; 255
    6312:	b4 e0       	ldi	r27, 0x04	; 4
    6314:	eb 0e       	add	r14, r27
    6316:	f1 1c       	adc	r15, r1
  #ifdef COREXY
    int32_t off_axis_position = 0;
  #endif
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    6318:	03 30       	cpi	r16, 0x03	; 3
    631a:	11 05       	cpc	r17, r1
    631c:	39 f6       	brne	.-114    	; 0x62ac <limits_go_home+0x38a>
        sys.position[idx] = set_axis_position;
      #endif

    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    631e:	0e 94 b4 2d 	call	0x5b68	; 0x5b68 <plan_sync_position>

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    6322:	20 e0       	ldi	r18, 0x00	; 0
    6324:	30 e0       	ldi	r19, 0x00	; 0
    6326:	a9 01       	movw	r20, r18
    6328:	60 91 48 09 	lds	r22, 0x0948
    632c:	70 91 49 09 	lds	r23, 0x0949
    6330:	80 91 4a 09 	lds	r24, 0x094A
    6334:	90 91 4b 09 	lds	r25, 0x094B
    6338:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    633c:	18 16       	cp	r1, r24
    633e:	0c f0       	brlt	.+2      	; 0x6342 <limits_go_home+0x420>
    6340:	7d c0       	rjmp	.+250    	; 0x643c <limits_go_home+0x51a>
    6342:	0f 2e       	mov	r0, r31
    6344:	f3 e2       	ldi	r31, 0x23	; 35
    6346:	cf 2e       	mov	r12, r31
    6348:	f9 e0       	ldi	r31, 0x09	; 9
    634a:	df 2e       	mov	r13, r31
    634c:	f0 2d       	mov	r31, r0
    634e:	ea a8       	ldd	r14, Y+50	; 0x32
    6350:	fb a8       	ldd	r15, Y+51	; 0x33
    6352:	00 e0       	ldi	r16, 0x00	; 0
    6354:	10 e0       	ldi	r17, 0x00	; 0
      if (cycle_mask & bit(idx)) {
        #ifdef HOMING_FORCE_SET_ORIGIN
          target[idx] = settings.homing_pulloff;  
          if ( bit_isfalse(settings.homing_dir_mask,bit(idx)) ) { target[idx] = -target[idx]; }     
        #else
          if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6356:	0f 2e       	mov	r0, r31
    6358:	fd e3       	ldi	r31, 0x3D	; 61
    635a:	af 2e       	mov	r10, r31
    635c:	f9 e0       	ldi	r31, 0x09	; 9
    635e:	bf 2e       	mov	r11, r31
    6360:	f0 2d       	mov	r31, r0
            target[idx] = settings.homing_pulloff+settings.max_travel[idx];
          } else {
            target[idx] = -settings.homing_pulloff;
    6362:	0f 2e       	mov	r0, r31
    6364:	f8 e4       	ldi	r31, 0x48	; 72
    6366:	8f 2e       	mov	r8, r31
    6368:	f9 e0       	ldi	r31, 0x09	; 9
    636a:	9f 2e       	mov	r9, r31
    636c:	f0 2d       	mov	r31, r0
    636e:	68 a8       	ldd	r6, Y+48	; 0x30
    6370:	79 a8       	ldd	r7, Y+49	; 0x31
  plan_sync_position(); // Sync planner position to homed machine position.

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    for (idx=0; idx<N_AXIS; idx++) {
      if (cycle_mask & bit(idx)) {
    6372:	c3 01       	movw	r24, r6
    6374:	00 2e       	mov	r0, r16
    6376:	02 c0       	rjmp	.+4      	; 0x637c <limits_go_home+0x45a>
    6378:	95 95       	asr	r25
    637a:	87 95       	ror	r24
    637c:	0a 94       	dec	r0
    637e:	e2 f7       	brpl	.-8      	; 0x6378 <limits_go_home+0x456>
    6380:	80 ff       	sbrs	r24, 0
    6382:	2a c0       	rjmp	.+84     	; 0x63d8 <limits_go_home+0x4b6>
        #ifdef HOMING_FORCE_SET_ORIGIN
          target[idx] = settings.homing_pulloff;  
          if ( bit_isfalse(settings.homing_dir_mask,bit(idx)) ) { target[idx] = -target[idx]; }     
        #else
          if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6384:	f5 01       	movw	r30, r10
    6386:	80 81       	ld	r24, Z
    6388:	90 e0       	ldi	r25, 0x00	; 0
    638a:	00 2e       	mov	r0, r16
    638c:	02 c0       	rjmp	.+4      	; 0x6392 <limits_go_home+0x470>
    638e:	95 95       	asr	r25
    6390:	87 95       	ror	r24
    6392:	0a 94       	dec	r0
    6394:	e2 f7       	brpl	.-8      	; 0x638e <limits_go_home+0x46c>
    6396:	80 ff       	sbrs	r24, 0
    6398:	13 c0       	rjmp	.+38     	; 0x63c0 <limits_go_home+0x49e>
            target[idx] = settings.homing_pulloff+settings.max_travel[idx];
    639a:	d6 01       	movw	r26, r12
    639c:	2d 91       	ld	r18, X+
    639e:	3d 91       	ld	r19, X+
    63a0:	4d 91       	ld	r20, X+
    63a2:	5c 91       	ld	r21, X
    63a4:	f4 01       	movw	r30, r8
    63a6:	60 81       	ld	r22, Z
    63a8:	71 81       	ldd	r23, Z+1	; 0x01
    63aa:	82 81       	ldd	r24, Z+2	; 0x02
    63ac:	93 81       	ldd	r25, Z+3	; 0x03
    63ae:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    63b2:	d7 01       	movw	r26, r14
    63b4:	6d 93       	st	X+, r22
    63b6:	7d 93       	st	X+, r23
    63b8:	8d 93       	st	X+, r24
    63ba:	9c 93       	st	X, r25
    63bc:	13 97       	sbiw	r26, 0x03	; 3
    63be:	17 c0       	rjmp	.+46     	; 0x63ee <limits_go_home+0x4cc>
          } else {
            target[idx] = -settings.homing_pulloff;
    63c0:	f4 01       	movw	r30, r8
    63c2:	80 81       	ld	r24, Z
    63c4:	91 81       	ldd	r25, Z+1	; 0x01
    63c6:	a2 81       	ldd	r26, Z+2	; 0x02
    63c8:	b3 81       	ldd	r27, Z+3	; 0x03
    63ca:	b0 58       	subi	r27, 0x80	; 128
    63cc:	f7 01       	movw	r30, r14
    63ce:	80 83       	st	Z, r24
    63d0:	91 83       	std	Z+1, r25	; 0x01
    63d2:	a2 83       	std	Z+2, r26	; 0x02
    63d4:	b3 83       	std	Z+3, r27	; 0x03
    63d6:	0b c0       	rjmp	.+22     	; 0x63ee <limits_go_home+0x4cc>
          }
        #endif      
      } else {
        // Non-active cycle axis. Set target to not move during pull-off. 
        target[idx] = system_convert_axis_steps_to_mpos(sys.position, idx);
    63d8:	60 2f       	mov	r22, r16
    63da:	8c e6       	ldi	r24, 0x6C	; 108
    63dc:	97 e0       	ldi	r25, 0x07	; 7
    63de:	0e 94 8a 3b 	call	0x7714	; 0x7714 <system_convert_axis_steps_to_mpos>
    63e2:	d7 01       	movw	r26, r14
    63e4:	6d 93       	st	X+, r22
    63e6:	7d 93       	st	X+, r23
    63e8:	8d 93       	st	X+, r24
    63ea:	9c 93       	st	X, r25
    63ec:	13 97       	sbiw	r26, 0x03	; 3
    63ee:	0f 5f       	subi	r16, 0xFF	; 255
    63f0:	1f 4f       	sbci	r17, 0xFF	; 255
    63f2:	b4 e0       	ldi	r27, 0x04	; 4
    63f4:	eb 0e       	add	r14, r27
    63f6:	f1 1c       	adc	r15, r1
    63f8:	e4 e0       	ldi	r30, 0x04	; 4
    63fa:	ce 0e       	add	r12, r30
    63fc:	d1 1c       	adc	r13, r1
  }
  plan_sync_position(); // Sync planner position to homed machine position.

  // Set pull-off motion target. Seperated from above loop if target is dependent on sys.position.
  if (settings.homing_pulloff > 0.0) {
    for (idx=0; idx<N_AXIS; idx++) {
    63fe:	03 30       	cpi	r16, 0x03	; 3
    6400:	11 05       	cpc	r17, r1
    6402:	09 f0       	breq	.+2      	; 0x6406 <limits_go_home+0x4e4>
    6404:	b6 cf       	rjmp	.-148    	; 0x6372 <limits_go_home+0x450>
      }
    }      
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, settings.homing_seek_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan motion.
    #else
      plan_buffer_line(target, settings.homing_seek_rate, false); // Bypass mc_line(). Directly plan motion.
    6406:	40 91 42 09 	lds	r20, 0x0942
    640a:	50 91 43 09 	lds	r21, 0x0943
    640e:	60 91 44 09 	lds	r22, 0x0944
    6412:	70 91 45 09 	lds	r23, 0x0945
    6416:	20 e0       	ldi	r18, 0x00	; 0
    6418:	ce 01       	movw	r24, r28
    641a:	01 96       	adiw	r24, 0x01	; 1
    641c:	0e 94 9a 2a 	call	0x5534	; 0x5534 <plan_buffer_line>
    #endif
  
    // Initiate pull-off using main motion control routines. 
    // TODO : Clean up state routines so that this motion still shows homing state.
    sys.state = STATE_IDLE;
    6420:	10 92 68 07 	sts	0x0768, r1
    bit_true_atomic(sys.rt_exec_state, EXEC_CYCLE_START);
    6424:	8f b7       	in	r24, 0x3f	; 63
    6426:	f8 94       	cli
    6428:	ea e6       	ldi	r30, 0x6A	; 106
    642a:	f7 e0       	ldi	r31, 0x07	; 7
    642c:	90 81       	ld	r25, Z
    642e:	92 60       	ori	r25, 0x02	; 2
    6430:	90 83       	st	Z, r25
    6432:	8f bf       	out	0x3f, r24	; 63
    protocol_execute_realtime();
    6434:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
    protocol_buffer_synchronize(); // Complete pull-off motion.
    6438:	0e 94 fe 1a 	call	0x35fc	; 0x35fc <protocol_buffer_synchronize>
  }
  
  // Set system state to homing before returning. 
  sys.state = STATE_HOMING; 
    643c:	84 e0       	ldi	r24, 0x04	; 4
    643e:	80 93 68 07 	sts	0x0768, r24
    6442:	09 c0       	rjmp	.+18     	; 0x6456 <limits_go_home+0x534>
    6444:	e0 e1       	ldi	r30, 0x10	; 16
    6446:	f0 e0       	ldi	r31, 0x00	; 0
    6448:	ec 0f       	add	r30, r28
    644a:	fd 1f       	adc	r31, r29
    644c:	e0 0f       	add	r30, r16
    644e:	f1 1f       	adc	r31, r17
          else { target[idx] -= max_travel; }
        }
      }

      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    6450:	80 81       	ld	r24, Z
    6452:	98 2a       	or	r9, r24
    6454:	a3 ce       	rjmp	.-698    	; 0x619c <limits_go_home+0x27a>
    protocol_buffer_synchronize(); // Complete pull-off motion.
  }
  
  // Set system state to homing before returning. 
  sys.state = STATE_HOMING; 
}
    6456:	e3 96       	adiw	r28, 0x33	; 51
    6458:	0f b6       	in	r0, 0x3f	; 63
    645a:	f8 94       	cli
    645c:	de bf       	out	0x3e, r29	; 62
    645e:	0f be       	out	0x3f, r0	; 63
    6460:	cd bf       	out	0x3d, r28	; 61
    6462:	df 91       	pop	r29
    6464:	cf 91       	pop	r28
    6466:	1f 91       	pop	r17
    6468:	0f 91       	pop	r16
    646a:	ff 90       	pop	r15
    646c:	ef 90       	pop	r14
    646e:	df 90       	pop	r13
    6470:	cf 90       	pop	r12
    6472:	bf 90       	pop	r11
    6474:	af 90       	pop	r10
    6476:	9f 90       	pop	r9
    6478:	8f 90       	pop	r8
    647a:	7f 90       	pop	r7
    647c:	6f 90       	pop	r6
    647e:	5f 90       	pop	r5
    6480:	4f 90       	pop	r4
    6482:	3f 90       	pop	r3
    6484:	2f 90       	pop	r2
    6486:	08 95       	ret

00006488 <limits_soft_check>:


// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
    6488:	af 92       	push	r10
    648a:	bf 92       	push	r11
    648c:	cf 92       	push	r12
    648e:	df 92       	push	r13
    6490:	ef 92       	push	r14
    6492:	ff 92       	push	r15
    6494:	0f 93       	push	r16
    6496:	1f 93       	push	r17
    6498:	cf 93       	push	r28
    649a:	df 93       	push	r29
    649c:	ec 01       	movw	r28, r24
    649e:	03 e2       	ldi	r16, 0x23	; 35
    64a0:	19 e0       	ldi	r17, 0x09	; 9
    64a2:	0f 2e       	mov	r0, r31
    64a4:	ff e2       	ldi	r31, 0x2F	; 47
    64a6:	af 2e       	mov	r10, r31
    64a8:	f9 e0       	ldi	r31, 0x09	; 9
    64aa:	bf 2e       	mov	r11, r31
    64ac:	f0 2d       	mov	r31, r0
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { soft_limit_error = true; }
      }
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { soft_limit_error = true; }
    64ae:	c9 90       	ld	r12, Y+
    64b0:	d9 90       	ld	r13, Y+
    64b2:	e9 90       	ld	r14, Y+
    64b4:	f9 90       	ld	r15, Y+
    64b6:	20 e0       	ldi	r18, 0x00	; 0
    64b8:	30 e0       	ldi	r19, 0x00	; 0
    64ba:	a9 01       	movw	r20, r18
    64bc:	c7 01       	movw	r24, r14
    64be:	b6 01       	movw	r22, r12
    64c0:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    64c4:	18 16       	cp	r1, r24
    64c6:	64 f0       	brlt	.+24     	; 0x64e0 <limits_soft_check+0x58>
    64c8:	f8 01       	movw	r30, r16
    64ca:	21 91       	ld	r18, Z+
    64cc:	31 91       	ld	r19, Z+
    64ce:	41 91       	ld	r20, Z+
    64d0:	51 91       	ld	r21, Z+
    64d2:	8f 01       	movw	r16, r30
    64d4:	c7 01       	movw	r24, r14
    64d6:	b6 01       	movw	r22, r12
    64d8:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    64dc:	88 23       	and	r24, r24
    64de:	34 f5       	brge	.+76     	; 0x652c <limits_soft_check+0xa4>
    
    if (soft_limit_error) {
      // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within 
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
    64e0:	80 91 68 07 	lds	r24, 0x0768
    64e4:	88 30       	cpi	r24, 0x08	; 8
    64e6:	a9 f4       	brne	.+42     	; 0x6512 <limits_soft_check+0x8a>
        bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD);
    64e8:	8f b7       	in	r24, 0x3f	; 63
    64ea:	f8 94       	cli
    64ec:	ea e6       	ldi	r30, 0x6A	; 106
    64ee:	f7 e0       	ldi	r31, 0x07	; 7
    64f0:	90 81       	ld	r25, Z
    64f2:	98 60       	ori	r25, 0x08	; 8
    64f4:	90 83       	st	Z, r25
    64f6:	8f bf       	out	0x3f, r24	; 63
        do {
          protocol_execute_realtime();
          if (sys.abort) { return; }
    64f8:	c7 e6       	ldi	r28, 0x67	; 103
    64fa:	d7 e0       	ldi	r29, 0x07	; 7
        } while ( sys.state != STATE_IDLE );
    64fc:	08 e6       	ldi	r16, 0x68	; 104
    64fe:	17 e0       	ldi	r17, 0x07	; 7
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
        bit_true_atomic(sys.rt_exec_state, EXEC_FEED_HOLD);
        do {
          protocol_execute_realtime();
    6500:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
          if (sys.abort) { return; }
    6504:	88 81       	ld	r24, Y
    6506:	81 11       	cpse	r24, r1
    6508:	15 c0       	rjmp	.+42     	; 0x6534 <limits_soft_check+0xac>
        } while ( sys.state != STATE_IDLE );
    650a:	f8 01       	movw	r30, r16
    650c:	80 81       	ld	r24, Z
    650e:	81 11       	cpse	r24, r1
    6510:	f7 cf       	rjmp	.-18     	; 0x6500 <limits_soft_check+0x78>
      }
    
      mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    6512:	0e 94 ad 0c 	call	0x195a	; 0x195a <mc_reset>
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
    6516:	8f b7       	in	r24, 0x3f	; 63
    6518:	f8 94       	cli
    651a:	eb e6       	ldi	r30, 0x6B	; 107
    651c:	f7 e0       	ldi	r31, 0x07	; 7
    651e:	90 81       	ld	r25, Z
    6520:	95 60       	ori	r25, 0x05	; 5
    6522:	90 83       	st	Z, r25
    6524:	8f bf       	out	0x3f, r24	; 63
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    6526:	0e 94 df 18 	call	0x31be	; 0x31be <protocol_execute_realtime>
      return;
    652a:	04 c0       	rjmp	.+8      	; 0x6534 <limits_soft_check+0xac>
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
  uint8_t idx;
  uint8_t soft_limit_error = false;
  for (idx=0; idx<N_AXIS; idx++) {
    652c:	0a 15       	cp	r16, r10
    652e:	1b 05       	cpc	r17, r11
    6530:	09 f0       	breq	.+2      	; 0x6534 <limits_soft_check+0xac>
    6532:	bd cf       	rjmp	.-134    	; 0x64ae <limits_soft_check+0x26>
      bit_true_atomic(sys.rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
      return;
    }
  }
}
    6534:	df 91       	pop	r29
    6536:	cf 91       	pop	r28
    6538:	1f 91       	pop	r17
    653a:	0f 91       	pop	r16
    653c:	ff 90       	pop	r15
    653e:	ef 90       	pop	r14
    6540:	df 90       	pop	r13
    6542:	cf 90       	pop	r12
    6544:	bf 90       	pop	r11
    6546:	af 90       	pop	r10
    6548:	08 95       	ret

0000654a <printString>:

#include "grbl.h"


void printString(const char *s)
{
    654a:	cf 93       	push	r28
    654c:	df 93       	push	r29
    654e:	ec 01       	movw	r28, r24
  while (*s)
    6550:	88 81       	ld	r24, Y
    6552:	88 23       	and	r24, r24
    6554:	31 f0       	breq	.+12     	; 0x6562 <printString+0x18>
    6556:	21 96       	adiw	r28, 0x01	; 1
    serial_write(*s++);
    6558:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
#include "grbl.h"


void printString(const char *s)
{
  while (*s)
    655c:	89 91       	ld	r24, Y+
    655e:	81 11       	cpse	r24, r1
    6560:	fb cf       	rjmp	.-10     	; 0x6558 <printString+0xe>
    serial_write(*s++);
}
    6562:	df 91       	pop	r29
    6564:	cf 91       	pop	r28
    6566:	08 95       	ret

00006568 <printPgmString>:


// Print a string stored in PGM-memory
void printPgmString(const char *s)
{
    6568:	cf 93       	push	r28
    656a:	df 93       	push	r29
  char c;
  while ((c = pgm_read_byte_near(s++)))
    656c:	ec 01       	movw	r28, r24
    656e:	21 96       	adiw	r28, 0x01	; 1
    6570:	fc 01       	movw	r30, r24
    6572:	84 91       	lpm	r24, Z
    6574:	88 23       	and	r24, r24
    6576:	39 f0       	breq	.+14     	; 0x6586 <printPgmString+0x1e>
    serial_write(c);
    6578:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>

// Print a string stored in PGM-memory
void printPgmString(const char *s)
{
  char c;
  while ((c = pgm_read_byte_near(s++)))
    657c:	fe 01       	movw	r30, r28
    657e:	84 91       	lpm	r24, Z
    6580:	21 96       	adiw	r28, 0x01	; 1
    6582:	81 11       	cpse	r24, r1
    6584:	f9 cf       	rjmp	.-14     	; 0x6578 <printPgmString+0x10>
    serial_write(c);
}
    6586:	df 91       	pop	r29
    6588:	cf 91       	pop	r28
    658a:	08 95       	ret

0000658c <print_uint8_base2>:
// 			'A' + buf[i - 1] - 10);
// }


void print_uint8_base2(uint8_t n)
{ 
    658c:	ef 92       	push	r14
    658e:	ff 92       	push	r15
    6590:	0f 93       	push	r16
    6592:	1f 93       	push	r17
    6594:	cf 93       	push	r28
    6596:	df 93       	push	r29
    6598:	cd b7       	in	r28, 0x3d	; 61
    659a:	de b7       	in	r29, 0x3e	; 62
    659c:	28 97       	sbiw	r28, 0x08	; 8
    659e:	0f b6       	in	r0, 0x3f	; 63
    65a0:	f8 94       	cli
    65a2:	de bf       	out	0x3e, r29	; 62
    65a4:	0f be       	out	0x3f, r0	; 63
    65a6:	cd bf       	out	0x3d, r28	; 61
    65a8:	fe 01       	movw	r30, r28
    65aa:	31 96       	adiw	r30, 0x01	; 1
    65ac:	7f 01       	movw	r14, r30
    65ae:	9e 01       	movw	r18, r28
    65b0:	27 5f       	subi	r18, 0xF7	; 247
    65b2:	3f 4f       	sbci	r19, 0xFF	; 255
	unsigned char buf[8];
	uint8_t i = 0;

	for (; i < 8; i++) {
		buf[i] = n & 1;
    65b4:	98 2f       	mov	r25, r24
    65b6:	91 70       	andi	r25, 0x01	; 1
    65b8:	91 93       	st	Z+, r25
		n >>= 1;
    65ba:	86 95       	lsr	r24
void print_uint8_base2(uint8_t n)
{ 
	unsigned char buf[8];
	uint8_t i = 0;

	for (; i < 8; i++) {
    65bc:	e2 17       	cp	r30, r18
    65be:	f3 07       	cpc	r31, r19
    65c0:	c9 f7       	brne	.-14     	; 0x65b4 <print_uint8_base2+0x28>
    65c2:	8e 01       	movw	r16, r28
    65c4:	07 5f       	subi	r16, 0xF7	; 247
    65c6:	1f 4f       	sbci	r17, 0xFF	; 255
		buf[i] = n & 1;
		n >>= 1;
	}

	for (; i > 0; i--)
		serial_write('0' + buf[i - 1]);
    65c8:	f8 01       	movw	r30, r16
    65ca:	82 91       	ld	r24, -Z
    65cc:	8f 01       	movw	r16, r30
    65ce:	80 5d       	subi	r24, 0xD0	; 208
    65d0:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
	for (; i < 8; i++) {
		buf[i] = n & 1;
		n >>= 1;
	}

	for (; i > 0; i--)
    65d4:	0e 15       	cp	r16, r14
    65d6:	1f 05       	cpc	r17, r15
    65d8:	b9 f7       	brne	.-18     	; 0x65c8 <print_uint8_base2+0x3c>
		serial_write('0' + buf[i - 1]);
}
    65da:	28 96       	adiw	r28, 0x08	; 8
    65dc:	0f b6       	in	r0, 0x3f	; 63
    65de:	f8 94       	cli
    65e0:	de bf       	out	0x3e, r29	; 62
    65e2:	0f be       	out	0x3f, r0	; 63
    65e4:	cd bf       	out	0x3d, r28	; 61
    65e6:	df 91       	pop	r29
    65e8:	cf 91       	pop	r28
    65ea:	1f 91       	pop	r17
    65ec:	0f 91       	pop	r16
    65ee:	ff 90       	pop	r15
    65f0:	ef 90       	pop	r14
    65f2:	08 95       	ret

000065f4 <print_uint8_base10>:


void print_uint8_base10(uint8_t n)
{ 
    65f4:	1f 93       	push	r17
    65f6:	cf 93       	push	r28
    65f8:	df 93       	push	r29
    65fa:	00 d0       	rcall	.+0      	; 0x65fc <print_uint8_base10+0x8>
    65fc:	1f 92       	push	r1
    65fe:	cd b7       	in	r28, 0x3d	; 61
    6600:	de b7       	in	r29, 0x3e	; 62
  if (n == 0) {
    6602:	81 11       	cpse	r24, r1
    6604:	04 c0       	rjmp	.+8      	; 0x660e <print_uint8_base10+0x1a>
    serial_write('0');
    6606:	80 e3       	ldi	r24, 0x30	; 48
    6608:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
    660c:	28 c0       	rjmp	.+80     	; 0x665e <print_uint8_base10+0x6a>
}


void print_uint8_base10(uint8_t n)
{ 
  if (n == 0) {
    660e:	90 e0       	ldi	r25, 0x00	; 0

  unsigned char buf[3];
  uint8_t i = 0;

  while (n > 0) {
      buf[i++] = n % 10 + '0';
    6610:	4d ec       	ldi	r20, 0xCD	; 205
    6612:	11 e0       	ldi	r17, 0x01	; 1
    6614:	19 0f       	add	r17, r25
    6616:	e1 e0       	ldi	r30, 0x01	; 1
    6618:	f0 e0       	ldi	r31, 0x00	; 0
    661a:	ec 0f       	add	r30, r28
    661c:	fd 1f       	adc	r31, r29
    661e:	e9 0f       	add	r30, r25
    6620:	f1 1d       	adc	r31, r1
    6622:	84 9f       	mul	r24, r20
    6624:	91 2d       	mov	r25, r1
    6626:	11 24       	eor	r1, r1
    6628:	96 95       	lsr	r25
    662a:	96 95       	lsr	r25
    662c:	96 95       	lsr	r25
    662e:	29 2f       	mov	r18, r25
    6630:	22 0f       	add	r18, r18
    6632:	32 2f       	mov	r19, r18
    6634:	33 0f       	add	r19, r19
    6636:	33 0f       	add	r19, r19
    6638:	23 0f       	add	r18, r19
    663a:	82 1b       	sub	r24, r18
    663c:	80 5d       	subi	r24, 0xD0	; 208
    663e:	80 83       	st	Z, r24
      n /= 10;
    6640:	89 2f       	mov	r24, r25
  } 

  unsigned char buf[3];
  uint8_t i = 0;

  while (n > 0) {
    6642:	99 23       	and	r25, r25
    6644:	11 f0       	breq	.+4      	; 0x664a <print_uint8_base10+0x56>
      buf[i++] = n % 10 + '0';
    6646:	91 2f       	mov	r25, r17
    6648:	e4 cf       	rjmp	.-56     	; 0x6612 <print_uint8_base10+0x1e>
      n /= 10;
  }

  for (; i > 0; i--)
    664a:	11 23       	and	r17, r17
    664c:	41 f0       	breq	.+16     	; 0x665e <print_uint8_base10+0x6a>
      serial_write(buf[i - 1]);
    664e:	fe 01       	movw	r30, r28
    6650:	e1 0f       	add	r30, r17
    6652:	f1 1d       	adc	r31, r1
    6654:	80 81       	ld	r24, Z
    6656:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
  while (n > 0) {
      buf[i++] = n % 10 + '0';
      n /= 10;
  }

  for (; i > 0; i--)
    665a:	11 50       	subi	r17, 0x01	; 1
    665c:	c1 f7       	brne	.-16     	; 0x664e <print_uint8_base10+0x5a>
      serial_write(buf[i - 1]);
}
    665e:	0f 90       	pop	r0
    6660:	0f 90       	pop	r0
    6662:	0f 90       	pop	r0
    6664:	df 91       	pop	r29
    6666:	cf 91       	pop	r28
    6668:	1f 91       	pop	r17
    666a:	08 95       	ret

0000666c <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up 
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    666c:	8f 92       	push	r8
    666e:	9f 92       	push	r9
    6670:	af 92       	push	r10
    6672:	bf 92       	push	r11
    6674:	cf 92       	push	r12
    6676:	df 92       	push	r13
    6678:	ef 92       	push	r14
    667a:	ff 92       	push	r15
    667c:	0f 93       	push	r16
    667e:	1f 93       	push	r17
    6680:	cf 93       	push	r28
    6682:	df 93       	push	r29
    6684:	cd b7       	in	r28, 0x3d	; 61
    6686:	de b7       	in	r29, 0x3e	; 62
    6688:	2a 97       	sbiw	r28, 0x0a	; 10
    668a:	0f b6       	in	r0, 0x3f	; 63
    668c:	f8 94       	cli
    668e:	de bf       	out	0x3e, r29	; 62
    6690:	0f be       	out	0x3f, r0	; 63
    6692:	cd bf       	out	0x3d, r28	; 61
    6694:	6b 01       	movw	r12, r22
    6696:	7c 01       	movw	r14, r24
    6698:	14 2f       	mov	r17, r20
  if (n < 0) {
    669a:	20 e0       	ldi	r18, 0x00	; 0
    669c:	30 e0       	ldi	r19, 0x00	; 0
    669e:	a9 01       	movw	r20, r18
    66a0:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__cmpsf2>
    66a4:	88 23       	and	r24, r24
    66a6:	3c f4       	brge	.+14     	; 0x66b6 <printFloat+0x4a>
    serial_write('-');
    66a8:	8d e2       	ldi	r24, 0x2D	; 45
    66aa:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
    n = -n;
    66ae:	f7 fa       	bst	r15, 7
    66b0:	f0 94       	com	r15
    66b2:	f7 f8       	bld	r15, 7
    66b4:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    66b6:	12 30       	cpi	r17, 0x02	; 2
    66b8:	88 f0       	brcs	.+34     	; 0x66dc <printFloat+0x70>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    66ba:	01 2f       	mov	r16, r17
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    66bc:	20 e0       	ldi	r18, 0x00	; 0
    66be:	30 e0       	ldi	r19, 0x00	; 0
    66c0:	48 ec       	ldi	r20, 0xC8	; 200
    66c2:	52 e4       	ldi	r21, 0x42	; 66
    66c4:	c7 01       	movw	r24, r14
    66c6:	b6 01       	movw	r22, r12
    66c8:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    66cc:	6b 01       	movw	r12, r22
    66ce:	7c 01       	movw	r14, r24
    decimals -= 2;
    66d0:	02 50       	subi	r16, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    66d2:	02 30       	cpi	r16, 0x02	; 2
    66d4:	98 f7       	brcc	.-26     	; 0x66bc <printFloat+0x50>
    66d6:	81 2f       	mov	r24, r17
    66d8:	81 70       	andi	r24, 0x01	; 1
    66da:	01 c0       	rjmp	.+2      	; 0x66de <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    66dc:	81 2f       	mov	r24, r17
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    66de:	88 23       	and	r24, r24
    66e0:	51 f0       	breq	.+20     	; 0x66f6 <printFloat+0x8a>
    66e2:	20 e0       	ldi	r18, 0x00	; 0
    66e4:	30 e0       	ldi	r19, 0x00	; 0
    66e6:	40 e2       	ldi	r20, 0x20	; 32
    66e8:	51 e4       	ldi	r21, 0x41	; 65
    66ea:	c7 01       	movw	r24, r14
    66ec:	b6 01       	movw	r22, r12
    66ee:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    66f2:	6b 01       	movw	r12, r22
    66f4:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    66f6:	20 e0       	ldi	r18, 0x00	; 0
    66f8:	30 e0       	ldi	r19, 0x00	; 0
    66fa:	40 e0       	ldi	r20, 0x00	; 0
    66fc:	5f e3       	ldi	r21, 0x3F	; 63
    66fe:	c7 01       	movw	r24, r14
    6700:	b6 01       	movw	r22, r12
    6702:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
    6706:	0e 94 09 3d 	call	0x7a12	; 0x7a12 <__fixsfsi>
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
    670a:	2e e2       	ldi	r18, 0x2E	; 46
    670c:	fe 01       	movw	r30, r28
    670e:	e1 0f       	add	r30, r17
    6710:	f1 1d       	adc	r31, r1
    6712:	21 83       	std	Z+1, r18	; 0x01
  while(a > 0) {
    6714:	61 15       	cp	r22, r1
    6716:	71 05       	cpc	r23, r1
    6718:	81 05       	cpc	r24, r1
    671a:	91 05       	cpc	r25, r1
    671c:	49 f1       	breq	.+82     	; 0x6770 <printFloat+0x104>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    671e:	20 e0       	ldi	r18, 0x00	; 0
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    6720:	01 e0       	ldi	r16, 0x01	; 1
    6722:	01 0f       	add	r16, r17
    buf[i++] = (a % 10) + '0'; // Get digit
    6724:	0f 2e       	mov	r0, r31
    6726:	fa e0       	ldi	r31, 0x0A	; 10
    6728:	8f 2e       	mov	r8, r31
    672a:	91 2c       	mov	r9, r1
    672c:	a1 2c       	mov	r10, r1
    672e:	b1 2c       	mov	r11, r1
    6730:	f0 2d       	mov	r31, r0
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    6732:	21 13       	cpse	r18, r17
    6734:	01 c0       	rjmp	.+2      	; 0x6738 <printFloat+0xcc>
    6736:	20 2f       	mov	r18, r16
    buf[i++] = (a % 10) + '0'; // Get digit
    6738:	dd 24       	eor	r13, r13
    673a:	d3 94       	inc	r13
    673c:	d2 0e       	add	r13, r18
    673e:	ee 24       	eor	r14, r14
    6740:	e3 94       	inc	r14
    6742:	f1 2c       	mov	r15, r1
    6744:	ec 0e       	add	r14, r28
    6746:	fd 1e       	adc	r15, r29
    6748:	e2 0e       	add	r14, r18
    674a:	f1 1c       	adc	r15, r1
    674c:	a5 01       	movw	r20, r10
    674e:	94 01       	movw	r18, r8
    6750:	0e 94 c5 3f 	call	0x7f8a	; 0x7f8a <__udivmodsi4>
    6754:	60 5d       	subi	r22, 0xD0	; 208
    6756:	f7 01       	movw	r30, r14
    6758:	60 83       	st	Z, r22
    a /= 10;
    675a:	62 2f       	mov	r22, r18
    675c:	73 2f       	mov	r23, r19
    675e:	84 2f       	mov	r24, r20
    6760:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    6762:	61 15       	cp	r22, r1
    6764:	71 05       	cpc	r23, r1
    6766:	81 05       	cpc	r24, r1
    6768:	91 05       	cpc	r25, r1
    676a:	19 f0       	breq	.+6      	; 0x6772 <printFloat+0x106>
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    676c:	2d 2d       	mov	r18, r13
    676e:	e1 cf       	rjmp	.-62     	; 0x6732 <printFloat+0xc6>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    6770:	d1 2c       	mov	r13, r1
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    6772:	d1 16       	cp	r13, r17
    6774:	70 f4       	brcc	.+28     	; 0x6792 <printFloat+0x126>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    6776:	90 e3       	ldi	r25, 0x30	; 48
    6778:	81 e0       	ldi	r24, 0x01	; 1
    677a:	8d 0d       	add	r24, r13
    677c:	e1 e0       	ldi	r30, 0x01	; 1
    677e:	f0 e0       	ldi	r31, 0x00	; 0
    6780:	ec 0f       	add	r30, r28
    6782:	fd 1f       	adc	r31, r29
    6784:	ed 0d       	add	r30, r13
    6786:	f1 1d       	adc	r31, r1
    6788:	90 83       	st	Z, r25
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    678a:	81 17       	cp	r24, r17
    678c:	29 f0       	breq	.+10     	; 0x6798 <printFloat+0x12c>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    678e:	d8 2e       	mov	r13, r24
    6790:	f3 cf       	rjmp	.-26     	; 0x6778 <printFloat+0x10c>
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    6792:	1d 11       	cpse	r17, r13
    6794:	0b c0       	rjmp	.+22     	; 0x67ac <printFloat+0x140>
    6796:	1d 2d       	mov	r17, r13
    i++;
    buf[i++] = '0'; 
    6798:	68 94       	set
    679a:	dd 24       	eor	r13, r13
    679c:	d1 f8       	bld	r13, 1
    679e:	d1 0e       	add	r13, r17
  }
  while (i < decimal_places) { 
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    i++;
    67a0:	1f 5f       	subi	r17, 0xFF	; 255
    buf[i++] = '0'; 
    67a2:	fe 01       	movw	r30, r28
    67a4:	e1 0f       	add	r30, r17
    67a6:	f1 1d       	adc	r31, r1
    67a8:	80 e3       	ldi	r24, 0x30	; 48
    67aa:	81 83       	std	Z+1, r24	; 0x01
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    67ac:	dd 20       	and	r13, r13
    67ae:	41 f0       	breq	.+16     	; 0x67c0 <printFloat+0x154>
    serial_write(buf[i-1]);
    67b0:	fe 01       	movw	r30, r28
    67b2:	ed 0d       	add	r30, r13
    67b4:	f1 1d       	adc	r31, r1
    67b6:	80 81       	ld	r24, Z
    67b8:	0e 94 14 18 	call	0x3028	; 0x3028 <serial_write>
    i++;
    buf[i++] = '0'; 
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    67bc:	da 94       	dec	r13
    67be:	c1 f7       	brne	.-16     	; 0x67b0 <printFloat+0x144>
    serial_write(buf[i-1]);
}
    67c0:	2a 96       	adiw	r28, 0x0a	; 10
    67c2:	0f b6       	in	r0, 0x3f	; 63
    67c4:	f8 94       	cli
    67c6:	de bf       	out	0x3e, r29	; 62
    67c8:	0f be       	out	0x3f, r0	; 63
    67ca:	cd bf       	out	0x3d, r28	; 61
    67cc:	df 91       	pop	r29
    67ce:	cf 91       	pop	r28
    67d0:	1f 91       	pop	r17
    67d2:	0f 91       	pop	r16
    67d4:	ff 90       	pop	r15
    67d6:	ef 90       	pop	r14
    67d8:	df 90       	pop	r13
    67da:	cf 90       	pop	r12
    67dc:	bf 90       	pop	r11
    67de:	af 90       	pop	r10
    67e0:	9f 90       	pop	r9
    67e2:	8f 90       	pop	r8
    67e4:	08 95       	ret

000067e6 <printFloat_CoordValue>:
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
//  - SettingValue: Handles all floating point settings values (always in mm.)
void printFloat_CoordValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) { 
    67e6:	20 91 3c 09 	lds	r18, 0x093C
    67ea:	20 ff       	sbrs	r18, 0
    67ec:	0a c0       	rjmp	.+20     	; 0x6802 <printFloat_CoordValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    67ee:	2b e8       	ldi	r18, 0x8B	; 139
    67f0:	32 e4       	ldi	r19, 0x42	; 66
    67f2:	41 e2       	ldi	r20, 0x21	; 33
    67f4:	5d e3       	ldi	r21, 0x3D	; 61
    67f6:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    67fa:	44 e0       	ldi	r20, 0x04	; 4
    67fc:	0e 94 36 33 	call	0x666c	; 0x666c <printFloat>
    6800:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    6802:	43 e0       	ldi	r20, 0x03	; 3
    6804:	0e 94 36 33 	call	0x666c	; 0x666c <printFloat>
    6808:	08 95       	ret

0000680a <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    680a:	20 91 3c 09 	lds	r18, 0x093C
    680e:	20 ff       	sbrs	r18, 0
    6810:	0a c0       	rjmp	.+20     	; 0x6826 <printFloat_RateValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    6812:	2b e8       	ldi	r18, 0x8B	; 139
    6814:	32 e4       	ldi	r19, 0x42	; 66
    6816:	41 e2       	ldi	r20, 0x21	; 33
    6818:	5d e3       	ldi	r21, 0x3D	; 61
    681a:	0e 94 d8 3e 	call	0x7db0	; 0x7db0 <__mulsf3>
    681e:	41 e0       	ldi	r20, 0x01	; 1
    6820:	0e 94 36 33 	call	0x666c	; 0x666c <printFloat>
    6824:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    6826:	40 e0       	ldi	r20, 0x00	; 0
    6828:	0e 94 36 33 	call	0x666c	; 0x666c <printFloat>
    682c:	08 95       	ret

0000682e <printFloat_SettingValue>:
  }
}

void printFloat_SettingValue(float n) { printFloat(n,N_DECIMAL_SETTINGVALUE); }
    682e:	43 e0       	ldi	r20, 0x03	; 3
    6830:	0e 94 36 33 	call	0x666c	; 0x666c <printFloat>
    6834:	08 95       	ret

00006836 <probe_init>:


// Probe pin initialization routine.
void probe_init() 
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    6836:	24 98       	cbi	0x04, 4	; 4
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    6838:	2c 9a       	sbi	0x05, 4	; 5
    683a:	08 95       	ret

0000683c <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to 
// appropriately set the pin logic according to setting for normal-high/normal-low operation 
// and the probing cycle modes for toward-workpiece/away-from-workpiece. 
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    683c:	10 92 54 09 	sts	0x0954, r1
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    6840:	90 91 3c 09 	lds	r25, 0x093C
    6844:	99 23       	and	r25, r25
    6846:	1c f0       	brlt	.+6      	; 0x684e <probe_configure_invert_mask+0x12>
    6848:	90 e1       	ldi	r25, 0x10	; 16
    684a:	90 93 54 09 	sts	0x0954, r25
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    684e:	88 23       	and	r24, r24
    6850:	31 f0       	breq	.+12     	; 0x685e <probe_configure_invert_mask+0x22>
    6852:	90 91 54 09 	lds	r25, 0x0954
    6856:	80 e1       	ldi	r24, 0x10	; 16
    6858:	89 27       	eor	r24, r25
    685a:	80 93 54 09 	sts	0x0954, r24
    685e:	08 95       	ret

00006860 <probe_get_state>:
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    6860:	83 b1       	in	r24, 0x03	; 3
    6862:	80 71       	andi	r24, 0x10	; 16
    6864:	90 91 54 09 	lds	r25, 0x0954
    6868:	89 27       	eor	r24, r25
    686a:	08 95       	ret

0000686c <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (sys.probe_state == PROBE_ACTIVE) {
    686c:	80 91 79 07 	lds	r24, 0x0779
    6870:	81 30       	cpi	r24, 0x01	; 1
    6872:	a1 f4       	brne	.+40     	; 0x689c <probe_state_monitor+0x30>
    if (probe_get_state()) {
    6874:	0e 94 30 34 	call	0x6860	; 0x6860 <probe_get_state>
    6878:	88 23       	and	r24, r24
    687a:	81 f0       	breq	.+32     	; 0x689c <probe_state_monitor+0x30>
      sys.probe_state = PROBE_OFF;
    687c:	10 92 79 07 	sts	0x0779, r1
      memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS);
    6880:	8c e0       	ldi	r24, 0x0C	; 12
    6882:	ec e6       	ldi	r30, 0x6C	; 108
    6884:	f7 e0       	ldi	r31, 0x07	; 7
    6886:	aa e7       	ldi	r26, 0x7A	; 122
    6888:	b7 e0       	ldi	r27, 0x07	; 7
    688a:	01 90       	ld	r0, Z+
    688c:	0d 92       	st	X+, r0
    688e:	8a 95       	dec	r24
    6890:	e1 f7       	brne	.-8      	; 0x688a <probe_state_monitor+0x1e>
      bit_true(sys.rt_exec_state, EXEC_MOTION_CANCEL);
    6892:	ea e6       	ldi	r30, 0x6A	; 106
    6894:	f7 e0       	ldi	r31, 0x07	; 7
    6896:	80 81       	ld	r24, Z
    6898:	80 64       	ori	r24, 0x40	; 64
    689a:	80 83       	st	Z, r24
    689c:	08 95       	ret

0000689e <report_status_message>:
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
// NOTE: In silent mode, all error codes are greater than zero.
// TODO: Install silent mode to return only numeric values, primarily for GUIs.
void report_status_message(uint8_t status_code) 
{
    689e:	cf 93       	push	r28
    68a0:	c8 2f       	mov	r28, r24
  if (status_code == 0) { // STATUS_OK
    68a2:	81 11       	cpse	r24, r1
    68a4:	05 c0       	rjmp	.+10     	; 0x68b0 <report_status_message+0x12>
    printPgmString(PSTR("ok\r\n"));
    68a6:	80 eb       	ldi	r24, 0xB0	; 176
    68a8:	99 e0       	ldi	r25, 0x09	; 9
    68aa:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    68ae:	66 c0       	rjmp	.+204    	; 0x697c <report_status_message+0xde>
  } else {
    printPgmString(PSTR("error: "));
    68b0:	88 ea       	ldi	r24, 0xA8	; 168
    68b2:	99 e0       	ldi	r25, 0x09	; 9
    68b4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    switch(status_code) {          
    68b8:	4c 2f       	mov	r20, r28
    68ba:	50 e0       	ldi	r21, 0x00	; 0
    68bc:	fa 01       	movw	r30, r20
    68be:	31 97       	sbiw	r30, 0x01	; 1
    68c0:	e6 31       	cpi	r30, 0x16	; 22
    68c2:	f1 05       	cpc	r31, r1
    68c4:	08 f0       	brcs	.+2      	; 0x68c8 <report_status_message+0x2a>
    68c6:	4f c0       	rjmp	.+158    	; 0x6966 <report_status_message+0xc8>
    68c8:	e5 50       	subi	r30, 0x05	; 5
    68ca:	ff 4f       	sbci	r31, 0xFF	; 255
    68cc:	0c 94 e7 3f 	jmp	0x7fce	; 0x7fce <__tablejump2__>
      case STATUS_EXPECTED_COMMAND_LETTER:
      printPgmString(PSTR("Expected command letter")); break;
    68d0:	80 e9       	ldi	r24, 0x90	; 144
    68d2:	99 e0       	ldi	r25, 0x09	; 9
    68d4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    68d8:	4d c0       	rjmp	.+154    	; 0x6974 <report_status_message+0xd6>
      case STATUS_BAD_NUMBER_FORMAT:
      printPgmString(PSTR("Bad number format")); break;
    68da:	8e e7       	ldi	r24, 0x7E	; 126
    68dc:	99 e0       	ldi	r25, 0x09	; 9
    68de:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    68e2:	48 c0       	rjmp	.+144    	; 0x6974 <report_status_message+0xd6>
      case STATUS_INVALID_STATEMENT:
      printPgmString(PSTR("Invalid statement")); break;
    68e4:	8c e6       	ldi	r24, 0x6C	; 108
    68e6:	99 e0       	ldi	r25, 0x09	; 9
    68e8:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    68ec:	43 c0       	rjmp	.+134    	; 0x6974 <report_status_message+0xd6>
      case STATUS_NEGATIVE_VALUE:
      printPgmString(PSTR("Value < 0")); break;
    68ee:	82 e6       	ldi	r24, 0x62	; 98
    68f0:	99 e0       	ldi	r25, 0x09	; 9
    68f2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    68f6:	3e c0       	rjmp	.+124    	; 0x6974 <report_status_message+0xd6>
      case STATUS_SETTING_DISABLED:
      printPgmString(PSTR("Setting disabled")); break;
    68f8:	81 e5       	ldi	r24, 0x51	; 81
    68fa:	99 e0       	ldi	r25, 0x09	; 9
    68fc:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6900:	39 c0       	rjmp	.+114    	; 0x6974 <report_status_message+0xd6>
      case STATUS_SETTING_STEP_PULSE_MIN:
      printPgmString(PSTR("Value < 3 usec")); break;
    6902:	82 e4       	ldi	r24, 0x42	; 66
    6904:	99 e0       	ldi	r25, 0x09	; 9
    6906:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    690a:	34 c0       	rjmp	.+104    	; 0x6974 <report_status_message+0xd6>
      case STATUS_SETTING_READ_FAIL:
      printPgmString(PSTR("EEPROM read fail. Using defaults")); break;
    690c:	81 e2       	ldi	r24, 0x21	; 33
    690e:	99 e0       	ldi	r25, 0x09	; 9
    6910:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6914:	2f c0       	rjmp	.+94     	; 0x6974 <report_status_message+0xd6>
      case STATUS_IDLE_ERROR:
      printPgmString(PSTR("Not idle")); break;
    6916:	88 e1       	ldi	r24, 0x18	; 24
    6918:	99 e0       	ldi	r25, 0x09	; 9
    691a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    691e:	2a c0       	rjmp	.+84     	; 0x6974 <report_status_message+0xd6>
      case STATUS_ALARM_LOCK:
      printPgmString(PSTR("Alarm lock")); break;
    6920:	8d e0       	ldi	r24, 0x0D	; 13
    6922:	99 e0       	ldi	r25, 0x09	; 9
    6924:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6928:	25 c0       	rjmp	.+74     	; 0x6974 <report_status_message+0xd6>
      case STATUS_SOFT_LIMIT_ERROR:
      printPgmString(PSTR("Homing not enabled")); break;
    692a:	8a ef       	ldi	r24, 0xFA	; 250
    692c:	98 e0       	ldi	r25, 0x08	; 8
    692e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6932:	20 c0       	rjmp	.+64     	; 0x6974 <report_status_message+0xd6>
      case STATUS_OVERFLOW:
      printPgmString(PSTR("Line overflow")); break; 
    6934:	8c ee       	ldi	r24, 0xEC	; 236
    6936:	98 e0       	ldi	r25, 0x08	; 8
    6938:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    693c:	1b c0       	rjmp	.+54     	; 0x6974 <report_status_message+0xd6>
      // case STATUS_MAX_STEP_RATE_EXCEEDED: 
      // printPgmString(PSTR("Step rate > 30kHz")); break;
      case STATUS_JOG_ONGOING_LOCK:
	  printPgmString(PSTR("Jogging ongoing; Ignoring GCode")); break;
    693e:	8c ec       	ldi	r24, 0xCC	; 204
    6940:	98 e0       	ldi	r25, 0x08	; 8
    6942:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6946:	16 c0       	rjmp	.+44     	; 0x6974 <report_status_message+0xd6>
	  
      // Common g-code parser errors.
      case STATUS_GCODE_MODAL_GROUP_VIOLATION:
      printPgmString(PSTR("Modal group violation")); break;
    6948:	86 eb       	ldi	r24, 0xB6	; 182
    694a:	98 e0       	ldi	r25, 0x08	; 8
    694c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6950:	11 c0       	rjmp	.+34     	; 0x6974 <report_status_message+0xd6>
      case STATUS_GCODE_UNSUPPORTED_COMMAND:
      printPgmString(PSTR("Unsupported command")); break;
    6952:	82 ea       	ldi	r24, 0xA2	; 162
    6954:	98 e0       	ldi	r25, 0x08	; 8
    6956:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    695a:	0c c0       	rjmp	.+24     	; 0x6974 <report_status_message+0xd6>
      case STATUS_GCODE_UNDEFINED_FEED_RATE:
      printPgmString(PSTR("Undefined feed rate")); break;
    695c:	8e e8       	ldi	r24, 0x8E	; 142
    695e:	98 e0       	ldi	r25, 0x08	; 8
    6960:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6964:	07 c0       	rjmp	.+14     	; 0x6974 <report_status_message+0xd6>
      default:
        // Remaining g-code parser errors with error codes
        printPgmString(PSTR("Invalid gcode ID:"));
    6966:	8c e7       	ldi	r24, 0x7C	; 124
    6968:	98 e0       	ldi	r25, 0x08	; 8
    696a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
        print_uint8_base10(status_code); // Print error code for user reference
    696e:	8c 2f       	mov	r24, r28
    6970:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
    }
    printPgmString(PSTR("\r\n"));
    6974:	89 e7       	ldi	r24, 0x79	; 121
    6976:	98 e0       	ldi	r25, 0x08	; 8
    6978:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }
}
    697c:	cf 91       	pop	r28
    697e:	08 95       	ret

00006980 <report_alarm_message>:

// Prints alarm messages.
void report_alarm_message(int8_t alarm_code)
{
    6980:	cf 93       	push	r28
    6982:	c8 2f       	mov	r28, r24
  printPgmString(PSTR("ALARM: "));
    6984:	81 e7       	ldi	r24, 0x71	; 113
    6986:	98 e0       	ldi	r25, 0x08	; 8
    6988:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  switch (alarm_code) {
    698c:	cd 3f       	cpi	r28, 0xFD	; 253
    698e:	91 f0       	breq	.+36     	; 0x69b4 <report_alarm_message+0x34>
    6990:	1c f4       	brge	.+6      	; 0x6998 <report_alarm_message+0x18>
    6992:	cc 3f       	cpi	r28, 0xFC	; 252
    6994:	a1 f0       	breq	.+40     	; 0x69be <report_alarm_message+0x3e>
    6996:	17 c0       	rjmp	.+46     	; 0x69c6 <report_alarm_message+0x46>
    6998:	ce 3f       	cpi	r28, 0xFE	; 254
    699a:	39 f0       	breq	.+14     	; 0x69aa <report_alarm_message+0x2a>
    699c:	cf 3f       	cpi	r28, 0xFF	; 255
    699e:	99 f4       	brne	.+38     	; 0x69c6 <report_alarm_message+0x46>
    case ALARM_HARD_LIMIT_ERROR: 
    printPgmString(PSTR("Hard limit")); break;
    69a0:	86 e6       	ldi	r24, 0x66	; 102
    69a2:	98 e0       	ldi	r25, 0x08	; 8
    69a4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    69a8:	0e c0       	rjmp	.+28     	; 0x69c6 <report_alarm_message+0x46>
    case ALARM_SOFT_LIMIT_ERROR:
    printPgmString(PSTR("Soft limit")); break;
    69aa:	8b e5       	ldi	r24, 0x5B	; 91
    69ac:	98 e0       	ldi	r25, 0x08	; 8
    69ae:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    69b2:	09 c0       	rjmp	.+18     	; 0x69c6 <report_alarm_message+0x46>
    case ALARM_ABORT_CYCLE: 
    printPgmString(PSTR("Abort during cycle")); break;
    69b4:	88 e4       	ldi	r24, 0x48	; 72
    69b6:	98 e0       	ldi	r25, 0x08	; 8
    69b8:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    69bc:	04 c0       	rjmp	.+8      	; 0x69c6 <report_alarm_message+0x46>
    case ALARM_PROBE_FAIL:
    printPgmString(PSTR("Probe fail")); break;
    69be:	8d e3       	ldi	r24, 0x3D	; 61
    69c0:	98 e0       	ldi	r25, 0x08	; 8
    69c2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }
  printPgmString(PSTR("\r\n"));
    69c6:	8a e3       	ldi	r24, 0x3A	; 58
    69c8:	98 e0       	ldi	r25, 0x08	; 8
    69ca:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  delay_ms(500); // Force delay to ensure message clears serial write buffer.
    69ce:	84 ef       	ldi	r24, 0xF4	; 244
    69d0:	91 e0       	ldi	r25, 0x01	; 1
    69d2:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <delay_ms>
}
    69d6:	cf 91       	pop	r28
    69d8:	08 95       	ret

000069da <report_feedback_message>:
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
// TODO: Install silence feedback messages option in settings
void report_feedback_message(uint8_t message_code)
{
    69da:	cf 93       	push	r28
    69dc:	c8 2f       	mov	r28, r24
  printPgmString(PSTR("["));
    69de:	88 e3       	ldi	r24, 0x38	; 56
    69e0:	98 e0       	ldi	r25, 0x08	; 8
    69e2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  switch(message_code) {
    69e6:	c3 30       	cpi	r28, 0x03	; 3
    69e8:	b1 f0       	breq	.+44     	; 0x6a16 <report_feedback_message+0x3c>
    69ea:	28 f4       	brcc	.+10     	; 0x69f6 <report_feedback_message+0x1c>
    69ec:	c1 30       	cpi	r28, 0x01	; 1
    69ee:	49 f0       	breq	.+18     	; 0x6a02 <report_feedback_message+0x28>
    69f0:	c2 30       	cpi	r28, 0x02	; 2
    69f2:	61 f0       	breq	.+24     	; 0x6a0c <report_feedback_message+0x32>
    69f4:	23 c0       	rjmp	.+70     	; 0x6a3c <report_feedback_message+0x62>
    69f6:	c5 30       	cpi	r28, 0x05	; 5
    69f8:	c1 f0       	breq	.+48     	; 0x6a2a <report_feedback_message+0x50>
    69fa:	90 f0       	brcs	.+36     	; 0x6a20 <report_feedback_message+0x46>
    69fc:	c6 30       	cpi	r28, 0x06	; 6
    69fe:	d1 f0       	breq	.+52     	; 0x6a34 <report_feedback_message+0x5a>
    6a00:	1d c0       	rjmp	.+58     	; 0x6a3c <report_feedback_message+0x62>
    case MESSAGE_CRITICAL_EVENT:
    printPgmString(PSTR("Reset to continue")); break;
    6a02:	86 e2       	ldi	r24, 0x26	; 38
    6a04:	98 e0       	ldi	r25, 0x08	; 8
    6a06:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a0a:	18 c0       	rjmp	.+48     	; 0x6a3c <report_feedback_message+0x62>
    case MESSAGE_ALARM_LOCK:
    printPgmString(PSTR("'$H'|'$X' to unlock")); break;
    6a0c:	82 e1       	ldi	r24, 0x12	; 18
    6a0e:	98 e0       	ldi	r25, 0x08	; 8
    6a10:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a14:	13 c0       	rjmp	.+38     	; 0x6a3c <report_feedback_message+0x62>
    case MESSAGE_ALARM_UNLOCK:
    printPgmString(PSTR("Caution: Unlocked")); break;
    6a16:	80 e0       	ldi	r24, 0x00	; 0
    6a18:	98 e0       	ldi	r25, 0x08	; 8
    6a1a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a1e:	0e c0       	rjmp	.+28     	; 0x6a3c <report_feedback_message+0x62>
    case MESSAGE_ENABLED:
    printPgmString(PSTR("Enabled")); break;
    6a20:	88 ef       	ldi	r24, 0xF8	; 248
    6a22:	97 e0       	ldi	r25, 0x07	; 7
    6a24:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a28:	09 c0       	rjmp	.+18     	; 0x6a3c <report_feedback_message+0x62>
    case MESSAGE_DISABLED:
    printPgmString(PSTR("Disabled")); break; 
    6a2a:	8f ee       	ldi	r24, 0xEF	; 239
    6a2c:	97 e0       	ldi	r25, 0x07	; 7
    6a2e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a32:	04 c0       	rjmp	.+8      	; 0x6a3c <report_feedback_message+0x62>
    case MESSAGE_SAFETY_DOOR_AJAR:
    printPgmString(PSTR("Check Door")); break;
    6a34:	84 ee       	ldi	r24, 0xE4	; 228
    6a36:	97 e0       	ldi	r25, 0x07	; 7
    6a38:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }
  printPgmString(PSTR("]\r\n"));
    6a3c:	80 ee       	ldi	r24, 0xE0	; 224
    6a3e:	97 e0       	ldi	r25, 0x07	; 7
    6a40:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
}
    6a44:	cf 91       	pop	r28
    6a46:	08 95       	ret

00006a48 <report_init_message>:


// Welcome message
void report_init_message()
{
  printPgmString(PSTR("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n"));
    6a48:	8a eb       	ldi	r24, 0xBA	; 186
    6a4a:	97 e0       	ldi	r25, 0x07	; 7
    6a4c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a50:	08 95       	ret

00006a52 <report_grbl_help>:
}

// Grbl help message
void report_grbl_help() {
  printPgmString(PSTR("$$ (view Grbl settings)\r\n"
    6a52:	86 e7       	ldi	r24, 0x76	; 118
    6a54:	96 e0       	ldi	r25, 0x06	; 6
    6a56:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a5a:	08 95       	ret

00006a5c <report_grbl_settings>:
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6a5c:	cf 92       	push	r12
    6a5e:	df 92       	push	r13
    6a60:	ef 92       	push	r14
    6a62:	ff 92       	push	r15
    6a64:	0f 93       	push	r16
    6a66:	1f 93       	push	r17
    6a68:	cf 93       	push	r28
    6a6a:	df 93       	push	r29
  // Print Grbl settings.
  printPgmString(PSTR("$0=")); print_uint8_base10(settings.pulse_microseconds);
    6a6c:	82 e7       	ldi	r24, 0x72	; 114
    6a6e:	96 e0       	ldi	r25, 0x06	; 6
    6a70:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a74:	80 91 2f 09 	lds	r24, 0x092F
    6a78:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (step pulse, usec)\r\n$1=")); print_uint8_base10(settings.stepper_idle_lock_time);
    6a7c:	89 e5       	ldi	r24, 0x59	; 89
    6a7e:	96 e0       	ldi	r25, 0x06	; 6
    6a80:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a84:	80 91 32 09 	lds	r24, 0x0932
    6a88:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (step idle delay, msec)\r\n$2=")); print_uint8_base10(settings.step_invert_mask); 
    6a8c:	8b e3       	ldi	r24, 0x3B	; 59
    6a8e:	96 e0       	ldi	r25, 0x06	; 6
    6a90:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6a94:	c0 e3       	ldi	r28, 0x30	; 48
    6a96:	d9 e0       	ldi	r29, 0x09	; 9
    6a98:	88 81       	ld	r24, Y
    6a9a:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (step port invert mask:")); print_uint8_base2(settings.step_invert_mask);  
    6a9e:	82 e2       	ldi	r24, 0x22	; 34
    6aa0:	96 e0       	ldi	r25, 0x06	; 6
    6aa2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6aa6:	88 81       	ld	r24, Y
    6aa8:	0e 94 c6 32 	call	0x658c	; 0x658c <print_uint8_base2>
  printPgmString(PSTR(")\r\n$3=")); print_uint8_base10(settings.dir_invert_mask); 
    6aac:	8b e1       	ldi	r24, 0x1B	; 27
    6aae:	96 e0       	ldi	r25, 0x06	; 6
    6ab0:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6ab4:	c1 e3       	ldi	r28, 0x31	; 49
    6ab6:	d9 e0       	ldi	r29, 0x09	; 9
    6ab8:	88 81       	ld	r24, Y
    6aba:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (dir port invert mask:")); print_uint8_base2(settings.dir_invert_mask);  
    6abe:	83 e0       	ldi	r24, 0x03	; 3
    6ac0:	96 e0       	ldi	r25, 0x06	; 6
    6ac2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6ac6:	88 81       	ld	r24, Y
    6ac8:	0e 94 c6 32 	call	0x658c	; 0x658c <print_uint8_base2>
  printPgmString(PSTR(")\r\n$4=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
    6acc:	8c ef       	ldi	r24, 0xFC	; 252
    6ace:	95 e0       	ldi	r25, 0x05	; 5
    6ad0:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6ad4:	cc e3       	ldi	r28, 0x3C	; 60
    6ad6:	d9 e0       	ldi	r29, 0x09	; 9
    6ad8:	88 81       	ld	r24, Y
    6ada:	82 fb       	bst	r24, 2
    6adc:	88 27       	eor	r24, r24
    6ade:	80 f9       	bld	r24, 0
    6ae0:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (step enable invert, bool)\r\n$5=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
    6ae4:	8b ed       	ldi	r24, 0xDB	; 219
    6ae6:	95 e0       	ldi	r25, 0x05	; 5
    6ae8:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6aec:	88 81       	ld	r24, Y
    6aee:	86 fb       	bst	r24, 6
    6af0:	88 27       	eor	r24, r24
    6af2:	80 f9       	bld	r24, 0
    6af4:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (limit pins invert, bool)\r\n$6=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
    6af8:	8b eb       	ldi	r24, 0xBB	; 187
    6afa:	95 e0       	ldi	r25, 0x05	; 5
    6afc:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6b00:	88 81       	ld	r24, Y
    6b02:	88 1f       	adc	r24, r24
    6b04:	88 27       	eor	r24, r24
    6b06:	88 1f       	adc	r24, r24
    6b08:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (probe pin invert, bool)\r\n$10=")); print_uint8_base10(settings.status_report_mask);
    6b0c:	8b e9       	ldi	r24, 0x9B	; 155
    6b0e:	95 e0       	ldi	r25, 0x05	; 5
    6b10:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6b14:	03 e3       	ldi	r16, 0x33	; 51
    6b16:	19 e0       	ldi	r17, 0x09	; 9
    6b18:	f8 01       	movw	r30, r16
    6b1a:	80 81       	ld	r24, Z
    6b1c:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (status report mask:")); print_uint8_base2(settings.status_report_mask);
    6b20:	85 e8       	ldi	r24, 0x85	; 133
    6b22:	95 e0       	ldi	r25, 0x05	; 5
    6b24:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6b28:	f8 01       	movw	r30, r16
    6b2a:	80 81       	ld	r24, Z
    6b2c:	0e 94 c6 32 	call	0x658c	; 0x658c <print_uint8_base2>
  printPgmString(PSTR(")\r\n$11=")); printFloat_SettingValue(settings.junction_deviation);
    6b30:	8d e7       	ldi	r24, 0x7D	; 125
    6b32:	95 e0       	ldi	r25, 0x05	; 5
    6b34:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6b38:	60 91 34 09 	lds	r22, 0x0934
    6b3c:	70 91 35 09 	lds	r23, 0x0935
    6b40:	80 91 36 09 	lds	r24, 0x0936
    6b44:	90 91 37 09 	lds	r25, 0x0937
    6b48:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
  printPgmString(PSTR(" (junction deviation, mm)\r\n$12=")); printFloat_SettingValue(settings.arc_tolerance);
    6b4c:	8d e5       	ldi	r24, 0x5D	; 93
    6b4e:	95 e0       	ldi	r25, 0x05	; 5
    6b50:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6b54:	60 91 38 09 	lds	r22, 0x0938
    6b58:	70 91 39 09 	lds	r23, 0x0939
    6b5c:	80 91 3a 09 	lds	r24, 0x093A
    6b60:	90 91 3b 09 	lds	r25, 0x093B
    6b64:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
  printPgmString(PSTR(" (arc tolerance, mm)\r\n$13=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
    6b68:	82 e4       	ldi	r24, 0x42	; 66
    6b6a:	95 e0       	ldi	r25, 0x05	; 5
    6b6c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6b70:	88 81       	ld	r24, Y
    6b72:	81 70       	andi	r24, 0x01	; 1
    6b74:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (report inches, bool)\r\n$20=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
    6b78:	85 e2       	ldi	r24, 0x25	; 37
    6b7a:	95 e0       	ldi	r25, 0x05	; 5
    6b7c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6b80:	88 81       	ld	r24, Y
    6b82:	85 fb       	bst	r24, 5
    6b84:	88 27       	eor	r24, r24
    6b86:	80 f9       	bld	r24, 0
    6b88:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (soft limits, bool)\r\n$21=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
    6b8c:	8a e0       	ldi	r24, 0x0A	; 10
    6b8e:	95 e0       	ldi	r25, 0x05	; 5
    6b90:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6b94:	88 81       	ld	r24, Y
    6b96:	83 fb       	bst	r24, 3
    6b98:	88 27       	eor	r24, r24
    6b9a:	80 f9       	bld	r24, 0
    6b9c:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (hard limits, bool)\r\n$22=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
    6ba0:	8f ee       	ldi	r24, 0xEF	; 239
    6ba2:	94 e0       	ldi	r25, 0x04	; 4
    6ba4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6ba8:	88 81       	ld	r24, Y
    6baa:	82 95       	swap	r24
    6bac:	81 70       	andi	r24, 0x01	; 1
    6bae:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (homing cycle, bool)\r\n$23=")); print_uint8_base10(settings.homing_dir_mask);
    6bb2:	83 ed       	ldi	r24, 0xD3	; 211
    6bb4:	94 e0       	ldi	r25, 0x04	; 4
    6bb6:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6bba:	cd e3       	ldi	r28, 0x3D	; 61
    6bbc:	d9 e0       	ldi	r29, 0x09	; 9
    6bbe:	88 81       	ld	r24, Y
    6bc0:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (homing dir invert mask:")); print_uint8_base2(settings.homing_dir_mask);  
    6bc4:	89 eb       	ldi	r24, 0xB9	; 185
    6bc6:	94 e0       	ldi	r25, 0x04	; 4
    6bc8:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6bcc:	88 81       	ld	r24, Y
    6bce:	0e 94 c6 32 	call	0x658c	; 0x658c <print_uint8_base2>
  printPgmString(PSTR(")\r\n$24=")); printFloat_SettingValue(settings.homing_feed_rate);
    6bd2:	81 eb       	ldi	r24, 0xB1	; 177
    6bd4:	94 e0       	ldi	r25, 0x04	; 4
    6bd6:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6bda:	60 91 3e 09 	lds	r22, 0x093E
    6bde:	70 91 3f 09 	lds	r23, 0x093F
    6be2:	80 91 40 09 	lds	r24, 0x0940
    6be6:	90 91 41 09 	lds	r25, 0x0941
    6bea:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
  printPgmString(PSTR(" (homing feed, mm/min)\r\n$25=")); printFloat_SettingValue(settings.homing_seek_rate);
    6bee:	84 e9       	ldi	r24, 0x94	; 148
    6bf0:	94 e0       	ldi	r25, 0x04	; 4
    6bf2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6bf6:	60 91 42 09 	lds	r22, 0x0942
    6bfa:	70 91 43 09 	lds	r23, 0x0943
    6bfe:	80 91 44 09 	lds	r24, 0x0944
    6c02:	90 91 45 09 	lds	r25, 0x0945
    6c06:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
  printPgmString(PSTR(" (homing seek, mm/min)\r\n$26=")); print_uint8_base10(settings.homing_debounce_delay);
    6c0a:	87 e7       	ldi	r24, 0x77	; 119
    6c0c:	94 e0       	ldi	r25, 0x04	; 4
    6c0e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6c12:	80 91 46 09 	lds	r24, 0x0946
    6c16:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR(" (homing debounce, msec)\r\n$27=")); printFloat_SettingValue(settings.homing_pulloff);
    6c1a:	88 e5       	ldi	r24, 0x58	; 88
    6c1c:	94 e0       	ldi	r25, 0x04	; 4
    6c1e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6c22:	60 91 48 09 	lds	r22, 0x0948
    6c26:	70 91 49 09 	lds	r23, 0x0949
    6c2a:	80 91 4a 09 	lds	r24, 0x094A
    6c2e:	90 91 4b 09 	lds	r25, 0x094B
    6c32:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
  printPgmString(PSTR(" (homing pull-off, mm)\r\n$30=")); printFloat_SettingValue(settings.z_zero_pulloff);
    6c36:	8b e3       	ldi	r24, 0x3B	; 59
    6c38:	94 e0       	ldi	r25, 0x04	; 4
    6c3a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6c3e:	60 91 4c 09 	lds	r22, 0x094C
    6c42:	70 91 4d 09 	lds	r23, 0x094D
    6c46:	80 91 4e 09 	lds	r24, 0x094E
    6c4a:	90 91 4f 09 	lds	r25, 0x094F
    6c4e:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
  printPgmString(PSTR(" (Z zero pull-off, mm)\r\n$31=")); printFloat_SettingValue(settings.z_zero_gauge);
    6c52:	8e e1       	ldi	r24, 0x1E	; 30
    6c54:	94 e0       	ldi	r25, 0x04	; 4
    6c56:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6c5a:	60 91 50 09 	lds	r22, 0x0950
    6c5e:	70 91 51 09 	lds	r23, 0x0951
    6c62:	80 91 52 09 	lds	r24, 0x0952
    6c66:	90 91 53 09 	lds	r25, 0x0953
    6c6a:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
  printPgmString(PSTR(" (Z zero gauge, mm)\r\n"));
    6c6e:	88 e0       	ldi	r24, 0x08	; 8
    6c70:	94 e0       	ldi	r25, 0x04	; 4
    6c72:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
    6c76:	0f 2e       	mov	r0, r31
    6c78:	f4 e6       	ldi	r31, 0x64	; 100
    6c7a:	df 2e       	mov	r13, r31
    6c7c:	f0 2d       	mov	r31, r0
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    6c7e:	10 e0       	ldi	r17, 0x00	; 0
    6c80:	0f 2e       	mov	r0, r31
    6c82:	ff ef       	ldi	r31, 0xFF	; 255
    6c84:	ef 2e       	mov	r14, r31
    6c86:	f8 e0       	ldi	r31, 0x08	; 8
    6c88:	ff 2e       	mov	r15, r31
    6c8a:	f0 2d       	mov	r31, r0
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6c8c:	c1 2c       	mov	r12, r1
    6c8e:	7a c0       	rjmp	.+244    	; 0x6d84 <report_grbl_settings+0x328>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printPgmString(PSTR("$"));
    6c90:	86 e0       	ldi	r24, 0x06	; 6
    6c92:	94 e0       	ldi	r25, 0x04	; 4
    6c94:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
      print_uint8_base10(val+idx);
    6c98:	80 2f       	mov	r24, r16
    6c9a:	8d 0d       	add	r24, r13
    6c9c:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
      printPgmString(PSTR("="));
    6ca0:	84 e0       	ldi	r24, 0x04	; 4
    6ca2:	94 e0       	ldi	r25, 0x04	; 4
    6ca4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
      switch (set_idx) {
    6ca8:	11 30       	cpi	r17, 0x01	; 1
    6caa:	69 f0       	breq	.+26     	; 0x6cc6 <report_grbl_settings+0x26a>
    6cac:	28 f0       	brcs	.+10     	; 0x6cb8 <report_grbl_settings+0x25c>
    6cae:	12 30       	cpi	r17, 0x02	; 2
    6cb0:	89 f0       	breq	.+34     	; 0x6cd4 <report_grbl_settings+0x278>
    6cb2:	13 30       	cpi	r17, 0x03	; 3
    6cb4:	e1 f0       	breq	.+56     	; 0x6cee <report_grbl_settings+0x292>
    6cb6:	24 c0       	rjmp	.+72     	; 0x6d00 <report_grbl_settings+0x2a4>
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
    6cb8:	68 81       	ld	r22, Y
    6cba:	79 81       	ldd	r23, Y+1	; 0x01
    6cbc:	8a 81       	ldd	r24, Y+2	; 0x02
    6cbe:	9b 81       	ldd	r25, Y+3	; 0x03
    6cc0:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
    6cc4:	1d c0       	rjmp	.+58     	; 0x6d00 <report_grbl_settings+0x2a4>
        case 1: printFloat_SettingValue(settings.max_rate[idx]); break;
    6cc6:	6c 85       	ldd	r22, Y+12	; 0x0c
    6cc8:	7d 85       	ldd	r23, Y+13	; 0x0d
    6cca:	8e 85       	ldd	r24, Y+14	; 0x0e
    6ccc:	9f 85       	ldd	r25, Y+15	; 0x0f
    6cce:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
    6cd2:	16 c0       	rjmp	.+44     	; 0x6d00 <report_grbl_settings+0x2a4>
        case 2: printFloat_SettingValue(settings.acceleration[idx]/(60*60)); break;
    6cd4:	20 e0       	ldi	r18, 0x00	; 0
    6cd6:	30 e0       	ldi	r19, 0x00	; 0
    6cd8:	41 e6       	ldi	r20, 0x61	; 97
    6cda:	55 e4       	ldi	r21, 0x45	; 69
    6cdc:	68 8d       	ldd	r22, Y+24	; 0x18
    6cde:	79 8d       	ldd	r23, Y+25	; 0x19
    6ce0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6ce2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6ce4:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
    6ce8:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
    6cec:	09 c0       	rjmp	.+18     	; 0x6d00 <report_grbl_settings+0x2a4>
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
    6cee:	8c a1       	ldd	r24, Y+36	; 0x24
    6cf0:	9d a1       	ldd	r25, Y+37	; 0x25
    6cf2:	ae a1       	ldd	r26, Y+38	; 0x26
    6cf4:	bf a1       	ldd	r27, Y+39	; 0x27
    6cf6:	bc 01       	movw	r22, r24
    6cf8:	cd 01       	movw	r24, r26
    6cfa:	90 58       	subi	r25, 0x80	; 128
    6cfc:	0e 94 17 34 	call	0x682e	; 0x682e <printFloat_SettingValue>
      }
      printPgmString(PSTR(" ("));
    6d00:	81 e0       	ldi	r24, 0x01	; 1
    6d02:	94 e0       	ldi	r25, 0x04	; 4
    6d04:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
      switch (idx) {
    6d08:	01 30       	cpi	r16, 0x01	; 1
    6d0a:	49 f0       	breq	.+18     	; 0x6d1e <report_grbl_settings+0x2c2>
    6d0c:	18 f0       	brcs	.+6      	; 0x6d14 <report_grbl_settings+0x2b8>
    6d0e:	02 30       	cpi	r16, 0x02	; 2
    6d10:	59 f0       	breq	.+22     	; 0x6d28 <report_grbl_settings+0x2cc>
    6d12:	0e c0       	rjmp	.+28     	; 0x6d30 <report_grbl_settings+0x2d4>
        case X_AXIS: printPgmString(PSTR("x")); break;
    6d14:	8f ef       	ldi	r24, 0xFF	; 255
    6d16:	93 e0       	ldi	r25, 0x03	; 3
    6d18:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6d1c:	09 c0       	rjmp	.+18     	; 0x6d30 <report_grbl_settings+0x2d4>
        case Y_AXIS: printPgmString(PSTR("y")); break;
    6d1e:	8d ef       	ldi	r24, 0xFD	; 253
    6d20:	93 e0       	ldi	r25, 0x03	; 3
    6d22:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6d26:	04 c0       	rjmp	.+8      	; 0x6d30 <report_grbl_settings+0x2d4>
        case Z_AXIS: printPgmString(PSTR("z")); break;
    6d28:	8b ef       	ldi	r24, 0xFB	; 251
    6d2a:	93 e0       	ldi	r25, 0x03	; 3
    6d2c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
      }
      switch (set_idx) {
    6d30:	11 30       	cpi	r17, 0x01	; 1
    6d32:	59 f0       	breq	.+22     	; 0x6d4a <report_grbl_settings+0x2ee>
    6d34:	28 f0       	brcs	.+10     	; 0x6d40 <report_grbl_settings+0x2e4>
    6d36:	12 30       	cpi	r17, 0x02	; 2
    6d38:	69 f0       	breq	.+26     	; 0x6d54 <report_grbl_settings+0x2f8>
    6d3a:	13 30       	cpi	r17, 0x03	; 3
    6d3c:	81 f0       	breq	.+32     	; 0x6d5e <report_grbl_settings+0x302>
    6d3e:	13 c0       	rjmp	.+38     	; 0x6d66 <report_grbl_settings+0x30a>
        case 0: printPgmString(PSTR(", step/mm")); break;
    6d40:	81 ef       	ldi	r24, 0xF1	; 241
    6d42:	93 e0       	ldi	r25, 0x03	; 3
    6d44:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6d48:	0e c0       	rjmp	.+28     	; 0x6d66 <report_grbl_settings+0x30a>
        case 1: printPgmString(PSTR(" max rate, mm/min")); break;
    6d4a:	8f ed       	ldi	r24, 0xDF	; 223
    6d4c:	93 e0       	ldi	r25, 0x03	; 3
    6d4e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6d52:	09 c0       	rjmp	.+18     	; 0x6d66 <report_grbl_settings+0x30a>
        case 2: printPgmString(PSTR(" accel, mm/sec^2")); break;
    6d54:	8e ec       	ldi	r24, 0xCE	; 206
    6d56:	93 e0       	ldi	r25, 0x03	; 3
    6d58:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6d5c:	04 c0       	rjmp	.+8      	; 0x6d66 <report_grbl_settings+0x30a>
        case 3: printPgmString(PSTR(" max travel, mm")); break;
    6d5e:	8e eb       	ldi	r24, 0xBE	; 190
    6d60:	93 e0       	ldi	r25, 0x03	; 3
    6d62:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
      }      
      printPgmString(PSTR(")\r\n"));
    6d66:	8a eb       	ldi	r24, 0xBA	; 186
    6d68:	93 e0       	ldi	r25, 0x03	; 3
    6d6a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
    6d6e:	0f 5f       	subi	r16, 0xFF	; 255
    6d70:	24 96       	adiw	r28, 0x04	; 4
    6d72:	03 30       	cpi	r16, 0x03	; 3
    6d74:	09 f0       	breq	.+2      	; 0x6d78 <report_grbl_settings+0x31c>
    6d76:	8c cf       	rjmp	.-232    	; 0x6c90 <report_grbl_settings+0x234>
        case 2: printPgmString(PSTR(" accel, mm/sec^2")); break;
        case 3: printPgmString(PSTR(" max travel, mm")); break;
      }      
      printPgmString(PSTR(")\r\n"));
    }
    val += AXIS_SETTINGS_INCREMENT;
    6d78:	fa e0       	ldi	r31, 0x0A	; 10
    6d7a:	df 0e       	add	r13, r31
  printPgmString(PSTR(" (Z zero gauge, mm)\r\n"));

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    6d7c:	1f 5f       	subi	r17, 0xFF	; 255
    6d7e:	8c e8       	ldi	r24, 0x8C	; 140
    6d80:	d8 16       	cp	r13, r24
    6d82:	19 f0       	breq	.+6      	; 0x6d8a <report_grbl_settings+0x32e>
    6d84:	e7 01       	movw	r28, r14
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    6d86:	0c 2d       	mov	r16, r12
    6d88:	83 cf       	rjmp	.-250    	; 0x6c90 <report_grbl_settings+0x234>
      }      
      printPgmString(PSTR(")\r\n"));
    }
    val += AXIS_SETTINGS_INCREMENT;
  }  
}
    6d8a:	df 91       	pop	r29
    6d8c:	cf 91       	pop	r28
    6d8e:	1f 91       	pop	r17
    6d90:	0f 91       	pop	r16
    6d92:	ff 90       	pop	r15
    6d94:	ef 90       	pop	r14
    6d96:	df 90       	pop	r13
    6d98:	cf 90       	pop	r12
    6d9a:	08 95       	ret

00006d9c <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported). 
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters()
{
    6d9c:	cf 93       	push	r28
  uint8_t i;
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:"));
    6d9e:	84 eb       	ldi	r24, 0xB4	; 180
    6da0:	93 e0       	ldi	r25, 0x03	; 3
    6da2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  for (i=0; i< N_AXIS; i++) {
    6da6:	c0 e0       	ldi	r28, 0x00	; 0
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
    6da8:	6c 2f       	mov	r22, r28
    6daa:	8a e7       	ldi	r24, 0x7A	; 122
    6dac:	97 e0       	ldi	r25, 0x07	; 7
    6dae:	0e 94 8a 3b 	call	0x7714	; 0x7714 <system_convert_axis_steps_to_mpos>
    printFloat_CoordValue(print_position[i]);
    6db2:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6db6:	c2 30       	cpi	r28, 0x02	; 2
    6db8:	20 f4       	brcc	.+8      	; 0x6dc2 <report_probe_parameters+0x26>
    6dba:	82 eb       	ldi	r24, 0xB2	; 178
    6dbc:	93 e0       	ldi	r25, 0x03	; 3
    6dbe:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  uint8_t i;
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:"));
  for (i=0; i< N_AXIS; i++) {
    6dc2:	cf 5f       	subi	r28, 0xFF	; 255
    6dc4:	c3 30       	cpi	r28, 0x03	; 3
    6dc6:	81 f7       	brne	.-32     	; 0x6da8 <report_probe_parameters+0xc>
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
    printFloat_CoordValue(print_position[i]);
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
  }
  printPgmString(PSTR(":"));
    6dc8:	80 eb       	ldi	r24, 0xB0	; 176
    6dca:	93 e0       	ldi	r25, 0x03	; 3
    6dcc:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  print_uint8_base10(sys.probe_succeeded);
    6dd0:	80 91 86 07 	lds	r24, 0x0786
    6dd4:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR("]\r\n"));
    6dd8:	8c ea       	ldi	r24, 0xAC	; 172
    6dda:	93 e0       	ldi	r25, 0x03	; 3
    6ddc:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
}
    6de0:	cf 91       	pop	r28
    6de2:	08 95       	ret

00006de4 <report_ngc_parameters>:


// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
    6de4:	df 92       	push	r13
    6de6:	ef 92       	push	r14
    6de8:	ff 92       	push	r15
    6dea:	0f 93       	push	r16
    6dec:	1f 93       	push	r17
    6dee:	cf 93       	push	r28
    6df0:	df 93       	push	r29
    6df2:	cd b7       	in	r28, 0x3d	; 61
    6df4:	de b7       	in	r29, 0x3e	; 62
    6df6:	2c 97       	sbiw	r28, 0x0c	; 12
    6df8:	0f b6       	in	r0, 0x3f	; 63
    6dfa:	f8 94       	cli
    6dfc:	de bf       	out	0x3e, r29	; 62
    6dfe:	0f be       	out	0x3f, r0	; 63
    6e00:	cd bf       	out	0x3d, r28	; 61
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    6e02:	e1 2c       	mov	r14, r1
      case 6: printPgmString(PSTR("28")); break;
      case 7: printPgmString(PSTR("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printPgmString(PSTR(":"));         
    for (i=0; i<N_AXIS; i++) {
    6e04:	d1 2c       	mov	r13, r1
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    if (!(settings_read_coord_data(coord_select,coord_data))) { 
    6e06:	be 01       	movw	r22, r28
    6e08:	6f 5f       	subi	r22, 0xFF	; 255
    6e0a:	7f 4f       	sbci	r23, 0xFF	; 255
    6e0c:	8e 2d       	mov	r24, r14
    6e0e:	0e 94 28 27 	call	0x4e50	; 0x4e50 <settings_read_coord_data>
    6e12:	81 11       	cpse	r24, r1
    6e14:	04 c0       	rjmp	.+8      	; 0x6e1e <report_ngc_parameters+0x3a>
      report_status_message(STATUS_SETTING_READ_FAIL); 
    6e16:	87 e0       	ldi	r24, 0x07	; 7
    6e18:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
    6e1c:	70 c0       	rjmp	.+224    	; 0x6efe <report_ngc_parameters+0x11a>
      return;
    } 
    printPgmString(PSTR("[G"));
    6e1e:	89 ea       	ldi	r24, 0xA9	; 169
    6e20:	93 e0       	ldi	r25, 0x03	; 3
    6e22:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    switch (coord_select) {
    6e26:	86 e0       	ldi	r24, 0x06	; 6
    6e28:	e8 16       	cp	r14, r24
    6e2a:	21 f0       	breq	.+8      	; 0x6e34 <report_ngc_parameters+0x50>
    6e2c:	e7 e0       	ldi	r30, 0x07	; 7
    6e2e:	ee 16       	cp	r14, r30
    6e30:	31 f0       	breq	.+12     	; 0x6e3e <report_ngc_parameters+0x5a>
    6e32:	0a c0       	rjmp	.+20     	; 0x6e48 <report_ngc_parameters+0x64>
      case 6: printPgmString(PSTR("28")); break;
    6e34:	86 ea       	ldi	r24, 0xA6	; 166
    6e36:	93 e0       	ldi	r25, 0x03	; 3
    6e38:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6e3c:	09 c0       	rjmp	.+18     	; 0x6e50 <report_ngc_parameters+0x6c>
      case 7: printPgmString(PSTR("30")); break;
    6e3e:	83 ea       	ldi	r24, 0xA3	; 163
    6e40:	93 e0       	ldi	r25, 0x03	; 3
    6e42:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6e46:	04 c0       	rjmp	.+8      	; 0x6e50 <report_ngc_parameters+0x6c>
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    6e48:	86 e3       	ldi	r24, 0x36	; 54
    6e4a:	8e 0d       	add	r24, r14
    6e4c:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
    }  
    printPgmString(PSTR(":"));         
    6e50:	81 ea       	ldi	r24, 0xA1	; 161
    6e52:	93 e0       	ldi	r25, 0x03	; 3
    6e54:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6e58:	8e 01       	movw	r16, r28
    6e5a:	0f 5f       	subi	r16, 0xFF	; 255
    6e5c:	1f 4f       	sbci	r17, 0xFF	; 255
    for (i=0; i<N_AXIS; i++) {
    6e5e:	fd 2c       	mov	r15, r13
      printFloat_CoordValue(coord_data[i]);
    6e60:	f8 01       	movw	r30, r16
    6e62:	61 91       	ld	r22, Z+
    6e64:	71 91       	ld	r23, Z+
    6e66:	81 91       	ld	r24, Z+
    6e68:	91 91       	ld	r25, Z+
    6e6a:	8f 01       	movw	r16, r30
    6e6c:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6e70:	f1 e0       	ldi	r31, 0x01	; 1
    6e72:	ff 15       	cp	r31, r15
    6e74:	28 f0       	brcs	.+10     	; 0x6e80 <report_ngc_parameters+0x9c>
    6e76:	8f e9       	ldi	r24, 0x9F	; 159
    6e78:	93 e0       	ldi	r25, 0x03	; 3
    6e7a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6e7e:	04 c0       	rjmp	.+8      	; 0x6e88 <report_ngc_parameters+0xa4>
      else { printPgmString(PSTR("]\r\n")); }
    6e80:	8b e9       	ldi	r24, 0x9B	; 155
    6e82:	93 e0       	ldi	r25, 0x03	; 3
    6e84:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
      case 6: printPgmString(PSTR("28")); break;
      case 7: printPgmString(PSTR("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printPgmString(PSTR(":"));         
    for (i=0; i<N_AXIS; i++) {
    6e88:	f3 94       	inc	r15
    6e8a:	83 e0       	ldi	r24, 0x03	; 3
    6e8c:	f8 12       	cpse	r15, r24
    6e8e:	e8 cf       	rjmp	.-48     	; 0x6e60 <report_ngc_parameters+0x7c>
// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    6e90:	e3 94       	inc	r14
    6e92:	e8 e0       	ldi	r30, 0x08	; 8
    6e94:	ee 12       	cpse	r14, r30
    6e96:	b7 cf       	rjmp	.-146    	; 0x6e06 <report_ngc_parameters+0x22>
      printFloat_CoordValue(coord_data[i]);
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
      else { printPgmString(PSTR("]\r\n")); }
    } 
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
    6e98:	85 e9       	ldi	r24, 0x95	; 149
    6e9a:	93 e0       	ldi	r25, 0x03	; 3
    6e9c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6ea0:	06 eb       	ldi	r16, 0xB6	; 182
    6ea2:	17 e0       	ldi	r17, 0x07	; 7
  for (i=0; i<N_AXIS; i++) {
    6ea4:	f1 2c       	mov	r15, r1
    printFloat_CoordValue(gc_state.coord_offset[i]);
    6ea6:	f8 01       	movw	r30, r16
    6ea8:	61 91       	ld	r22, Z+
    6eaa:	71 91       	ld	r23, Z+
    6eac:	81 91       	ld	r24, Z+
    6eae:	91 91       	ld	r25, Z+
    6eb0:	8f 01       	movw	r16, r30
    6eb2:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6eb6:	f1 e0       	ldi	r31, 0x01	; 1
    6eb8:	ff 15       	cp	r31, r15
    6eba:	28 f0       	brcs	.+10     	; 0x6ec6 <report_ngc_parameters+0xe2>
    6ebc:	83 e9       	ldi	r24, 0x93	; 147
    6ebe:	93 e0       	ldi	r25, 0x03	; 3
    6ec0:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6ec4:	04 c0       	rjmp	.+8      	; 0x6ece <report_ngc_parameters+0xea>
    else { printPgmString(PSTR("]\r\n")); }
    6ec6:	8f e8       	ldi	r24, 0x8F	; 143
    6ec8:	93 e0       	ldi	r25, 0x03	; 3
    6eca:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
      else { printPgmString(PSTR("]\r\n")); }
    } 
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
  for (i=0; i<N_AXIS; i++) {
    6ece:	f3 94       	inc	r15
    6ed0:	83 e0       	ldi	r24, 0x03	; 3
    6ed2:	f8 12       	cpse	r15, r24
    6ed4:	e8 cf       	rjmp	.-48     	; 0x6ea6 <report_ngc_parameters+0xc2>
    printFloat_CoordValue(gc_state.coord_offset[i]);
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    else { printPgmString(PSTR("]\r\n")); }
  } 
  printPgmString(PSTR("[TLO:")); // Print tool length offset value
    6ed6:	89 e8       	ldi	r24, 0x89	; 137
    6ed8:	93 e0       	ldi	r25, 0x03	; 3
    6eda:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  printFloat_CoordValue(gc_state.tool_length_offset);
    6ede:	60 91 c2 07 	lds	r22, 0x07C2
    6ee2:	70 91 c3 07 	lds	r23, 0x07C3
    6ee6:	80 91 c4 07 	lds	r24, 0x07C4
    6eea:	90 91 c5 07 	lds	r25, 0x07C5
    6eee:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
  printPgmString(PSTR("]\r\n"));
    6ef2:	85 e8       	ldi	r24, 0x85	; 133
    6ef4:	93 e0       	ldi	r25, 0x03	; 3
    6ef6:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  report_probe_parameters(); // Print probe parameters. Not persistent in memory.
    6efa:	0e 94 ce 36 	call	0x6d9c	; 0x6d9c <report_probe_parameters>
}
    6efe:	2c 96       	adiw	r28, 0x0c	; 12
    6f00:	0f b6       	in	r0, 0x3f	; 63
    6f02:	f8 94       	cli
    6f04:	de bf       	out	0x3e, r29	; 62
    6f06:	0f be       	out	0x3f, r0	; 63
    6f08:	cd bf       	out	0x3d, r28	; 61
    6f0a:	df 91       	pop	r29
    6f0c:	cf 91       	pop	r28
    6f0e:	1f 91       	pop	r17
    6f10:	0f 91       	pop	r16
    6f12:	ff 90       	pop	r15
    6f14:	ef 90       	pop	r14
    6f16:	df 90       	pop	r13
    6f18:	08 95       	ret

00006f1a <report_gcode_modes>:


// Print current gcode parser mode state
void report_gcode_modes()
{
  printPgmString(PSTR("["));
    6f1a:	83 e8       	ldi	r24, 0x83	; 131
    6f1c:	93 e0       	ldi	r25, 0x03	; 3
    6f1e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  
  switch (gc_state.modal.motion) {
    6f22:	80 91 87 07 	lds	r24, 0x0787
    6f26:	90 e0       	ldi	r25, 0x00	; 0
    6f28:	89 30       	cpi	r24, 0x09	; 9
    6f2a:	91 05       	cpc	r25, r1
    6f2c:	88 f5       	brcc	.+98     	; 0x6f90 <report_gcode_modes+0x76>
    6f2e:	fc 01       	movw	r30, r24
    6f30:	ef 5e       	subi	r30, 0xEF	; 239
    6f32:	fe 4f       	sbci	r31, 0xFE	; 254
    6f34:	0c 94 e7 3f 	jmp	0x7fce	; 0x7fce <__tablejump2__>
    case MOTION_MODE_SEEK : printPgmString(PSTR("G0")); break;
    6f38:	80 e8       	ldi	r24, 0x80	; 128
    6f3a:	93 e0       	ldi	r25, 0x03	; 3
    6f3c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6f40:	27 c0       	rjmp	.+78     	; 0x6f90 <report_gcode_modes+0x76>
    case MOTION_MODE_LINEAR : printPgmString(PSTR("G1")); break;
    6f42:	8d e7       	ldi	r24, 0x7D	; 125
    6f44:	93 e0       	ldi	r25, 0x03	; 3
    6f46:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6f4a:	22 c0       	rjmp	.+68     	; 0x6f90 <report_gcode_modes+0x76>
    case MOTION_MODE_CW_ARC : printPgmString(PSTR("G2")); break;
    6f4c:	8a e7       	ldi	r24, 0x7A	; 122
    6f4e:	93 e0       	ldi	r25, 0x03	; 3
    6f50:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6f54:	1d c0       	rjmp	.+58     	; 0x6f90 <report_gcode_modes+0x76>
    case MOTION_MODE_CCW_ARC : printPgmString(PSTR("G3")); break;
    6f56:	87 e7       	ldi	r24, 0x77	; 119
    6f58:	93 e0       	ldi	r25, 0x03	; 3
    6f5a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6f5e:	18 c0       	rjmp	.+48     	; 0x6f90 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_TOWARD : printPgmString(PSTR("G38.2")); break;    
    6f60:	81 e7       	ldi	r24, 0x71	; 113
    6f62:	93 e0       	ldi	r25, 0x03	; 3
    6f64:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6f68:	13 c0       	rjmp	.+38     	; 0x6f90 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_TOWARD_NO_ERROR : printPgmString(PSTR("G38.3")); break;    
    6f6a:	8b e6       	ldi	r24, 0x6B	; 107
    6f6c:	93 e0       	ldi	r25, 0x03	; 3
    6f6e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6f72:	0e c0       	rjmp	.+28     	; 0x6f90 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_AWAY : printPgmString(PSTR("G38.4")); break;    
    6f74:	85 e6       	ldi	r24, 0x65	; 101
    6f76:	93 e0       	ldi	r25, 0x03	; 3
    6f78:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6f7c:	09 c0       	rjmp	.+18     	; 0x6f90 <report_gcode_modes+0x76>
    case MOTION_MODE_PROBE_AWAY_NO_ERROR : printPgmString(PSTR("G38.5")); break;    
    6f7e:	8f e5       	ldi	r24, 0x5F	; 95
    6f80:	93 e0       	ldi	r25, 0x03	; 3
    6f82:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6f86:	04 c0       	rjmp	.+8      	; 0x6f90 <report_gcode_modes+0x76>
    case MOTION_MODE_NONE : printPgmString(PSTR("G80")); break;
    6f88:	8b e5       	ldi	r24, 0x5B	; 91
    6f8a:	93 e0       	ldi	r25, 0x03	; 3
    6f8c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }

  printPgmString(PSTR(" G"));
    6f90:	88 e5       	ldi	r24, 0x58	; 88
    6f92:	93 e0       	ldi	r25, 0x03	; 3
    6f94:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  print_uint8_base10(gc_state.modal.coord_select+54);
    6f98:	80 91 8d 07 	lds	r24, 0x078D
    6f9c:	8a 5c       	subi	r24, 0xCA	; 202
    6f9e:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  
  switch (gc_state.modal.plane_select) {
    6fa2:	80 91 8b 07 	lds	r24, 0x078B
    6fa6:	81 30       	cpi	r24, 0x01	; 1
    6fa8:	49 f0       	breq	.+18     	; 0x6fbc <report_gcode_modes+0xa2>
    6faa:	18 f0       	brcs	.+6      	; 0x6fb2 <report_gcode_modes+0x98>
    6fac:	82 30       	cpi	r24, 0x02	; 2
    6fae:	59 f0       	breq	.+22     	; 0x6fc6 <report_gcode_modes+0xac>
    6fb0:	0e c0       	rjmp	.+28     	; 0x6fce <report_gcode_modes+0xb4>
    case PLANE_SELECT_XY : printPgmString(PSTR(" G17")); break;
    6fb2:	83 e5       	ldi	r24, 0x53	; 83
    6fb4:	93 e0       	ldi	r25, 0x03	; 3
    6fb6:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6fba:	09 c0       	rjmp	.+18     	; 0x6fce <report_gcode_modes+0xb4>
    case PLANE_SELECT_ZX : printPgmString(PSTR(" G18")); break;
    6fbc:	8e e4       	ldi	r24, 0x4E	; 78
    6fbe:	93 e0       	ldi	r25, 0x03	; 3
    6fc0:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6fc4:	04 c0       	rjmp	.+8      	; 0x6fce <report_gcode_modes+0xb4>
    case PLANE_SELECT_YZ : printPgmString(PSTR(" G19")); break;
    6fc6:	89 e4       	ldi	r24, 0x49	; 73
    6fc8:	93 e0       	ldi	r25, 0x03	; 3
    6fca:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }
  
  if (gc_state.modal.units == UNITS_MODE_MM) { printPgmString(PSTR(" G21")); }
    6fce:	80 91 89 07 	lds	r24, 0x0789
    6fd2:	81 11       	cpse	r24, r1
    6fd4:	05 c0       	rjmp	.+10     	; 0x6fe0 <report_gcode_modes+0xc6>
    6fd6:	84 e4       	ldi	r24, 0x44	; 68
    6fd8:	93 e0       	ldi	r25, 0x03	; 3
    6fda:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6fde:	04 c0       	rjmp	.+8      	; 0x6fe8 <report_gcode_modes+0xce>
  else { printPgmString(PSTR(" G20")); }
    6fe0:	8f e3       	ldi	r24, 0x3F	; 63
    6fe2:	93 e0       	ldi	r25, 0x03	; 3
    6fe4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  
  if (gc_state.modal.distance == DISTANCE_MODE_ABSOLUTE) { printPgmString(PSTR(" G90")); }
    6fe8:	80 91 8a 07 	lds	r24, 0x078A
    6fec:	81 11       	cpse	r24, r1
    6fee:	05 c0       	rjmp	.+10     	; 0x6ffa <report_gcode_modes+0xe0>
    6ff0:	8a e3       	ldi	r24, 0x3A	; 58
    6ff2:	93 e0       	ldi	r25, 0x03	; 3
    6ff4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    6ff8:	04 c0       	rjmp	.+8      	; 0x7002 <report_gcode_modes+0xe8>
  else { printPgmString(PSTR(" G91")); }
    6ffa:	85 e3       	ldi	r24, 0x35	; 53
    6ffc:	93 e0       	ldi	r25, 0x03	; 3
    6ffe:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  
  if (gc_state.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { printPgmString(PSTR(" G93")); }
    7002:	80 91 88 07 	lds	r24, 0x0788
    7006:	81 30       	cpi	r24, 0x01	; 1
    7008:	29 f4       	brne	.+10     	; 0x7014 <report_gcode_modes+0xfa>
    700a:	80 e3       	ldi	r24, 0x30	; 48
    700c:	93 e0       	ldi	r25, 0x03	; 3
    700e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    7012:	04 c0       	rjmp	.+8      	; 0x701c <report_gcode_modes+0x102>
  else { printPgmString(PSTR(" G94")); }
    7014:	8b e2       	ldi	r24, 0x2B	; 43
    7016:	93 e0       	ldi	r25, 0x03	; 3
    7018:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    
  switch (gc_state.modal.program_flow) {
    701c:	80 91 8e 07 	lds	r24, 0x078E
    7020:	81 30       	cpi	r24, 0x01	; 1
    7022:	49 f0       	breq	.+18     	; 0x7036 <report_gcode_modes+0x11c>
    7024:	18 f0       	brcs	.+6      	; 0x702c <report_gcode_modes+0x112>
    7026:	82 30       	cpi	r24, 0x02	; 2
    7028:	59 f0       	breq	.+22     	; 0x7040 <report_gcode_modes+0x126>
    702a:	0e c0       	rjmp	.+28     	; 0x7048 <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_RUNNING : printPgmString(PSTR(" M0")); break;
    702c:	87 e2       	ldi	r24, 0x27	; 39
    702e:	93 e0       	ldi	r25, 0x03	; 3
    7030:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    7034:	09 c0       	rjmp	.+18     	; 0x7048 <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_PAUSED : printPgmString(PSTR(" M1")); break;
    7036:	83 e2       	ldi	r24, 0x23	; 35
    7038:	93 e0       	ldi	r25, 0x03	; 3
    703a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    703e:	04 c0       	rjmp	.+8      	; 0x7048 <report_gcode_modes+0x12e>
    case PROGRAM_FLOW_COMPLETED : printPgmString(PSTR(" M2")); break;
    7040:	8f e1       	ldi	r24, 0x1F	; 31
    7042:	93 e0       	ldi	r25, 0x03	; 3
    7044:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }

  switch (gc_state.modal.spindle) {
    7048:	80 91 90 07 	lds	r24, 0x0790
    704c:	81 30       	cpi	r24, 0x01	; 1
    704e:	21 f0       	breq	.+8      	; 0x7058 <report_gcode_modes+0x13e>
    7050:	68 f0       	brcs	.+26     	; 0x706c <report_gcode_modes+0x152>
    7052:	82 30       	cpi	r24, 0x02	; 2
    7054:	31 f0       	breq	.+12     	; 0x7062 <report_gcode_modes+0x148>
    7056:	0e c0       	rjmp	.+28     	; 0x7074 <report_gcode_modes+0x15a>
    case SPINDLE_ENABLE_CW : printPgmString(PSTR(" M3")); break;
    7058:	8b e1       	ldi	r24, 0x1B	; 27
    705a:	93 e0       	ldi	r25, 0x03	; 3
    705c:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    7060:	09 c0       	rjmp	.+18     	; 0x7074 <report_gcode_modes+0x15a>
    case SPINDLE_ENABLE_CCW : printPgmString(PSTR(" M4")); break;
    7062:	87 e1       	ldi	r24, 0x17	; 23
    7064:	93 e0       	ldi	r25, 0x03	; 3
    7066:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    706a:	04 c0       	rjmp	.+8      	; 0x7074 <report_gcode_modes+0x15a>
    case SPINDLE_DISABLE : printPgmString(PSTR(" M5")); break;
    706c:	83 e1       	ldi	r24, 0x13	; 19
    706e:	93 e0       	ldi	r25, 0x03	; 3
    7070:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }
  
  switch (gc_state.modal.coolant) {
    7074:	80 91 8f 07 	lds	r24, 0x078F
    7078:	88 23       	and	r24, r24
    707a:	19 f0       	breq	.+6      	; 0x7082 <report_gcode_modes+0x168>
    707c:	82 30       	cpi	r24, 0x02	; 2
    707e:	31 f0       	breq	.+12     	; 0x708c <report_gcode_modes+0x172>
    7080:	09 c0       	rjmp	.+18     	; 0x7094 <report_gcode_modes+0x17a>
    case COOLANT_DISABLE : printPgmString(PSTR(" M9")); break;
    7082:	8f e0       	ldi	r24, 0x0F	; 15
    7084:	93 e0       	ldi	r25, 0x03	; 3
    7086:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    708a:	04 c0       	rjmp	.+8      	; 0x7094 <report_gcode_modes+0x17a>
    case COOLANT_FLOOD_ENABLE : printPgmString(PSTR(" M8")); break;
    708c:	8b e0       	ldi	r24, 0x0B	; 11
    708e:	93 e0       	ldi	r25, 0x03	; 3
    7090:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    #ifdef ENABLE_M7
      case COOLANT_MIST_ENABLE : printPgmString(PSTR(" M7")); break;
    #endif
  }
  
  printPgmString(PSTR(" T"));
    7094:	88 e0       	ldi	r24, 0x08	; 8
    7096:	93 e0       	ldi	r25, 0x03	; 3
    7098:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  print_uint8_base10(gc_state.tool);
    709c:	80 91 99 07 	lds	r24, 0x0799
    70a0:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  
  printPgmString(PSTR(" F"));
    70a4:	85 e0       	ldi	r24, 0x05	; 5
    70a6:	93 e0       	ldi	r25, 0x03	; 3
    70a8:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  printFloat_RateValue(gc_state.feed_rate);
    70ac:	60 91 95 07 	lds	r22, 0x0795
    70b0:	70 91 96 07 	lds	r23, 0x0796
    70b4:	80 91 97 07 	lds	r24, 0x0797
    70b8:	90 91 98 07 	lds	r25, 0x0798
    70bc:	0e 94 05 34 	call	0x680a	; 0x680a <printFloat_RateValue>
  #ifdef VARIABLE_SPINDLE
    printPgmString(PSTR(" S"));
    printFloat_RateValue(gc_state.spindle_speed);
  #endif

  printPgmString(PSTR("]\r\n"));
    70c0:	81 e0       	ldi	r24, 0x01	; 1
    70c2:	93 e0       	ldi	r25, 0x03	; 3
    70c4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    70c8:	08 95       	ret

000070ca <report_startup_line>:
}

// Prints specified startup line
void report_startup_line(uint8_t n, char *line)
{
    70ca:	1f 93       	push	r17
    70cc:	cf 93       	push	r28
    70ce:	df 93       	push	r29
    70d0:	18 2f       	mov	r17, r24
    70d2:	eb 01       	movw	r28, r22
  printPgmString(PSTR("$N")); print_uint8_base10(n);
    70d4:	8e ef       	ldi	r24, 0xFE	; 254
    70d6:	92 e0       	ldi	r25, 0x02	; 2
    70d8:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    70dc:	81 2f       	mov	r24, r17
    70de:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  printPgmString(PSTR("=")); printString(line);
    70e2:	8c ef       	ldi	r24, 0xFC	; 252
    70e4:	92 e0       	ldi	r25, 0x02	; 2
    70e6:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    70ea:	ce 01       	movw	r24, r28
    70ec:	0e 94 a5 32 	call	0x654a	; 0x654a <printString>
  printPgmString(PSTR("\r\n"));
    70f0:	89 ef       	ldi	r24, 0xF9	; 249
    70f2:	92 e0       	ldi	r25, 0x02	; 2
    70f4:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
}
    70f8:	df 91       	pop	r29
    70fa:	cf 91       	pop	r28
    70fc:	1f 91       	pop	r17
    70fe:	08 95       	ret

00007100 <report_build_info>:


// Prints build info line
void report_build_info(char *line)
{
    7100:	cf 93       	push	r28
    7102:	df 93       	push	r29
    7104:	ec 01       	movw	r28, r24
  printPgmString(PSTR("[" GRBL_VERSION "." GRBL_VERSION_BUILD ":"));
    7106:	80 ee       	ldi	r24, 0xE0	; 224
    7108:	92 e0       	ldi	r25, 0x02	; 2
    710a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  printString(line);
    710e:	ce 01       	movw	r24, r28
    7110:	0e 94 a5 32 	call	0x654a	; 0x654a <printString>
  printPgmString(PSTR("]\r\n"));
    7114:	8c ed       	ldi	r24, 0xDC	; 220
    7116:	92 e0       	ldi	r25, 0x02	; 2
    7118:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
}
    711c:	df 91       	pop	r29
    711e:	cf 91       	pop	r28
    7120:	08 95       	ret

00007122 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly, 
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    7122:	bf 92       	push	r11
    7124:	cf 92       	push	r12
    7126:	df 92       	push	r13
    7128:	ef 92       	push	r14
    712a:	ff 92       	push	r15
    712c:	0f 93       	push	r16
    712e:	1f 93       	push	r17
    7130:	cf 93       	push	r28
    7132:	df 93       	push	r29
    7134:	cd b7       	in	r28, 0x3d	; 61
    7136:	de b7       	in	r29, 0x3e	; 62
    7138:	68 97       	sbiw	r28, 0x18	; 24
    713a:	0f b6       	in	r0, 0x3f	; 63
    713c:	f8 94       	cli
    713e:	de bf       	out	0x3e, r29	; 62
    7140:	0f be       	out	0x3f, r0	; 63
    7142:	cd bf       	out	0x3d, r28	; 61
  // the system power on location (0,0,0) and work coordinate position (G54 and G92 applied). Eventually
  // to be added are distance to go on block, processed block id, and feed rate. Also a settings bitmask
  // for a user to select the desired real-time data.
  uint8_t i;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys.position,sizeof(sys.position));
    7144:	8c e0       	ldi	r24, 0x0C	; 12
    7146:	ec e6       	ldi	r30, 0x6C	; 108
    7148:	f7 e0       	ldi	r31, 0x07	; 7
    714a:	de 01       	movw	r26, r28
    714c:	11 96       	adiw	r26, 0x01	; 1
    714e:	01 90       	ld	r0, Z+
    7150:	0d 92       	st	X+, r0
    7152:	8a 95       	dec	r24
    7154:	e1 f7       	brne	.-8      	; 0x714e <report_realtime_status+0x2c>
  float print_position[N_AXIS];
 
  // Report current machine state
  switch (sys.state) {
    7156:	80 91 68 07 	lds	r24, 0x0768
    715a:	88 30       	cpi	r24, 0x08	; 8
    715c:	c9 f0       	breq	.+50     	; 0x7190 <report_realtime_status+0x6e>
    715e:	40 f4       	brcc	.+16     	; 0x7170 <report_realtime_status+0x4e>
    7160:	81 30       	cpi	r24, 0x01	; 1
    7162:	29 f1       	breq	.+74     	; 0x71ae <report_realtime_status+0x8c>
    7164:	80 f0       	brcs	.+32     	; 0x7186 <report_realtime_status+0x64>
    7166:	82 30       	cpi	r24, 0x02	; 2
    7168:	39 f1       	breq	.+78     	; 0x71b8 <report_realtime_status+0x96>
    716a:	84 30       	cpi	r24, 0x04	; 4
    716c:	d9 f0       	breq	.+54     	; 0x71a4 <report_realtime_status+0x82>
    716e:	32 c0       	rjmp	.+100    	; 0x71d4 <report_realtime_status+0xb2>
    7170:	80 32       	cpi	r24, 0x20	; 32
    7172:	39 f1       	breq	.+78     	; 0x71c2 <report_realtime_status+0xa0>
    7174:	18 f4       	brcc	.+6      	; 0x717c <report_realtime_status+0x5a>
    7176:	80 31       	cpi	r24, 0x10	; 16
    7178:	81 f0       	breq	.+32     	; 0x719a <report_realtime_status+0x78>
    717a:	2c c0       	rjmp	.+88     	; 0x71d4 <report_realtime_status+0xb2>
    717c:	80 34       	cpi	r24, 0x40	; 64
    717e:	41 f0       	breq	.+16     	; 0x7190 <report_realtime_status+0x6e>
    7180:	80 38       	cpi	r24, 0x80	; 128
    7182:	21 f1       	breq	.+72     	; 0x71cc <report_realtime_status+0xaa>
    7184:	27 c0       	rjmp	.+78     	; 0x71d4 <report_realtime_status+0xb2>
    case STATE_IDLE: printPgmString(PSTR("<Idle")); break;
    7186:	86 ed       	ldi	r24, 0xD6	; 214
    7188:	92 e0       	ldi	r25, 0x02	; 2
    718a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    718e:	22 c0       	rjmp	.+68     	; 0x71d4 <report_realtime_status+0xb2>
    case STATE_MOTION_CANCEL: // Report run state.
    case STATE_CYCLE: printPgmString(PSTR("<Run")); break;
    7190:	81 ed       	ldi	r24, 0xD1	; 209
    7192:	92 e0       	ldi	r25, 0x02	; 2
    7194:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    7198:	1d c0       	rjmp	.+58     	; 0x71d4 <report_realtime_status+0xb2>
    case STATE_HOLD: printPgmString(PSTR("<Hold")); break;
    719a:	8b ec       	ldi	r24, 0xCB	; 203
    719c:	92 e0       	ldi	r25, 0x02	; 2
    719e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    71a2:	18 c0       	rjmp	.+48     	; 0x71d4 <report_realtime_status+0xb2>
    case STATE_HOMING: printPgmString(PSTR("<Home")); break;
    71a4:	85 ec       	ldi	r24, 0xC5	; 197
    71a6:	92 e0       	ldi	r25, 0x02	; 2
    71a8:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    71ac:	13 c0       	rjmp	.+38     	; 0x71d4 <report_realtime_status+0xb2>
    case STATE_ALARM: printPgmString(PSTR("<Alarm")); break;
    71ae:	8e eb       	ldi	r24, 0xBE	; 190
    71b0:	92 e0       	ldi	r25, 0x02	; 2
    71b2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    71b6:	0e c0       	rjmp	.+28     	; 0x71d4 <report_realtime_status+0xb2>
    case STATE_CHECK_MODE: printPgmString(PSTR("<Check")); break;
    71b8:	87 eb       	ldi	r24, 0xB7	; 183
    71ba:	92 e0       	ldi	r25, 0x02	; 2
    71bc:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    71c0:	09 c0       	rjmp	.+18     	; 0x71d4 <report_realtime_status+0xb2>
    case STATE_SAFETY_DOOR: printPgmString(PSTR("<Door")); break;
    71c2:	81 eb       	ldi	r24, 0xB1	; 177
    71c4:	92 e0       	ldi	r25, 0x02	; 2
    71c6:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    71ca:	04 c0       	rjmp	.+8      	; 0x71d4 <report_realtime_status+0xb2>
	case STATE_JOG: printPgmString(PSTR("<Jog")); break;
    71cc:	8c ea       	ldi	r24, 0xAC	; 172
    71ce:	92 e0       	ldi	r25, 0x02	; 2
    71d0:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }
 
  // If reporting a position, convert the current step count (current_position) to millimeters.
  if (bit_istrue(settings.status_report_mask,(BITFLAG_RT_STATUS_MACHINE_POSITION | BITFLAG_RT_STATUS_WORK_POSITION))) {
    71d4:	80 91 33 09 	lds	r24, 0x0933
    71d8:	83 70       	andi	r24, 0x03	; 3
    71da:	39 f0       	breq	.+14     	; 0x71ea <report_realtime_status+0xc8>
    system_convert_array_steps_to_mpos(print_position,current_position);
    71dc:	be 01       	movw	r22, r28
    71de:	6f 5f       	subi	r22, 0xFF	; 255
    71e0:	7f 4f       	sbci	r23, 0xFF	; 255
    71e2:	ce 01       	movw	r24, r28
    71e4:	0d 96       	adiw	r24, 0x0d	; 13
    71e6:	0e 94 a6 3b 	call	0x774c	; 0x774c <system_convert_array_steps_to_mpos>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    71ea:	80 91 33 09 	lds	r24, 0x0933
    71ee:	80 ff       	sbrs	r24, 0
    71f0:	1e c0       	rjmp	.+60     	; 0x722e <report_realtime_status+0x10c>
    printPgmString(PSTR(",MPos:")); 
    71f2:	85 ea       	ldi	r24, 0xA5	; 165
    71f4:	92 e0       	ldi	r25, 0x02	; 2
    71f6:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    71fa:	6d 85       	ldd	r22, Y+13	; 0x0d
    71fc:	7e 85       	ldd	r23, Y+14	; 0x0e
    71fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    7200:	98 89       	ldd	r25, Y+16	; 0x10
    7202:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    7206:	83 ea       	ldi	r24, 0xA3	; 163
    7208:	92 e0       	ldi	r25, 0x02	; 2
    720a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    720e:	69 89       	ldd	r22, Y+17	; 0x11
    7210:	7a 89       	ldd	r23, Y+18	; 0x12
    7212:	8b 89       	ldd	r24, Y+19	; 0x13
    7214:	9c 89       	ldd	r25, Y+20	; 0x14
    7216:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    721a:	83 ea       	ldi	r24, 0xA3	; 163
    721c:	92 e0       	ldi	r25, 0x02	; 2
    721e:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (i=0; i< N_AXIS; i++) {
      printFloat_CoordValue(print_position[i]);
    7222:	6d 89       	ldd	r22, Y+21	; 0x15
    7224:	7e 89       	ldd	r23, Y+22	; 0x16
    7226:	8f 89       	ldd	r24, Y+23	; 0x17
    7228:	98 8d       	ldd	r25, Y+24	; 0x18
    722a:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    722e:	80 91 33 09 	lds	r24, 0x0933
    7232:	81 ff       	sbrs	r24, 1
    7234:	4c c0       	rjmp	.+152    	; 0x72ce <report_realtime_status+0x1ac>
    printPgmString(PSTR(",WPos:")); 
    7236:	8c e9       	ldi	r24, 0x9C	; 156
    7238:	92 e0       	ldi	r25, 0x02	; 2
    723a:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    723e:	8e 01       	movw	r16, r28
    7240:	03 5f       	subi	r16, 0xF3	; 243
    7242:	1f 4f       	sbci	r17, 0xFF	; 255
    7244:	0f 2e       	mov	r0, r31
    7246:	fa ea       	ldi	r31, 0xAA	; 170
    7248:	ef 2e       	mov	r14, r31
    724a:	f7 e0       	ldi	r31, 0x07	; 7
    724c:	ff 2e       	mov	r15, r31
    724e:	f0 2d       	mov	r31, r0
    for (i=0; i< N_AXIS; i++) {
    7250:	b1 2c       	mov	r11, r1
      // Apply work coordinate offsets and tool length offset to current position.
      print_position[i] -= gc_state.coord_system[i]+gc_state.coord_offset[i];
    7252:	f7 01       	movw	r30, r14
    7254:	61 91       	ld	r22, Z+
    7256:	71 91       	ld	r23, Z+
    7258:	81 91       	ld	r24, Z+
    725a:	91 91       	ld	r25, Z+
    725c:	7f 01       	movw	r14, r30
    725e:	20 85       	ldd	r18, Z+8	; 0x08
    7260:	31 85       	ldd	r19, Z+9	; 0x09
    7262:	42 85       	ldd	r20, Z+10	; 0x0a
    7264:	53 85       	ldd	r21, Z+11	; 0x0b
    7266:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__addsf3>
    726a:	9b 01       	movw	r18, r22
    726c:	ac 01       	movw	r20, r24
    726e:	f8 01       	movw	r30, r16
    7270:	60 81       	ld	r22, Z
    7272:	71 81       	ldd	r23, Z+1	; 0x01
    7274:	82 81       	ldd	r24, Z+2	; 0x02
    7276:	93 81       	ldd	r25, Z+3	; 0x03
    7278:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    727c:	f8 01       	movw	r30, r16
    727e:	60 83       	st	Z, r22
    7280:	71 83       	std	Z+1, r23	; 0x01
    7282:	82 83       	std	Z+2, r24	; 0x02
    7284:	93 83       	std	Z+3, r25	; 0x03
      if (i == TOOL_LENGTH_OFFSET_AXIS) { print_position[i] -= gc_state.tool_length_offset; }    
    7286:	f2 e0       	ldi	r31, 0x02	; 2
    7288:	bf 12       	cpse	r11, r31
    728a:	12 c0       	rjmp	.+36     	; 0x72b0 <report_realtime_status+0x18e>
    728c:	20 91 c2 07 	lds	r18, 0x07C2
    7290:	30 91 c3 07 	lds	r19, 0x07C3
    7294:	40 91 c4 07 	lds	r20, 0x07C4
    7298:	50 91 c5 07 	lds	r21, 0x07C5
    729c:	0e 94 c0 3b 	call	0x7780	; 0x7780 <__subsf3>
    72a0:	f8 01       	movw	r30, r16
    72a2:	60 83       	st	Z, r22
    72a4:	71 83       	std	Z+1, r23	; 0x01
    72a6:	82 83       	std	Z+2, r24	; 0x02
    72a8:	93 83       	std	Z+3, r25	; 0x03
      printFloat_CoordValue(print_position[i]);
    72aa:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
    72ae:	0f c0       	rjmp	.+30     	; 0x72ce <report_realtime_status+0x1ac>
    72b0:	0e 94 f3 33 	call	0x67e6	; 0x67e6 <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    72b4:	f1 e0       	ldi	r31, 0x01	; 1
    72b6:	fb 15       	cp	r31, r11
    72b8:	20 f0       	brcs	.+8      	; 0x72c2 <report_realtime_status+0x1a0>
    72ba:	8a e9       	ldi	r24, 0x9A	; 154
    72bc:	92 e0       	ldi	r25, 0x02	; 2
    72be:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printPgmString(PSTR(",WPos:")); 
    for (i=0; i< N_AXIS; i++) {
    72c2:	b3 94       	inc	r11
    72c4:	0c 5f       	subi	r16, 0xFC	; 252
    72c6:	1f 4f       	sbci	r17, 0xFF	; 255
    72c8:	23 e0       	ldi	r18, 0x03	; 3
    72ca:	b2 12       	cpse	r11, r18
    72cc:	c2 cf       	rjmp	.-124    	; 0x7252 <report_realtime_status+0x130>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
        
  // Returns the number of active blocks are in the planner buffer.
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_PLANNER_BUFFER)) {
    72ce:	80 91 33 09 	lds	r24, 0x0933
    72d2:	82 ff       	sbrs	r24, 2
    72d4:	08 c0       	rjmp	.+16     	; 0x72e6 <report_realtime_status+0x1c4>
    printPgmString(PSTR(",Buf:"));
    72d6:	84 e9       	ldi	r24, 0x94	; 148
    72d8:	92 e0       	ldi	r25, 0x02	; 2
    72da:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    print_uint8_base10(plan_get_block_buffer_count());
    72de:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <plan_get_block_buffer_count>
    72e2:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
  }

  // Report serial read buffer status
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_SERIAL_RX)) {
    72e6:	80 91 33 09 	lds	r24, 0x0933
    72ea:	83 ff       	sbrs	r24, 3
    72ec:	08 c0       	rjmp	.+16     	; 0x72fe <report_realtime_status+0x1dc>
    printPgmString(PSTR(",RX:"));
    72ee:	8f e8       	ldi	r24, 0x8F	; 143
    72f0:	92 e0       	ldi	r25, 0x02	; 2
    72f2:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
    print_uint8_base10(serial_get_rx_buffer_count());
    72f6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <serial_get_rx_buffer_count>
    72fa:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <print_uint8_base10>
    print_uint8_base2(LIMIT_PIN & LIMIT_MASK);  
    printPgmString(PSTR(",Ctl:"));
    print_uint8_base2(CONTROL_PIN & CONTROL_MASK);
  #endif
  
  printPgmString(PSTR(">\r\n"));
    72fe:	8b e8       	ldi	r24, 0x8B	; 139
    7300:	92 e0       	ldi	r25, 0x02	; 2
    7302:	0e 94 b4 32 	call	0x6568	; 0x6568 <printPgmString>
}
    7306:	68 96       	adiw	r28, 0x18	; 24
    7308:	0f b6       	in	r0, 0x3f	; 63
    730a:	f8 94       	cli
    730c:	de bf       	out	0x3e, r29	; 62
    730e:	0f be       	out	0x3f, r0	; 63
    7310:	cd bf       	out	0x3d, r28	; 61
    7312:	df 91       	pop	r29
    7314:	cf 91       	pop	r28
    7316:	1f 91       	pop	r17
    7318:	0f 91       	pop	r16
    731a:	ff 90       	pop	r15
    731c:	ef 90       	pop	r14
    731e:	df 90       	pop	r13
    7320:	cf 90       	pop	r12
    7322:	bf 90       	pop	r11
    7324:	08 95       	ret

00007326 <system_init>:
#include "grbl.h"


void system_init() 
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    7326:	87 b1       	in	r24, 0x07	; 7
    7328:	88 7f       	andi	r24, 0xF8	; 248
    732a:	87 b9       	out	0x07, r24	; 7
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    732c:	88 b1       	in	r24, 0x08	; 8
    732e:	87 60       	ori	r24, 0x07	; 7
    7330:	88 b9       	out	0x08, r24	; 8
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    7332:	ed e6       	ldi	r30, 0x6D	; 109
    7334:	f0 e0       	ldi	r31, 0x00	; 0
    7336:	80 81       	ld	r24, Z
    7338:	87 60       	ori	r24, 0x07	; 7
    733a:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    733c:	e8 e6       	ldi	r30, 0x68	; 104
    733e:	f0 e0       	ldi	r31, 0x00	; 0
    7340:	80 81       	ld	r24, Z
    7342:	84 60       	ori	r24, 0x04	; 4
    7344:	80 83       	st	Z, r24
    7346:	08 95       	ret

00007348 <__vector_6>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when 
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect) 
{
    7348:	1f 92       	push	r1
    734a:	0f 92       	push	r0
    734c:	0f b6       	in	r0, 0x3f	; 63
    734e:	0f 92       	push	r0
    7350:	11 24       	eor	r1, r1
    7352:	2f 93       	push	r18
    7354:	3f 93       	push	r19
    7356:	4f 93       	push	r20
    7358:	5f 93       	push	r21
    735a:	6f 93       	push	r22
    735c:	7f 93       	push	r23
    735e:	8f 93       	push	r24
    7360:	9f 93       	push	r25
    7362:	af 93       	push	r26
    7364:	bf 93       	push	r27
    7366:	ef 93       	push	r30
    7368:	ff 93       	push	r31
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    736a:	86 b1       	in	r24, 0x06	; 6
  #ifndef INVERT_CONTROL_PIN
    pin ^= CONTROL_MASK;
    736c:	80 95       	com	r24
    736e:	87 70       	andi	r24, 0x07	; 7
  #endif
  // Enter only if any CONTROL pin is detected as active.
  if (pin) { 
    7370:	a9 f0       	breq	.+42     	; 0x739c <__vector_6+0x54>
    if (bit_istrue(pin,bit(RESET_BIT))) {
    7372:	80 ff       	sbrs	r24, 0
    7374:	03 c0       	rjmp	.+6      	; 0x737c <__vector_6+0x34>
      mc_reset();
    7376:	0e 94 ad 0c 	call	0x195a	; 0x195a <mc_reset>
    737a:	10 c0       	rjmp	.+32     	; 0x739c <__vector_6+0x54>
    } else if (bit_istrue(pin,bit(CYCLE_START_BIT))) {
    737c:	98 2f       	mov	r25, r24
    737e:	94 70       	andi	r25, 0x04	; 4
    7380:	31 f0       	breq	.+12     	; 0x738e <__vector_6+0x46>
      bit_true(sys.rt_exec_state, EXEC_CYCLE_START);
    7382:	ea e6       	ldi	r30, 0x6A	; 106
    7384:	f7 e0       	ldi	r31, 0x07	; 7
    7386:	80 81       	ld	r24, Z
    7388:	82 60       	ori	r24, 0x02	; 2
    738a:	80 83       	st	Z, r24
    738c:	07 c0       	rjmp	.+14     	; 0x739c <__vector_6+0x54>
    #ifndef ENABLE_SAFETY_DOOR_INPUT_PIN
      } else if (bit_istrue(pin,bit(FEED_HOLD_BIT))) {
    738e:	81 ff       	sbrs	r24, 1
    7390:	05 c0       	rjmp	.+10     	; 0x739c <__vector_6+0x54>
        bit_true(sys.rt_exec_state, EXEC_FEED_HOLD); 
    7392:	ea e6       	ldi	r30, 0x6A	; 106
    7394:	f7 e0       	ldi	r31, 0x07	; 7
    7396:	80 81       	ld	r24, Z
    7398:	88 60       	ori	r24, 0x08	; 8
    739a:	80 83       	st	Z, r24
      } else if (bit_istrue(pin,bit(SAFETY_DOOR_BIT))) {
        bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
    #endif
    } 
  }
}
    739c:	ff 91       	pop	r31
    739e:	ef 91       	pop	r30
    73a0:	bf 91       	pop	r27
    73a2:	af 91       	pop	r26
    73a4:	9f 91       	pop	r25
    73a6:	8f 91       	pop	r24
    73a8:	7f 91       	pop	r23
    73aa:	6f 91       	pop	r22
    73ac:	5f 91       	pop	r21
    73ae:	4f 91       	pop	r20
    73b0:	3f 91       	pop	r19
    73b2:	2f 91       	pop	r18
    73b4:	0f 90       	pop	r0
    73b6:	0f be       	out	0x3f, r0	; 63
    73b8:	0f 90       	pop	r0
    73ba:	1f 90       	pop	r1
    73bc:	18 95       	reti

000073be <system_check_safety_door_ajar>:
      return(bit_isfalse(CONTROL_PIN,bit(SAFETY_DOOR_BIT)));
    #endif
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
  #endif
}
    73be:	80 e0       	ldi	r24, 0x00	; 0
    73c0:	08 95       	ret

000073c2 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
    73c2:	1f 93       	push	r17
    73c4:	cf 93       	push	r28
    73c6:	df 93       	push	r29
    73c8:	ec 01       	movw	r28, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    73ca:	10 e0       	ldi	r17, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    73cc:	be 01       	movw	r22, r28
    73ce:	81 2f       	mov	r24, r17
    73d0:	0e 94 f6 26 	call	0x4dec	; 0x4dec <settings_read_startup_line>
    73d4:	81 11       	cpse	r24, r1
    73d6:	04 c0       	rjmp	.+8      	; 0x73e0 <system_execute_startup+0x1e>
      report_status_message(STATUS_SETTING_READ_FAIL);
    73d8:	87 e0       	ldi	r24, 0x07	; 7
    73da:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
    73de:	0b c0       	rjmp	.+22     	; 0x73f6 <system_execute_startup+0x34>
    } else {
      if (line[0] != 0) {
    73e0:	88 81       	ld	r24, Y
    73e2:	88 23       	and	r24, r24
    73e4:	41 f0       	breq	.+16     	; 0x73f6 <system_execute_startup+0x34>
        printString(line); // Echo startup line to indicate execution.
    73e6:	ce 01       	movw	r24, r28
    73e8:	0e 94 a5 32 	call	0x654a	; 0x654a <printString>
        report_status_message(gc_execute_line(line));
    73ec:	ce 01       	movw	r24, r28
    73ee:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <gc_execute_line>
    73f2:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    73f6:	1f 5f       	subi	r17, 0xFF	; 255
    73f8:	12 30       	cpi	r17, 0x02	; 2
    73fa:	41 f7       	brne	.-48     	; 0x73cc <system_execute_startup+0xa>
        printString(line); // Echo startup line to indicate execution.
        report_status_message(gc_execute_line(line));
      }
    } 
  }  
}
    73fc:	df 91       	pop	r29
    73fe:	cf 91       	pop	r28
    7400:	1f 91       	pop	r17
    7402:	08 95       	ret

00007404 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle, 
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
    7404:	8f 92       	push	r8
    7406:	9f 92       	push	r9
    7408:	af 92       	push	r10
    740a:	bf 92       	push	r11
    740c:	cf 92       	push	r12
    740e:	df 92       	push	r13
    7410:	ef 92       	push	r14
    7412:	ff 92       	push	r15
    7414:	1f 93       	push	r17
    7416:	cf 93       	push	r28
    7418:	df 93       	push	r29
    741a:	cd b7       	in	r28, 0x3d	; 61
    741c:	de b7       	in	r29, 0x3e	; 62
    741e:	29 97       	sbiw	r28, 0x09	; 9
    7420:	0f b6       	in	r0, 0x3f	; 63
    7422:	f8 94       	cli
    7424:	de bf       	out	0x3e, r29	; 62
    7426:	0f be       	out	0x3f, r0	; 63
    7428:	cd bf       	out	0x3d, r28	; 61
    742a:	7c 01       	movw	r14, r24
  uint8_t char_counter = 1; 
    742c:	81 e0       	ldi	r24, 0x01	; 1
    742e:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    7430:	f7 01       	movw	r30, r14
    7432:	81 81       	ldd	r24, Z+1	; 0x01
    7434:	83 34       	cpi	r24, 0x43	; 67
    7436:	41 f1       	breq	.+80     	; 0x7488 <system_execute_line+0x84>
    7438:	28 f4       	brcc	.+10     	; 0x7444 <system_execute_line+0x40>
    743a:	88 23       	and	r24, r24
    743c:	41 f0       	breq	.+16     	; 0x744e <system_execute_line+0x4a>
    743e:	84 32       	cpi	r24, 0x24	; 36
    7440:	51 f0       	breq	.+20     	; 0x7456 <system_execute_line+0x52>
    7442:	4f c0       	rjmp	.+158    	; 0x74e2 <system_execute_line+0xde>
    7444:	87 34       	cpi	r24, 0x47	; 71
    7446:	b1 f0       	breq	.+44     	; 0x7474 <system_execute_line+0x70>
    7448:	88 35       	cpi	r24, 0x58	; 88
    744a:	c9 f1       	breq	.+114    	; 0x74be <system_execute_line+0xba>
    744c:	4a c0       	rjmp	.+148    	; 0x74e2 <system_execute_line+0xde>
    case 0 : report_grbl_help(); break;
    744e:	0e 94 29 35 	call	0x6a52	; 0x6a52 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7452:	80 e0       	ldi	r24, 0x00	; 0
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    7454:	4d c1       	rjmp	.+666    	; 0x76f0 <system_execute_line+0x2ec>
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7456:	82 e0       	ldi	r24, 0x02	; 2
    7458:	89 83       	std	Y+1, r24	; 0x01
    745a:	f7 01       	movw	r30, r14
    745c:	82 81       	ldd	r24, Z+2	; 0x02
    745e:	81 11       	cpse	r24, r1
    7460:	21 c1       	rjmp	.+578    	; 0x76a4 <system_execute_line+0x2a0>
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7462:	80 91 68 07 	lds	r24, 0x0768
    7466:	88 71       	andi	r24, 0x18	; 24
    7468:	09 f0       	breq	.+2      	; 0x746c <system_execute_line+0x68>
    746a:	1e c1       	rjmp	.+572    	; 0x76a8 <system_execute_line+0x2a4>
      else { report_grbl_settings(); }
    746c:	0e 94 2e 35 	call	0x6a5c	; 0x6a5c <report_grbl_settings>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7470:	80 e0       	ldi	r24, 0x00	; 0
    case 0 : report_grbl_help(); break;
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
      else { report_grbl_settings(); }
      break;
    7472:	3e c1       	rjmp	.+636    	; 0x76f0 <system_execute_line+0x2ec>
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7474:	82 e0       	ldi	r24, 0x02	; 2
    7476:	89 83       	std	Y+1, r24	; 0x01
    7478:	f7 01       	movw	r30, r14
    747a:	82 81       	ldd	r24, Z+2	; 0x02
    747c:	81 11       	cpse	r24, r1
    747e:	16 c1       	rjmp	.+556    	; 0x76ac <system_execute_line+0x2a8>
      else { report_gcode_modes(); }
    7480:	0e 94 8d 37 	call	0x6f1a	; 0x6f1a <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7484:	80 e0       	ldi	r24, 0x00	; 0
      break;
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      else { report_gcode_modes(); }
      break;   
    7486:	34 c1       	rjmp	.+616    	; 0x76f0 <system_execute_line+0x2ec>
    case 'C' : // Set check g-code mode [IDLE/CHECK]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7488:	82 e0       	ldi	r24, 0x02	; 2
    748a:	89 83       	std	Y+1, r24	; 0x01
    748c:	f7 01       	movw	r30, r14
    748e:	82 81       	ldd	r24, Z+2	; 0x02
    7490:	81 11       	cpse	r24, r1
    7492:	0e c1       	rjmp	.+540    	; 0x76b0 <system_execute_line+0x2ac>
      // Perform reset when toggling off. Check g-code mode should only work if Grbl
      // is idle and ready, regardless of alarm locks. This is mainly to keep things
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
    7494:	80 91 68 07 	lds	r24, 0x0768
    7498:	82 30       	cpi	r24, 0x02	; 2
    749a:	39 f4       	brne	.+14     	; 0x74aa <system_execute_line+0xa6>
        mc_reset(); 
    749c:	0e 94 ad 0c 	call	0x195a	; 0x195a <mc_reset>
        report_feedback_message(MESSAGE_DISABLED);
    74a0:	85 e0       	ldi	r24, 0x05	; 5
    74a2:	0e 94 ed 34 	call	0x69da	; 0x69da <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74a6:	80 e0       	ldi	r24, 0x00	; 0
    74a8:	23 c1       	rjmp	.+582    	; 0x76f0 <system_execute_line+0x2ec>
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
        mc_reset(); 
        report_feedback_message(MESSAGE_DISABLED);
      } else {
        if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    74aa:	81 11       	cpse	r24, r1
    74ac:	03 c1       	rjmp	.+518    	; 0x76b4 <system_execute_line+0x2b0>
        sys.state = STATE_CHECK_MODE;
    74ae:	82 e0       	ldi	r24, 0x02	; 2
    74b0:	80 93 68 07 	sts	0x0768, r24
        report_feedback_message(MESSAGE_ENABLED);
    74b4:	84 e0       	ldi	r24, 0x04	; 4
    74b6:	0e 94 ed 34 	call	0x69da	; 0x69da <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74ba:	80 e0       	ldi	r24, 0x00	; 0
    74bc:	19 c1       	rjmp	.+562    	; 0x76f0 <system_execute_line+0x2ec>
        sys.state = STATE_CHECK_MODE;
        report_feedback_message(MESSAGE_ENABLED);
      }
      break; 
    case 'X' : // Disable alarm lock [ALARM]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    74be:	82 e0       	ldi	r24, 0x02	; 2
    74c0:	89 83       	std	Y+1, r24	; 0x01
    74c2:	f7 01       	movw	r30, r14
    74c4:	82 81       	ldd	r24, Z+2	; 0x02
    74c6:	81 11       	cpse	r24, r1
    74c8:	f7 c0       	rjmp	.+494    	; 0x76b8 <system_execute_line+0x2b4>
      if (sys.state == STATE_ALARM) { 
    74ca:	80 91 68 07 	lds	r24, 0x0768
    74ce:	81 30       	cpi	r24, 0x01	; 1
    74d0:	09 f0       	breq	.+2      	; 0x74d4 <system_execute_line+0xd0>
    74d2:	f4 c0       	rjmp	.+488    	; 0x76bc <system_execute_line+0x2b8>
        report_feedback_message(MESSAGE_ALARM_UNLOCK);
    74d4:	83 e0       	ldi	r24, 0x03	; 3
    74d6:	0e 94 ed 34 	call	0x69da	; 0x69da <report_feedback_message>
        sys.state = STATE_IDLE;
    74da:	10 92 68 07 	sts	0x0768, r1
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    74de:	80 e0       	ldi	r24, 0x00	; 0
    74e0:	07 c1       	rjmp	.+526    	; 0x76f0 <system_execute_line+0x2ec>
      // handled by the planner. It would be possible for the jog subprogram to insert blocks into the
      // block buffer without having the planner plan them. It would need to manage de/ac-celerations 
      // on its own carefully. This approach could be effective and possibly size/memory efficient.        
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    74e2:	90 91 68 07 	lds	r25, 0x0768
    74e6:	92 30       	cpi	r25, 0x02	; 2
    74e8:	08 f0       	brcs	.+2      	; 0x74ec <system_execute_line+0xe8>
    74ea:	ea c0       	rjmp	.+468    	; 0x76c0 <system_execute_line+0x2bc>
      switch( line[char_counter] ) {
    74ec:	88 34       	cpi	r24, 0x48	; 72
    74ee:	a1 f0       	breq	.+40     	; 0x7518 <system_execute_line+0x114>
    74f0:	18 f4       	brcc	.+6      	; 0x74f8 <system_execute_line+0xf4>
    74f2:	83 32       	cpi	r24, 0x23	; 35
    74f4:	39 f0       	breq	.+14     	; 0x7504 <system_execute_line+0x100>
    74f6:	66 c0       	rjmp	.+204    	; 0x75c4 <system_execute_line+0x1c0>
    74f8:	89 34       	cpi	r24, 0x49	; 73
    74fa:	21 f1       	breq	.+72     	; 0x7544 <system_execute_line+0x140>
    74fc:	8e 34       	cpi	r24, 0x4E	; 78
    74fe:	09 f4       	brne	.+2      	; 0x7502 <system_execute_line+0xfe>
    7500:	44 c0       	rjmp	.+136    	; 0x758a <system_execute_line+0x186>
    7502:	60 c0       	rjmp	.+192    	; 0x75c4 <system_execute_line+0x1c0>
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7504:	82 e0       	ldi	r24, 0x02	; 2
    7506:	89 83       	std	Y+1, r24	; 0x01
    7508:	f7 01       	movw	r30, r14
    750a:	82 81       	ldd	r24, Z+2	; 0x02
    750c:	81 11       	cpse	r24, r1
    750e:	da c0       	rjmp	.+436    	; 0x76c4 <system_execute_line+0x2c0>
          else { report_ngc_parameters(); }
    7510:	0e 94 f2 36 	call	0x6de4	; 0x6de4 <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7514:	80 e0       	ldi	r24, 0x00	; 0
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;          
    7516:	ec c0       	rjmp	.+472    	; 0x76f0 <system_execute_line+0x2ec>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
    7518:	80 91 3c 09 	lds	r24, 0x093C
    751c:	84 ff       	sbrs	r24, 4
    751e:	d4 c0       	rjmp	.+424    	; 0x76c8 <system_execute_line+0x2c4>
            sys.state = STATE_HOMING; // Set system state variable
    7520:	84 e0       	ldi	r24, 0x04	; 4
    7522:	80 93 68 07 	sts	0x0768, r24
              bit_true(sys.rt_exec_state, EXEC_SAFETY_DOOR);
              protocol_execute_realtime(); // Enter safety door mode.
            }
            
            
            mc_homing_cycle(); 
    7526:	0e 94 12 0c 	call	0x1824	; 0x1824 <mc_homing_cycle>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
    752a:	80 91 67 07 	lds	r24, 0x0767
    752e:	81 11       	cpse	r24, r1
    7530:	cd c0       	rjmp	.+410    	; 0x76cc <system_execute_line+0x2c8>
              sys.state = STATE_IDLE; // Set to IDLE when complete.
    7532:	10 92 68 07 	sts	0x0768, r1
              st_go_idle(); // Set steppers to the settings idle state before returning.
    7536:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <st_go_idle>
              system_execute_startup(line); 
    753a:	c7 01       	movw	r24, r14
    753c:	0e 94 e1 39 	call	0x73c2	; 0x73c2 <system_execute_startup>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7540:	80 e0       	ldi	r24, 0x00	; 0
    7542:	d6 c0       	rjmp	.+428    	; 0x76f0 <system_execute_line+0x2ec>
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
    7544:	82 e0       	ldi	r24, 0x02	; 2
    7546:	89 83       	std	Y+1, r24	; 0x01
    7548:	f7 01       	movw	r30, r14
    754a:	82 81       	ldd	r24, Z+2	; 0x02
    754c:	81 11       	cpse	r24, r1
    754e:	08 c0       	rjmp	.+16     	; 0x7560 <system_execute_line+0x15c>
            settings_read_build_info(line);
    7550:	c7 01       	movw	r24, r14
    7552:	0e 94 13 27 	call	0x4e26	; 0x4e26 <settings_read_build_info>
            report_build_info(line);
    7556:	c7 01       	movw	r24, r14
    7558:	0e 94 80 38 	call	0x7100	; 0x7100 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    755c:	80 e0       	ldi	r24, 0x00	; 0
    755e:	c8 c0       	rjmp	.+400    	; 0x76f0 <system_execute_line+0x2ec>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7560:	8d 33       	cpi	r24, 0x3D	; 61
    7562:	09 f0       	breq	.+2      	; 0x7566 <system_execute_line+0x162>
    7564:	b5 c0       	rjmp	.+362    	; 0x76d0 <system_execute_line+0x2cc>
    7566:	83 e0       	ldi	r24, 0x03	; 3
            helper_var = char_counter; // Set helper variable as counter to start of user info line.
            do {
              line[char_counter-helper_var] = line[char_counter];
    7568:	f7 01       	movw	r30, r14
    756a:	e8 0f       	add	r30, r24
    756c:	f1 1d       	adc	r31, r1
    756e:	90 81       	ld	r25, Z
    7570:	df 01       	movw	r26, r30
    7572:	13 97       	sbiw	r26, 0x03	; 3
    7574:	9c 93       	st	X, r25
            } while (line[char_counter++] != 0);
    7576:	8f 5f       	subi	r24, 0xFF	; 255
    7578:	90 81       	ld	r25, Z
    757a:	91 11       	cpse	r25, r1
    757c:	f5 cf       	rjmp	.-22     	; 0x7568 <system_execute_line+0x164>
    757e:	89 83       	std	Y+1, r24	; 0x01
            settings_store_build_info(line);
    7580:	c7 01       	movw	r24, r14
    7582:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7586:	80 e0       	ldi	r24, 0x00	; 0
    7588:	b3 c0       	rjmp	.+358    	; 0x76f0 <system_execute_line+0x2ec>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break;                 
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    758a:	82 e0       	ldi	r24, 0x02	; 2
    758c:	89 83       	std	Y+1, r24	; 0x01
    758e:	f7 01       	movw	r30, r14
    7590:	82 81       	ldd	r24, Z+2	; 0x02
    7592:	81 11       	cpse	r24, r1
    7594:	13 c0       	rjmp	.+38     	; 0x75bc <system_execute_line+0x1b8>
    7596:	10 e0       	ldi	r17, 0x00	; 0
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    7598:	b7 01       	movw	r22, r14
    759a:	81 2f       	mov	r24, r17
    759c:	0e 94 f6 26 	call	0x4dec	; 0x4dec <settings_read_startup_line>
    75a0:	81 11       	cpse	r24, r1
    75a2:	04 c0       	rjmp	.+8      	; 0x75ac <system_execute_line+0x1a8>
                report_status_message(STATUS_SETTING_READ_FAIL);
    75a4:	87 e0       	ldi	r24, 0x07	; 7
    75a6:	0e 94 4f 34 	call	0x689e	; 0x689e <report_status_message>
    75aa:	04 c0       	rjmp	.+8      	; 0x75b4 <system_execute_line+0x1b0>
              } else {
                report_startup_line(helper_var,line);
    75ac:	b7 01       	movw	r22, r14
    75ae:	81 2f       	mov	r24, r17
    75b0:	0e 94 65 38 	call	0x70ca	; 0x70ca <report_startup_line>
            settings_store_build_info(line);
          }
          break;                 
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    75b4:	1f 5f       	subi	r17, 0xFF	; 255
    75b6:	12 30       	cpi	r17, 0x02	; 2
    75b8:	79 f7       	brne	.-34     	; 0x7598 <system_execute_line+0x194>
    75ba:	8c c0       	rjmp	.+280    	; 0x76d4 <system_execute_line+0x2d0>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    75bc:	91 11       	cpse	r25, r1
    75be:	8c c0       	rjmp	.+280    	; 0x76d8 <system_execute_line+0x2d4>
            helper_var = true;  // Set helper_var to flag storing method. 
    75c0:	11 e0       	ldi	r17, 0x01	; 1
    75c2:	01 c0       	rjmp	.+2      	; 0x75c6 <system_execute_line+0x1c2>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
    75c4:	10 e0       	ldi	r17, 0x00	; 0
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    75c6:	ae 01       	movw	r20, r28
    75c8:	4e 5f       	subi	r20, 0xFE	; 254
    75ca:	5f 4f       	sbci	r21, 0xFF	; 255
    75cc:	be 01       	movw	r22, r28
    75ce:	6f 5f       	subi	r22, 0xFF	; 255
    75d0:	7f 4f       	sbci	r23, 0xFF	; 255
    75d2:	c7 01       	movw	r24, r14
    75d4:	0e 94 f9 2d 	call	0x5bf2	; 0x5bf2 <read_float>
    75d8:	88 23       	and	r24, r24
    75da:	09 f4       	brne	.+2      	; 0x75de <system_execute_line+0x1da>
    75dc:	7f c0       	rjmp	.+254    	; 0x76dc <system_execute_line+0x2d8>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    75de:	89 81       	ldd	r24, Y+1	; 0x01
    75e0:	21 e0       	ldi	r18, 0x01	; 1
    75e2:	28 0f       	add	r18, r24
    75e4:	29 83       	std	Y+1, r18	; 0x01
    75e6:	f7 01       	movw	r30, r14
    75e8:	e8 0f       	add	r30, r24
    75ea:	f1 1d       	adc	r31, r1
    75ec:	80 81       	ld	r24, Z
    75ee:	8d 33       	cpi	r24, 0x3D	; 61
    75f0:	09 f0       	breq	.+2      	; 0x75f4 <system_execute_line+0x1f0>
    75f2:	76 c0       	rjmp	.+236    	; 0x76e0 <system_execute_line+0x2dc>
          if (helper_var) { // Store startup line
    75f4:	11 23       	and	r17, r17
    75f6:	39 f1       	breq	.+78     	; 0x7646 <system_execute_line+0x242>
    75f8:	42 2f       	mov	r20, r18
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    75fa:	30 e0       	ldi	r19, 0x00	; 0
    75fc:	84 2f       	mov	r24, r20
    75fe:	90 e0       	ldi	r25, 0x00	; 0
    7600:	f7 01       	movw	r30, r14
    7602:	e8 0f       	add	r30, r24
    7604:	f9 1f       	adc	r31, r25
    7606:	50 81       	ld	r21, Z
    7608:	82 1b       	sub	r24, r18
    760a:	93 0b       	sbc	r25, r19
    760c:	d7 01       	movw	r26, r14
    760e:	a8 0f       	add	r26, r24
    7610:	b9 1f       	adc	r27, r25
    7612:	5c 93       	st	X, r21
            } while (line[char_counter++] != 0);
    7614:	4f 5f       	subi	r20, 0xFF	; 255
    7616:	80 81       	ld	r24, Z
    7618:	81 11       	cpse	r24, r1
    761a:	f0 cf       	rjmp	.-32     	; 0x75fc <system_execute_line+0x1f8>
    761c:	49 83       	std	Y+1, r20	; 0x01
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    761e:	c7 01       	movw	r24, r14
    7620:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <gc_execute_line>
    7624:	18 2f       	mov	r17, r24
            if (helper_var) { return(helper_var); }
    7626:	81 11       	cpse	r24, r1
    7628:	5d c0       	rjmp	.+186    	; 0x76e4 <system_execute_line+0x2e0>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    762a:	6a 81       	ldd	r22, Y+2	; 0x02
    762c:	7b 81       	ldd	r23, Y+3	; 0x03
    762e:	8c 81       	ldd	r24, Y+4	; 0x04
    7630:	9d 81       	ldd	r25, Y+5	; 0x05
    7632:	0e 94 a6 3f 	call	0x7f4c	; 0x7f4c <trunc>
    7636:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
    763a:	86 2f       	mov	r24, r22
              settings_store_startup_line(helper_var,line);
    763c:	b7 01       	movw	r22, r14
    763e:	0e 94 d4 25 	call	0x4ba8	; 0x4ba8 <settings_store_startup_line>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7642:	81 2f       	mov	r24, r17
    7644:	55 c0       	rjmp	.+170    	; 0x76f0 <system_execute_line+0x2ec>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7646:	ae 01       	movw	r20, r28
    7648:	4a 5f       	subi	r20, 0xFA	; 250
    764a:	5f 4f       	sbci	r21, 0xFF	; 255
    764c:	be 01       	movw	r22, r28
    764e:	6f 5f       	subi	r22, 0xFF	; 255
    7650:	7f 4f       	sbci	r23, 0xFF	; 255
    7652:	c7 01       	movw	r24, r14
    7654:	0e 94 f9 2d 	call	0x5bf2	; 0x5bf2 <read_float>
    7658:	88 23       	and	r24, r24
    765a:	09 f4       	brne	.+2      	; 0x765e <system_execute_line+0x25a>
    765c:	44 c0       	rjmp	.+136    	; 0x76e6 <system_execute_line+0x2e2>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    765e:	89 81       	ldd	r24, Y+1	; 0x01
    7660:	f7 01       	movw	r30, r14
    7662:	e8 0f       	add	r30, r24
    7664:	f1 1d       	adc	r31, r1
    7666:	80 81       	ld	r24, Z
    7668:	81 11       	cpse	r24, r1
    766a:	3f c0       	rjmp	.+126    	; 0x76ea <system_execute_line+0x2e6>
    766c:	ca 80       	ldd	r12, Y+2	; 0x02
    766e:	db 80       	ldd	r13, Y+3	; 0x03
    7670:	ec 80       	ldd	r14, Y+4	; 0x04
    7672:	fd 80       	ldd	r15, Y+5	; 0x05
    7674:	20 e0       	ldi	r18, 0x00	; 0
    7676:	30 e0       	ldi	r19, 0x00	; 0
    7678:	4f e7       	ldi	r20, 0x7F	; 127
    767a:	53 e4       	ldi	r21, 0x43	; 67
    767c:	c7 01       	movw	r24, r14
    767e:	b6 01       	movw	r22, r12
    7680:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <__gesf2>
    7684:	18 16       	cp	r1, r24
    7686:	9c f1       	brlt	.+102    	; 0x76ee <system_execute_line+0x2ea>
            return(settings_store_global_setting((uint8_t)parameter, value));
    7688:	8e 80       	ldd	r8, Y+6	; 0x06
    768a:	9f 80       	ldd	r9, Y+7	; 0x07
    768c:	a8 84       	ldd	r10, Y+8	; 0x08
    768e:	b9 84       	ldd	r11, Y+9	; 0x09
    7690:	c7 01       	movw	r24, r14
    7692:	b6 01       	movw	r22, r12
    7694:	0e 94 0e 3d 	call	0x7a1c	; 0x7a1c <__fixunssfsi>
    7698:	86 2f       	mov	r24, r22
    769a:	b5 01       	movw	r22, r10
    769c:	a4 01       	movw	r20, r8
    769e:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <settings_store_global_setting>
    76a2:	26 c0       	rjmp	.+76     	; 0x76f0 <system_execute_line+0x2ec>
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case '$' : // Prints Grbl settings
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76a4:	83 e0       	ldi	r24, 0x03	; 3
    76a6:	24 c0       	rjmp	.+72     	; 0x76f0 <system_execute_line+0x2ec>
      if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    76a8:	88 e0       	ldi	r24, 0x08	; 8
    76aa:	22 c0       	rjmp	.+68     	; 0x76f0 <system_execute_line+0x2ec>
      else { report_grbl_settings(); }
      break;
    case 'G' : // Prints gcode parser state
      // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76ac:	83 e0       	ldi	r24, 0x03	; 3
    76ae:	20 c0       	rjmp	.+64     	; 0x76f0 <system_execute_line+0x2ec>
      else { report_gcode_modes(); }
      break;   
    case 'C' : // Set check g-code mode [IDLE/CHECK]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76b0:	83 e0       	ldi	r24, 0x03	; 3
    76b2:	1e c0       	rjmp	.+60     	; 0x76f0 <system_execute_line+0x2ec>
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
        mc_reset(); 
        report_feedback_message(MESSAGE_DISABLED);
      } else {
        if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    76b4:	88 e0       	ldi	r24, 0x08	; 8
    76b6:	1c c0       	rjmp	.+56     	; 0x76f0 <system_execute_line+0x2ec>
        sys.state = STATE_CHECK_MODE;
        report_feedback_message(MESSAGE_ENABLED);
      }
      break; 
    case 'X' : // Disable alarm lock [ALARM]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76b8:	83 e0       	ldi	r24, 0x03	; 3
    76ba:	1a c0       	rjmp	.+52     	; 0x76f0 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76bc:	80 e0       	ldi	r24, 0x00	; 0
    76be:	18 c0       	rjmp	.+48     	; 0x76f0 <system_execute_line+0x2ec>
      // handled by the planner. It would be possible for the jog subprogram to insert blocks into the
      // block buffer without having the planner plan them. It would need to manage de/ac-celerations 
      // on its own carefully. This approach could be effective and possibly size/memory efficient.        
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    76c0:	88 e0       	ldi	r24, 0x08	; 8
    76c2:	16 c0       	rjmp	.+44     	; 0x76f0 <system_execute_line+0x2ec>
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    76c4:	83 e0       	ldi	r24, 0x03	; 3
    76c6:	14 c0       	rjmp	.+40     	; 0x76f0 <system_execute_line+0x2ec>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
              sys.state = STATE_IDLE; // Set to IDLE when complete.
              st_go_idle(); // Set steppers to the settings idle state before returning.
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
    76c8:	85 e0       	ldi	r24, 0x05	; 5
    76ca:	12 c0       	rjmp	.+36     	; 0x76f0 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76cc:	80 e0       	ldi	r24, 0x00	; 0
    76ce:	10 c0       	rjmp	.+32     	; 0x76f0 <system_execute_line+0x2ec>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    76d0:	83 e0       	ldi	r24, 0x03	; 3
    76d2:	0e c0       	rjmp	.+28     	; 0x76f0 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76d4:	80 e0       	ldi	r24, 0x00	; 0
    76d6:	0c c0       	rjmp	.+24     	; 0x76f0 <system_execute_line+0x2ec>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    76d8:	88 e0       	ldi	r24, 0x08	; 8
    76da:	0a c0       	rjmp	.+20     	; 0x76f0 <system_execute_line+0x2ec>
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    76dc:	82 e0       	ldi	r24, 0x02	; 2
    76de:	08 c0       	rjmp	.+16     	; 0x76f0 <system_execute_line+0x2ec>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    76e0:	83 e0       	ldi	r24, 0x03	; 3
    76e2:	06 c0       	rjmp	.+12     	; 0x76f0 <system_execute_line+0x2ec>
    76e4:	05 c0       	rjmp	.+10     	; 0x76f0 <system_execute_line+0x2ec>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    76e6:	82 e0       	ldi	r24, 0x02	; 2
    76e8:	03 c0       	rjmp	.+6      	; 0x76f0 <system_execute_line+0x2ec>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    76ea:	83 e0       	ldi	r24, 0x03	; 3
    76ec:	01 c0       	rjmp	.+2      	; 0x76f0 <system_execute_line+0x2ec>
    76ee:	83 e0       	ldi	r24, 0x03	; 3
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    76f0:	29 96       	adiw	r28, 0x09	; 9
    76f2:	0f b6       	in	r0, 0x3f	; 63
    76f4:	f8 94       	cli
    76f6:	de bf       	out	0x3e, r29	; 62
    76f8:	0f be       	out	0x3f, r0	; 63
    76fa:	cd bf       	out	0x3d, r28	; 61
    76fc:	df 91       	pop	r29
    76fe:	cf 91       	pop	r28
    7700:	1f 91       	pop	r17
    7702:	ff 90       	pop	r15
    7704:	ef 90       	pop	r14
    7706:	df 90       	pop	r13
    7708:	cf 90       	pop	r12
    770a:	bf 90       	pop	r11
    770c:	af 90       	pop	r10
    770e:	9f 90       	pop	r9
    7710:	8f 90       	pop	r8
    7712:	08 95       	ret

00007714 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    7714:	cf 93       	push	r28
    7716:	df 93       	push	r29
      pos = 0.5*((steps[A_MOTOR] + steps[B_MOTOR])/settings.steps_per_mm[idx]);
    } else { // (idx==B_MOTOR)
      pos = 0.5*((steps[A_MOTOR] - steps[B_MOTOR])/settings.steps_per_mm[idx]);
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    7718:	c6 2f       	mov	r28, r22
    771a:	d0 e0       	ldi	r29, 0x00	; 0
    771c:	cc 0f       	add	r28, r28
    771e:	dd 1f       	adc	r29, r29
    7720:	cc 0f       	add	r28, r28
    7722:	dd 1f       	adc	r29, r29
    7724:	8c 0f       	add	r24, r28
    7726:	9d 1f       	adc	r25, r29
    7728:	fc 01       	movw	r30, r24
    772a:	60 81       	ld	r22, Z
    772c:	71 81       	ldd	r23, Z+1	; 0x01
    772e:	82 81       	ldd	r24, Z+2	; 0x02
    7730:	93 81       	ldd	r25, Z+3	; 0x03
    7732:	0e 94 3c 3d 	call	0x7a78	; 0x7a78 <__floatsisf>
    7736:	c1 50       	subi	r28, 0x01	; 1
    7738:	d7 4f       	sbci	r29, 0xF7	; 247
    773a:	28 81       	ld	r18, Y
    773c:	39 81       	ldd	r19, Y+1	; 0x01
    773e:	4a 81       	ldd	r20, Y+2	; 0x02
    7740:	5b 81       	ldd	r21, Y+3	; 0x03
    7742:	0e 94 a1 3c 	call	0x7942	; 0x7942 <__divsf3>
  #endif
  return(pos);
}
    7746:	df 91       	pop	r29
    7748:	cf 91       	pop	r28
    774a:	08 95       	ret

0000774c <system_convert_array_steps_to_mpos>:
  

void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    774c:	ff 92       	push	r15
    774e:	0f 93       	push	r16
    7750:	1f 93       	push	r17
    7752:	cf 93       	push	r28
    7754:	df 93       	push	r29
    7756:	8b 01       	movw	r16, r22
    7758:	ec 01       	movw	r28, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    775a:	f1 2c       	mov	r15, r1
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    775c:	6f 2d       	mov	r22, r15
    775e:	c8 01       	movw	r24, r16
    7760:	0e 94 8a 3b 	call	0x7714	; 0x7714 <system_convert_axis_steps_to_mpos>
    7764:	69 93       	st	Y+, r22
    7766:	79 93       	st	Y+, r23
    7768:	89 93       	st	Y+, r24
    776a:	99 93       	st	Y+, r25
  

void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    776c:	f3 94       	inc	r15
    776e:	83 e0       	ldi	r24, 0x03	; 3
    7770:	f8 12       	cpse	r15, r24
    7772:	f4 cf       	rjmp	.-24     	; 0x775c <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    7774:	df 91       	pop	r29
    7776:	cf 91       	pop	r28
    7778:	1f 91       	pop	r17
    777a:	0f 91       	pop	r16
    777c:	ff 90       	pop	r15
    777e:	08 95       	ret

00007780 <__subsf3>:
    7780:	50 58       	subi	r21, 0x80	; 128

00007782 <__addsf3>:
    7782:	bb 27       	eor	r27, r27
    7784:	aa 27       	eor	r26, r26
    7786:	0e d0       	rcall	.+28     	; 0x77a4 <__addsf3x>
    7788:	76 c2       	rjmp	.+1260   	; 0x7c76 <__fp_round>
    778a:	3f d2       	rcall	.+1150   	; 0x7c0a <__fp_pscA>
    778c:	30 f0       	brcs	.+12     	; 0x779a <__addsf3+0x18>
    778e:	44 d2       	rcall	.+1160   	; 0x7c18 <__fp_pscB>
    7790:	20 f0       	brcs	.+8      	; 0x779a <__addsf3+0x18>
    7792:	31 f4       	brne	.+12     	; 0x77a0 <__addsf3+0x1e>
    7794:	9f 3f       	cpi	r25, 0xFF	; 255
    7796:	11 f4       	brne	.+4      	; 0x779c <__addsf3+0x1a>
    7798:	1e f4       	brtc	.+6      	; 0x77a0 <__addsf3+0x1e>
    779a:	0f c2       	rjmp	.+1054   	; 0x7bba <__fp_nan>
    779c:	0e f4       	brtc	.+2      	; 0x77a0 <__addsf3+0x1e>
    779e:	e0 95       	com	r30
    77a0:	e7 fb       	bst	r30, 7
    77a2:	dc c1       	rjmp	.+952    	; 0x7b5c <__fp_inf>

000077a4 <__addsf3x>:
    77a4:	e9 2f       	mov	r30, r25
    77a6:	89 d2       	rcall	.+1298   	; 0x7cba <__fp_split3>
    77a8:	80 f3       	brcs	.-32     	; 0x778a <__addsf3+0x8>
    77aa:	ba 17       	cp	r27, r26
    77ac:	62 07       	cpc	r22, r18
    77ae:	73 07       	cpc	r23, r19
    77b0:	84 07       	cpc	r24, r20
    77b2:	95 07       	cpc	r25, r21
    77b4:	18 f0       	brcs	.+6      	; 0x77bc <__addsf3x+0x18>
    77b6:	71 f4       	brne	.+28     	; 0x77d4 <__addsf3x+0x30>
    77b8:	9e f5       	brtc	.+102    	; 0x7820 <__addsf3x+0x7c>
    77ba:	b8 c2       	rjmp	.+1392   	; 0x7d2c <__fp_zero>
    77bc:	0e f4       	brtc	.+2      	; 0x77c0 <__addsf3x+0x1c>
    77be:	e0 95       	com	r30
    77c0:	0b 2e       	mov	r0, r27
    77c2:	ba 2f       	mov	r27, r26
    77c4:	a0 2d       	mov	r26, r0
    77c6:	0b 01       	movw	r0, r22
    77c8:	b9 01       	movw	r22, r18
    77ca:	90 01       	movw	r18, r0
    77cc:	0c 01       	movw	r0, r24
    77ce:	ca 01       	movw	r24, r20
    77d0:	a0 01       	movw	r20, r0
    77d2:	11 24       	eor	r1, r1
    77d4:	ff 27       	eor	r31, r31
    77d6:	59 1b       	sub	r21, r25
    77d8:	99 f0       	breq	.+38     	; 0x7800 <__addsf3x+0x5c>
    77da:	59 3f       	cpi	r21, 0xF9	; 249
    77dc:	50 f4       	brcc	.+20     	; 0x77f2 <__addsf3x+0x4e>
    77de:	50 3e       	cpi	r21, 0xE0	; 224
    77e0:	68 f1       	brcs	.+90     	; 0x783c <__addsf3x+0x98>
    77e2:	1a 16       	cp	r1, r26
    77e4:	f0 40       	sbci	r31, 0x00	; 0
    77e6:	a2 2f       	mov	r26, r18
    77e8:	23 2f       	mov	r18, r19
    77ea:	34 2f       	mov	r19, r20
    77ec:	44 27       	eor	r20, r20
    77ee:	58 5f       	subi	r21, 0xF8	; 248
    77f0:	f3 cf       	rjmp	.-26     	; 0x77d8 <__addsf3x+0x34>
    77f2:	46 95       	lsr	r20
    77f4:	37 95       	ror	r19
    77f6:	27 95       	ror	r18
    77f8:	a7 95       	ror	r26
    77fa:	f0 40       	sbci	r31, 0x00	; 0
    77fc:	53 95       	inc	r21
    77fe:	c9 f7       	brne	.-14     	; 0x77f2 <__addsf3x+0x4e>
    7800:	7e f4       	brtc	.+30     	; 0x7820 <__addsf3x+0x7c>
    7802:	1f 16       	cp	r1, r31
    7804:	ba 0b       	sbc	r27, r26
    7806:	62 0b       	sbc	r22, r18
    7808:	73 0b       	sbc	r23, r19
    780a:	84 0b       	sbc	r24, r20
    780c:	ba f0       	brmi	.+46     	; 0x783c <__addsf3x+0x98>
    780e:	91 50       	subi	r25, 0x01	; 1
    7810:	a1 f0       	breq	.+40     	; 0x783a <__addsf3x+0x96>
    7812:	ff 0f       	add	r31, r31
    7814:	bb 1f       	adc	r27, r27
    7816:	66 1f       	adc	r22, r22
    7818:	77 1f       	adc	r23, r23
    781a:	88 1f       	adc	r24, r24
    781c:	c2 f7       	brpl	.-16     	; 0x780e <__addsf3x+0x6a>
    781e:	0e c0       	rjmp	.+28     	; 0x783c <__addsf3x+0x98>
    7820:	ba 0f       	add	r27, r26
    7822:	62 1f       	adc	r22, r18
    7824:	73 1f       	adc	r23, r19
    7826:	84 1f       	adc	r24, r20
    7828:	48 f4       	brcc	.+18     	; 0x783c <__addsf3x+0x98>
    782a:	87 95       	ror	r24
    782c:	77 95       	ror	r23
    782e:	67 95       	ror	r22
    7830:	b7 95       	ror	r27
    7832:	f7 95       	ror	r31
    7834:	9e 3f       	cpi	r25, 0xFE	; 254
    7836:	08 f0       	brcs	.+2      	; 0x783a <__addsf3x+0x96>
    7838:	b3 cf       	rjmp	.-154    	; 0x77a0 <__addsf3+0x1e>
    783a:	93 95       	inc	r25
    783c:	88 0f       	add	r24, r24
    783e:	08 f0       	brcs	.+2      	; 0x7842 <__addsf3x+0x9e>
    7840:	99 27       	eor	r25, r25
    7842:	ee 0f       	add	r30, r30
    7844:	97 95       	ror	r25
    7846:	87 95       	ror	r24
    7848:	08 95       	ret
    784a:	df d1       	rcall	.+958    	; 0x7c0a <__fp_pscA>
    784c:	58 f0       	brcs	.+22     	; 0x7864 <__addsf3x+0xc0>
    784e:	80 e8       	ldi	r24, 0x80	; 128
    7850:	91 e0       	ldi	r25, 0x01	; 1
    7852:	09 f4       	brne	.+2      	; 0x7856 <__addsf3x+0xb2>
    7854:	9e ef       	ldi	r25, 0xFE	; 254
    7856:	e0 d1       	rcall	.+960    	; 0x7c18 <__fp_pscB>
    7858:	28 f0       	brcs	.+10     	; 0x7864 <__addsf3x+0xc0>
    785a:	40 e8       	ldi	r20, 0x80	; 128
    785c:	51 e0       	ldi	r21, 0x01	; 1
    785e:	59 f4       	brne	.+22     	; 0x7876 <atan2+0xe>
    7860:	5e ef       	ldi	r21, 0xFE	; 254
    7862:	09 c0       	rjmp	.+18     	; 0x7876 <atan2+0xe>
    7864:	aa c1       	rjmp	.+852    	; 0x7bba <__fp_nan>
    7866:	62 c2       	rjmp	.+1220   	; 0x7d2c <__fp_zero>

00007868 <atan2>:
    7868:	e9 2f       	mov	r30, r25
    786a:	e0 78       	andi	r30, 0x80	; 128
    786c:	26 d2       	rcall	.+1100   	; 0x7cba <__fp_split3>
    786e:	68 f3       	brcs	.-38     	; 0x784a <__addsf3x+0xa6>
    7870:	09 2e       	mov	r0, r25
    7872:	05 2a       	or	r0, r21
    7874:	c1 f3       	breq	.-16     	; 0x7866 <__addsf3x+0xc2>
    7876:	26 17       	cp	r18, r22
    7878:	37 07       	cpc	r19, r23
    787a:	48 07       	cpc	r20, r24
    787c:	59 07       	cpc	r21, r25
    787e:	38 f0       	brcs	.+14     	; 0x788e <atan2+0x26>
    7880:	0e 2e       	mov	r0, r30
    7882:	07 f8       	bld	r0, 7
    7884:	e0 25       	eor	r30, r0
    7886:	69 f0       	breq	.+26     	; 0x78a2 <atan2+0x3a>
    7888:	e0 25       	eor	r30, r0
    788a:	e0 64       	ori	r30, 0x40	; 64
    788c:	0a c0       	rjmp	.+20     	; 0x78a2 <atan2+0x3a>
    788e:	ef 63       	ori	r30, 0x3F	; 63
    7890:	07 f8       	bld	r0, 7
    7892:	00 94       	com	r0
    7894:	07 fa       	bst	r0, 7
    7896:	db 01       	movw	r26, r22
    7898:	b9 01       	movw	r22, r18
    789a:	9d 01       	movw	r18, r26
    789c:	dc 01       	movw	r26, r24
    789e:	ca 01       	movw	r24, r20
    78a0:	ad 01       	movw	r20, r26
    78a2:	ef 93       	push	r30
    78a4:	5d d0       	rcall	.+186    	; 0x7960 <__divsf3_pse>
    78a6:	e7 d1       	rcall	.+974    	; 0x7c76 <__fp_round>
    78a8:	0a d0       	rcall	.+20     	; 0x78be <atan>
    78aa:	5f 91       	pop	r21
    78ac:	55 23       	and	r21, r21
    78ae:	31 f0       	breq	.+12     	; 0x78bc <atan2+0x54>
    78b0:	2b ed       	ldi	r18, 0xDB	; 219
    78b2:	3f e0       	ldi	r19, 0x0F	; 15
    78b4:	49 e4       	ldi	r20, 0x49	; 73
    78b6:	50 fd       	sbrc	r21, 0
    78b8:	49 ec       	ldi	r20, 0xC9	; 201
    78ba:	63 cf       	rjmp	.-314    	; 0x7782 <__addsf3>
    78bc:	08 95       	ret

000078be <atan>:
    78be:	df 93       	push	r29
    78c0:	dd 27       	eor	r29, r29
    78c2:	b9 2f       	mov	r27, r25
    78c4:	bf 77       	andi	r27, 0x7F	; 127
    78c6:	40 e8       	ldi	r20, 0x80	; 128
    78c8:	5f e3       	ldi	r21, 0x3F	; 63
    78ca:	16 16       	cp	r1, r22
    78cc:	17 06       	cpc	r1, r23
    78ce:	48 07       	cpc	r20, r24
    78d0:	5b 07       	cpc	r21, r27
    78d2:	10 f4       	brcc	.+4      	; 0x78d8 <atan+0x1a>
    78d4:	d9 2f       	mov	r29, r25
    78d6:	35 d2       	rcall	.+1130   	; 0x7d42 <inverse>
    78d8:	9f 93       	push	r25
    78da:	8f 93       	push	r24
    78dc:	7f 93       	push	r23
    78de:	6f 93       	push	r22
    78e0:	32 d3       	rcall	.+1636   	; 0x7f46 <square>
    78e2:	e4 e3       	ldi	r30, 0x34	; 52
    78e4:	f2 e0       	ldi	r31, 0x02	; 2
    78e6:	6c d1       	rcall	.+728    	; 0x7bc0 <__fp_powser>
    78e8:	c6 d1       	rcall	.+908    	; 0x7c76 <__fp_round>
    78ea:	2f 91       	pop	r18
    78ec:	3f 91       	pop	r19
    78ee:	4f 91       	pop	r20
    78f0:	5f 91       	pop	r21
    78f2:	6a d2       	rcall	.+1236   	; 0x7dc8 <__mulsf3x>
    78f4:	dd 23       	and	r29, r29
    78f6:	49 f0       	breq	.+18     	; 0x790a <atan+0x4c>
    78f8:	90 58       	subi	r25, 0x80	; 128
    78fa:	a2 ea       	ldi	r26, 0xA2	; 162
    78fc:	2a ed       	ldi	r18, 0xDA	; 218
    78fe:	3f e0       	ldi	r19, 0x0F	; 15
    7900:	49 ec       	ldi	r20, 0xC9	; 201
    7902:	5f e3       	ldi	r21, 0x3F	; 63
    7904:	d0 78       	andi	r29, 0x80	; 128
    7906:	5d 27       	eor	r21, r29
    7908:	4d df       	rcall	.-358    	; 0x77a4 <__addsf3x>
    790a:	df 91       	pop	r29
    790c:	b4 c1       	rjmp	.+872    	; 0x7c76 <__fp_round>

0000790e <ceil>:
    790e:	f7 d1       	rcall	.+1006   	; 0x7cfe <__fp_trunc>
    7910:	80 f0       	brcs	.+32     	; 0x7932 <ceil+0x24>
    7912:	9f 37       	cpi	r25, 0x7F	; 127
    7914:	40 f4       	brcc	.+16     	; 0x7926 <ceil+0x18>
    7916:	91 11       	cpse	r25, r1
    7918:	0e f4       	brtc	.+2      	; 0x791c <ceil+0xe>
    791a:	09 c2       	rjmp	.+1042   	; 0x7d2e <__fp_szero>
    791c:	60 e0       	ldi	r22, 0x00	; 0
    791e:	70 e0       	ldi	r23, 0x00	; 0
    7920:	80 e8       	ldi	r24, 0x80	; 128
    7922:	9f e3       	ldi	r25, 0x3F	; 63
    7924:	08 95       	ret
    7926:	26 f0       	brts	.+8      	; 0x7930 <ceil+0x22>
    7928:	1b 16       	cp	r1, r27
    792a:	61 1d       	adc	r22, r1
    792c:	71 1d       	adc	r23, r1
    792e:	81 1d       	adc	r24, r1
    7930:	1b c1       	rjmp	.+566    	; 0x7b68 <__fp_mintl>
    7932:	35 c1       	rjmp	.+618    	; 0x7b9e <__fp_mpack>

00007934 <__cmpsf2>:
    7934:	ef d0       	rcall	.+478    	; 0x7b14 <__fp_cmp>
    7936:	08 f4       	brcc	.+2      	; 0x793a <__cmpsf2+0x6>
    7938:	81 e0       	ldi	r24, 0x01	; 1
    793a:	08 95       	ret

0000793c <cos>:
    793c:	75 d1       	rcall	.+746    	; 0x7c28 <__fp_rempio2>
    793e:	e3 95       	inc	r30
    7940:	ab c1       	rjmp	.+854    	; 0x7c98 <__fp_sinus>

00007942 <__divsf3>:
    7942:	0c d0       	rcall	.+24     	; 0x795c <__divsf3x>
    7944:	98 c1       	rjmp	.+816    	; 0x7c76 <__fp_round>
    7946:	68 d1       	rcall	.+720    	; 0x7c18 <__fp_pscB>
    7948:	40 f0       	brcs	.+16     	; 0x795a <__divsf3+0x18>
    794a:	5f d1       	rcall	.+702    	; 0x7c0a <__fp_pscA>
    794c:	30 f0       	brcs	.+12     	; 0x795a <__divsf3+0x18>
    794e:	21 f4       	brne	.+8      	; 0x7958 <__divsf3+0x16>
    7950:	5f 3f       	cpi	r21, 0xFF	; 255
    7952:	19 f0       	breq	.+6      	; 0x795a <__divsf3+0x18>
    7954:	03 c1       	rjmp	.+518    	; 0x7b5c <__fp_inf>
    7956:	51 11       	cpse	r21, r1
    7958:	ea c1       	rjmp	.+980    	; 0x7d2e <__fp_szero>
    795a:	2f c1       	rjmp	.+606    	; 0x7bba <__fp_nan>

0000795c <__divsf3x>:
    795c:	ae d1       	rcall	.+860    	; 0x7cba <__fp_split3>
    795e:	98 f3       	brcs	.-26     	; 0x7946 <__divsf3+0x4>

00007960 <__divsf3_pse>:
    7960:	99 23       	and	r25, r25
    7962:	c9 f3       	breq	.-14     	; 0x7956 <__divsf3+0x14>
    7964:	55 23       	and	r21, r21
    7966:	b1 f3       	breq	.-20     	; 0x7954 <__divsf3+0x12>
    7968:	95 1b       	sub	r25, r21
    796a:	55 0b       	sbc	r21, r21
    796c:	bb 27       	eor	r27, r27
    796e:	aa 27       	eor	r26, r26
    7970:	62 17       	cp	r22, r18
    7972:	73 07       	cpc	r23, r19
    7974:	84 07       	cpc	r24, r20
    7976:	38 f0       	brcs	.+14     	; 0x7986 <__divsf3_pse+0x26>
    7978:	9f 5f       	subi	r25, 0xFF	; 255
    797a:	5f 4f       	sbci	r21, 0xFF	; 255
    797c:	22 0f       	add	r18, r18
    797e:	33 1f       	adc	r19, r19
    7980:	44 1f       	adc	r20, r20
    7982:	aa 1f       	adc	r26, r26
    7984:	a9 f3       	breq	.-22     	; 0x7970 <__divsf3_pse+0x10>
    7986:	33 d0       	rcall	.+102    	; 0x79ee <__divsf3_pse+0x8e>
    7988:	0e 2e       	mov	r0, r30
    798a:	3a f0       	brmi	.+14     	; 0x799a <__divsf3_pse+0x3a>
    798c:	e0 e8       	ldi	r30, 0x80	; 128
    798e:	30 d0       	rcall	.+96     	; 0x79f0 <__divsf3_pse+0x90>
    7990:	91 50       	subi	r25, 0x01	; 1
    7992:	50 40       	sbci	r21, 0x00	; 0
    7994:	e6 95       	lsr	r30
    7996:	00 1c       	adc	r0, r0
    7998:	ca f7       	brpl	.-14     	; 0x798c <__divsf3_pse+0x2c>
    799a:	29 d0       	rcall	.+82     	; 0x79ee <__divsf3_pse+0x8e>
    799c:	fe 2f       	mov	r31, r30
    799e:	27 d0       	rcall	.+78     	; 0x79ee <__divsf3_pse+0x8e>
    79a0:	66 0f       	add	r22, r22
    79a2:	77 1f       	adc	r23, r23
    79a4:	88 1f       	adc	r24, r24
    79a6:	bb 1f       	adc	r27, r27
    79a8:	26 17       	cp	r18, r22
    79aa:	37 07       	cpc	r19, r23
    79ac:	48 07       	cpc	r20, r24
    79ae:	ab 07       	cpc	r26, r27
    79b0:	b0 e8       	ldi	r27, 0x80	; 128
    79b2:	09 f0       	breq	.+2      	; 0x79b6 <__divsf3_pse+0x56>
    79b4:	bb 0b       	sbc	r27, r27
    79b6:	80 2d       	mov	r24, r0
    79b8:	bf 01       	movw	r22, r30
    79ba:	ff 27       	eor	r31, r31
    79bc:	93 58       	subi	r25, 0x83	; 131
    79be:	5f 4f       	sbci	r21, 0xFF	; 255
    79c0:	2a f0       	brmi	.+10     	; 0x79cc <__divsf3_pse+0x6c>
    79c2:	9e 3f       	cpi	r25, 0xFE	; 254
    79c4:	51 05       	cpc	r21, r1
    79c6:	68 f0       	brcs	.+26     	; 0x79e2 <__divsf3_pse+0x82>
    79c8:	c9 c0       	rjmp	.+402    	; 0x7b5c <__fp_inf>
    79ca:	b1 c1       	rjmp	.+866    	; 0x7d2e <__fp_szero>
    79cc:	5f 3f       	cpi	r21, 0xFF	; 255
    79ce:	ec f3       	brlt	.-6      	; 0x79ca <__divsf3_pse+0x6a>
    79d0:	98 3e       	cpi	r25, 0xE8	; 232
    79d2:	dc f3       	brlt	.-10     	; 0x79ca <__divsf3_pse+0x6a>
    79d4:	86 95       	lsr	r24
    79d6:	77 95       	ror	r23
    79d8:	67 95       	ror	r22
    79da:	b7 95       	ror	r27
    79dc:	f7 95       	ror	r31
    79de:	9f 5f       	subi	r25, 0xFF	; 255
    79e0:	c9 f7       	brne	.-14     	; 0x79d4 <__divsf3_pse+0x74>
    79e2:	88 0f       	add	r24, r24
    79e4:	91 1d       	adc	r25, r1
    79e6:	96 95       	lsr	r25
    79e8:	87 95       	ror	r24
    79ea:	97 f9       	bld	r25, 7
    79ec:	08 95       	ret
    79ee:	e1 e0       	ldi	r30, 0x01	; 1
    79f0:	66 0f       	add	r22, r22
    79f2:	77 1f       	adc	r23, r23
    79f4:	88 1f       	adc	r24, r24
    79f6:	bb 1f       	adc	r27, r27
    79f8:	62 17       	cp	r22, r18
    79fa:	73 07       	cpc	r23, r19
    79fc:	84 07       	cpc	r24, r20
    79fe:	ba 07       	cpc	r27, r26
    7a00:	20 f0       	brcs	.+8      	; 0x7a0a <__divsf3_pse+0xaa>
    7a02:	62 1b       	sub	r22, r18
    7a04:	73 0b       	sbc	r23, r19
    7a06:	84 0b       	sbc	r24, r20
    7a08:	ba 0b       	sbc	r27, r26
    7a0a:	ee 1f       	adc	r30, r30
    7a0c:	88 f7       	brcc	.-30     	; 0x79f0 <__divsf3_pse+0x90>
    7a0e:	e0 95       	com	r30
    7a10:	08 95       	ret

00007a12 <__fixsfsi>:
    7a12:	04 d0       	rcall	.+8      	; 0x7a1c <__fixunssfsi>
    7a14:	68 94       	set
    7a16:	b1 11       	cpse	r27, r1
    7a18:	8a c1       	rjmp	.+788    	; 0x7d2e <__fp_szero>
    7a1a:	08 95       	ret

00007a1c <__fixunssfsi>:
    7a1c:	56 d1       	rcall	.+684    	; 0x7cca <__fp_splitA>
    7a1e:	88 f0       	brcs	.+34     	; 0x7a42 <__fixunssfsi+0x26>
    7a20:	9f 57       	subi	r25, 0x7F	; 127
    7a22:	90 f0       	brcs	.+36     	; 0x7a48 <__fixunssfsi+0x2c>
    7a24:	b9 2f       	mov	r27, r25
    7a26:	99 27       	eor	r25, r25
    7a28:	b7 51       	subi	r27, 0x17	; 23
    7a2a:	a0 f0       	brcs	.+40     	; 0x7a54 <__fixunssfsi+0x38>
    7a2c:	d1 f0       	breq	.+52     	; 0x7a62 <__fixunssfsi+0x46>
    7a2e:	66 0f       	add	r22, r22
    7a30:	77 1f       	adc	r23, r23
    7a32:	88 1f       	adc	r24, r24
    7a34:	99 1f       	adc	r25, r25
    7a36:	1a f0       	brmi	.+6      	; 0x7a3e <__fixunssfsi+0x22>
    7a38:	ba 95       	dec	r27
    7a3a:	c9 f7       	brne	.-14     	; 0x7a2e <__fixunssfsi+0x12>
    7a3c:	12 c0       	rjmp	.+36     	; 0x7a62 <__fixunssfsi+0x46>
    7a3e:	b1 30       	cpi	r27, 0x01	; 1
    7a40:	81 f0       	breq	.+32     	; 0x7a62 <__fixunssfsi+0x46>
    7a42:	74 d1       	rcall	.+744    	; 0x7d2c <__fp_zero>
    7a44:	b1 e0       	ldi	r27, 0x01	; 1
    7a46:	08 95       	ret
    7a48:	71 c1       	rjmp	.+738    	; 0x7d2c <__fp_zero>
    7a4a:	67 2f       	mov	r22, r23
    7a4c:	78 2f       	mov	r23, r24
    7a4e:	88 27       	eor	r24, r24
    7a50:	b8 5f       	subi	r27, 0xF8	; 248
    7a52:	39 f0       	breq	.+14     	; 0x7a62 <__fixunssfsi+0x46>
    7a54:	b9 3f       	cpi	r27, 0xF9	; 249
    7a56:	cc f3       	brlt	.-14     	; 0x7a4a <__fixunssfsi+0x2e>
    7a58:	86 95       	lsr	r24
    7a5a:	77 95       	ror	r23
    7a5c:	67 95       	ror	r22
    7a5e:	b3 95       	inc	r27
    7a60:	d9 f7       	brne	.-10     	; 0x7a58 <__fixunssfsi+0x3c>
    7a62:	3e f4       	brtc	.+14     	; 0x7a72 <__fixunssfsi+0x56>
    7a64:	90 95       	com	r25
    7a66:	80 95       	com	r24
    7a68:	70 95       	com	r23
    7a6a:	61 95       	neg	r22
    7a6c:	7f 4f       	sbci	r23, 0xFF	; 255
    7a6e:	8f 4f       	sbci	r24, 0xFF	; 255
    7a70:	9f 4f       	sbci	r25, 0xFF	; 255
    7a72:	08 95       	ret

00007a74 <__floatunsisf>:
    7a74:	e8 94       	clt
    7a76:	09 c0       	rjmp	.+18     	; 0x7a8a <__floatsisf+0x12>

00007a78 <__floatsisf>:
    7a78:	97 fb       	bst	r25, 7
    7a7a:	3e f4       	brtc	.+14     	; 0x7a8a <__floatsisf+0x12>
    7a7c:	90 95       	com	r25
    7a7e:	80 95       	com	r24
    7a80:	70 95       	com	r23
    7a82:	61 95       	neg	r22
    7a84:	7f 4f       	sbci	r23, 0xFF	; 255
    7a86:	8f 4f       	sbci	r24, 0xFF	; 255
    7a88:	9f 4f       	sbci	r25, 0xFF	; 255
    7a8a:	99 23       	and	r25, r25
    7a8c:	a9 f0       	breq	.+42     	; 0x7ab8 <__floatsisf+0x40>
    7a8e:	f9 2f       	mov	r31, r25
    7a90:	96 e9       	ldi	r25, 0x96	; 150
    7a92:	bb 27       	eor	r27, r27
    7a94:	93 95       	inc	r25
    7a96:	f6 95       	lsr	r31
    7a98:	87 95       	ror	r24
    7a9a:	77 95       	ror	r23
    7a9c:	67 95       	ror	r22
    7a9e:	b7 95       	ror	r27
    7aa0:	f1 11       	cpse	r31, r1
    7aa2:	f8 cf       	rjmp	.-16     	; 0x7a94 <__floatsisf+0x1c>
    7aa4:	fa f4       	brpl	.+62     	; 0x7ae4 <__floatsisf+0x6c>
    7aa6:	bb 0f       	add	r27, r27
    7aa8:	11 f4       	brne	.+4      	; 0x7aae <__floatsisf+0x36>
    7aaa:	60 ff       	sbrs	r22, 0
    7aac:	1b c0       	rjmp	.+54     	; 0x7ae4 <__floatsisf+0x6c>
    7aae:	6f 5f       	subi	r22, 0xFF	; 255
    7ab0:	7f 4f       	sbci	r23, 0xFF	; 255
    7ab2:	8f 4f       	sbci	r24, 0xFF	; 255
    7ab4:	9f 4f       	sbci	r25, 0xFF	; 255
    7ab6:	16 c0       	rjmp	.+44     	; 0x7ae4 <__floatsisf+0x6c>
    7ab8:	88 23       	and	r24, r24
    7aba:	11 f0       	breq	.+4      	; 0x7ac0 <__floatsisf+0x48>
    7abc:	96 e9       	ldi	r25, 0x96	; 150
    7abe:	11 c0       	rjmp	.+34     	; 0x7ae2 <__floatsisf+0x6a>
    7ac0:	77 23       	and	r23, r23
    7ac2:	21 f0       	breq	.+8      	; 0x7acc <__floatsisf+0x54>
    7ac4:	9e e8       	ldi	r25, 0x8E	; 142
    7ac6:	87 2f       	mov	r24, r23
    7ac8:	76 2f       	mov	r23, r22
    7aca:	05 c0       	rjmp	.+10     	; 0x7ad6 <__floatsisf+0x5e>
    7acc:	66 23       	and	r22, r22
    7ace:	71 f0       	breq	.+28     	; 0x7aec <__floatsisf+0x74>
    7ad0:	96 e8       	ldi	r25, 0x86	; 134
    7ad2:	86 2f       	mov	r24, r22
    7ad4:	70 e0       	ldi	r23, 0x00	; 0
    7ad6:	60 e0       	ldi	r22, 0x00	; 0
    7ad8:	2a f0       	brmi	.+10     	; 0x7ae4 <__floatsisf+0x6c>
    7ada:	9a 95       	dec	r25
    7adc:	66 0f       	add	r22, r22
    7ade:	77 1f       	adc	r23, r23
    7ae0:	88 1f       	adc	r24, r24
    7ae2:	da f7       	brpl	.-10     	; 0x7ada <__floatsisf+0x62>
    7ae4:	88 0f       	add	r24, r24
    7ae6:	96 95       	lsr	r25
    7ae8:	87 95       	ror	r24
    7aea:	97 f9       	bld	r25, 7
    7aec:	08 95       	ret

00007aee <floor>:
    7aee:	07 d1       	rcall	.+526    	; 0x7cfe <__fp_trunc>
    7af0:	80 f0       	brcs	.+32     	; 0x7b12 <floor+0x24>
    7af2:	9f 37       	cpi	r25, 0x7F	; 127
    7af4:	40 f4       	brcc	.+16     	; 0x7b06 <floor+0x18>
    7af6:	91 11       	cpse	r25, r1
    7af8:	0e f0       	brts	.+2      	; 0x7afc <floor+0xe>
    7afa:	19 c1       	rjmp	.+562    	; 0x7d2e <__fp_szero>
    7afc:	60 e0       	ldi	r22, 0x00	; 0
    7afe:	70 e0       	ldi	r23, 0x00	; 0
    7b00:	80 e8       	ldi	r24, 0x80	; 128
    7b02:	9f eb       	ldi	r25, 0xBF	; 191
    7b04:	08 95       	ret
    7b06:	26 f4       	brtc	.+8      	; 0x7b10 <floor+0x22>
    7b08:	1b 16       	cp	r1, r27
    7b0a:	61 1d       	adc	r22, r1
    7b0c:	71 1d       	adc	r23, r1
    7b0e:	81 1d       	adc	r24, r1
    7b10:	2b c0       	rjmp	.+86     	; 0x7b68 <__fp_mintl>
    7b12:	45 c0       	rjmp	.+138    	; 0x7b9e <__fp_mpack>

00007b14 <__fp_cmp>:
    7b14:	99 0f       	add	r25, r25
    7b16:	00 08       	sbc	r0, r0
    7b18:	55 0f       	add	r21, r21
    7b1a:	aa 0b       	sbc	r26, r26
    7b1c:	e0 e8       	ldi	r30, 0x80	; 128
    7b1e:	fe ef       	ldi	r31, 0xFE	; 254
    7b20:	16 16       	cp	r1, r22
    7b22:	17 06       	cpc	r1, r23
    7b24:	e8 07       	cpc	r30, r24
    7b26:	f9 07       	cpc	r31, r25
    7b28:	c0 f0       	brcs	.+48     	; 0x7b5a <__fp_cmp+0x46>
    7b2a:	12 16       	cp	r1, r18
    7b2c:	13 06       	cpc	r1, r19
    7b2e:	e4 07       	cpc	r30, r20
    7b30:	f5 07       	cpc	r31, r21
    7b32:	98 f0       	brcs	.+38     	; 0x7b5a <__fp_cmp+0x46>
    7b34:	62 1b       	sub	r22, r18
    7b36:	73 0b       	sbc	r23, r19
    7b38:	84 0b       	sbc	r24, r20
    7b3a:	95 0b       	sbc	r25, r21
    7b3c:	39 f4       	brne	.+14     	; 0x7b4c <__fp_cmp+0x38>
    7b3e:	0a 26       	eor	r0, r26
    7b40:	61 f0       	breq	.+24     	; 0x7b5a <__fp_cmp+0x46>
    7b42:	23 2b       	or	r18, r19
    7b44:	24 2b       	or	r18, r20
    7b46:	25 2b       	or	r18, r21
    7b48:	21 f4       	brne	.+8      	; 0x7b52 <__fp_cmp+0x3e>
    7b4a:	08 95       	ret
    7b4c:	0a 26       	eor	r0, r26
    7b4e:	09 f4       	brne	.+2      	; 0x7b52 <__fp_cmp+0x3e>
    7b50:	a1 40       	sbci	r26, 0x01	; 1
    7b52:	a6 95       	lsr	r26
    7b54:	8f ef       	ldi	r24, 0xFF	; 255
    7b56:	81 1d       	adc	r24, r1
    7b58:	81 1d       	adc	r24, r1
    7b5a:	08 95       	ret

00007b5c <__fp_inf>:
    7b5c:	97 f9       	bld	r25, 7
    7b5e:	9f 67       	ori	r25, 0x7F	; 127
    7b60:	80 e8       	ldi	r24, 0x80	; 128
    7b62:	70 e0       	ldi	r23, 0x00	; 0
    7b64:	60 e0       	ldi	r22, 0x00	; 0
    7b66:	08 95       	ret

00007b68 <__fp_mintl>:
    7b68:	88 23       	and	r24, r24
    7b6a:	71 f4       	brne	.+28     	; 0x7b88 <__fp_mintl+0x20>
    7b6c:	77 23       	and	r23, r23
    7b6e:	21 f0       	breq	.+8      	; 0x7b78 <__fp_mintl+0x10>
    7b70:	98 50       	subi	r25, 0x08	; 8
    7b72:	87 2b       	or	r24, r23
    7b74:	76 2f       	mov	r23, r22
    7b76:	07 c0       	rjmp	.+14     	; 0x7b86 <__fp_mintl+0x1e>
    7b78:	66 23       	and	r22, r22
    7b7a:	11 f4       	brne	.+4      	; 0x7b80 <__fp_mintl+0x18>
    7b7c:	99 27       	eor	r25, r25
    7b7e:	0d c0       	rjmp	.+26     	; 0x7b9a <__fp_mintl+0x32>
    7b80:	90 51       	subi	r25, 0x10	; 16
    7b82:	86 2b       	or	r24, r22
    7b84:	70 e0       	ldi	r23, 0x00	; 0
    7b86:	60 e0       	ldi	r22, 0x00	; 0
    7b88:	2a f0       	brmi	.+10     	; 0x7b94 <__fp_mintl+0x2c>
    7b8a:	9a 95       	dec	r25
    7b8c:	66 0f       	add	r22, r22
    7b8e:	77 1f       	adc	r23, r23
    7b90:	88 1f       	adc	r24, r24
    7b92:	da f7       	brpl	.-10     	; 0x7b8a <__fp_mintl+0x22>
    7b94:	88 0f       	add	r24, r24
    7b96:	96 95       	lsr	r25
    7b98:	87 95       	ror	r24
    7b9a:	97 f9       	bld	r25, 7
    7b9c:	08 95       	ret

00007b9e <__fp_mpack>:
    7b9e:	9f 3f       	cpi	r25, 0xFF	; 255
    7ba0:	31 f0       	breq	.+12     	; 0x7bae <__fp_mpack_finite+0xc>

00007ba2 <__fp_mpack_finite>:
    7ba2:	91 50       	subi	r25, 0x01	; 1
    7ba4:	20 f4       	brcc	.+8      	; 0x7bae <__fp_mpack_finite+0xc>
    7ba6:	87 95       	ror	r24
    7ba8:	77 95       	ror	r23
    7baa:	67 95       	ror	r22
    7bac:	b7 95       	ror	r27
    7bae:	88 0f       	add	r24, r24
    7bb0:	91 1d       	adc	r25, r1
    7bb2:	96 95       	lsr	r25
    7bb4:	87 95       	ror	r24
    7bb6:	97 f9       	bld	r25, 7
    7bb8:	08 95       	ret

00007bba <__fp_nan>:
    7bba:	9f ef       	ldi	r25, 0xFF	; 255
    7bbc:	80 ec       	ldi	r24, 0xC0	; 192
    7bbe:	08 95       	ret

00007bc0 <__fp_powser>:
    7bc0:	df 93       	push	r29
    7bc2:	cf 93       	push	r28
    7bc4:	1f 93       	push	r17
    7bc6:	0f 93       	push	r16
    7bc8:	ff 92       	push	r15
    7bca:	ef 92       	push	r14
    7bcc:	df 92       	push	r13
    7bce:	7b 01       	movw	r14, r22
    7bd0:	8c 01       	movw	r16, r24
    7bd2:	68 94       	set
    7bd4:	05 c0       	rjmp	.+10     	; 0x7be0 <__fp_powser+0x20>
    7bd6:	da 2e       	mov	r13, r26
    7bd8:	ef 01       	movw	r28, r30
    7bda:	f6 d0       	rcall	.+492    	; 0x7dc8 <__mulsf3x>
    7bdc:	fe 01       	movw	r30, r28
    7bde:	e8 94       	clt
    7be0:	a5 91       	lpm	r26, Z+
    7be2:	25 91       	lpm	r18, Z+
    7be4:	35 91       	lpm	r19, Z+
    7be6:	45 91       	lpm	r20, Z+
    7be8:	55 91       	lpm	r21, Z+
    7bea:	ae f3       	brts	.-22     	; 0x7bd6 <__fp_powser+0x16>
    7bec:	ef 01       	movw	r28, r30
    7bee:	da dd       	rcall	.-1100   	; 0x77a4 <__addsf3x>
    7bf0:	fe 01       	movw	r30, r28
    7bf2:	97 01       	movw	r18, r14
    7bf4:	a8 01       	movw	r20, r16
    7bf6:	da 94       	dec	r13
    7bf8:	79 f7       	brne	.-34     	; 0x7bd8 <__fp_powser+0x18>
    7bfa:	df 90       	pop	r13
    7bfc:	ef 90       	pop	r14
    7bfe:	ff 90       	pop	r15
    7c00:	0f 91       	pop	r16
    7c02:	1f 91       	pop	r17
    7c04:	cf 91       	pop	r28
    7c06:	df 91       	pop	r29
    7c08:	08 95       	ret

00007c0a <__fp_pscA>:
    7c0a:	00 24       	eor	r0, r0
    7c0c:	0a 94       	dec	r0
    7c0e:	16 16       	cp	r1, r22
    7c10:	17 06       	cpc	r1, r23
    7c12:	18 06       	cpc	r1, r24
    7c14:	09 06       	cpc	r0, r25
    7c16:	08 95       	ret

00007c18 <__fp_pscB>:
    7c18:	00 24       	eor	r0, r0
    7c1a:	0a 94       	dec	r0
    7c1c:	12 16       	cp	r1, r18
    7c1e:	13 06       	cpc	r1, r19
    7c20:	14 06       	cpc	r1, r20
    7c22:	05 06       	cpc	r0, r21
    7c24:	08 95       	ret
    7c26:	c9 cf       	rjmp	.-110    	; 0x7bba <__fp_nan>

00007c28 <__fp_rempio2>:
    7c28:	50 d0       	rcall	.+160    	; 0x7cca <__fp_splitA>
    7c2a:	e8 f3       	brcs	.-6      	; 0x7c26 <__fp_pscB+0xe>
    7c2c:	e8 94       	clt
    7c2e:	e0 e0       	ldi	r30, 0x00	; 0
    7c30:	bb 27       	eor	r27, r27
    7c32:	9f 57       	subi	r25, 0x7F	; 127
    7c34:	f0 f0       	brcs	.+60     	; 0x7c72 <__fp_rempio2+0x4a>
    7c36:	2a ed       	ldi	r18, 0xDA	; 218
    7c38:	3f e0       	ldi	r19, 0x0F	; 15
    7c3a:	49 ec       	ldi	r20, 0xC9	; 201
    7c3c:	06 c0       	rjmp	.+12     	; 0x7c4a <__fp_rempio2+0x22>
    7c3e:	ee 0f       	add	r30, r30
    7c40:	bb 0f       	add	r27, r27
    7c42:	66 1f       	adc	r22, r22
    7c44:	77 1f       	adc	r23, r23
    7c46:	88 1f       	adc	r24, r24
    7c48:	28 f0       	brcs	.+10     	; 0x7c54 <__fp_rempio2+0x2c>
    7c4a:	b2 3a       	cpi	r27, 0xA2	; 162
    7c4c:	62 07       	cpc	r22, r18
    7c4e:	73 07       	cpc	r23, r19
    7c50:	84 07       	cpc	r24, r20
    7c52:	28 f0       	brcs	.+10     	; 0x7c5e <__fp_rempio2+0x36>
    7c54:	b2 5a       	subi	r27, 0xA2	; 162
    7c56:	62 0b       	sbc	r22, r18
    7c58:	73 0b       	sbc	r23, r19
    7c5a:	84 0b       	sbc	r24, r20
    7c5c:	e3 95       	inc	r30
    7c5e:	9a 95       	dec	r25
    7c60:	72 f7       	brpl	.-36     	; 0x7c3e <__fp_rempio2+0x16>
    7c62:	80 38       	cpi	r24, 0x80	; 128
    7c64:	30 f4       	brcc	.+12     	; 0x7c72 <__fp_rempio2+0x4a>
    7c66:	9a 95       	dec	r25
    7c68:	bb 0f       	add	r27, r27
    7c6a:	66 1f       	adc	r22, r22
    7c6c:	77 1f       	adc	r23, r23
    7c6e:	88 1f       	adc	r24, r24
    7c70:	d2 f7       	brpl	.-12     	; 0x7c66 <__fp_rempio2+0x3e>
    7c72:	90 48       	sbci	r25, 0x80	; 128
    7c74:	96 cf       	rjmp	.-212    	; 0x7ba2 <__fp_mpack_finite>

00007c76 <__fp_round>:
    7c76:	09 2e       	mov	r0, r25
    7c78:	03 94       	inc	r0
    7c7a:	00 0c       	add	r0, r0
    7c7c:	11 f4       	brne	.+4      	; 0x7c82 <__fp_round+0xc>
    7c7e:	88 23       	and	r24, r24
    7c80:	52 f0       	brmi	.+20     	; 0x7c96 <__fp_round+0x20>
    7c82:	bb 0f       	add	r27, r27
    7c84:	40 f4       	brcc	.+16     	; 0x7c96 <__fp_round+0x20>
    7c86:	bf 2b       	or	r27, r31
    7c88:	11 f4       	brne	.+4      	; 0x7c8e <__fp_round+0x18>
    7c8a:	60 ff       	sbrs	r22, 0
    7c8c:	04 c0       	rjmp	.+8      	; 0x7c96 <__fp_round+0x20>
    7c8e:	6f 5f       	subi	r22, 0xFF	; 255
    7c90:	7f 4f       	sbci	r23, 0xFF	; 255
    7c92:	8f 4f       	sbci	r24, 0xFF	; 255
    7c94:	9f 4f       	sbci	r25, 0xFF	; 255
    7c96:	08 95       	ret

00007c98 <__fp_sinus>:
    7c98:	ef 93       	push	r30
    7c9a:	e0 ff       	sbrs	r30, 0
    7c9c:	06 c0       	rjmp	.+12     	; 0x7caa <__fp_sinus+0x12>
    7c9e:	a2 ea       	ldi	r26, 0xA2	; 162
    7ca0:	2a ed       	ldi	r18, 0xDA	; 218
    7ca2:	3f e0       	ldi	r19, 0x0F	; 15
    7ca4:	49 ec       	ldi	r20, 0xC9	; 201
    7ca6:	5f eb       	ldi	r21, 0xBF	; 191
    7ca8:	7d dd       	rcall	.-1286   	; 0x77a4 <__addsf3x>
    7caa:	e5 df       	rcall	.-54     	; 0x7c76 <__fp_round>
    7cac:	0f 90       	pop	r0
    7cae:	03 94       	inc	r0
    7cb0:	01 fc       	sbrc	r0, 1
    7cb2:	90 58       	subi	r25, 0x80	; 128
    7cb4:	e1 e6       	ldi	r30, 0x61	; 97
    7cb6:	f2 e0       	ldi	r31, 0x02	; 2
    7cb8:	57 c1       	rjmp	.+686    	; 0x7f68 <__fp_powsodd>

00007cba <__fp_split3>:
    7cba:	57 fd       	sbrc	r21, 7
    7cbc:	90 58       	subi	r25, 0x80	; 128
    7cbe:	44 0f       	add	r20, r20
    7cc0:	55 1f       	adc	r21, r21
    7cc2:	59 f0       	breq	.+22     	; 0x7cda <__fp_splitA+0x10>
    7cc4:	5f 3f       	cpi	r21, 0xFF	; 255
    7cc6:	71 f0       	breq	.+28     	; 0x7ce4 <__fp_splitA+0x1a>
    7cc8:	47 95       	ror	r20

00007cca <__fp_splitA>:
    7cca:	88 0f       	add	r24, r24
    7ccc:	97 fb       	bst	r25, 7
    7cce:	99 1f       	adc	r25, r25
    7cd0:	61 f0       	breq	.+24     	; 0x7cea <__fp_splitA+0x20>
    7cd2:	9f 3f       	cpi	r25, 0xFF	; 255
    7cd4:	79 f0       	breq	.+30     	; 0x7cf4 <__fp_splitA+0x2a>
    7cd6:	87 95       	ror	r24
    7cd8:	08 95       	ret
    7cda:	12 16       	cp	r1, r18
    7cdc:	13 06       	cpc	r1, r19
    7cde:	14 06       	cpc	r1, r20
    7ce0:	55 1f       	adc	r21, r21
    7ce2:	f2 cf       	rjmp	.-28     	; 0x7cc8 <__fp_split3+0xe>
    7ce4:	46 95       	lsr	r20
    7ce6:	f1 df       	rcall	.-30     	; 0x7cca <__fp_splitA>
    7ce8:	08 c0       	rjmp	.+16     	; 0x7cfa <__fp_splitA+0x30>
    7cea:	16 16       	cp	r1, r22
    7cec:	17 06       	cpc	r1, r23
    7cee:	18 06       	cpc	r1, r24
    7cf0:	99 1f       	adc	r25, r25
    7cf2:	f1 cf       	rjmp	.-30     	; 0x7cd6 <__fp_splitA+0xc>
    7cf4:	86 95       	lsr	r24
    7cf6:	71 05       	cpc	r23, r1
    7cf8:	61 05       	cpc	r22, r1
    7cfa:	08 94       	sec
    7cfc:	08 95       	ret

00007cfe <__fp_trunc>:
    7cfe:	e5 df       	rcall	.-54     	; 0x7cca <__fp_splitA>
    7d00:	a0 f0       	brcs	.+40     	; 0x7d2a <__fp_trunc+0x2c>
    7d02:	be e7       	ldi	r27, 0x7E	; 126
    7d04:	b9 17       	cp	r27, r25
    7d06:	88 f4       	brcc	.+34     	; 0x7d2a <__fp_trunc+0x2c>
    7d08:	bb 27       	eor	r27, r27
    7d0a:	9f 38       	cpi	r25, 0x8F	; 143
    7d0c:	60 f4       	brcc	.+24     	; 0x7d26 <__fp_trunc+0x28>
    7d0e:	16 16       	cp	r1, r22
    7d10:	b1 1d       	adc	r27, r1
    7d12:	67 2f       	mov	r22, r23
    7d14:	78 2f       	mov	r23, r24
    7d16:	88 27       	eor	r24, r24
    7d18:	98 5f       	subi	r25, 0xF8	; 248
    7d1a:	f7 cf       	rjmp	.-18     	; 0x7d0a <__fp_trunc+0xc>
    7d1c:	86 95       	lsr	r24
    7d1e:	77 95       	ror	r23
    7d20:	67 95       	ror	r22
    7d22:	b1 1d       	adc	r27, r1
    7d24:	93 95       	inc	r25
    7d26:	96 39       	cpi	r25, 0x96	; 150
    7d28:	c8 f3       	brcs	.-14     	; 0x7d1c <__fp_trunc+0x1e>
    7d2a:	08 95       	ret

00007d2c <__fp_zero>:
    7d2c:	e8 94       	clt

00007d2e <__fp_szero>:
    7d2e:	bb 27       	eor	r27, r27
    7d30:	66 27       	eor	r22, r22
    7d32:	77 27       	eor	r23, r23
    7d34:	cb 01       	movw	r24, r22
    7d36:	97 f9       	bld	r25, 7
    7d38:	08 95       	ret

00007d3a <__gesf2>:
    7d3a:	ec de       	rcall	.-552    	; 0x7b14 <__fp_cmp>
    7d3c:	08 f4       	brcc	.+2      	; 0x7d40 <__gesf2+0x6>
    7d3e:	8f ef       	ldi	r24, 0xFF	; 255
    7d40:	08 95       	ret

00007d42 <inverse>:
    7d42:	9b 01       	movw	r18, r22
    7d44:	ac 01       	movw	r20, r24
    7d46:	60 e0       	ldi	r22, 0x00	; 0
    7d48:	70 e0       	ldi	r23, 0x00	; 0
    7d4a:	80 e8       	ldi	r24, 0x80	; 128
    7d4c:	9f e3       	ldi	r25, 0x3F	; 63
    7d4e:	f9 cd       	rjmp	.-1038   	; 0x7942 <__divsf3>

00007d50 <lround>:
    7d50:	bc df       	rcall	.-136    	; 0x7cca <__fp_splitA>
    7d52:	58 f1       	brcs	.+86     	; 0x7daa <lround+0x5a>
    7d54:	9e 57       	subi	r25, 0x7E	; 126
    7d56:	58 f1       	brcs	.+86     	; 0x7dae <lround+0x5e>
    7d58:	98 51       	subi	r25, 0x18	; 24
    7d5a:	a0 f0       	brcs	.+40     	; 0x7d84 <lround+0x34>
    7d5c:	e9 f0       	breq	.+58     	; 0x7d98 <lround+0x48>
    7d5e:	98 30       	cpi	r25, 0x08	; 8
    7d60:	20 f5       	brcc	.+72     	; 0x7daa <lround+0x5a>
    7d62:	09 2e       	mov	r0, r25
    7d64:	99 27       	eor	r25, r25
    7d66:	66 0f       	add	r22, r22
    7d68:	77 1f       	adc	r23, r23
    7d6a:	88 1f       	adc	r24, r24
    7d6c:	99 1f       	adc	r25, r25
    7d6e:	0a 94       	dec	r0
    7d70:	d1 f7       	brne	.-12     	; 0x7d66 <lround+0x16>
    7d72:	12 c0       	rjmp	.+36     	; 0x7d98 <lround+0x48>
    7d74:	06 2e       	mov	r0, r22
    7d76:	67 2f       	mov	r22, r23
    7d78:	78 2f       	mov	r23, r24
    7d7a:	88 27       	eor	r24, r24
    7d7c:	98 5f       	subi	r25, 0xF8	; 248
    7d7e:	11 f4       	brne	.+4      	; 0x7d84 <lround+0x34>
    7d80:	00 0c       	add	r0, r0
    7d82:	07 c0       	rjmp	.+14     	; 0x7d92 <lround+0x42>
    7d84:	99 3f       	cpi	r25, 0xF9	; 249
    7d86:	b4 f3       	brlt	.-20     	; 0x7d74 <lround+0x24>
    7d88:	86 95       	lsr	r24
    7d8a:	77 95       	ror	r23
    7d8c:	67 95       	ror	r22
    7d8e:	93 95       	inc	r25
    7d90:	d9 f7       	brne	.-10     	; 0x7d88 <lround+0x38>
    7d92:	61 1d       	adc	r22, r1
    7d94:	71 1d       	adc	r23, r1
    7d96:	81 1d       	adc	r24, r1
    7d98:	3e f4       	brtc	.+14     	; 0x7da8 <lround+0x58>
    7d9a:	90 95       	com	r25
    7d9c:	80 95       	com	r24
    7d9e:	70 95       	com	r23
    7da0:	61 95       	neg	r22
    7da2:	7f 4f       	sbci	r23, 0xFF	; 255
    7da4:	8f 4f       	sbci	r24, 0xFF	; 255
    7da6:	9f 4f       	sbci	r25, 0xFF	; 255
    7da8:	08 95       	ret
    7daa:	68 94       	set
    7dac:	c0 cf       	rjmp	.-128    	; 0x7d2e <__fp_szero>
    7dae:	be cf       	rjmp	.-132    	; 0x7d2c <__fp_zero>

00007db0 <__mulsf3>:
    7db0:	0b d0       	rcall	.+22     	; 0x7dc8 <__mulsf3x>
    7db2:	61 cf       	rjmp	.-318    	; 0x7c76 <__fp_round>
    7db4:	2a df       	rcall	.-428    	; 0x7c0a <__fp_pscA>
    7db6:	28 f0       	brcs	.+10     	; 0x7dc2 <__mulsf3+0x12>
    7db8:	2f df       	rcall	.-418    	; 0x7c18 <__fp_pscB>
    7dba:	18 f0       	brcs	.+6      	; 0x7dc2 <__mulsf3+0x12>
    7dbc:	95 23       	and	r25, r21
    7dbe:	09 f0       	breq	.+2      	; 0x7dc2 <__mulsf3+0x12>
    7dc0:	cd ce       	rjmp	.-614    	; 0x7b5c <__fp_inf>
    7dc2:	fb ce       	rjmp	.-522    	; 0x7bba <__fp_nan>
    7dc4:	11 24       	eor	r1, r1
    7dc6:	b3 cf       	rjmp	.-154    	; 0x7d2e <__fp_szero>

00007dc8 <__mulsf3x>:
    7dc8:	78 df       	rcall	.-272    	; 0x7cba <__fp_split3>
    7dca:	a0 f3       	brcs	.-24     	; 0x7db4 <__mulsf3+0x4>

00007dcc <__mulsf3_pse>:
    7dcc:	95 9f       	mul	r25, r21
    7dce:	d1 f3       	breq	.-12     	; 0x7dc4 <__mulsf3+0x14>
    7dd0:	95 0f       	add	r25, r21
    7dd2:	50 e0       	ldi	r21, 0x00	; 0
    7dd4:	55 1f       	adc	r21, r21
    7dd6:	62 9f       	mul	r22, r18
    7dd8:	f0 01       	movw	r30, r0
    7dda:	72 9f       	mul	r23, r18
    7ddc:	bb 27       	eor	r27, r27
    7dde:	f0 0d       	add	r31, r0
    7de0:	b1 1d       	adc	r27, r1
    7de2:	63 9f       	mul	r22, r19
    7de4:	aa 27       	eor	r26, r26
    7de6:	f0 0d       	add	r31, r0
    7de8:	b1 1d       	adc	r27, r1
    7dea:	aa 1f       	adc	r26, r26
    7dec:	64 9f       	mul	r22, r20
    7dee:	66 27       	eor	r22, r22
    7df0:	b0 0d       	add	r27, r0
    7df2:	a1 1d       	adc	r26, r1
    7df4:	66 1f       	adc	r22, r22
    7df6:	82 9f       	mul	r24, r18
    7df8:	22 27       	eor	r18, r18
    7dfa:	b0 0d       	add	r27, r0
    7dfc:	a1 1d       	adc	r26, r1
    7dfe:	62 1f       	adc	r22, r18
    7e00:	73 9f       	mul	r23, r19
    7e02:	b0 0d       	add	r27, r0
    7e04:	a1 1d       	adc	r26, r1
    7e06:	62 1f       	adc	r22, r18
    7e08:	83 9f       	mul	r24, r19
    7e0a:	a0 0d       	add	r26, r0
    7e0c:	61 1d       	adc	r22, r1
    7e0e:	22 1f       	adc	r18, r18
    7e10:	74 9f       	mul	r23, r20
    7e12:	33 27       	eor	r19, r19
    7e14:	a0 0d       	add	r26, r0
    7e16:	61 1d       	adc	r22, r1
    7e18:	23 1f       	adc	r18, r19
    7e1a:	84 9f       	mul	r24, r20
    7e1c:	60 0d       	add	r22, r0
    7e1e:	21 1d       	adc	r18, r1
    7e20:	82 2f       	mov	r24, r18
    7e22:	76 2f       	mov	r23, r22
    7e24:	6a 2f       	mov	r22, r26
    7e26:	11 24       	eor	r1, r1
    7e28:	9f 57       	subi	r25, 0x7F	; 127
    7e2a:	50 40       	sbci	r21, 0x00	; 0
    7e2c:	8a f0       	brmi	.+34     	; 0x7e50 <__mulsf3_pse+0x84>
    7e2e:	e1 f0       	breq	.+56     	; 0x7e68 <__mulsf3_pse+0x9c>
    7e30:	88 23       	and	r24, r24
    7e32:	4a f0       	brmi	.+18     	; 0x7e46 <__mulsf3_pse+0x7a>
    7e34:	ee 0f       	add	r30, r30
    7e36:	ff 1f       	adc	r31, r31
    7e38:	bb 1f       	adc	r27, r27
    7e3a:	66 1f       	adc	r22, r22
    7e3c:	77 1f       	adc	r23, r23
    7e3e:	88 1f       	adc	r24, r24
    7e40:	91 50       	subi	r25, 0x01	; 1
    7e42:	50 40       	sbci	r21, 0x00	; 0
    7e44:	a9 f7       	brne	.-22     	; 0x7e30 <__mulsf3_pse+0x64>
    7e46:	9e 3f       	cpi	r25, 0xFE	; 254
    7e48:	51 05       	cpc	r21, r1
    7e4a:	70 f0       	brcs	.+28     	; 0x7e68 <__mulsf3_pse+0x9c>
    7e4c:	87 ce       	rjmp	.-754    	; 0x7b5c <__fp_inf>
    7e4e:	6f cf       	rjmp	.-290    	; 0x7d2e <__fp_szero>
    7e50:	5f 3f       	cpi	r21, 0xFF	; 255
    7e52:	ec f3       	brlt	.-6      	; 0x7e4e <__mulsf3_pse+0x82>
    7e54:	98 3e       	cpi	r25, 0xE8	; 232
    7e56:	dc f3       	brlt	.-10     	; 0x7e4e <__mulsf3_pse+0x82>
    7e58:	86 95       	lsr	r24
    7e5a:	77 95       	ror	r23
    7e5c:	67 95       	ror	r22
    7e5e:	b7 95       	ror	r27
    7e60:	f7 95       	ror	r31
    7e62:	e7 95       	ror	r30
    7e64:	9f 5f       	subi	r25, 0xFF	; 255
    7e66:	c1 f7       	brne	.-16     	; 0x7e58 <__mulsf3_pse+0x8c>
    7e68:	fe 2b       	or	r31, r30
    7e6a:	88 0f       	add	r24, r24
    7e6c:	91 1d       	adc	r25, r1
    7e6e:	96 95       	lsr	r25
    7e70:	87 95       	ror	r24
    7e72:	97 f9       	bld	r25, 7
    7e74:	08 95       	ret

00007e76 <round>:
    7e76:	29 df       	rcall	.-430    	; 0x7cca <__fp_splitA>
    7e78:	e0 f0       	brcs	.+56     	; 0x7eb2 <round+0x3c>
    7e7a:	9e 37       	cpi	r25, 0x7E	; 126
    7e7c:	d8 f0       	brcs	.+54     	; 0x7eb4 <round+0x3e>
    7e7e:	96 39       	cpi	r25, 0x96	; 150
    7e80:	b8 f4       	brcc	.+46     	; 0x7eb0 <round+0x3a>
    7e82:	9e 38       	cpi	r25, 0x8E	; 142
    7e84:	48 f4       	brcc	.+18     	; 0x7e98 <round+0x22>
    7e86:	67 2f       	mov	r22, r23
    7e88:	78 2f       	mov	r23, r24
    7e8a:	88 27       	eor	r24, r24
    7e8c:	98 5f       	subi	r25, 0xF8	; 248
    7e8e:	f9 cf       	rjmp	.-14     	; 0x7e82 <round+0xc>
    7e90:	86 95       	lsr	r24
    7e92:	77 95       	ror	r23
    7e94:	67 95       	ror	r22
    7e96:	93 95       	inc	r25
    7e98:	95 39       	cpi	r25, 0x95	; 149
    7e9a:	d0 f3       	brcs	.-12     	; 0x7e90 <round+0x1a>
    7e9c:	b6 2f       	mov	r27, r22
    7e9e:	b1 70       	andi	r27, 0x01	; 1
    7ea0:	6b 0f       	add	r22, r27
    7ea2:	71 1d       	adc	r23, r1
    7ea4:	81 1d       	adc	r24, r1
    7ea6:	20 f4       	brcc	.+8      	; 0x7eb0 <round+0x3a>
    7ea8:	87 95       	ror	r24
    7eaa:	77 95       	ror	r23
    7eac:	67 95       	ror	r22
    7eae:	93 95       	inc	r25
    7eb0:	5b ce       	rjmp	.-842    	; 0x7b68 <__fp_mintl>
    7eb2:	75 ce       	rjmp	.-790    	; 0x7b9e <__fp_mpack>
    7eb4:	3c cf       	rjmp	.-392    	; 0x7d2e <__fp_szero>

00007eb6 <sin>:
    7eb6:	9f 93       	push	r25
    7eb8:	b7 de       	rcall	.-658    	; 0x7c28 <__fp_rempio2>
    7eba:	0f 90       	pop	r0
    7ebc:	07 fc       	sbrc	r0, 7
    7ebe:	ee 5f       	subi	r30, 0xFE	; 254
    7ec0:	eb ce       	rjmp	.-554    	; 0x7c98 <__fp_sinus>
    7ec2:	11 f4       	brne	.+4      	; 0x7ec8 <sin+0x12>
    7ec4:	0e f4       	brtc	.+2      	; 0x7ec8 <sin+0x12>
    7ec6:	79 ce       	rjmp	.-782    	; 0x7bba <__fp_nan>
    7ec8:	6a ce       	rjmp	.-812    	; 0x7b9e <__fp_mpack>

00007eca <sqrt>:
    7eca:	ff de       	rcall	.-514    	; 0x7cca <__fp_splitA>
    7ecc:	d0 f3       	brcs	.-12     	; 0x7ec2 <sin+0xc>
    7ece:	99 23       	and	r25, r25
    7ed0:	d9 f3       	breq	.-10     	; 0x7ec8 <sin+0x12>
    7ed2:	ce f3       	brts	.-14     	; 0x7ec6 <sin+0x10>
    7ed4:	9f 57       	subi	r25, 0x7F	; 127
    7ed6:	55 0b       	sbc	r21, r21
    7ed8:	87 ff       	sbrs	r24, 7
    7eda:	3f d0       	rcall	.+126    	; 0x7f5a <__fp_norm2>
    7edc:	00 24       	eor	r0, r0
    7ede:	a0 e6       	ldi	r26, 0x60	; 96
    7ee0:	40 ea       	ldi	r20, 0xA0	; 160
    7ee2:	90 01       	movw	r18, r0
    7ee4:	80 58       	subi	r24, 0x80	; 128
    7ee6:	56 95       	lsr	r21
    7ee8:	97 95       	ror	r25
    7eea:	28 f4       	brcc	.+10     	; 0x7ef6 <sqrt+0x2c>
    7eec:	80 5c       	subi	r24, 0xC0	; 192
    7eee:	66 0f       	add	r22, r22
    7ef0:	77 1f       	adc	r23, r23
    7ef2:	88 1f       	adc	r24, r24
    7ef4:	20 f0       	brcs	.+8      	; 0x7efe <sqrt+0x34>
    7ef6:	26 17       	cp	r18, r22
    7ef8:	37 07       	cpc	r19, r23
    7efa:	48 07       	cpc	r20, r24
    7efc:	30 f4       	brcc	.+12     	; 0x7f0a <sqrt+0x40>
    7efe:	62 1b       	sub	r22, r18
    7f00:	73 0b       	sbc	r23, r19
    7f02:	84 0b       	sbc	r24, r20
    7f04:	20 29       	or	r18, r0
    7f06:	31 29       	or	r19, r1
    7f08:	4a 2b       	or	r20, r26
    7f0a:	a6 95       	lsr	r26
    7f0c:	17 94       	ror	r1
    7f0e:	07 94       	ror	r0
    7f10:	20 25       	eor	r18, r0
    7f12:	31 25       	eor	r19, r1
    7f14:	4a 27       	eor	r20, r26
    7f16:	58 f7       	brcc	.-42     	; 0x7eee <sqrt+0x24>
    7f18:	66 0f       	add	r22, r22
    7f1a:	77 1f       	adc	r23, r23
    7f1c:	88 1f       	adc	r24, r24
    7f1e:	20 f0       	brcs	.+8      	; 0x7f28 <sqrt+0x5e>
    7f20:	26 17       	cp	r18, r22
    7f22:	37 07       	cpc	r19, r23
    7f24:	48 07       	cpc	r20, r24
    7f26:	30 f4       	brcc	.+12     	; 0x7f34 <sqrt+0x6a>
    7f28:	62 0b       	sbc	r22, r18
    7f2a:	73 0b       	sbc	r23, r19
    7f2c:	84 0b       	sbc	r24, r20
    7f2e:	20 0d       	add	r18, r0
    7f30:	31 1d       	adc	r19, r1
    7f32:	41 1d       	adc	r20, r1
    7f34:	a0 95       	com	r26
    7f36:	81 f7       	brne	.-32     	; 0x7f18 <sqrt+0x4e>
    7f38:	b9 01       	movw	r22, r18
    7f3a:	84 2f       	mov	r24, r20
    7f3c:	91 58       	subi	r25, 0x81	; 129
    7f3e:	88 0f       	add	r24, r24
    7f40:	96 95       	lsr	r25
    7f42:	87 95       	ror	r24
    7f44:	08 95       	ret

00007f46 <square>:
    7f46:	9b 01       	movw	r18, r22
    7f48:	ac 01       	movw	r20, r24
    7f4a:	32 cf       	rjmp	.-412    	; 0x7db0 <__mulsf3>

00007f4c <trunc>:
    7f4c:	d8 de       	rcall	.-592    	; 0x7cfe <__fp_trunc>
    7f4e:	20 f0       	brcs	.+8      	; 0x7f58 <trunc+0xc>
    7f50:	9f 37       	cpi	r25, 0x7F	; 127
    7f52:	08 f4       	brcc	.+2      	; 0x7f56 <trunc+0xa>
    7f54:	ec ce       	rjmp	.-552    	; 0x7d2e <__fp_szero>
    7f56:	08 ce       	rjmp	.-1008   	; 0x7b68 <__fp_mintl>
    7f58:	22 ce       	rjmp	.-956    	; 0x7b9e <__fp_mpack>

00007f5a <__fp_norm2>:
    7f5a:	91 50       	subi	r25, 0x01	; 1
    7f5c:	50 40       	sbci	r21, 0x00	; 0
    7f5e:	66 0f       	add	r22, r22
    7f60:	77 1f       	adc	r23, r23
    7f62:	88 1f       	adc	r24, r24
    7f64:	d2 f7       	brpl	.-12     	; 0x7f5a <__fp_norm2>
    7f66:	08 95       	ret

00007f68 <__fp_powsodd>:
    7f68:	9f 93       	push	r25
    7f6a:	8f 93       	push	r24
    7f6c:	7f 93       	push	r23
    7f6e:	6f 93       	push	r22
    7f70:	ff 93       	push	r31
    7f72:	ef 93       	push	r30
    7f74:	9b 01       	movw	r18, r22
    7f76:	ac 01       	movw	r20, r24
    7f78:	1b df       	rcall	.-458    	; 0x7db0 <__mulsf3>
    7f7a:	ef 91       	pop	r30
    7f7c:	ff 91       	pop	r31
    7f7e:	20 de       	rcall	.-960    	; 0x7bc0 <__fp_powser>
    7f80:	2f 91       	pop	r18
    7f82:	3f 91       	pop	r19
    7f84:	4f 91       	pop	r20
    7f86:	5f 91       	pop	r21
    7f88:	13 cf       	rjmp	.-474    	; 0x7db0 <__mulsf3>

00007f8a <__udivmodsi4>:
    7f8a:	a1 e2       	ldi	r26, 0x21	; 33
    7f8c:	1a 2e       	mov	r1, r26
    7f8e:	aa 1b       	sub	r26, r26
    7f90:	bb 1b       	sub	r27, r27
    7f92:	fd 01       	movw	r30, r26
    7f94:	0d c0       	rjmp	.+26     	; 0x7fb0 <__udivmodsi4_ep>

00007f96 <__udivmodsi4_loop>:
    7f96:	aa 1f       	adc	r26, r26
    7f98:	bb 1f       	adc	r27, r27
    7f9a:	ee 1f       	adc	r30, r30
    7f9c:	ff 1f       	adc	r31, r31
    7f9e:	a2 17       	cp	r26, r18
    7fa0:	b3 07       	cpc	r27, r19
    7fa2:	e4 07       	cpc	r30, r20
    7fa4:	f5 07       	cpc	r31, r21
    7fa6:	20 f0       	brcs	.+8      	; 0x7fb0 <__udivmodsi4_ep>
    7fa8:	a2 1b       	sub	r26, r18
    7faa:	b3 0b       	sbc	r27, r19
    7fac:	e4 0b       	sbc	r30, r20
    7fae:	f5 0b       	sbc	r31, r21

00007fb0 <__udivmodsi4_ep>:
    7fb0:	66 1f       	adc	r22, r22
    7fb2:	77 1f       	adc	r23, r23
    7fb4:	88 1f       	adc	r24, r24
    7fb6:	99 1f       	adc	r25, r25
    7fb8:	1a 94       	dec	r1
    7fba:	69 f7       	brne	.-38     	; 0x7f96 <__udivmodsi4_loop>
    7fbc:	60 95       	com	r22
    7fbe:	70 95       	com	r23
    7fc0:	80 95       	com	r24
    7fc2:	90 95       	com	r25
    7fc4:	9b 01       	movw	r18, r22
    7fc6:	ac 01       	movw	r20, r24
    7fc8:	bd 01       	movw	r22, r26
    7fca:	cf 01       	movw	r24, r30
    7fcc:	08 95       	ret

00007fce <__tablejump2__>:
    7fce:	ee 0f       	add	r30, r30
    7fd0:	ff 1f       	adc	r31, r31

00007fd2 <__tablejump__>:
    7fd2:	05 90       	lpm	r0, Z+
    7fd4:	f4 91       	lpm	r31, Z
    7fd6:	e0 2d       	mov	r30, r0
    7fd8:	09 94       	ijmp

00007fda <__umulhisi3>:
    7fda:	a2 9f       	mul	r26, r18
    7fdc:	b0 01       	movw	r22, r0
    7fde:	b3 9f       	mul	r27, r19
    7fe0:	c0 01       	movw	r24, r0
    7fe2:	a3 9f       	mul	r26, r19
    7fe4:	70 0d       	add	r23, r0
    7fe6:	81 1d       	adc	r24, r1
    7fe8:	11 24       	eor	r1, r1
    7fea:	91 1d       	adc	r25, r1
    7fec:	b2 9f       	mul	r27, r18
    7fee:	70 0d       	add	r23, r0
    7ff0:	81 1d       	adc	r24, r1
    7ff2:	11 24       	eor	r1, r1
    7ff4:	91 1d       	adc	r25, r1
    7ff6:	08 95       	ret

00007ff8 <__muluhisi3>:
    7ff8:	0e 94 ed 3f 	call	0x7fda	; 0x7fda <__umulhisi3>
    7ffc:	a5 9f       	mul	r26, r21
    7ffe:	90 0d       	add	r25, r0
    8000:	b4 9f       	mul	r27, r20
    8002:	90 0d       	add	r25, r0
    8004:	a4 9f       	mul	r26, r20
    8006:	80 0d       	add	r24, r0
    8008:	91 1d       	adc	r25, r1
    800a:	11 24       	eor	r1, r1
    800c:	08 95       	ret

0000800e <_exit>:
    800e:	f8 94       	cli

00008010 <__stop_program>:
    8010:	ff cf       	rjmp	.-2      	; 0x8010 <__stop_program>
